<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>PikaBot Is Back With a Vengeance - Part 2 | OALABS Research</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="PikaBot Is Back With a Vengeance - Part 2" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Automated String Decryption" />
<meta property="og:description" content="Automated String Decryption" />
<link rel="canonical" href="https://research.openanalysis.net/pikabot/debugging/string%20decryption/emulation/memulator/2023/11/19/new-pikabot-strings.html" />
<meta property="og:url" content="https://research.openanalysis.net/pikabot/debugging/string%20decryption/emulation/memulator/2023/11/19/new-pikabot-strings.html" />
<meta property="og:site_name" content="OALABS Research" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-19T00:00:00-06:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="PikaBot Is Back With a Vengeance - Part 2" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-11-19T00:00:00-06:00","datePublished":"2023-11-19T00:00:00-06:00","description":"Automated String Decryption","headline":"PikaBot Is Back With a Vengeance - Part 2","mainEntityOfPage":{"@type":"WebPage","@id":"https://research.openanalysis.net/pikabot/debugging/string%20decryption/emulation/memulator/2023/11/19/new-pikabot-strings.html"},"url":"https://research.openanalysis.net/pikabot/debugging/string%20decryption/emulation/memulator/2023/11/19/new-pikabot-strings.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://research.openanalysis.net/feed.xml" title="OALABS Research" /><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />

<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">OALABS Research</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">PikaBot Is Back With a Vengeance - Part 2</h1><p class="page-description">Automated String Decryption</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2023-11-19T00:00:00-06:00" itemprop="datePublished">
        Nov 19, 2023
      </time>
       â€¢ <span class="read-time" title="Estimated read time">
    
    
      108 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/categories/#pikabot">pikabot</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#debugging">debugging</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#string decryption">string decryption</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#emulation">emulation</a>
        &nbsp;
      
        <a class="category-tags-link" href="/categories/#memulator">memulator</a>
        
      
      </p>
    

    
      
        <div class="pb-5 d-flex flex-justify-left">
            <div class="px-2">
                <a href="https://www.youtube.com/c/OALabs" role="button" target="_blank">
                    <img class="notebook-badge-image" src="https://img.shields.io/badge/-YouTube-FF0000" alt="Join us on YouTube">
                </a>
            </div>
            <div class="px-2">
                <a href="https://www.twitch.tv/oalabslive" role="button" target="_blank">
                    <img class="notebook-badge-image" src="https://img.shields.io/twitch/status/oalabslive?style=social" alt="Join us on Twitch">
                </a>
            </div>
            <div class="px-2">
                <a href="https://discord.gg/cw4U3WHvpn" role="button" target="_blank">
                    <img class="notebook-badge-image" src="https://img.shields.io/badge/-Join Our Discord-blueviolet" alt="Join Discord">
                </a>
            </div>
            <div class="px-2">
                <a href="https://www.patreon.com/oalabs" role="button" target="_blank">
                    <img class="notebook-badge-image" src="https://img.shields.io/badge/-OALABS Patreon-FF424D" alt="Support us on Patreon">
                </a>
            </div>
          <div class="px-2">

    <a href="https://github.com/OALabs/research/tree/master/_notebooks/2023-11-19-new-pikabot-strings.ipynb" role="button" target="_blank">
<img class="notebook-badge-image" src="/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div>

          
          
          
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#Overview">Overview </a></li>
<li class="toc-entry toc-h2"><a href="#Sample">Sample </a></li>
<li class="toc-entry toc-h2"><a href="#String-Decryption">String Decryption </a>
<ul>
<li class="toc-entry toc-h3"><a href="#Locating-Strings">Locating Strings </a></li>
<li class="toc-entry toc-h3"><a href="#Decryption">Decryption </a></li>
</ul>
</li>
</ul><!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2023-11-19-new-pikabot-strings.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Overview">
<a class="anchor" href="#Overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview<a class="anchor-link" href="#Overview"> </a>
</h2>
<p>This is a continuation of our work on the new Pikabot core module. Our initial analysis can be found <a href="https://research.openanalysis.net/pikabot/debugging/string%20decryption/2023/11/12/new-pikabot.html">here</a>.</p>
<h2 id="Sample">
<a class="anchor" href="#Sample" aria-hidden="true"><span class="octicon octicon-link"></span></a>Sample<a class="anchor-link" href="#Sample"> </a>
</h2>
<p><code>39d6f7865949ae7bb846f56bff4f62a96d7277d2872fec68c09e1227e6db9206</code> <a href="https://www.unpac.me/results/671ae130-6070-48fc-82f2-afc305fdbf3d?hash=39d6f7865949ae7bb846f56bff4f62a96d7277d2872fec68c09e1227e6db9206#/">UnpacMe</a></p>
<h2 id="String-Decryption">
<a class="anchor" href="#String-Decryption" aria-hidden="true"><span class="octicon octicon-link"></span></a>String Decryption<a class="anchor-link" href="#String-Decryption"> </a>
</h2>
<ul>
<li>Strings are inline </li>
<li>The string data is built in a stack string (pushed on to the stack as DWORDs)</li>
<li>The keys are cstrings in the <code>.data</code> section</li>
<li>The first layer of encryption is RC4 (inline)</li>
<li>The decrypted strings are base64 encoded </li>
<li>The base64 encoded strings are then decrypted usuing AES CBC <ul>
<li>The AES key and IV are themselves base64 strings but only the first 32/16 bytes are used and the strings are not decoded</li>
</ul>
</li>
</ul>
<h3 id="Locating-Strings">
<a class="anchor" href="#Locating-Strings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Locating Strings<a class="anchor-link" href="#Locating-Strings"> </a>
</h3>
<p>The RC4 key setup loops are good markers.</p>
<p>The first time we have a compare with 256 this is the entry to the RC4 decryption
The second time we have a compare with 256 this is the key setup loop</p>

<pre><code>3D 00 01 00 00                          cmp     eax, 100h
81 FE 00 01 00 00                       cmp     esi, 100h
81 FF 00 01 00 00                       cmp     edi, 100h</code></pre>
<p>After the first compare with 256 but before the second compare with 256 when we have a div this is the key length.</p>

<pre><code>F7 75 F0                                div     [ebp+var_key_length]</code></pre>
<p>After the first two compare with 256 the first xor byte with memory address is the start of the encrypted data on the stack.</p>

<pre><code>32 44 0D B0                             xor     al, byte ptr [ebp+ecx+var_data_enc]</code></pre>
<p>Once we have found the data xor the first compare is the end of the RC4 decryption... also the string length.</p>

<pre><code>83 F9 40                                cmp     ecx, 40h ; '@'
0F 82 22 FF FF FF                       jb      loc_408E37</code></pre>
<h3 id="Decryption">
<a class="anchor" href="#Decryption" aria-hidden="true"><span class="octicon octicon-link"></span></a>Decryption<a class="anchor-link" href="#Decryption"> </a>
</h3>
<p>We are going to use a custom emulator that only handles memory operations no control flow. Using the above rules we will implement "dump points" for the key, and encrypted data.</p>
<p>This idea and tool is based on the initial "memulator" concept from <a href="https://github.com/oopsmishap">@mishap</a> <a href="https://gist.github.com/oopsmishap/d8f72e3f2324691f0067ed473278dff3">pxor_string_decrypt_wip.py</a>.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pefile</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">capstone</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">capstone.x86</span> <span class="kn">import</span> <span class="o">*</span>

<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">MemorySegment</span><span class="p">:</span>
    <span class="n">address</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">bytes</span>


<span class="k">class</span> <span class="nc">ProcessMemory</span><span class="p">:</span>
    <span class="n">memory</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">MemorySegment</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">def</span> <span class="nf">_section_align</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">size</span> <span class="o">+</span> <span class="mh">0x1000</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mh">0x1000</span><span class="p">)</span> <span class="o">*</span> <span class="mh">0x1000</span>

    <span class="k">def</span> <span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="c1"># Check if the memory is already allocated or if it overlaps with another allocation</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">&lt;=</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Memory already allocated: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">address</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">&lt;</span> <span class="n">address</span> <span class="o">+</span> <span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Memory already allocated: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="c1"># Align the size</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_section_align</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="c1"># Allocate the memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">MemorySegment</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x00</span><span class="s1">'</span> <span class="o">*</span> <span class="n">size</span><span class="p">))</span>
        <span class="c1"># Return the address and new size</span>
        <span class="k">return</span> <span class="n">address</span><span class="p">,</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="c1"># Get the memory segment</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">&lt;=</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Memory not allocated: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="c1"># Check if we are reading out of bounds</span>
        <span class="k">if</span> <span class="n">address</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Reading out of bounds: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="c1"># Return the data</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">address</span> <span class="o">-</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span><span class="p">:</span><span class="n">address</span> <span class="o">-</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">size</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># Get the memory segment</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">&lt;=</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Memory not allocated: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="c1"># Check if we are writing out of bounds</span>
        <span class="k">if</span> <span class="n">address</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Writing out of bounds: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="c1"># Write the data</span>
        <span class="n">m</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">data</span><span class="p">[:</span><span class="n">address</span> <span class="o">-</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">address</span> <span class="o">-</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):]</span>
        <span class="c1"># Return number of bytes written</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dump_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="c1"># Get the memory segment</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">&lt;=</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Memory not allocated: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="c1"># Return the data</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">clear_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
        <span class="c1"># Get the memory segment</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">memory</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">&lt;=</span> <span class="n">address</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">.</span><span class="n">address</span> <span class="o">+</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Memory not allocated: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">address</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        <span class="c1"># Clear the data</span>
        <span class="n">m</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x00</span><span class="s1">'</span> <span class="o">*</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span>


<span class="n">ADDRESS_MASK</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span>

<span class="k">def</span> <span class="nf">op_mem</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">aligned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">mem_address</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">base</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">base</span>
    <span class="k">if</span> <span class="n">base</span> <span class="o">!=</span> <span class="n">X86_REG_INVALID</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">base</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">mem_address</span> <span class="o">+=</span> <span class="n">value</span>

    <span class="n">index</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">index</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">X86_REG_INVALID</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">mem_address</span> <span class="o">+=</span> <span class="n">value</span> <span class="o">*</span> <span class="n">op</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">scale</span>

    <span class="n">disp</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">mem</span><span class="o">.</span><span class="n">disp</span> <span class="c1"># TODO: negative value handling?</span>
    <span class="n">mem_address</span> <span class="o">+=</span> <span class="n">disp</span>
    <span class="n">mem_address</span> <span class="o">&amp;=</span> <span class="n">ADDRESS_MASK</span>
    <span class="k">if</span> <span class="n">aligned</span><span class="p">:</span>
        <span class="n">alignment</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">mem_address</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">alignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">"Address </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">mem_address</span><span class="p">)</span><span class="si">}</span><span class="s2"> not aligned to </span><span class="si">{</span><span class="n">alignment</span><span class="si">}</span><span class="s2">"</span>
    <span class="k">return</span> <span class="n">mem_address</span>

<span class="k">def</span> <span class="nf">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">aligned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">op</span><span class="p">:</span> <span class="n">X86Op</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CS_OP_REG</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">reg</span>
        <span class="k">return</span> <span class="n">regs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CS_OP_MEM</span><span class="p">:</span>
        <span class="n">mem_address</span> <span class="o">=</span> <span class="n">op_mem</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">aligned</span><span class="o">=</span><span class="n">aligned</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">mem_address</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CS_OP_IMM</span><span class="p">:</span>
        <span class="c1"># TODO: sign extend?</span>
        <span class="k">return</span> <span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">imm</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">aligned</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">op</span><span class="p">:</span> <span class="n">X86Op</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">size</span>
    <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CS_OP_REG</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">reg</span>
        <span class="n">regs</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">elif</span> <span class="n">op</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CS_OP_MEM</span><span class="p">:</span>
        <span class="n">mem_address</span> <span class="o">=</span> <span class="n">op_mem</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">aligned</span><span class="o">=</span><span class="n">aligned</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span>
        <span class="c1"># TODO: handle invalid memory access</span>
        <span class="n">memory</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mem_address</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">print_stack</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
    <span class="c1"># Print the stack -255  bytes with addresses in hex as DWORDS</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="mi">6</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">ptr</span> <span class="o">-</span> <span class="n">size</span> <span class="o">+</span> <span class="n">i</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">address</span> <span class="o">==</span> <span class="n">ptr</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">address</span><span class="si">:</span><span class="s2">08x</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">08x</span><span class="si">}</span><span class="s2"> &lt;--- POINTER"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">address</span><span class="si">:</span><span class="s2">08x</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">value</span><span class="si">:</span><span class="s2">08x</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rc4</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="n">S</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">))</span>
    <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">out</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">''</span>
    <span class="c1"># KSA Phase</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)])</span> <span class="o">%</span> <span class="mi">256</span>
        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="c1"># PRGA Phase</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">256</span>
        <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">%</span> <span class="mi">256</span>
        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># swap</span>
        <span class="n">out</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">char</span> <span class="o">^</span> <span class="n">S</span><span class="p">[(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">S</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="o">%</span> <span class="mi">256</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="n">file_data</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s1">'/tmp/FakeSearchProtocolHost.bin'</span><span class="p">,</span> <span class="s1">'rb'</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="n">pe</span> <span class="o">=</span> <span class="n">pefile</span><span class="o">.</span><span class="n">PE</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">file_data</span><span class="p">)</span>

<span class="n">section_data</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">entry_point</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">OPTIONAL_HEADER</span><span class="o">.</span><span class="n">AddressOfEntryPoint</span>
<span class="n">pe_base</span> <span class="o">=</span> <span class="n">pe</span><span class="o">.</span><span class="n">OPTIONAL_HEADER</span><span class="o">.</span><span class="n">ImageBase</span>


<span class="n">memory</span> <span class="o">=</span> <span class="n">ProcessMemory</span><span class="p">()</span>

<span class="c1"># Allocate memory for each of the sections and write them to the memory</span>
<span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">pe</span><span class="o">.</span><span class="n">sections</span><span class="p">:</span>
    <span class="n">address</span> <span class="o">=</span> <span class="n">pe_base</span> <span class="o">+</span> <span class="n">section</span><span class="o">.</span><span class="n">VirtualAddress</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">Misc_VirtualSize</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
    <span class="n">memory</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">memory</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">address</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>


<span class="c1"># Allocate memory for the stack</span>
<span class="n">stack_address</span> <span class="o">=</span> <span class="mh">0x1000</span>
<span class="n">stack_size</span> <span class="o">=</span> <span class="mh">0x200000</span>
<span class="n">memory</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">stack_address</span><span class="p">,</span> <span class="n">stack_size</span><span class="p">)</span>


<span class="c1"># Scan all instructions</span>
<span class="c1"># For ret reset the stack and set the ESP/EBP registers</span>
<span class="c1"># When we hit cmp 0x100 test the strings on the stack</span>
<span class="n">test_start</span> <span class="o">=</span> <span class="mh">0x00408C55</span>
<span class="n">test_end</span> <span class="o">=</span> <span class="mh">0x004090EE</span> 

<span class="n">test_start</span> <span class="o">=</span> <span class="mh">0x004020A0</span>
<span class="n">test_end</span> <span class="o">=</span> <span class="mh">0x0040458D</span> 

<span class="n">code</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">test_start</span><span class="p">,</span> <span class="n">test_end</span> <span class="o">-</span> <span class="n">test_start</span><span class="p">)</span>

<span class="n">cs</span> <span class="o">=</span> <span class="n">Cs</span><span class="p">(</span><span class="n">CS_ARCH_X86</span><span class="p">,</span> <span class="n">CS_MODE_32</span><span class="p">)</span>
<span class="n">cs</span><span class="o">.</span><span class="n">detail</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">cs</span><span class="o">.</span><span class="n">skipdata</span> <span class="o">=</span> <span class="kc">True</span>

<span class="n">regs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">X86_REG_ENDING</span>

<span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESP</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack_address</span> <span class="o">+</span> <span class="n">stack_size</span><span class="o">//</span><span class="mi">2</span>
<span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_EBP</span><span class="p">]</span> <span class="o">=</span> <span class="n">stack_address</span> <span class="o">+</span> <span class="n">stack_size</span><span class="o">//</span><span class="mi">2</span>

<span class="n">string_start</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">flag_watch_cmp</span> <span class="o">=</span> <span class="kc">False</span> 
<span class="n">flag_enter_key_loop</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">flag_enter_rc4</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">string_start_candidate</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">cs</span><span class="o">.</span><span class="n">disasm</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">test_start</span><span class="p">):</span>
    <span class="n">esp</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESP</span><span class="p">]</span>
    <span class="n">ebp</span> <span class="o">=</span> <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_EBP</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">address</span><span class="si">:</span><span class="s2">08x</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">esp</span> <span class="o">-</span> <span class="n">ebp</span><span class="p">)</span><span class="si">}</span><span class="s2">) </span><span class="se">\t</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">mnemonic</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">op_str</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_MOV</span><span class="p">:</span>
            <span class="c1">#print(f"\tMOV")</span>
            <span class="c1"># Move from operand 1 to operand 0</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flag_enter_key_loop</span><span class="p">:</span>
                <span class="c1"># If the size is 1 byte and the second operand is a memory address</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CS_OP_MEM</span><span class="p">:</span>
                    <span class="n">string_start_candidate</span> <span class="o">=</span> <span class="n">op_mem</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_MOVZX</span><span class="p">:</span>
            <span class="c1">#print(f"\tMOVZX")</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Move from operand 1 to operand 0 with zero extension</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_AND</span><span class="p">:</span>
            <span class="c1">#print(f"\tAND")</span>
            <span class="c1"># AND operand 0 and operand 1</span>
            <span class="n">value0</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">value1</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value0</span> <span class="o">&amp;</span> <span class="n">value1</span>
            <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_OR</span><span class="p">:</span>
            <span class="c1">#print(f"\tOR")</span>
            <span class="c1"># OR operand 0 and operand 1</span>
            <span class="n">value0</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">value1</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value0</span> <span class="o">|</span> <span class="n">value1</span>
            <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_ADD</span><span class="p">:</span>
            <span class="c1">#print(f"\tADD")</span>
            <span class="c1"># Add operand 0 and operand 1</span>
            <span class="n">value0</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">value1</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value0</span> <span class="o">+</span> <span class="n">value1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ADDRESS_MASK</span>
            <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_SUB</span><span class="p">:</span>
            <span class="c1">#print(f"\tSUB")</span>
            <span class="c1"># Subtract operand 1 from operand 0</span>
            <span class="n">value0</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">value1</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value0</span> <span class="o">-</span> <span class="n">value1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">ADDRESS_MASK</span>
            <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_MOVSB</span><span class="p">:</span>
            <span class="c1">#print(f"\tMOVSB")</span>
            <span class="c1"># Read byte from DS:ESI and write to ES:EDI</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESI</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">memory</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_EDI</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># Increment ESI and EDI</span>
            <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_EDI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_MOVSW</span><span class="p">:</span>
            <span class="c1">#print(f"\tMOVSW")</span>
            <span class="c1"># Read word from DS:ESI and write to ES:EDI</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESI</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">memory</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_EDI</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># Increment ESI and EDI</span>
            <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_EDI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span>
        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_MOVSD</span><span class="p">:</span>
            <span class="c1">#print(f"\tMOVSD")</span>
            <span class="c1"># Read byte by byte from memeory at DS:ESI until null byte</span>
            <span class="n">out</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">''</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESI</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="sa">b</span><span class="s1">'</span><span class="se">\x00</span><span class="s1">'</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">isascii</span><span class="p">()</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\t\t</span><span class="s2">Potential key: </span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

            <span class="c1"># Read dword from DS:ESI and write to ES:EDI</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESI</span><span class="p">],</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">memory</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_EDI</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
            <span class="c1"># Increment ESI and EDI</span>
            <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">4</span>
            <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_EDI</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">4</span>
        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_LEA</span><span class="p">:</span>
            <span class="c1">#print(f"\tLEA")</span>
            <span class="c1"># Load effective address from operand 1 to operand 0</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">op_mem</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_PUSH</span><span class="p">:</span>
            <span class="c1">#print(f"\tPUSH")</span>
            <span class="c1"># Push operand 0</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESP</span><span class="p">]</span> <span class="o">-=</span> <span class="n">size</span>
            <span class="c1"># Write value to stack and decrement ESP</span>
            <span class="n">memory</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESP</span><span class="p">],</span> <span class="n">value</span><span class="o">.</span><span class="n">to_bytes</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">))</span>
            

        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_POP</span><span class="p">:</span>
            <span class="c1">#print(f"\tPOP")</span>
            <span class="c1"># Read value from stack and increment ESP</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="n">value_data</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESP</span><span class="p">],</span> <span class="n">size</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="o">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">value_data</span><span class="p">,</span> <span class="s2">"little"</span><span class="p">)</span>
            <span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ESP</span><span class="p">]</span> <span class="o">+=</span> <span class="n">size</span>
            <span class="c1"># Write value to operand 0</span>
            <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_CMP</span><span class="p">:</span>
            <span class="c1">#print(f"\tCMP")</span>
            <span class="c1"># Compare operand 0 and operand 1</span>
            <span class="n">value0</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">value1</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># If watch flag is set and </span>
            <span class="k">if</span> <span class="n">flag_watch_cmp</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\t\t</span><span class="s2">CMP </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">value1</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                <span class="c1"># This is the end of our string decryption loop </span>
                <span class="c1"># Read string from stack</span>
                <span class="n">string_data</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">string_start</span><span class="p">,</span> <span class="n">value1</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\t\t</span><span class="s2">String: </span><span class="si">{</span><span class="n">string_data</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                <span class="c1"># Try to decrypt the string with all the keys</span>
                <span class="n">out_string</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">decrypted</span> <span class="o">=</span> <span class="n">rc4</span><span class="p">(</span><span class="n">string_data</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">decrypted</span><span class="o">.</span><span class="n">isascii</span><span class="p">():</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\t\t</span><span class="s2">Decrypted: </span><span class="si">{</span><span class="n">decrypted</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">if</span> <span class="n">out_string</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Try with candidate string instead</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">"No strings found attempting with candidate"</span><span class="p">)</span>
                    <span class="c1"># This is the end of our string decryption loop </span>
                    <span class="c1"># Read string from stack</span>
                    <span class="n">string_data</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">string_start_candidate</span><span class="p">,</span> <span class="n">value1</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\t\t</span><span class="s2">String: </span><span class="si">{</span><span class="n">string_data</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                    <span class="c1"># Try to decrypt the string with all the keys</span>
                    <span class="n">out_string</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">decrypted</span> <span class="o">=</span> <span class="n">rc4</span><span class="p">(</span><span class="n">string_data</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\t</span><span class="s2">\TEST: </span><span class="si">{</span><span class="n">decrypted</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">decrypted</span><span class="o">.</span><span class="n">isascii</span><span class="p">():</span>
                                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\t\t</span><span class="s2">Decrypted: </span><span class="si">{</span><span class="n">decrypted</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                        <span class="k">except</span><span class="p">:</span>
                            <span class="k">pass</span>

                <span class="c1"># Reset the flags</span>
                <span class="n">flag_watch_cmp</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">flag_enter_key_loop</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">flag_enter_rc4</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">string_start_candidate</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"END for RC4 - Reset flags"</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value1</span> <span class="o">==</span> <span class="mh">0x100</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">flag_enter_rc4</span><span class="p">:</span>
                <span class="n">flag_enter_rc4</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"START for RC4 - Set flag"</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value1</span> <span class="o">==</span> <span class="mh">0x100</span> <span class="ow">and</span> <span class="n">flag_enter_rc4</span><span class="p">:</span>
                <span class="n">flag_enter_key_loop</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"START for key loop - Scanning for XOR"</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">value1</span> <span class="o">==</span> <span class="mh">0x100</span> <span class="ow">and</span> <span class="n">flag_enter_key_loop</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">"Too many cmp 0x100"</span><span class="p">)</span>

        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_INC</span><span class="p">:</span>
            <span class="c1">#print(f"\tINC")</span>
            <span class="c1"># Increment operand 0</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        
        <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">X86_INS_XOR</span><span class="p">:</span>
            <span class="c1">#print(f"\tXOR")</span>
            <span class="c1"># If operand 0 is a single byte and operand 1 is on the stack this is the string xor</span>
            <span class="k">if</span> <span class="n">flag_enter_key_loop</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">CS_OP_MEM</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ECX: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_ECX</span><span class="p">])</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"EBP: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">regs</span><span class="p">[</span><span class="n">X86_REG_EBP</span><span class="p">])</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                <span class="c1"># Read the string from the stack</span>
                <span class="n">string_address</span> <span class="o">=</span> <span class="n">op_mem</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># If string address is on the stack break</span>
                <span class="k">if</span> <span class="n">stack_address</span> <span class="o">&lt;=</span> <span class="n">string_address</span> <span class="o">&lt;</span> <span class="n">stack_address</span> <span class="o">+</span> <span class="n">stack_size</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="se">\t\t</span><span class="s2">String address: </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="n">string_address</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
                    <span class="n">string_start</span> <span class="o">=</span> <span class="n">string_address</span>
                    <span class="n">flag_watch_cmp</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># Otherwise xor operand 0 and operand 1</span>
            <span class="n">value0</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">value1</span> <span class="o">=</span> <span class="n">op_read</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value0</span> <span class="o">^</span> <span class="n">value1</span>
            <span class="n">op_write</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"ERROR: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
        


    
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>004020a0 (0x0) 	push ebp
004020a1 (-0x4) 	mov ebp, esp
004020a3 (0x0) 	sub esp, 0xcf4
004020a9 (-0xcf4) 	push esi
004020aa (-0xcf8) 	push edi
004020ab (-0xcfc) 	mov esi, 0x42c310
004020b0 (-0xcfc) 	mov dword ptr [ebp - 0x24], 0xde1b14ca
004020b7 (-0xcfc) 	lea edi, [ebp - 0xdc]
004020bd (-0xcfc) 	mov dword ptr [ebp - 0x20], 0xebd6d435
004020c4 (-0xcfc) 	xor ecx, ecx
004020c6 (-0xcfc) 	mov dword ptr [ebp - 0x1c], 0x45f4f4d
004020cd (-0xcfc) 	mov dword ptr [ebp - 0x18], 0x561dbb2f
004020d4 (-0xcfc) 	mov eax, ecx
004020d6 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'wilActivity'
004020d7 (-0xcfc) 	mov dword ptr [ebp - 0x14], 0xb6ff748d
004020de (-0xcfc) 	mov dword ptr [ebp - 0x10], 0x228a25e9
004020e5 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'ctivity'
004020e6 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
004020e7 (-0xcfc) 	mov edi, ecx
004020e9 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
004020f0 (-0xcfc) 	inc eax
004020f1 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
004020f6 (-0xcfc) 	jb 0x4020e9
004020f8 (-0xcfc) 	mov esi, ecx
004020fa (-0xcfc) 	mov dword ptr [ebp - 0x1d4], 0xb
00402104 (-0xcfc) 	xor edx, edx
00402106 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
0040210d (-0xcfc) 	mov eax, esi
0040210f (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402112 (-0xcfc) 	div dword ptr [ebp - 0x1d4]
00402118 (-0xcfc) 	movzx ecx, cl
0040211b (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0xdc]
00402123 (-0xcfc) 	add eax, edi
00402125 (-0xcfc) 	add ecx, eax
00402127 (-0xcfc) 	movzx edi, cl
0040212a (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
00402131 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00402138 (-0xcfc) 	inc esi
00402139 (-0xcfc) 	mov al, byte ptr [ebp - 1]
0040213c (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402143 (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00402149 (-0xcfc) 	jb 0x402104
0040214b (-0xcfc) 	mov esi, dword ptr [0x434050]
00402151 (-0xcfc) 	xor eax, eax
00402153 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402156 (-0xcfc) 	mov edi, eax
00402158 (-0xcfc) 	mov dword ptr [ebp - 0xc], eax
0040215b (-0xcfc) 	lea eax, [edi + 1]
0040215e (-0xcfc) 	mov edx, 0x434030
00402163 (-0xcfc) 	push 0x434030
00402168 (-0xd00) 	push ecx
00402169 (-0xd04) 	movzx edi, al
0040216c (-0xd04) 	call 0x401e4c
00402171 (-0xd04) 	pop ecx
00402172 (-0xd00) 	pop ecx
00402173 (-0xcfc) 	xor ecx, ecx
00402175 (-0xcfc) 	mov eax, ecx
00402177 (-0xcfc) 	and esi, 0xaeb0ad0
0040217d (-0xcfc) 	inc eax
0040217e (-0xcfc) 	cmp word ptr [eax*2 + 0x42c950], cx
00402186 (-0xcfc) 	jne 0x402177
00402188 (-0xcfc) 	cmp eax, 0x1d81
0040218d (-0xcfc) 	jae 0x402196
0040218f (-0xcfc) 	mov eax, 0x9a3d370d
00402194 (-0xcfc) 	jmp 0x4021a0
00402196 (-0xcfc) 	call 0x4011d8
0040219b (-0xcfc) 	mov eax, 0x58e6e92
004021a0 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
004021a7 (-0xcfc) 	xor esi, eax
004021a9 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004021ac (-0xcfc) 	movzx edx, cl
004021af (-0xcfc) 	add eax, edx
004021b1 (-0xcfc) 	movzx eax, al
004021b4 (-0xcfc) 	mov dword ptr [ebp - 8], eax
004021b7 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004021be (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
004021c5 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004021c8 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
004021cf (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
004021d7 (-0xcfc) 	mov ecx, dword ptr [ebp - 0xc]
004021da (-0xcfc) 	add eax, edx
004021dc (-0xcfc) 	movzx eax, al
004021df (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004021e6 (-0xcfc) 	xor al, byte ptr [ebp + ecx - 0x24]
ECX: 0x0
EBP: 0x100ffc
		String address: 0x100fd8
004021ea (-0xcfc) 	mov byte ptr [ebp + ecx - 0x364], al
004021f1 (-0xcfc) 	inc ecx
004021f2 (-0xcfc) 	mov dword ptr [ebp - 0xc], ecx
004021f5 (-0xcfc) 	cmp ecx, 0x18
		CMP 0x18
		String: ca141bde35d4d6eb4d4f5f042fbb1d568d74ffb6e9258a22
		Decrypted: b'nE7wz0OCtKCchwwSPNrGqw__'
No strings found attempting with candidate
		String: 000000000000000000000000000000000000000000000000
	\TEST: b'\xa4Q,\xa9O\xe4\x99\xa89\x04\x1cgG\xccj\x05\xdd:\x8d\xf1\x98R\xd5}'
	\TEST: b'\xe1\xd1\x15g\xa0\xe6@\xf0\xff3_3\x95\xf1I[\x11\x9b-\x99\xd9\x00\xa0\xc9'
END for RC4 - Reset flags
004021f8 (-0xcfc) 	jb 0x40215b
004021fe (-0xcfc) 	push 0x15
00402200 (-0xd00) 	pop eax
00402201 (-0xcfc) 	push 0x19
00402203 (-0xd00) 	mov dword ptr [ebp - 0x8c], eax
00402209 (-0xd00) 	lea edi, [ebp - 0x24]
0040220c (-0xd00) 	mov byte ptr [ebp - 0x5b], al
0040220f (-0xd00) 	xor edx, edx
00402211 (-0xd00) 	pop eax
00402212 (-0xcfc) 	mov dword ptr [ebp - 0xd0], esi
00402218 (-0xcfc) 	mov esi, 0x42c4e0
0040221d (-0xcfc) 	push 5
0040221f (-0xd00) 	pop ecx
00402220 (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'ext-ms-win-imm-l1-1-0'
00402222 (-0xcfc) 	mov dword ptr [ebp - 0xc], eax
00402225 (-0xcfc) 	mov byte ptr [ebp - 0x5a], al
00402228 (-0xcfc) 	mov eax, edx
0040222a (-0xcfc) 	mov byte ptr [ebp - 0x34c], dl
00402230 (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402232 (-0xcfc) 	mov byte ptr [ebp - 0x5c], 0xda
00402236 (-0xcfc) 	mov edi, edx
00402238 (-0xcfc) 	mov dword ptr [ebp - 0x59], 0x9aea4a30
0040223f (-0xcfc) 	mov dword ptr [ebp - 0x55], 0xa48e842d
00402246 (-0xcfc) 	mov dword ptr [ebp - 0x51], 0x96eabda9
0040224d (-0xcfc) 	mov dword ptr [ebp - 0x4d], 0xcad2959e
00402254 (-0xcfc) 	mov dword ptr [ebp - 0x49], 0x76085f23
0040225b (-0xcfc) 	mov dword ptr [ebp - 0x45], 0x9e2da54d
00402262 (-0xcfc) 	mov dword ptr [ebp - 0x41], 0xaa6f23bf
00402269 (-0xcfc) 	mov dword ptr [ebp - 0x3d], 0x86e725a7
00402270 (-0xcfc) 	mov word ptr [ebp - 0x39], 0x5a9e
00402276 (-0xcfc) 	mov byte ptr [ebp - 0x37], 0x70
0040227a (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00402281 (-0xcfc) 	inc eax
00402282 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00402287 (-0xcfc) 	jb 0x40227a
00402289 (-0xcfc) 	mov esi, edx
0040228b (-0xcfc) 	xor edx, edx
0040228d (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
00402294 (-0xcfc) 	mov eax, esi
00402296 (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402299 (-0xcfc) 	div dword ptr [ebp - 0x8c]
0040229f (-0xcfc) 	movzx ecx, cl
004022a2 (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x24]
004022a7 (-0xcfc) 	add eax, edi
004022a9 (-0xcfc) 	add ecx, eax
004022ab (-0xcfc) 	movzx edi, cl
004022ae (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
004022b5 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
004022bc (-0xcfc) 	inc esi
004022bd (-0xcfc) 	mov al, byte ptr [ebp - 1]
004022c0 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
004022c7 (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
004022cd (-0xcfc) 	jb 0x40228b
004022cf (-0xcfc) 	mov esi, dword ptr [ebp - 0xd0]
004022d5 (-0xcfc) 	xor eax, eax
004022d7 (-0xcfc) 	add esi, 0x31f6092c
004022dd (-0xcfc) 	mov dword ptr [ebp - 8], eax
004022e0 (-0xcfc) 	mov dword ptr [ebp - 0x28], esi
004022e3 (-0xcfc) 	mov edi, eax
004022e5 (-0xcfc) 	mov esi, eax
004022e7 (-0xcfc) 	lea eax, [esi + 1]
004022ea (-0xcfc) 	movzx esi, al
004022ed (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004022f0 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
004022f7 (-0xcfc) 	movzx edx, cl
004022fa (-0xcfc) 	add eax, edx
004022fc (-0xcfc) 	movzx eax, al
004022ff (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402302 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402309 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00402310 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402313 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
0040231a (-0xcfc) 	movzx eax, byte ptr [ebp + esi - 0x2d8]
00402322 (-0xcfc) 	add eax, edx
00402324 (-0xcfc) 	movzx eax, al
00402327 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
0040232e (-0xcfc) 	xor al, byte ptr [ebp + edi - 0x5c]
ECX: 0x12f
EBP: 0x100ffc
		String address: 0x100fa0
00402332 (-0xcfc) 	movzx eax, al
00402335 (-0xcfc) 	mov word ptr [ebp + edi*2 - 0x7b0], ax
0040233d (-0xcfc) 	inc edi
0040233e (-0xcfc) 	cmp edi, 0x26
		CMP 0x26
		String: dacaca304aea9a2d848ea4a9bdea969e95d2ca235f08764da52d9ebf236faaa725e7869e5a70
No strings found attempting with candidate
		String: ca00000000000000000000000000000000000000000000000000000000000000000000000000
	\TEST: b'kS,\x04x\xda\xa2\x1b\xc2\xa3\xe2\x9c\xf8\xac\xbb\xaa\xad\x91\xfe\x0egJG\x7f\x88\x19\xa7\xfagW\x9a\x92g\xd7\xb4\xaeo\r'
END for RC4 - Reset flags
00402341 (-0xcfc) 	jb 0x4022e7
00402343 (-0xcfc) 	push 6
00402345 (-0xd00) 	pop ecx
00402346 (-0xcfc) 	mov esi, 0x42c500
0040234b (-0xcfc) 	mov dword ptr [ebp - 0x24], 0xd5525b78
00402352 (-0xcfc) 	lea edi, [ebp - 0x50]
00402355 (-0xcfc) 	mov dword ptr [ebp - 0x20], 0xf180dc52
0040235c (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'originatingContextMessage'
0040235e (-0xcfc) 	xor eax, eax
00402360 (-0xcfc) 	mov dword ptr [ebp - 0x1c], 0x60b13c8f
00402367 (-0xcfc) 	xor ecx, ecx
00402369 (-0xcfc) 	mov word ptr [ebp - 0x764], ax
00402370 (-0xcfc) 	mov dword ptr [ebp - 0x18], 0x5f624d36
00402377 (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402379 (-0xcfc) 	mov dword ptr [ebp - 0x14], 0x87b263aa
00402380 (-0xcfc) 	mov edi, ecx
00402382 (-0xcfc) 	mov dword ptr [ebp - 0x10], 0x4efd945f
00402389 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00402390 (-0xcfc) 	inc eax
00402391 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00402396 (-0xcfc) 	jb 0x402389
00402398 (-0xcfc) 	mov esi, ecx
0040239a (-0xcfc) 	xor edx, edx
0040239c (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
004023a3 (-0xcfc) 	mov eax, esi
004023a5 (-0xcfc) 	mov byte ptr [ebp - 1], cl
004023a8 (-0xcfc) 	div dword ptr [ebp - 0xc]
004023ab (-0xcfc) 	movzx ecx, cl
004023ae (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x50]
004023b3 (-0xcfc) 	add eax, edi
004023b5 (-0xcfc) 	add ecx, eax
004023b7 (-0xcfc) 	movzx edi, cl
004023ba (-0xcfc) 	imul ecx, dword ptr [ebp - 0x28], 0x246c21ca
004023c1 (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
004023c8 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
004023cf (-0xcfc) 	inc esi
004023d0 (-0xcfc) 	mov al, byte ptr [ebp - 1]
004023d3 (-0xcfc) 	mov dword ptr [ebp - 0x28], ecx
004023d6 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
004023dd (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
004023e3 (-0xcfc) 	jb 0x40239a
004023e5 (-0xcfc) 	xor eax, eax
004023e7 (-0xcfc) 	or ecx, 0xa58c2a84
004023ed (-0xcfc) 	mov dword ptr [ebp - 8], eax
004023f0 (-0xcfc) 	mov edi, eax
004023f2 (-0xcfc) 	mov dword ptr [ebp - 0x28], ecx
004023f5 (-0xcfc) 	mov esi, eax
004023f7 (-0xcfc) 	mov dword ptr [0x434050], ecx
004023fd (-0xcfc) 	lea eax, [edi + 1]
00402400 (-0xcfc) 	movzx edi, al
00402403 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402406 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
0040240d (-0xcfc) 	movzx edx, cl
00402410 (-0xcfc) 	add eax, edx
00402412 (-0xcfc) 	movzx eax, al
00402415 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402418 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
0040241f (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402426 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402429 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
00402430 (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
00402438 (-0xcfc) 	add eax, edx
0040243a (-0xcfc) 	movzx eax, al
0040243d (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402444 (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x24]
ECX: 0xa58c2aff
EBP: 0x100ffc
		String address: 0x100fd8
00402448 (-0xcfc) 	mov byte ptr [ebp + esi - 0x380], al
0040244f (-0xcfc) 	inc esi
00402450 (-0xcfc) 	cmp esi, 0x18
		CMP 0x18
		String: 785b52d552dc80f18f3cb160364d625faa63b2875f94fd4e
		Decrypted: b'zSe8ewjd/1YU9iaNCqGyGQ__'
No strings found attempting with candidate
		String: 100000000000000000000000000000000000000000000000
	\TEST: b'\x12\x087\xed7\xab\xea\x95\xa0\r\xe85\x0f$\x03\x11\xe9\x12\xf5\xfe\x18\xc5\xa2\x11'
END for RC4 - Reset flags
00402453 (-0xcfc) 	jb 0x4023fd
00402455 (-0xcfc) 	push 0x11
00402457 (-0xd00) 	pop eax
00402458 (-0xcfc) 	push 6
0040245a (-0xd00) 	pop ecx
0040245b (-0xcfc) 	mov esi, 0x42c51c
00402460 (-0xcfc) 	mov dword ptr [ebp - 0x88], eax
00402466 (-0xcfc) 	lea edi, [ebp - 0x50]
00402469 (-0xcfc) 	mov byte ptr [ebp - 0x18], al
0040246c (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'EventThrottleFlushPeriodMs'
0040246e (-0xcfc) 	xor edx, edx
00402470 (-0xcfc) 	mov dword ptr [ebp - 0x24], 0x8095c5a6
00402477 (-0xcfc) 	mov byte ptr [ebp - 0x368], dl
0040247d (-0xcfc) 	mov eax, edx
0040247f (-0xcfc) 	mov dword ptr [ebp - 0x20], 0x3be0b4e7
00402486 (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402488 (-0xcfc) 	mov dword ptr [ebp - 0x1c], 0x736f9f2d
0040248f (-0xcfc) 	mov dword ptr [ebp - 0x17], 0x539ee56a
00402496 (-0xcfc) 	mov dword ptr [ebp - 0x13], 0x6a53c520
0040249d (-0xcfc) 	movsb byte ptr es:[edi], byte ptr [esi]
0040249e (-0xcfc) 	mov word ptr [ebp - 0xf], 0x70cb
004024a4 (-0xcfc) 	mov edi, edx
004024a6 (-0xcfc) 	mov byte ptr [ebp - 0xd], 0x24
004024aa (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
004024b1 (-0xcfc) 	inc eax
004024b2 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
004024b7 (-0xcfc) 	jb 0x4024aa
004024b9 (-0xcfc) 	mov esi, edx
004024bb (-0xcfc) 	mov dword ptr [ebp - 0xd0], 0x1a
004024c5 (-0xcfc) 	xor edx, edx
004024c7 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
004024ce (-0xcfc) 	mov eax, esi
004024d0 (-0xcfc) 	mov byte ptr [ebp - 1], cl
004024d3 (-0xcfc) 	div dword ptr [ebp - 0xd0]
004024d9 (-0xcfc) 	movzx ecx, cl
004024dc (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x50]
004024e1 (-0xcfc) 	add eax, edi
004024e3 (-0xcfc) 	add ecx, eax
004024e5 (-0xcfc) 	movzx edi, cl
004024e8 (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
004024ef (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
004024f6 (-0xcfc) 	inc esi
004024f7 (-0xcfc) 	mov al, byte ptr [ebp - 1]
004024fa (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402501 (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00402507 (-0xcfc) 	jb 0x4024c5
00402509 (-0xcfc) 	mov esi, 0x42c538
0040250e (-0xcfc) 	lea edi, [ebp - 0xdc]
00402514 (-0xcfc) 	xor eax, eax
00402516 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402519 (-0xcfc) 	mov dword ptr [ebp - 0xc], eax
0040251c (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'fileName'
0040251d (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
0040251e (-0xcfc) 	movsb byte ptr es:[edi], byte ptr [esi]
0040251f (-0xcfc) 	mov esi, dword ptr [ebp - 0x1d8]
00402525 (-0xcfc) 	mov edi, eax
00402527 (-0xcfc) 	call 0x401b4e
0040252c (-0xcfc) 	xor ecx, ecx
0040252e (-0xcfc) 	cmp byte ptr [ebp - 0xdc], 0x66
00402535 (-0xcfc) 	jne 0x40257e
00402537 (-0xcfc) 	mov al, 0x66
00402539 (-0xcfc) 	test al, al
0040253b (-0xcfc) 	je 0x402557
0040253d (-0xcfc) 	cmp byte ptr [ebp + ecx - 0xdc], 0
00402545 (-0xcfc) 	je 0x402557
00402547 (-0xcfc) 	mov al, byte ptr [ecx + 0x42c935]
0040254d (-0xcfc) 	inc ecx
0040254e (-0xcfc) 	cmp al, byte ptr [ebp + ecx - 0xdc]
00402555 (-0xcfc) 	je 0x402539
00402557 (-0xcfc) 	cmp esi, ecx
00402559 (-0xcfc) 	jae 0x40257e
0040255b (-0xcfc) 	mov eax, dword ptr [ebp - 0x28]
0040255e (-0xcfc) 	cmp esi, 0x1e04
00402564 (-0xcfc) 	jne 0x40256c
00402566 (-0xcfc) 	imul eax, eax, 0x5c946095
0040256c (-0xcfc) 	and eax, 0x9dfce841
00402571 (-0xcfc) 	inc esi
00402572 (-0xcfc) 	mov dword ptr [0x434050], eax
00402577 (-0xcfc) 	cmp esi, ecx
00402579 (-0xcfc) 	jb 0x40255e
0040257b (-0xcfc) 	mov dword ptr [ebp - 0x28], eax
0040257e (-0xcfc) 	lea eax, [edi + 1]
00402581 (-0xcfc) 	movzx edi, al
00402584 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402587 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
0040258e (-0xcfc) 	movzx edx, cl
00402591 (-0xcfc) 	add eax, edx
00402593 (-0xcfc) 	movzx eax, al
00402596 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402599 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004025a0 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
004025a7 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004025aa (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
004025b1 (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
004025b9 (-0xcfc) 	mov ecx, dword ptr [ebp - 0xc]
004025bc (-0xcfc) 	add eax, edx
004025be (-0xcfc) 	movzx eax, al
004025c1 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004025c8 (-0xcfc) 	xor al, byte ptr [ebp + ecx - 0x24]
ECX: 0x0
EBP: 0x100ffc
		String address: 0x100fd8
004025cc (-0xcfc) 	mov byte ptr [ebp + ecx - 0x39c], al
004025d3 (-0xcfc) 	inc ecx
004025d4 (-0xcfc) 	mov dword ptr [ebp - 0xc], ecx
004025d7 (-0xcfc) 	cmp ecx, 0x18
		CMP 0x18
		String: a6c59580e7b4e03b2d9f6f73686ae59e5320c5536acb7024
		Decrypted: b'3w5AzxdtmK2o\x116gYlQSTxA__'
No strings found attempting with candidate
		String: 000000000000000000000000000000001000000000000000
	\TEST: b'\x95\xb2\xa0\xc1\x9d\xcc\x84O@\xd4]\x1cy\\\x82\xc7/q\x96\x07\x12\x8a/{'
	\TEST: b'\x14\x86)\xaf\x84\x89j\x0e\x98e\xa4}\xa1\xba\xbc\xf0\xee\xd7}\xb47\xb9\xa2\x18'
END for RC4 - Reset flags
004025da (-0xcfc) 	jb 0x402527
004025e0 (-0xcfc) 	mov esi, 0x42c544
004025e5 (-0xcfc) 	mov dword ptr [ebp - 0x24], 0x5934d13a
004025ec (-0xcfc) 	lea edi, [ebp - 0x2e8]
004025f2 (-0xcfc) 	mov word ptr [ebp - 0x20], 0xa84e
004025f8 (-0xcfc) 	push 0xe
004025fa (-0xd00) 	pop eax
004025fb (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'network reset'
004025fc (-0xcfc) 	xor ecx, ecx
004025fe (-0xcfc) 	mov dword ptr [ebp - 0x68], eax
00402601 (-0xcfc) 	mov byte ptr [ebp - 0x1e], al
00402604 (-0xcfc) 	push 0x16
00402606 (-0xd00) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'ork reset'
00402607 (-0xd00) 	pop eax
00402608 (-0xcfc) 	mov dword ptr [ebp - 0x34], eax
0040260b (-0xcfc) 	mov byte ptr [ebp - 0x19], al
0040260e (-0xcfc) 	mov eax, ecx
00402610 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'reset'
00402611 (-0xcfc) 	mov byte ptr [ebp - 0x384], cl
00402617 (-0xcfc) 	mov dword ptr [ebp - 0x1d], 0x56f05874
0040261e (-0xcfc) 	mov dword ptr [ebp - 0x18], 0x283970c8
00402625 (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402627 (-0xcfc) 	mov dword ptr [ebp - 0x14], 0xdaa7a0bc
0040262e (-0xcfc) 	mov edi, ecx
00402630 (-0xcfc) 	mov dword ptr [ebp - 0x10], 0x78b4e37d
00402637 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
0040263e (-0xcfc) 	inc eax
0040263f (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00402644 (-0xcfc) 	jb 0x402637
00402646 (-0xcfc) 	mov esi, ecx
00402648 (-0xcfc) 	xor edx, edx
0040264a (-0xcfc) 	mov dword ptr [ebp - 0xc], 0xd
00402651 (-0xcfc) 	mov eax, esi
00402653 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
0040265a (-0xcfc) 	div dword ptr [ebp - 0xc]
0040265d (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402660 (-0xcfc) 	movzx ecx, cl
00402663 (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x2e8]
0040266b (-0xcfc) 	add eax, edi
0040266d (-0xcfc) 	add ecx, eax
0040266f (-0xcfc) 	movzx edi, cl
00402672 (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
00402679 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00402680 (-0xcfc) 	inc esi
00402681 (-0xcfc) 	mov al, byte ptr [ebp - 1]
00402684 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
0040268b (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00402691 (-0xcfc) 	jb 0x402648
00402693 (-0xcfc) 	xor eax, eax
00402695 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402698 (-0xcfc) 	mov edi, eax
0040269a (-0xcfc) 	mov esi, eax
0040269c (-0xcfc) 	lea eax, [edi + 1]
0040269f (-0xcfc) 	movzx edi, al
004026a2 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004026a5 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
004026ac (-0xcfc) 	movzx edx, cl
004026af (-0xcfc) 	add eax, edx
004026b1 (-0xcfc) 	movzx eax, al
004026b4 (-0xcfc) 	mov dword ptr [ebp - 8], eax
004026b7 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004026be (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
004026c5 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004026c8 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
004026cf (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
004026d7 (-0xcfc) 	add eax, edx
004026d9 (-0xcfc) 	movzx eax, al
004026dc (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004026e3 (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x24]
ECX: 0x114
EBP: 0x100ffc
		String address: 0x100fd8
004026e7 (-0xcfc) 	mov byte ptr [ebp + esi - 0x3b8], al
004026ee (-0xcfc) 	inc esi
004026ef (-0xcfc) 	cmp esi, 0x18
		CMP 0x18
		String: 3ad134594ea8a67458f056a6c8703928bca0a7da7de3b478
No strings found attempting with candidate
		String: a60000000000000000000000000000000000000000000000
	\TEST: b"\xfa\xa9~.\t\xd8b'l\x82\x1eD\xbc\x02]J\xee\xf8\xcb\xa3&gt;\xb2\xeb'"
	\TEST: b'\x82b\xb8\x18\xce9j\xfch$W\xe6Z\xefJ \xb4!`\xc1t\xa3\xaa\x86'
	\TEST: b'\xc7\x92\xb0\xf5Y\xe2\n\xfb\tK\xec\x88{\x95\x8do\xf4e_\xb6\x07\x1c\xce\xdf'
END for RC4 - Reset flags
004026f2 (-0xcfc) 	jb 0x40269c
004026f4 (-0xcfc) 	mov ecx, 0xa8
004026f9 (-0xcfc) 	lea edi, [ebp - 0xa50]
004026ff (-0xcfc) 	mov esi, 0x4330c0
00402704 (-0xcfc) 	xor edx, edx
00402706 (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
00402708 (-0xcfc) 	mov esi, 0x42c554
0040270d (-0xcfc) 	mov byte ptr [ebp - 0x3a0], dl
00402713 (-0xcfc) 	lea edi, [ebp - 0x80]
00402716 (-0xcfc) 	mov dword ptr [ebp - 8], edx
00402719 (-0xcfc) 	mov eax, edx
0040271b (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'already_connected'
0040271c (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'ady_connected'
0040271d (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'connected'
0040271e (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'ected'
0040271f (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402721 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00402728 (-0xcfc) 	inc eax
00402729 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
0040272e (-0xcfc) 	jb 0x402721
00402730 (-0xcfc) 	mov esi, dword ptr [ebp - 0x28]
00402733 (-0xcfc) 	mov edi, edx
00402735 (-0xcfc) 	mov dword ptr [ebp - 0xc], edi
00402738 (-0xcfc) 	xor edx, edx
0040273a (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
00402741 (-0xcfc) 	mov eax, edi
00402743 (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402746 (-0xcfc) 	div dword ptr [ebp - 0x88]
0040274c (-0xcfc) 	movzx ecx, cl
0040274f (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x80]
00402754 (-0xcfc) 	add eax, dword ptr [ebp - 8]
00402757 (-0xcfc) 	add ecx, eax
00402759 (-0xcfc) 	cmp byte ptr [0x434030], 0
00402760 (-0xcfc) 	movzx eax, cl
00402763 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402766 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
0040276d (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402774 (-0xcfc) 	je 0x402795
00402776 (-0xcfc) 	mov edi, 0x434030
0040277b (-0xcfc) 	call 0x4015df
00402780 (-0xcfc) 	or esi, 0xac7b822
00402786 (-0xcfc) 	inc edi
00402787 (-0xcfc) 	cmp byte ptr [edi], 0
0040278a (-0xcfc) 	jne 0x40277b
0040278c (-0xcfc) 	mov edi, dword ptr [ebp - 0xc]
0040278f (-0xcfc) 	mov dword ptr [0x434050], esi
00402795 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402798 (-0xcfc) 	inc edi
00402799 (-0xcfc) 	mov cl, byte ptr [ebp - 1]
0040279c (-0xcfc) 	mov dword ptr [ebp - 0xc], edi
0040279f (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
004027a6 (-0xcfc) 	cmp edi, 0x100
START for key loop - Scanning for XOR
004027ac (-0xcfc) 	jb 0x402738
004027ae (-0xcfc) 	xor eax, eax
004027b0 (-0xcfc) 	mov dword ptr [ebp - 0x64], eax
004027b3 (-0xcfc) 	mov dword ptr [ebp - 0x30], eax
004027b6 (-0xcfc) 	mov dword ptr [ebp - 0xc], eax
004027b9 (-0xcfc) 	call 0x401000
004027be (-0xcfc) 	mov esi, dword ptr [0x434050]
004027c4 (-0xcfc) 	xor edi, edi
004027c6 (-0xcfc) 	call 0x4013ec
004027cb (-0xcfc) 	add esi, 0xa5e2559
004027d1 (-0xcfc) 	inc edi
004027d2 (-0xcfc) 	cmp byte ptr [edi + 0x42caa0], 0
004027d9 (-0xcfc) 	jne 0x4027c6
004027db (-0xcfc) 	cmp edi, 0x2569
004027e1 (-0xcfc) 	jae 0x4027f0
004027e3 (-0xcfc) 	call 0x401b4e
004027e8 (-0xcfc) 	or esi, 0x2f6f3e83
004027ee (-0xcfc) 	jmp 0x4027f6
004027f0 (-0xcfc) 	add esi, 0x1054466c
004027f6 (-0xcfc) 	mov eax, dword ptr [ebp - 0x30]
004027f9 (-0xcfc) 	lea edi, [ebp - 0x80]
004027fc (-0xcfc) 	inc eax
004027fd (-0xcfc) 	mov dword ptr [ebp - 0x28], esi
00402800 (-0xcfc) 	movzx eax, al
00402803 (-0xcfc) 	mov dword ptr [ebp - 0x30], eax
00402806 (-0xcfc) 	mov dword ptr [0x434050], esi
0040280c (-0xcfc) 	mov esi, 0x42c568
00402811 (-0xcfc) 	push 5
00402813 (-0xd00) 	mov al, byte ptr [ebp + eax - 0x2d8]
0040281a (-0xd00) 	movzx ecx, al
0040281d (-0xd00) 	mov byte ptr [ebp - 1], al
00402820 (-0xd00) 	mov eax, dword ptr [ebp - 0x64]
00402823 (-0xd00) 	add eax, ecx
00402825 (-0xd00) 	mov dword ptr [ebp - 0x2c], ecx
00402828 (-0xd00) 	movzx eax, al
0040282b (-0xd00) 	pop ecx
0040282c (-0xcfc) 	mov dword ptr [ebp - 0x64], eax
0040282f (-0xcfc) 	xor eax, eax
00402831 (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'protocolHandlerName'
00402833 (-0xcfc) 	cmp byte ptr [ebp - 0x80], 0x66
00402837 (-0xcfc) 	mov dword ptr [ebp - 8], eax
0040283a (-0xcfc) 	jne 0x402869
0040283c (-0xcfc) 	mov cl, 0x66
0040283e (-0xcfc) 	test cl, cl
00402840 (-0xcfc) 	je 0x402869
00402842 (-0xcfc) 	cmp byte ptr [ebp + eax - 0x80], 0
00402847 (-0xcfc) 	je 0x402869
00402849 (-0xcfc) 	push ecx
0040284a (-0xd00) 	push 0x42caa0
0040284f (-0xd04) 	call 0x401955
00402854 (-0xd04) 	mov eax, dword ptr [ebp - 8]
00402857 (-0xd04) 	inc eax
00402858 (-0xd04) 	pop ecx
00402859 (-0xd00) 	pop ecx
0040285a (-0xcfc) 	mov dword ptr [ebp - 8], eax
0040285d (-0xcfc) 	mov cl, byte ptr [eax + 0x42c934]
00402863 (-0xcfc) 	cmp cl, byte ptr [ebp + eax - 0x80]
00402867 (-0xcfc) 	je 0x40283e
00402869 (-0xcfc) 	mov esi, 0x434030
0040286e (-0xcfc) 	mov edx, esi
00402870 (-0xcfc) 	call 0x401dd8
00402875 (-0xcfc) 	mov ecx, dword ptr [ebp - 8]
00402878 (-0xcfc) 	movzx eax, byte ptr [ebp + ecx - 0x80]
0040287d (-0xcfc) 	movzx ecx, byte ptr [ecx + 0x42c934]
00402884 (-0xcfc) 	sub ecx, eax
00402886 (-0xcfc) 	mov eax, dword ptr [ebp - 0x28]
00402889 (-0xcfc) 	cmp ecx, 0x7dc
0040288f (-0xcfc) 	jbe 0x4028b2
00402891 (-0xcfc) 	or eax, 0x2bb67cf0
00402896 (-0xcfc) 	mov edx, esi
00402898 (-0xcfc) 	push 0x42c934
0040289d (-0xd00) 	push ecx
0040289e (-0xd04) 	mov dword ptr [ebp - 0x28], eax
004028a1 (-0xd04) 	mov dword ptr [0x434050], eax
004028a6 (-0xd04) 	call 0x401e4c
004028ab (-0xd04) 	mov edx, dword ptr [ebp - 0x28]
004028ae (-0xd04) 	pop ecx
004028af (-0xd00) 	pop ecx
004028b0 (-0xcfc) 	jmp 0x4028c7
004028b2 (-0xcfc) 	and eax, 0x7718229a
004028b7 (-0xcfc) 	mov dword ptr [0x434050], eax
004028bc (-0xcfc) 	call 0x401000
004028c1 (-0xcfc) 	mov edx, dword ptr [0x434050]
004028c7 (-0xcfc) 	mov esi, dword ptr [ebp - 0x64]
004028ca (-0xcfc) 	mov ecx, dword ptr [ebp - 0x30]
004028cd (-0xcfc) 	mov al, byte ptr [ebp + esi - 0x2d8]
004028d4 (-0xcfc) 	mov byte ptr [ebp + ecx - 0x2d8], al
004028db (-0xcfc) 	mov al, byte ptr [ebp - 1]
004028de (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
004028e5 (-0xcfc) 	movzx eax, byte ptr [ebp + ecx - 0x2d8]
004028ed (-0xcfc) 	add eax, dword ptr [ebp - 0x2c]
004028f0 (-0xcfc) 	mov ecx, dword ptr [ebp - 0xc]
004028f3 (-0xcfc) 	movzx eax, al
004028f6 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004028fd (-0xcfc) 	xor al, byte ptr [ebp + ecx - 0xa50]
ECX: 0x0
EBP: 0x100ffc
		String address: 0x1005ac
00402904 (-0xcfc) 	mov byte ptr [ebp + ecx - 0xcf4], al
0040290b (-0xcfc) 	inc ecx
0040290c (-0xcfc) 	mov dword ptr [ebp - 0xc], ecx
0040290f (-0xcfc) 	cmp ecx, 0x2a0
		CMP 0x2a0
		String: 41acf7990000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
No strings found attempting with candidate
		String: 0000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000680000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009c000000000000000000a60000000000000000000000000000000000000000000000000000000000000000000000ca0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000066696c654e616d65007479001a0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000015000000110000000000000070726f746164795f636f6e6e6563746564000000000000000e0000000000000000000000dacaca304aea9a2d848ea4a94576656e745468235f08764da52d9ebf236faaa725e7869e
	\TEST: b'\x14\xc7\x9b\xcf\x0eb\xaa\xe8!+\xb1\x9b\xd5\xde^\xa5\x8c\xaa\xb7\xf4\xdb(Z\xf7\x9f\n2Y\x00&lt;\xf3!\n\x8f\xed`bl\tF\x02aY]1\xc5G\xd8BDAx\\\xd0\xc8\xd4Z\xad\x1f\x87\x0fDU\xf9\xb5\x9b\x9b\xf2\x9b\xaaW\x97:\x18\xeb\x8f\xd7\x84\x85\x18\x86\xe5N\xa1\xd8X@?\xe1 $?\xd2\xc2\x0f~{o\xab\x13\x8b&lt;&amp;A\xcb/`\x1d\x12{\xcb\x90yM\x84\xbb\x14o5\xd1\xa6 \x87\xa9%\xb5\xbd\xc9\xd0\xa8\xa4\x89\xd2W\x97=1P\x86\x80\xdb\xc4]\x0c\xee\xe3\tn\xf3.@Ks \xe8\xf9\xa2X\x88I\xff\x19m=\xafv&lt;\x89\xf6\xdc`\xaep\xef\xf82\xedy\x08\xfb}NE6\x0b!H\x98\xaa\xa4\xe7\xab\x7f!y\xedO"g\x8dQ%/\xc5(\x11e\x8a\xd7\xee\n\xb4\x9b[\xee\xa4)\xe9~\xa1p]!\'\xdd\n\xf7\xc9\xedS6\x93\x95&amp;\x80t\x16\xfe}s\xe4\xcf\xf7\xe6*\xa36\xd5\xdbx\xce\xb4\x85\x04\xa2\xcaf\xc2\x93SFio\x94$\xa4\xb5\x97\xf2\xf5,^\x87M#\x19\x99\x8d0\x8f\xa9\xe9\x04\x81\xb1\xcc4\xdd\x8b\x9e\xbe:w\x19k\xe3s\x15T\xa3\x14\xb7\xb5\xa6\x8a\x01\xfa\xe0Xt+\x13\x81\xb9r\xf5s\x85\xb8t3\xee\x15\xaf\x17\x0fJ{\x16\xad\r6\xbfyf\x04\xea\xcc\x1dZ\xfbB\x9e\x9a\xe9@{\xb4\xcd\xcbO8\xfe\x98\xf6\xeb~\xfb\xb9\x8c\xfcB\xb6O\xc67\x01\xe3\x17\x90\xbe\xed\xd7\xac\xda:\xc6\xf5\x06x\x1c\xef|\x81\x95~\x06\x84\xcb\xd0\xb7\x9d\xdc,\x92\xe14\xf6pX\x99Azm\xed\xfd\x02\xaa\x97\xbb\xe4i\xc4\x974\xf2K\xf0\x92\x00\x1d\xbf.\x02\xef\xe9\xc1\xbd\xaa~{\xa3\x96\xd8\xe4/\xbb\xe2C\x84m\xa0]\xb4)\xa7\x97\xd5\xa6N\x03a,\xaf`\x82\x18\xdd\xda\xfb9\x9fa\x96\xa7\xb7\xb1+\xb0F%\xdc@\xb8\xe8\x9bWP\x89\x98\xea\x18;,e\xfb R\xcf\xbe&lt;\x8d#\xb4\xc3\xf1n\xd1\x05c6\x81\xae:;\xcey@\xff\xd3\xf7\xa0W*@I\x98z[]\x04\xf3~\xe6\x04h\x9b\x8f\xc0\x1e\xfe\r]xK3\xf9\xfa\x1c\x80\x0f\x92\xd6\x81\x08\x842W\x12\x17:\xa9x\x82\x91}84\xcd\x03\x1e\xc7Xs\x05\x0b#\x92O\x0e\x12v\xc9]3i&lt;\x9d\x1b\xbb\x8d\xd8\xbc\xec\x08\xa5\xfa\xb8P$R\x90\xcf\xc3\x11\xfc\xd8c\xd4X\xbd\xad\xe9K\xd4\xfc\xeb\xf2\xb5\xff\x1fO\xcbT\x83\xcd\xb6%\x99\x1b\r\x00\x94x\x91F\x172v\x054\xa1\xc8xo\x93}\x01\x8al\xef\x0f\xfa\x1e&amp;\x8e\xb7\xde\xab\xd9\x91Rf\xf6Y\xbbbh\xe3;\xe0d;\xe6\x92\xdcG\x18\xe2\xbd\xc9L'
	\TEST: b'\xbc\x00\x13&amp;\xbb\xd1\xa5XQ]\xbeu\xfdz\x87\x93\xd4)D\x94+/`\n\xef@8\xd6\xb13\xfcR\xd1\xa3\xb3\x05k\xc4\xc60\x0fM#\x87!\xe1\xb3%\xb7\xc7L\xcd\xd4\xb3n\xa8\x04\x9b#\x92\x0b\xa4\xb2\xedN$9\xb7"x\x9dBc\xb4\xc5\xf5$\xf6\xf7,``&amp;\x13G\xbc\x8fV\xdb\xa6\x18\x01\x10S*\x1c\xdaM\xb0\xf8\xdc\x16GEM\xd2\xc4mRs\x0bh`\x9f\x12\x9c\xad\'d!\xb7\xd5\xae\xcc\xf9\x9b\x802\xdc\xeerG\x92\xa0\x8b\x050U\xbd\xc2\x9e\xc8[\x9f\x17\x8c\xeaGbV^\xde\xdc\x9eo[\x8e2\x9b\xf8A\xbf\xdf\xaf\x90]4\x83p\x8e\xef\xb6\xb2\xd9\x0c\xfad\xa4\xa4O\xdb\xca\xad\x99\x17\x16D\xaf\x03\xa1\x95\x81\xc3\x89&gt;,\x02\x1a9\x8c\x8152\xdfo)\xf2\xedkS\xcb\x91\xed\x92X\x19a\xd9\xda\x0c\xb9\x13\x1e\xddy\x17\xdch{\x9c\x8f\x1aa\xe4td\xd7F~\x02$\xfe\x0fu\xf7n\xcf\x15\x15\x9b\xcc\x1b\x01F\x9b\xcb\x10\xe6$\xf2\xe3\x8dD\xb1\xeeS\x96\xceJe#\xa7\xbe\xf6z\xcd\xa9\xfa_\xbea\xd1\xd6T\xa83\xc4*J\xcc\xafYH\x8e\r\xefHO]\'\xf5\xc8\x81\xe1\xf3\x94p\xf1x\xf0\xa5\xc7%^\x01\xdec\xa9\x0c\xd0\x8a\x15\xe5}a&lt;;d\x15X\x03\xff\xe7;\x14sc\xed\xcd\x95I\xbe\xe6\x1c\xa9]\x83\x8eY\xd17\xbb\xe0?\x82\xd1he??\xd3\xee\xa8\xae\x8e\xd6\xd1\x85P\x07S\xa9\xac^\x1b*\x85\x90@\xfa\xbdj4\xa3\xb1\x9de\xe6\x01B\x18\x80\xf0\xb5\xf0o\xeaH\xfd\xaa\xac\xfcAu\x1b\x9d\x1div\xecl"i\xafi\xc5\x1e\x1c\x9aq\x837\xa0=\xb1Uc\xed\xd0\xf2$\x15Nm\x86\x11e\x90Fo)\xbc\xf2\x8flaRf3\x07\xe9\x95\x8aW\x16V:"^q\xd9\xe6\x1fA\xc2r\x19\x84#Q\xa5\xe2\xac\x8e\x84k\xeewn\xc5\xee_\'\x86\xd3\x93[\x0e\xc10$4S\xb8l\x89\xf5\xd3\xd1@\xe8 \x7f\xeeq\x9dP\xf1\x918X\x9e:\x07\x11\x10rX\xa4\xea\xd9\x1e\x18\x85\xa3\xbb\x80\xc59\x98\xed\x1b\xb4,\xdaJnV3\xa5ez\x1e\xc3P\xb3S8\xd3\xa5\x00\xfc\xe4n\x91R\x92u\xea\x95N\xf3j\xbcX\xc5\x9ar\x9fk\x83\t\xf3\xf9]\x16\x99Ax)\x12\xde%b\x80i`\xd2\x0cz\xd46e\xe9\xf8\xb3DV\xa0\xcd\xd0\x07@\xf4\xe4Z\xb6h\xa6hr\x92x\x14_\x01\xa3\x8a#S\x91.\xb6\xbf|\xf3b9u\x11J\xcb!f\x8aG\xfa\xc8\xa3\xae\xe6$\xd4\xb9\xa6\xc4\x11\\\xb8\xcb\x87\xe2\xc7w&gt;H\t\x8ebI\x8d\x8e\xf1ft\x13\x86aH\x95\xa0\t'
	\TEST: b'Ro\xe1 \xa7\xe4\xe2\xa2\xf5\x9b\x97\x10\xea\x10{f\xb5\xa5\xd1[\xf5y\r\xe0\x1a\x80\xcb\xd6/\xe6\xd7\xe5\x8fJ\xef\x9c.\x05)\xc7\xf8\x15\x0f\xb1\x00\x8c\xcd\xd4\xafv?$O/\xab\xf7\xd4\x9aK\x11\xa5E\xc2\x88\xc73j\x95\x81\xacr\xa7s\x0f)s\xca\xba:\x10\x00\x1d\x1e\xa6nL\xe81?Y\x8a\xf2/\x135\xcd|"\xa2\xb9\xcb\x06T\x9f|\x1a+\xb2\xeb\xb5\x8d\xfa\x1f\x05/\\5\x86T\x12]\x8d\x8b= \x08]\xdbX\x90Pk\xc8d\xb11\xf8\x93\xd9\x07\xdd@\xc2\xcfj@\x7f\x81wy\xe3\xadKq;\x8d\x08W\xbc\xc9z\x1a\xd3\x8a\x89`)\x1f\xda\xdbr\xfe_\xb8\x88\x18M\xe5\xbeMY\xa4(z\xac\x8ev\x13\x93)t?\xc8\xa5\n\x08\xe6\xd3\xc9\xf9\xe7^\xf5Dg\xbe\xc2\xf7\xb5U\xa8}\xe4$\x98\\\xc2\xc0\xbf&amp;\xa3\xed\x8f\xb4\xaf\x8a\x0fe%\xa19\xce?z\x11{\x16&amp;\\J\xa48~\xf9\x92\xda\x05\x062\xa5{1\xc0$\x8a\xe0)\xa3T\xba\xd6\x9c\xb8\xeby&lt;\x00/e1$\x9cm\x16\x00\xe4\xc4\xa5\xf1\xb65\xda\x0e\xb2\xb7\x86_\x92\xeb\x8as\xc1\x00"\xa3F\x83\xc2\xadFU{\xfdJR\xbe\xfd\x9e\\e\t\'3yQ\xbf\xbb\x99\x98\xc0[\xb2\xce\xf0aY\xef\xe7K&amp;Y\xach\xb9\xd2O5\t\x0fF \xf6*\xed\xce\xbf\xf3\xec8\xd4\x18.O;\xaaCg\xee\x04_Z\naDz\xff\xb2\xcc\xd5\x17\xae0C\x9d\'~\xe2\xa3B0\x07\xad\x99\xbd\x08e\xbbX\xa7\xe5\'\xd9z\x9d.\x0bX\xab\x07\x01\x8a xtJg\xf8x\x8a\xa2\x18EA\xf4\xf0\'Z!\x82\xb6z\xa5E\xd5e\x15Q|&lt;\x16\xb3\xdbt\xb1/V\xb1\x02 \x07\x19\xf3\x16\x0b\xe6R\xfb\x9ao/g\x13\xf6Y\xeeQ\x00a\r\xfb\xff\x95.\x15\xe8\xcay\xc8\x1am\xe0\xb8\x7f\x80\xeb\x99\xd6\x9ea\x00\x8fM\x0b\xbam,\xbbm\x85D\xde\xa1v\xc0\r\x87\x90\x8b\xdd\xcd\xe4\xd3=\x18u\xf8\xf6N\x06l\x1b\xd4\xc2\xc0\x82\x10C\x85\xd3\xd0h\x0f\xd92k\xa7X\xff\xc04_\xd76\xe9\x9fz8b\xe2\xf2P\xfc,\xdb\xd47\x1a2\xd9\xad\xdb\xb3R\xedc\xd9j\xac\xebT\xf1([\xa8\xeb\x8e$\xdd\xd5\x93\xca\xa6\x88\x9c\xb6\xc6\x8d\xe8\x88\xbf\xfb5\x82\x98\x8a^\xbeX\x9fT\x84\xa0\xe2\xf5\xd9qJM\xd9c\x01\xb9\xe3\xdaMH\x0b|I\x96\x8e\xc5\xe6\x0e2\x9f\x80\xd1|\x98C\xb3\xc6\xa9W\x93S~\xf2\x13\xcb\x87z\x8d.\x0c.\xa5\xd8\xe7V\x1b^\xdd\xcc\xa5\x9f\xe9c\xc1x\xd1km\x1b\xb7\xbc&amp;\x18x\x8b\xcb\xb8\x07\xc76\x9a\xec\xb9H!\x9e'
	\TEST: b'b\x026\xfb\xf1\xd4\xa6\xba\xe4\xb3\xa1\x1c\xec1\xd04\xc0L\x8f}6\x92QfVP\x9bQC\x12\x8d\xa8\xe1\x8ef\xc2\x9f&gt;a\xd0\x0f-\xe4\x07\xd8\xabE0=\x8c9I\x00\x7f\xf0\xb3\x8d\x84M\nu\xca_\x1aU\xa6bXW\x03\xb3\xda\x8d\xed\xce\x9f\xd0"w\xda\xa4\x08\x19\x18\xb6\x04\xd7\xd7Q.\x81\xceE\xa3G\t0d\x15\xf0\xb6\xda|aU[\xd9&gt;\xacKH\xde\xab4\xdfN@Vn\x1f\x0e1\xbaN\xc6\r\xc4+3\xb8\xfe#\xe9\xa4\xe7Ei\xf5e\xa8\xc9\x1b\xd3\x99|\xbbQT\xcd\x0f\xa4\xe2\x90\x18\x14\x17k\xd9"V\xdfJ-S\x01nKm\x0bqy\xd82-\xd5\xb5B U\x83\xa9\xe3\x0e\x87)\xf3\x126\x97\xbaO\xbd\x13$\xd5]\x11\x14+q\x15P\xb1/\xb0,&lt;\xde\xb8\xcc\xbb#}\'XH5X@X\xa9\xbe\x16\x04\xc2\x88^\xfbA\xad\xc4\xaft\x85\x90\\\xcd?\xc7bx\xabf\xf6\xa6\xb4O\xb9\'\x93\xfe\xf7\xd9\x1c\xb3e\xc9\x89gJ\x02&gt;\x14=\xa7\x90+\xbe2\x92\x1f\xce\xb5\x10\xd7\x90\x96\x12;\xb9 \x8d\x00\xef8q\xf5\xfb7\xd4\xfa\x0c\x8a:N\x8eF\x7fn\xd2\x19MG\xc8\xd5\xb2\x9d\x1c\xd0\xf3\x96\xdf8\x0c\xf7\x86\xa6NI\xd0\x1bL\r\x1a\x8av\x85\xb3\x1b\x7f\x10\x0c \x14-\x8c\x19\xef\x06\xd5\x1a\x06\xdd\x9dF\xe0\x9b\xd1\xaaD\xe0\x9f\xc6\x889\x8c!\x15L\xde_\x9a\xca\x92M\x0e$\xfd\xf8\xdbP\xbc\x1f\xb4\x86E\xd3\xa2\n{\xc5\x04\xf7N\x83\xe8\x12U\x85\xf4\x9ay\xc3\xbf\xd3\x1e\xc5\xd1!\xde\x00i\r\xca\x9b\x1bI\x12\x92\x04\x11\xe8G\x89a5-Z4?\xa2\xc7\xaf\n\x86Kz\xc0\xa1\xa0\xd5\x89\x88\xf4W\x15\xfb?\r\x9a\xbf[\xa8c\xd3lO"\t\x1b/\x13{\xaf\x05\xef\xbd\rv^\x19\xf5\x8f\x1ce\x89\xd4\x14\xf1@\x89)gt\xfa\x14\xbc\x1e\xbe\x94\x0b\xa4\x04Q \x9fJ+[9\x897DXO\xe4\xa9\xe9\x12\xd5\x1c\xa2\xfeO\xb5\xb1\xec\x83o\xfb\x97S\x8d\xc5\x0c\xe7n5\xb6\xa1xn\x04\xc0\xca\x81\x81D\xa7Q\xc9\xec\x1a\x0cq\xd9\xe0\xac\xf6\xe7\xaf\xdf\x99\xe2\x08\xcf\xb7\xcb\xae/\x82\x94\xd7\xd3E\xd1\xf3\xc1pO\x05.\x99\r\x91\xb8c\xf3E\xcea\xd0\xfd\xa7Z\x86.\xe7\xc5\xa2\x19\x1a\x92{\xeb\x88w\x8a+\xb6\xd7\xb4\x05\xb9\xdc\xfa\x9d\xf7JP\x9e\xaf\x91\xf4eoJ\x0e\x9ar-\xeeD\x0c\x8cXXS\xbb\xa3\xec\'\xe9\xee\x1d&gt;\xa5\xcb\x1a\xc78\xb5\r\xfc\\\x15\x92W\x87\x86%\x7fRw\x92\x8b\x7f(\xde"\xdeA\x9c3\xc5\xb7X\xe3\x08V\xde\xce\x05\xdc\x8e(\x89lYpw;'
	\TEST: b'9\xa4LgG{\xa4 \xa8\x03e:\x98#\x9d\x1a\x83Bm\x1a\xca\x1dXR7\x15\x15.\xad\x9d9\xcb\xe3\x8b\x112\xe9\xe2\x10\xe3T\xc8\x96}|K\xb0\x88\x85\xfd\xa7v\x90]NJ\n\x18\x89!,\xf7\xdf\xc75)_\xed\xb5`\x06\x89\x82\xaf\xc5\x1a\x89,\xd5\xfd\x0cc\x9a\xae\x84^\xaa\xd5\x1d\xb5\x85\xb8\xec\xca\xd8W]\x84\xd6\n\x8ed\xfa\xe3\xe6Fej\xac[\xba\xbe\xf0\x19\x8bH\xe9\xce\xae\x95"$\x14\x84\xd2d\xc58pC~\xdbz\x90\x0e\n\xf33K\x9d\xde-+\xe27n\\z;\xf4U\xc1OIS\xf9\xdb\x1ev\x8eq\xeb\xbd\xda\xab\x91\xd5\x13\x1c\x928l\xa1\x8efdx\xa4 \'\xc9z\xe6W\xaf\x1f\x01\xaf\xb8\x8a\xa0\x1ef\xc5hmA@~t\xa7\xb6\xeb\xd1\x0b\xcb\x95,\x95\'\x0e\xc7e4\x9e\xab,$xk\x19\x02d.\xbc\xbf\x1fm\xe2\x8d4\x8d\x89\xd4\x04=AR#4\xd3\xe6\x1c\xe0\xf5T\x82\xd6\xbc\xd8.R(Q\xb58\x84\xec\xff/\'\xd9\x98\xf0\x13\n\x19\xd8\xca\xc0\x9eU\\\xc9\x81\x8f\x07#\xce\xc6Vy\xc1\x8d\x8a.\xbf\xe7^\xd4Q\xc1\x9dkPz\x86N\xd1\t\xb7bafS\x8a\xa3\x81\x04\xb8M\x9f\x9f\x8cj\xd2\x19h\xda\xb9Z6\x95\xc3\x9dY\xb3\xce\x92x"\xc8\xaf\xa5\xd0u\xff\x9c\x9c:\x92U8\xd6\x8b\xea\x02\xbb\x04\x83&lt;\xab\xe1\x1d\x89\\\xfd(_W\x00\xa4|\xcd\x87US\xb6\xfd4Bxe\x9e\xe6\x8a\xe1:\xb8\xcdz\xf0(FV\xec\xe1\x81\x96}Iz\x06Z\x06\xa9\x01k\xa1:\xb6R\xbd[\xbf\xfe\x95\xad@y\x9a\xc8\xb6\xe9\xbe\x98\xc7\x00\x1aEa_\x97\xd1+\xb0`\xd7Kc\x1e\xc5\xd4\xcb\xcdrKZ\x04\x0fv\xffE\xbf\x0f\tG\x07\x84!\x02\x01\r\x8f\xb5\x13\xd2\x0b\xb2\x0c4\xa7\x8fC\x12?&lt;\x02\x1a$\xd4\x15\x03ZV\xc4\x8fQ\x95\xec\x00Z\xdf\x92\x91|\xb0\xa4\xd4}\\o\x1e\xdf]bR\xdb\x15E\xa3\xc4_*\xd6LF\xa0\xcd\xb7{z\xdasunm\xc4-\xb3\xc4\xd6\xa1\x1a\xe7bM\n\x96E\xc8\xbc\x92&lt;\xfb~\\\xe5J\xa9\x0cL\xfb\x14\xb3\x1a\xbf\x92\x8b\xa8q\xc3\x9d \x0c\xf5\xf83\xbd\x0b^9\xc8\x85\x17,\xd1\xab\xa9\xa6\x0c\xf9\xb3K\xbb\x00\xd1\x86$1\x12\x01(\x13\xb9\x1ap\x9d\xbe]\xef\'kmN]\x92\xdd\xf7;\xcc~\x98}\xbbo\xa2|\xdc&lt;\xfb\x16\xa3\xb2\xf9\x95\xe9\xc1m\xa1\xc3S\xe1^\xdd\xc0[\xca\x8c\xe3\x02nP\r\xd7\xf0{X\x1a\x89s\x19\x1e8\x88\xd9\x9e^N!\xc1\xe7\x9c\xc4\x03b\x89\x8dp\xb8\x92s6\xc3\xb6c)E\xf2\xc9\xb3&gt;'
END for RC4 - Reset flags
00402915 (-0xcfc) 	jb 0x4027b9
0040291b (-0xcfc) 	push 5
0040291d (-0xd00) 	pop ecx
0040291e (-0xcfc) 	mov esi, 0x42c140
00402923 (-0xcfc) 	mov dword ptr [ebp - 0x84], 0xe5a0999d
0040292d (-0xcfc) 	lea edi, [ebp - 0x24]
00402930 (-0xcfc) 	mov dword ptr [ebp - 0x80], 0xde265110
00402937 (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'currentContextMessage'
00402939 (-0xcfc) 	xor eax, eax
0040293b (-0xcfc) 	mov dword ptr [ebp - 0x7c], 0x857b150
00402942 (-0xcfc) 	xor edx, 0x97c53415
00402948 (-0xcfc) 	mov byte ptr [ebp - 0xa54], al
0040294e (-0xcfc) 	mov dword ptr [ebp - 0x78], 0x4aff979b
00402955 (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402957 (-0xcfc) 	mov dword ptr [ebp - 0x74], 0xe389e0fc
0040295e (-0xcfc) 	mov edi, eax
00402960 (-0xcfc) 	mov dword ptr [ebp - 0x70], 0x8c5d48ef
00402967 (-0xcfc) 	mov dword ptr [ebp - 0x28], edx
0040296a (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00402971 (-0xcfc) 	inc eax
00402972 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00402977 (-0xcfc) 	jb 0x40296a
00402979 (-0xcfc) 	xor esi, esi
0040297b (-0xcfc) 	xor edx, edx
0040297d (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
00402984 (-0xcfc) 	mov eax, esi
00402986 (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402989 (-0xcfc) 	div dword ptr [ebp - 0x8c]
0040298f (-0xcfc) 	movzx ecx, cl
00402992 (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x24]
00402997 (-0xcfc) 	add eax, edi
00402999 (-0xcfc) 	add ecx, eax
0040299b (-0xcfc) 	movzx edi, cl
0040299e (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
004029a5 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
004029ac (-0xcfc) 	inc esi
004029ad (-0xcfc) 	mov al, byte ptr [ebp - 1]
004029b0 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
004029b7 (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
004029bd (-0xcfc) 	jb 0x40297b
004029bf (-0xcfc) 	xor eax, eax
004029c1 (-0xcfc) 	mov dword ptr [ebp - 8], eax
004029c4 (-0xcfc) 	mov edi, eax
004029c6 (-0xcfc) 	mov esi, eax
004029c8 (-0xcfc) 	lea eax, [edi + 1]
004029cb (-0xcfc) 	movzx edi, al
004029ce (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004029d1 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
004029d8 (-0xcfc) 	movzx edx, cl
004029db (-0xcfc) 	add eax, edx
004029dd (-0xcfc) 	movzx eax, al
004029e0 (-0xcfc) 	mov dword ptr [ebp - 8], eax
004029e3 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004029ea (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
004029f1 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004029f4 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
004029fb (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
00402a03 (-0xcfc) 	add eax, edx
00402a05 (-0xcfc) 	movzx eax, al
00402a08 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402a0f (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x84]
ECX: 0xa4
EBP: 0x100ffc
		String address: 0x100f78
00402a16 (-0xcfc) 	mov byte ptr [ebp + esi - 0x3d4], al
00402a1d (-0xcfc) 	inc esi
00402a1e (-0xcfc) 	cmp esi, 0x18
		CMP 0x18
		String: 9d99a0e5105126de50b157089b97ff4afce089e3ef485d8c
		Decrypted: b'Gde8pBiEKFF7lpxrfHR6ag__'
No strings found attempting with candidate
		String: 410000000000000000000000000000000000000000000000
	\TEST: b'\x9b\xfd\xc5\xdd`\x13O\x9b\x1b\xf7\x11?\xf7\xe7\x878\x9a\xa8\xdb\xd5\x8e/\x02\xd3'
END for RC4 - Reset flags
00402a21 (-0xcfc) 	jb 0x4029c8
00402a23 (-0xcfc) 	mov esi, 0x42c57c
00402a28 (-0xcfc) 	mov dword ptr [ebp - 0x24], 0xd2daf2e8
00402a2f (-0xcfc) 	push 0x11
00402a31 (-0xd00) 	pop eax
00402a32 (-0xcfc) 	mov byte ptr [ebp - 0x16], al
00402a35 (-0xcfc) 	lea edi, [ebp - 0xdc]
00402a3b (-0xcfc) 	mov eax, dword ptr [ebp - 0x28]
00402a3e (-0xcfc) 	xor ecx, ecx
00402a40 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'callContext'
00402a41 (-0xcfc) 	or eax, 0x785b2e9d
00402a46 (-0xcfc) 	imul eax, eax, 0x20cefeee
00402a4c (-0xcfc) 	mov byte ptr [ebp - 0x3bc], cl
00402a52 (-0xcfc) 	mov dword ptr [ebp - 0x20], 0x5aec74cb
00402a59 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'Context'
00402a5a (-0xcfc) 	mov dword ptr [ebp - 0x1c], 0xe19837cf
00402a61 (-0xcfc) 	mov dword ptr [ebp - 0x2c], eax
00402a64 (-0xcfc) 	mov dword ptr [0x434050], eax
00402a69 (-0xcfc) 	mov eax, ecx
00402a6b (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
00402a6c (-0xcfc) 	mov word ptr [ebp - 0x18], 0xc9df
00402a72 (-0xcfc) 	mov edi, ecx
00402a74 (-0xcfc) 	mov dword ptr [ebp - 0x15], 0xb42c0878
00402a7b (-0xcfc) 	mov dword ptr [ebp - 0x11], 0x3639af8f
00402a82 (-0xcfc) 	mov byte ptr [ebp - 0xd], 0x52
00402a86 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00402a8d (-0xcfc) 	inc eax
00402a8e (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00402a93 (-0xcfc) 	jb 0x402a86
00402a95 (-0xcfc) 	mov esi, ecx
00402a97 (-0xcfc) 	xor edx, edx
00402a99 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
00402aa0 (-0xcfc) 	mov eax, esi
00402aa2 (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402aa5 (-0xcfc) 	div dword ptr [ebp - 0x1d4]
00402aab (-0xcfc) 	movzx ecx, cl
00402aae (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0xdc]
00402ab6 (-0xcfc) 	add eax, edi
00402ab8 (-0xcfc) 	add ecx, eax
00402aba (-0xcfc) 	movzx edi, cl
00402abd (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
00402ac4 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00402acb (-0xcfc) 	inc esi
00402acc (-0xcfc) 	mov al, byte ptr [ebp - 1]
00402acf (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402ad6 (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00402adc (-0xcfc) 	jb 0x402a97
00402ade (-0xcfc) 	xor eax, eax
00402ae0 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402ae3 (-0xcfc) 	mov edi, eax
00402ae5 (-0xcfc) 	mov esi, eax
00402ae7 (-0xcfc) 	lea eax, [edi + 1]
00402aea (-0xcfc) 	movzx edi, al
00402aed (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402af0 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
00402af7 (-0xcfc) 	movzx edx, cl
00402afa (-0xcfc) 	add eax, edx
00402afc (-0xcfc) 	movzx eax, al
00402aff (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402b02 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402b09 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402b10 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402b13 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
00402b1a (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
00402b22 (-0xcfc) 	add eax, edx
00402b24 (-0xcfc) 	movzx eax, al
00402b27 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402b2e (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x24]
ECX: 0x13f
EBP: 0x100ffc
		String address: 0x100fd8
00402b32 (-0xcfc) 	mov byte ptr [ebp + esi - 0x40c], al
00402b39 (-0xcfc) 	inc esi
00402b3a (-0xcfc) 	cmp esi, 0x18
		CMP 0x18
		String: e8f2dad2cb74ec5acf3798e1dfc9dc78082cb48faf393652
No strings found attempting with candidate
		String: dc0000000000000000000000000000000000000000000000
	\TEST: b'\r\x80\xeb\xe0\xaaE\xdf"\x98\x1c\xe1\xb8\x8f\x9b\x7f@9~\xd9\xc5\x84Ni\r'
	\TEST: b'j\xeaF\x12jSOUO\xeb^\xe16\xb0_z\x0e:\xcf\x0f\x06\xc4\xcf\x1c'
END for RC4 - Reset flags
00402b3d (-0xcfc) 	jb 0x402ae7
00402b3f (-0xcfc) 	push 0x12
00402b41 (-0xd00) 	pop eax
00402b42 (-0xcfc) 	push 5
00402b44 (-0xd00) 	pop ecx
00402b45 (-0xcfc) 	mov esi, 0x42c588
00402b4a (-0xcfc) 	mov dword ptr [ebp - 0x2f0], eax
00402b50 (-0xcfc) 	lea edi, [ebp - 0x24]
00402b53 (-0xcfc) 	mov byte ptr [ebp - 0x76], al
00402b56 (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'argument out of domain'
00402b58 (-0xcfc) 	xor edx, edx
00402b5a (-0xcfc) 	mov dword ptr [ebp - 0x84], 0x86b6f46e
00402b64 (-0xcfc) 	mov byte ptr [ebp - 0x3f4], dl
00402b6a (-0xcfc) 	mov eax, edx
00402b6c (-0xcfc) 	mov dword ptr [ebp - 0x80], 0xf6d8ccfb
00402b73 (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402b75 (-0xcfc) 	mov dword ptr [ebp - 0x7c], 0xda5a8c7d
00402b7c (-0xcfc) 	mov word ptr [ebp - 0x78], 0xde65
00402b82 (-0xcfc) 	mov dword ptr [ebp - 0x75], 0xe4636b64
00402b89 (-0xcfc) 	movsb byte ptr es:[edi], byte ptr [esi]
00402b8a (-0xcfc) 	mov dword ptr [ebp - 0x71], 0xf0633655
00402b91 (-0xcfc) 	mov edi, edx
00402b93 (-0xcfc) 	mov byte ptr [ebp - 0x6d], 0x96
00402b97 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00402b9e (-0xcfc) 	inc eax
00402b9f (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00402ba4 (-0xcfc) 	jb 0x402b97
00402ba6 (-0xcfc) 	mov esi, edx
00402ba8 (-0xcfc) 	xor edx, edx
00402baa (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
00402bb1 (-0xcfc) 	mov eax, esi
00402bb3 (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402bb6 (-0xcfc) 	div dword ptr [ebp - 0x34]
00402bb9 (-0xcfc) 	movzx ecx, cl
00402bbc (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x24]
00402bc1 (-0xcfc) 	add eax, edi
00402bc3 (-0xcfc) 	add ecx, eax
00402bc5 (-0xcfc) 	movzx edi, cl
00402bc8 (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
00402bcf (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00402bd6 (-0xcfc) 	inc esi
00402bd7 (-0xcfc) 	mov al, byte ptr [ebp - 1]
00402bda (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402be1 (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00402be7 (-0xcfc) 	jb 0x402ba8
00402be9 (-0xcfc) 	xor eax, eax
00402beb (-0xcfc) 	mov dword ptr [ebp - 0x2ec], 0xf
00402bf5 (-0xcfc) 	mov esi, eax
00402bf7 (-0xcfc) 	mov dword ptr [ebp - 0xc], eax
00402bfa (-0xcfc) 	mov edx, eax
00402bfc (-0xcfc) 	lea eax, [edx + 1]
00402bff (-0xcfc) 	movzx edx, al
00402c02 (-0xcfc) 	mov dword ptr [ebp - 0x34], edx
00402c05 (-0xcfc) 	mov cl, byte ptr [ebp + edx - 0x2d8]
00402c0c (-0xcfc) 	movzx eax, cl
00402c0f (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402c12 (-0xcfc) 	add eax, esi
00402c14 (-0xcfc) 	movzx esi, al
00402c17 (-0xcfc) 	mov dword ptr [ebp - 0x64], esi
00402c1a (-0xcfc) 	mov al, byte ptr [ebp + esi - 0x2d8]
00402c21 (-0xcfc) 	mov byte ptr [ebp + edx - 0x2d8], al
00402c28 (-0xcfc) 	mov edx, 0x42c934
00402c2d (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], cl
00402c34 (-0xcfc) 	call 0x401dd8
00402c39 (-0xcfc) 	push 0xf
00402c3b (-0xd00) 	pop eax
00402c3c (-0xcfc) 	mov ecx, eax
00402c3e (-0xcfc) 	lea edi, [ebp - 0x334]
00402c44 (-0xcfc) 	mov esi, 0x42c5a0
00402c49 (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'onecoreuap\\base\\appmodel\\search\\common\\pkmutild\\cregistry.cxx'
00402c4b (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402c4d (-0xcfc) 	cmp byte ptr [ebp - 0x334], 0x66
00402c54 (-0xcfc) 	jne 0x402c78
00402c56 (-0xcfc) 	mov cl, 0x66
00402c58 (-0xcfc) 	xor eax, eax
00402c5a (-0xcfc) 	test cl, cl
00402c5c (-0xcfc) 	je 0x402c78
00402c5e (-0xcfc) 	cmp byte ptr [ebp + eax - 0x334], 0
00402c66 (-0xcfc) 	je 0x402c78
00402c68 (-0xcfc) 	mov cl, byte ptr [eax + 0x42c935]
00402c6e (-0xcfc) 	inc eax
00402c6f (-0xcfc) 	cmp cl, byte ptr [ebp + eax - 0x334]
00402c76 (-0xcfc) 	je 0x402c5a
00402c78 (-0xcfc) 	mov edx, dword ptr [ebp - 0x34]
00402c7b (-0xcfc) 	mov ecx, dword ptr [ebp - 0xc]
00402c7e (-0xcfc) 	mov esi, dword ptr [ebp - 0x64]
00402c81 (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x2d8]
00402c89 (-0xcfc) 	add eax, dword ptr [ebp - 8]
00402c8c (-0xcfc) 	movzx eax, al
00402c8f (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402c96 (-0xcfc) 	xor al, byte ptr [ebp + ecx - 0x84]
ECX: 0x0
EBP: 0x100ffc
		String address: 0x100f78
00402c9d (-0xcfc) 	mov byte ptr [ebp + ecx - 0x3f0], al
00402ca4 (-0xcfc) 	inc ecx
00402ca5 (-0xcfc) 	mov dword ptr [ebp - 0xc], ecx
00402ca8 (-0xcfc) 	cmp ecx, 0x18
		CMP 0x18
		String: 6ef4b686fbccd8f67d8c5ada65de34646b63e4553663f096
		Decrypted: b'Y7RIrIMq5ozWl4chjWkndQ__'
No strings found attempting with candidate
		String: 340000000000000000000000004100000000000000000000
	\TEST: b'\x03\xc3\xe4\xcf\x89\x85\x95\x87H\xe3 \x8d\t\xabW\x0c\x014\x8f;R2\xaf\xc9'
	\TEST: b'\xdb"\tNO\xc9\x90H\x93ri&lt;\x9f\x0c\x88\xfd{\x99\xee\x89\x8d\xae\x87\x9b'
END for RC4 - Reset flags
00402cab (-0xcfc) 	jb 0x402bfc
00402cb1 (-0xcfc) 	mov esi, 0x42c5e0
00402cb6 (-0xcfc) 	mov word ptr [ebp - 0x24], 0x47fb
00402cbc (-0xcfc) 	lea edi, [ebp - 0x80]
00402cbf (-0xcfc) 	mov byte ptr [ebp - 0x22], 0x4b
00402cc3 (-0xcfc) 	push 0xe
00402cc5 (-0xd00) 	xor ecx, ecx
00402cc7 (-0xd00) 	mov dword ptr [ebp - 0x20], 0x393274fd
00402cce (-0xd00) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'SrchCollatorAdmin'
00402ccf (-0xd00) 	pop eax
00402cd0 (-0xcfc) 	mov byte ptr [ebp - 0x21], al
00402cd3 (-0xcfc) 	mov eax, ecx
00402cd5 (-0xcfc) 	mov byte ptr [ebp - 0x3d8], cl
00402cdb (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'CollatorAdmin'
00402cdc (-0xcfc) 	mov dword ptr [ebp - 0x1c], 0x959b19b
00402ce3 (-0xcfc) 	mov dword ptr [ebp - 0x18], 0x7380ea01
00402cea (-0xcfc) 	mov dword ptr [ebp - 0x14], 0xa2d799ff
00402cf1 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'atorAdmin'
00402cf2 (-0xcfc) 	mov dword ptr [ebp - 0x10], 0xd9fcbeeb
00402cf9 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'Admin'
00402cfa (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402cfc (-0xcfc) 	mov edi, ecx
00402cfe (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00402d05 (-0xcfc) 	inc eax
00402d06 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00402d0b (-0xcfc) 	jb 0x402cfe
00402d0d (-0xcfc) 	mov esi, ecx
00402d0f (-0xcfc) 	xor edx, edx
00402d11 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
00402d18 (-0xcfc) 	mov eax, esi
00402d1a (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402d1d (-0xcfc) 	div dword ptr [ebp - 0x88]
00402d23 (-0xcfc) 	movzx ecx, cl
00402d26 (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x80]
00402d2b (-0xcfc) 	add eax, edi
00402d2d (-0xcfc) 	add ecx, eax
00402d2f (-0xcfc) 	movzx edi, cl
00402d32 (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
00402d39 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00402d40 (-0xcfc) 	inc esi
00402d41 (-0xcfc) 	mov al, byte ptr [ebp - 1]
00402d44 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402d4b (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00402d51 (-0xcfc) 	jb 0x402d0f
00402d53 (-0xcfc) 	xor eax, eax
00402d55 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402d58 (-0xcfc) 	mov edi, eax
00402d5a (-0xcfc) 	mov esi, eax
00402d5c (-0xcfc) 	lea eax, [edi + 1]
00402d5f (-0xcfc) 	movzx edi, al
00402d62 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402d65 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
00402d6c (-0xcfc) 	movzx edx, cl
00402d6f (-0xcfc) 	add eax, edx
00402d71 (-0xcfc) 	movzx eax, al
00402d74 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402d77 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402d7e (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402d85 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402d88 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
00402d8f (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
00402d97 (-0xcfc) 	add eax, edx
00402d99 (-0xcfc) 	movzx eax, al
00402d9c (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402da3 (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x24]
ECX: 0xad
EBP: 0x100ffc
		String address: 0x100fd8
00402da7 (-0xcfc) 	mov byte ptr [ebp + esi - 0x428], al
00402dae (-0xcfc) 	inc esi
00402daf (-0xcfc) 	cmp esi, 0x18
		CMP 0x18
		String: fb474b5afd7432399bb1590901ea8073ff99d7a2ebbefcd9
		Decrypted: b'z7r7/mMHMZ/UtteyHvjY6w__'
No strings found attempting with candidate
		String: 5a0000000000000000000000000068000000000000000000
	\TEST: b'\xdbp9m\xd2\x19\x7fq\xd6\xebv\\u\x9e\x8d\n\xb7\xef\xbd\xfb\xdd\xc9\xa3\x86'
	\TEST: b'\x80\xfb\x8bf}\x16\x04\x1bfG\x03"\xd6\xc9\xfcd\x00\xc9\xa5\x17&lt;\xa6Ud'
	\TEST: b'\x055=^\\\xe3\xad\xa0\xf0) \xe9G\x80\xafP,\xe1\x89\xe1\xe8:\xdeh'
	\TEST: b'9\xe6;\xac\xa9L\xa0_j\xeb\x04\x8c\xa6\x80\xde\xa02\x87\xa4\xd70H_\x7f'
END for RC4 - Reset flags
00402db2 (-0xcfc) 	jb 0x402d5c
00402db4 (-0xcfc) 	mov esi, 0x42c5f4
00402db9 (-0xcfc) 	mov dword ptr [ebp - 0x60], 0xc3babb3a
00402dc0 (-0xcfc) 	lea edi, [ebp - 0xdc]
00402dc6 (-0xcfc) 	mov byte ptr [ebp - 0x5c], 0x65
00402dca (-0xcfc) 	xor edx, edx
00402dcc (-0xcfc) 	mov dword ptr [ebp - 0x5a], 0x8e694539
00402dd3 (-0xcfc) 	xor dword ptr [ebp - 0x2c], 0x95eb9a56
00402dda (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'no message'
00402ddb (-0xcfc) 	push 0x15
00402ddd (-0xd00) 	pop eax
00402dde (-0xcfc) 	mov byte ptr [ebp - 0x5b], al
00402de1 (-0xcfc) 	mov eax, edx
00402de3 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'essage'
00402de4 (-0xcfc) 	mov byte ptr [ebp - 0x410], dl
00402dea (-0xcfc) 	mov dword ptr [ebp - 0x56], 0xf2638ddb
00402df1 (-0xcfc) 	mov dword ptr [ebp - 0x52], 0x803c6696
00402df8 (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00402dfa (-0xcfc) 	mov dword ptr [ebp - 0x4e], 0x778e5796
00402e01 (-0xcfc) 	mov dword ptr [ebp - 0x4a], 0xd07705b6
00402e08 (-0xcfc) 	mov dword ptr [ebp - 0x46], 0x613b642c
00402e0f (-0xcfc) 	movsb byte ptr es:[edi], byte ptr [esi]
00402e10 (-0xcfc) 	mov dword ptr [ebp - 0x42], 0x5235c5f
00402e17 (-0xcfc) 	mov edi, edx
00402e19 (-0xcfc) 	mov dword ptr [ebp - 0x3e], 0x7a6d83ae
00402e20 (-0xcfc) 	mov dword ptr [ebp - 0x3a], 0x288e3e86
00402e27 (-0xcfc) 	mov word ptr [ebp - 0x36], 0xce02
00402e2d (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00402e34 (-0xcfc) 	inc eax
00402e35 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00402e3a (-0xcfc) 	jb 0x402e2d
00402e3c (-0xcfc) 	mov esi, edx
00402e3e (-0xcfc) 	mov dword ptr [ebp - 0x34], 0xa
00402e45 (-0xcfc) 	xor edx, edx
00402e47 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
00402e4e (-0xcfc) 	mov eax, esi
00402e50 (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402e53 (-0xcfc) 	div dword ptr [ebp - 0x34]
00402e56 (-0xcfc) 	movzx ecx, cl
00402e59 (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0xdc]
00402e61 (-0xcfc) 	add eax, edi
00402e63 (-0xcfc) 	add ecx, eax
00402e65 (-0xcfc) 	movzx edi, cl
00402e68 (-0xcfc) 	mov ecx, dword ptr [ebp - 0x2c]
00402e6b (-0xcfc) 	xor ecx, 0xb31a97f9
00402e71 (-0xcfc) 	mov dword ptr [ebp - 0x2c], ecx
00402e74 (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
00402e7b (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00402e82 (-0xcfc) 	inc esi
00402e83 (-0xcfc) 	mov al, byte ptr [ebp - 1]
00402e86 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402e8d (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00402e93 (-0xcfc) 	jb 0x402e45
00402e95 (-0xcfc) 	xor eax, eax
00402e97 (-0xcfc) 	and ecx, 0x58679545
00402e9d (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402ea0 (-0xcfc) 	mov edi, eax
00402ea2 (-0xcfc) 	mov dword ptr [ebp - 0x2c], ecx
00402ea5 (-0xcfc) 	mov esi, eax
00402ea7 (-0xcfc) 	lea eax, [edi + 1]
00402eaa (-0xcfc) 	movzx edi, al
00402ead (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402eb0 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
00402eb7 (-0xcfc) 	movzx edx, cl
00402eba (-0xcfc) 	add eax, edx
00402ebc (-0xcfc) 	movzx eax, al
00402ebf (-0xcfc) 	mov dword ptr [ebp - 8], eax
00402ec2 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402ec9 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00402ed0 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00402ed3 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
00402eda (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
00402ee2 (-0xcfc) 	add eax, edx
00402ee4 (-0xcfc) 	movzx eax, al
00402ee7 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00402eee (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x60]
ECX: 0x58261100
EBP: 0x100ffc
		String address: 0x100f9c
00402ef2 (-0xcfc) 	mov byte ptr [ebp + esi - 0x700], al
00402ef9 (-0xcfc) 	inc esi
00402efa (-0xcfc) 	cmp esi, 0x2c
		CMP 0x2c
		String: 3abbbac365a13945698edb8d63f296663c8096578e77b60577d02c643b615f5c2305ae836d7a863e8e2802ce
No strings found attempting with candidate
		String: a100000000a60000000000000000000000000000000000000000000000000000000000000000000000ca0000
	\TEST: b'\xf9\xee\xd4\xec+\xeai"&gt;\xd9\xe3\xe3!\x93\xe2SX\xcb\xe7\x1f\xe8?\xfdJ\x1b\xfbV4}\x00\x1c\x11[1\xf9\xd2/\x0b\xc8I\xcf\xb2i\x91'
	\TEST: b'\xc5uR\x91_\x83$\xfeC\xf1\x05\x8e\xeb?\xeb!\x0c\xf4[\xecU\x93\x89\x11z\x0e:\xa1T\x05\xdf`\x84\xf4\xe0\x11\xd2\x97=\xd1r\xaf\x1b\x13'
END for RC4 - Reset flags
00402efd (-0xcfc) 	jb 0x402ea7
00402eff (-0xcfc) 	mov esi, 0x42c57c
00402f04 (-0xcfc) 	mov dword ptr [ebp - 0x24], 0xaaa3f8e1
00402f0b (-0xcfc) 	lea edi, [ebp - 0xdc]
00402f11 (-0xcfc) 	mov dword ptr [ebp - 0x20], 0x50b906ff
00402f18 (-0xcfc) 	xor edx, edx
00402f1a (-0xcfc) 	mov dword ptr [ebp - 0x1c], 0xefa44db7
00402f21 (-0xcfc) 	sub dword ptr [ebp - 0x2c], 0x44c09500
00402f28 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'callContext'
00402f29 (-0xcfc) 	push 0xf
00402f2b (-0xd00) 	pop eax
00402f2c (-0xcfc) 	mov byte ptr [ebp - 0xf], al
00402f2f (-0xcfc) 	mov eax, edx
00402f31 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'Context'
00402f32 (-0xcfc) 	mov byte ptr [ebp - 0x6d4], dl
00402f38 (-0xcfc) 	mov dword ptr [ebp - 0x18], 0x2f46caea
00402f3f (-0xcfc) 	mov dword ptr [ebp - 0x14], 0x8e940451
00402f46 (-0xcfc) 	mov byte ptr [ebp - 0x10], 0xe9
00402f4a (-0xcfc) 	mov word ptr [ebp - 0xe], 0x5236
00402f50 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
00402f51 (-0xcfc) 	mov dword ptr [ebp - 8], edx
00402f54 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00402f5b (-0xcfc) 	inc eax
00402f5c (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00402f61 (-0xcfc) 	jb 0x402f54
00402f63 (-0xcfc) 	mov dword ptr [ebp - 0x64], edx
00402f66 (-0xcfc) 	call 0x4015df
00402f6b (-0xcfc) 	push 6
00402f6d (-0xd00) 	pop ecx
00402f6e (-0xcfc) 	mov esi, 0x42c600
00402f73 (-0xcfc) 	lea edi, [ebp - 0xf8]
00402f79 (-0xcfc) 	xor eax, eax
00402f7b (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'operation not permitted'
00402f7d (-0xcfc) 	cmp byte ptr [ebp - 0xf8], 0x6f
00402f84 (-0xcfc) 	jne 0x402fdb
00402f86 (-0xcfc) 	mov cl, 0x6f
00402f88 (-0xcfc) 	test cl, cl
00402f8a (-0xcfc) 	je 0x402fa6
00402f8c (-0xcfc) 	cmp byte ptr [ebp + eax - 0xf8], 0
00402f94 (-0xcfc) 	je 0x402fa6
00402f96 (-0xcfc) 	mov cl, byte ptr [eax + 0x42caa1]
00402f9c (-0xcfc) 	inc eax
00402f9d (-0xcfc) 	cmp cl, byte ptr [ebp + eax - 0xf8]
00402fa4 (-0xcfc) 	je 0x402f88
00402fa6 (-0xcfc) 	mov edi, dword ptr [ebp - 0x34]
00402fa9 (-0xcfc) 	mov dword ptr [ebp - 0xc], eax
00402fac (-0xcfc) 	cmp edi, eax
00402fae (-0xcfc) 	jae 0x402fdb
00402fb0 (-0xcfc) 	mov esi, eax
00402fb2 (-0xcfc) 	cmp edi, 0x244a
00402fb8 (-0xcfc) 	jne 0x402fc3
00402fba (-0xcfc) 	imul eax, dword ptr [ebp - 0x2c], 0xa37af6b3
00402fc1 (-0xcfc) 	jmp 0x402fc6
00402fc3 (-0xcfc) 	mov eax, dword ptr [ebp - 0x2c]
00402fc6 (-0xcfc) 	or eax, 0x4a4ac1a
00402fcb (-0xcfc) 	mov dword ptr [ebp - 0x2c], eax
00402fce (-0xcfc) 	call 0x401b4e
00402fd3 (-0xcfc) 	inc edi
00402fd4 (-0xcfc) 	cmp edi, esi
00402fd6 (-0xcfc) 	jb 0x402fb2
00402fd8 (-0xcfc) 	mov dword ptr [ebp - 0x34], edi
00402fdb (-0xcfc) 	mov esi, dword ptr [ebp - 0x64]
00402fde (-0xcfc) 	xor edx, edx
00402fe0 (-0xcfc) 	push 0xb
00402fe2 (-0xd00) 	mov eax, esi
00402fe4 (-0xd00) 	pop edi
00402fe5 (-0xcfc) 	div edi
00402fe7 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
00402fee (-0xcfc) 	mov byte ptr [ebp - 1], cl
00402ff1 (-0xcfc) 	movzx ecx, cl
00402ff4 (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0xdc]
00402ffc (-0xcfc) 	add eax, dword ptr [ebp - 8]
00402fff (-0xcfc) 	add ecx, eax
00403001 (-0xcfc) 	movzx ecx, cl
00403004 (-0xcfc) 	mov dword ptr [ebp - 8], ecx
00403007 (-0xcfc) 	mov al, byte ptr [ebp + ecx - 0x2d8]
0040300e (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00403015 (-0xcfc) 	inc esi
00403016 (-0xcfc) 	mov al, byte ptr [ebp - 1]
00403019 (-0xcfc) 	mov byte ptr [ebp + ecx - 0x2d8], al
00403020 (-0xcfc) 	mov dword ptr [ebp - 0x64], esi
00403023 (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00403029 (-0xcfc) 	jb 0x402f66
0040302f (-0xcfc) 	xor eax, eax
00403031 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00403034 (-0xcfc) 	mov edi, eax
00403036 (-0xcfc) 	mov esi, eax
00403038 (-0xcfc) 	lea eax, [edi + 1]
0040303b (-0xcfc) 	movzx edi, al
0040303e (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00403041 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
00403048 (-0xcfc) 	movzx edx, cl
0040304b (-0xcfc) 	add eax, edx
0040304d (-0xcfc) 	movzx eax, al
00403050 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00403053 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
0040305a (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00403061 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00403064 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
0040306b (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
00403073 (-0xcfc) 	add eax, edx
00403075 (-0xcfc) 	movzx eax, al
00403078 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
0040307f (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x24]
ECX: 0x9b
EBP: 0x100ffc
		String address: 0x100fd8
00403083 (-0xcfc) 	mov byte ptr [ebp + esi - 0x444], al
0040308a (-0xcfc) 	inc esi
0040308b (-0xcfc) 	cmp esi, 0x18
		CMP 0x18
		String: e1f8a3aaff06b950b74da4efeaca462f5104948ee99b3652
No strings found attempting with candidate
		String: 9b9c00000000a100000000a6000000000000000000000000
	\TEST: b'J\x1c\xeb\xe0\xaaE~"\x98\x1c\xe1\x1e\x8f\x9b\x7f@9~\xd9\xc5\x84Ni\r'
	\TEST: b'-vF\x12jS\xeeUO\xeb^G6\xb0_z\x0e:\xcf\x0f\x06\xc4\xcf\x1c'
	\TEST: b'\xc9z\xd5&lt;\x03b\xec\x06\xf2X\xf2:Y4\x1a\x93\xc1\xfe&amp;jM\xb9\xb3?'
END for RC4 - Reset flags
0040308e (-0xcfc) 	jb 0x403038
00403090 (-0xcfc) 	push 0x41
00403092 (-0xd00) 	pop eax
00403093 (-0xcfc) 	push 0xc
00403095 (-0xd00) 	mov dword ptr [ebp - 0x34], eax
00403098 (-0xd00) 	lea edi, [ebp - 0x338]
0040309e (-0xd00) 	mov byte ptr [ebp - 0x5c], al
004030a1 (-0xd00) 	mov esi, 0x42c618
004030a6 (-0xd00) 	pop eax
004030a7 (-0xcfc) 	push 0xf
004030a9 (-0xd00) 	mov dword ptr [ebp - 0x2f4], eax
004030af (-0xd00) 	xor edx, edx
004030b1 (-0xd00) 	mov byte ptr [ebp - 0x4c], al
004030b4 (-0xd00) 	pop eax
004030b5 (-0xcfc) 	push 0x19
004030b7 (-0xd00) 	mov byte ptr [ebp - 0x3d], al
004030ba (-0xd00) 	pop eax
004030bb (-0xcfc) 	push 0x10
004030bd (-0xd00) 	pop ecx
004030be (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'onecoreuap\\base\\AppModel\\Search\\common\\include\\secutil_common.hxx'
004030c0 (-0xcfc) 	mov byte ptr [ebp - 0x37], al
004030c3 (-0xcfc) 	mov eax, edx
004030c5 (-0xcfc) 	mov byte ptr [ebp - 0x42c], dl
004030cb (-0xcfc) 	mov dword ptr [ebp - 0x60], 0xacca7be9
004030d2 (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
004030d4 (-0xcfc) 	mov dword ptr [ebp - 0x5b], 0x82c120c2
004030db (-0xcfc) 	mov edi, edx
004030dd (-0xcfc) 	mov dword ptr [ebp - 0x57], 0xa164d044
004030e4 (-0xcfc) 	mov dword ptr [ebp - 0x53], 0xf5a56b54
004030eb (-0xcfc) 	mov word ptr [ebp - 0x4f], 0x40df
004030f1 (-0xcfc) 	mov byte ptr [ebp - 0x4d], 2
004030f5 (-0xcfc) 	mov dword ptr [ebp - 0x4b], 0x46bd0e4
004030fc (-0xcfc) 	mov dword ptr [ebp - 0x47], 0xdfa1a6b0
00403103 (-0xcfc) 	mov dword ptr [ebp - 0x43], 0x4a76f53a
0040310a (-0xcfc) 	mov word ptr [ebp - 0x3f], 0xb04d
00403110 (-0xcfc) 	mov dword ptr [ebp - 0x3c], 0xb1988ead
00403117 (-0xcfc) 	mov byte ptr [ebp - 0x38], 0xf3
0040311b (-0xcfc) 	mov word ptr [ebp - 0x36], 0xc4c7
00403121 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00403128 (-0xcfc) 	inc eax
00403129 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
0040312e (-0xcfc) 	jb 0x403121
00403130 (-0xcfc) 	mov eax, dword ptr [ebp - 0x2c]
00403133 (-0xcfc) 	mov esi, edx
00403135 (-0xcfc) 	and eax, 0xb87cd7b5
0040313a (-0xcfc) 	add eax, 0x4a1b74ff
0040313f (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
00403146 (-0xcfc) 	mov dword ptr [ebp - 0x2c], eax
00403149 (-0xcfc) 	xor edx, edx
0040314b (-0xcfc) 	mov eax, esi
0040314d (-0xcfc) 	mov byte ptr [ebp - 1], cl
00403150 (-0xcfc) 	div dword ptr [ebp - 0x34]
00403153 (-0xcfc) 	movzx ecx, cl
00403156 (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x338]
0040315e (-0xcfc) 	add eax, edi
00403160 (-0xcfc) 	add ecx, eax
00403162 (-0xcfc) 	movzx edi, cl
00403165 (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
0040316c (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00403173 (-0xcfc) 	inc esi
00403174 (-0xcfc) 	mov al, byte ptr [ebp - 1]
00403177 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
0040317e (-0xcfc) 	mov eax, dword ptr [ebp - 0x2c]
00403181 (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00403187 (-0xcfc) 	jb 0x40313a
00403189 (-0xcfc) 	xor eax, eax
0040318b (-0xcfc) 	mov dword ptr [ebp - 8], eax
0040318e (-0xcfc) 	mov edi, eax
00403190 (-0xcfc) 	mov esi, eax
00403192 (-0xcfc) 	lea eax, [edi + 1]
00403195 (-0xcfc) 	movzx edi, al
00403198 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
0040319b (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
004031a2 (-0xcfc) 	movzx edx, cl
004031a5 (-0xcfc) 	add eax, edx
004031a7 (-0xcfc) 	movzx eax, al
004031aa (-0xcfc) 	mov dword ptr [ebp - 8], eax
004031ad (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004031b4 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
004031bb (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004031be (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
004031c5 (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
004031cd (-0xcfc) 	add eax, edx
004031cf (-0xcfc) 	movzx eax, al
004031d2 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004031d9 (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x60]
ECX: 0xe9
EBP: 0x100ffc
		String address: 0x100f9c
004031dd (-0xcfc) 	mov byte ptr [ebp + esi - 0x730], al
004031e4 (-0xcfc) 	inc esi
004031e5 (-0xcfc) 	cmp esi, 0x2c
		CMP 0x2c
		String: e97bcaac7ac220c18244d064a1546ba5f5df40027ae4d06b04b0a6a1df3af5764a4db07aad8e98b1f37ac7c4
		Decrypted: b"jaOtsQD1HT7oW/+N8bq1\x07rb5G/32X83Ki9E'RIsyQLs_"
No strings found attempting with candidate
		String: 7a00000000000000000000000000000000000000000000000000000000000000009b9c00000000a100000000
	\TEST: b'\xf9\x1a\x85\xd8\t\x93d\xf0\xca\x10\xe7\x0b\xf6{@\xeb\xcd\xbd13}\x96\xb2^C\x9f\x95\x93\x87\x02\xc6=#\xefi]\xff\xc7\xebi\xa26\xb4\x9b'
END for RC4 - Reset flags
004031e8 (-0xcfc) 	jb 0x403192
004031ea (-0xcfc) 	mov esi, 0x42c65c
004031ef (-0xcfc) 	lea edi, [ebp - 0x80]
004031f2 (-0xcfc) 	xor edx, edx
004031f4 (-0xcfc) 	mov byte ptr [ebp - 0x704], dl
004031fa (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'SrchDSSConnection'
004031fb (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'DSSConnection'
004031fc (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'onnection'
004031fd (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'ction'
004031fe (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
00403200 (-0xcfc) 	cmp byte ptr [ebp - 0x80], 0x66
00403204 (-0xcfc) 	jne 0x403221
00403206 (-0xcfc) 	mov cl, 0x66
00403208 (-0xcfc) 	mov eax, edx
0040320a (-0xcfc) 	test cl, cl
0040320c (-0xcfc) 	je 0x403221
0040320e (-0xcfc) 	cmp byte ptr [ebp + eax - 0x80], dl
00403212 (-0xcfc) 	je 0x403221
00403214 (-0xcfc) 	mov cl, byte ptr [eax + 0x42c935]
0040321a (-0xcfc) 	inc eax
0040321b (-0xcfc) 	cmp cl, byte ptr [ebp + eax - 0x80]
0040321f (-0xcfc) 	je 0x40320a
00403221 (-0xcfc) 	mov ecx, dword ptr [ebp - 0x2c]
00403224 (-0xcfc) 	lea edi, [ebp - 0x2e8]
0040322a (-0xcfc) 	mov esi, 0x42c670
0040322f (-0xcfc) 	mov dword ptr [ebp - 0x24], 0x9ce82d35
00403236 (-0xcfc) 	push 0x16
00403238 (-0xd00) 	pop eax
00403239 (-0xcfc) 	mov byte ptr [ebp - 0x1b], al
0040323c (-0xcfc) 	mov eax, 0x42c934
00403241 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'SrchServiceObj'
00403242 (-0xcfc) 	mov dword ptr [ebp - 0x20], 0x8f3f178e
00403249 (-0xcfc) 	mov byte ptr [ebp - 0x1c], 0xf2
0040324d (-0xcfc) 	mov dword ptr [ebp - 0x1a], 0x92a12ab3
00403254 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'ServiceObj'
00403255 (-0xcfc) 	mov dword ptr [ebp - 0x16], 0x3caa066f
0040325c (-0xcfc) 	mov dword ptr [ebp - 0x12], 0xf06cc14e
00403263 (-0xcfc) 	mov word ptr [ebp - 0xe], 0x34f0
00403269 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'iceObj'
0040326a (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
0040326c (-0xcfc) 	movsb byte ptr es:[edi], byte ptr [esi]
0040326d (-0xcfc) 	and ecx, 0x433c21fe
00403273 (-0xcfc) 	inc eax
00403274 (-0xcfc) 	cmp byte ptr [eax], dl
00403276 (-0xcfc) 	jne 0x40326d
00403278 (-0xcfc) 	mov dword ptr [ebp - 0xc], edx
0040327b (-0xcfc) 	mov eax, edx
0040327d (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00403284 (-0xcfc) 	inc eax
00403285 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
0040328a (-0xcfc) 	jb 0x40327d
0040328c (-0xcfc) 	mov esi, edx
0040328e (-0xcfc) 	lea edi, [ecx + 0x560c10ba]
00403294 (-0xcfc) 	xor edx, edx
00403296 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
0040329d (-0xcfc) 	mov eax, esi
0040329f (-0xcfc) 	mov byte ptr [ebp - 1], cl
004032a2 (-0xcfc) 	div dword ptr [ebp - 0x68]
004032a5 (-0xcfc) 	movzx ecx, cl
004032a8 (-0xcfc) 	or edi, 0x542e616c
004032ae (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x2e8]
004032b6 (-0xcfc) 	add eax, dword ptr [ebp - 0xc]
004032b9 (-0xcfc) 	add ecx, eax
004032bb (-0xcfc) 	movzx ecx, cl
004032be (-0xcfc) 	mov dword ptr [ebp - 0xc], ecx
004032c1 (-0xcfc) 	mov al, byte ptr [ebp + ecx - 0x2d8]
004032c8 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
004032cf (-0xcfc) 	inc esi
004032d0 (-0xcfc) 	mov al, byte ptr [ebp - 1]
004032d3 (-0xcfc) 	mov byte ptr [ebp + ecx - 0x2d8], al
004032da (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
004032e0 (-0xcfc) 	jb 0x403294
004032e2 (-0xcfc) 	xor eax, eax
004032e4 (-0xcfc) 	mov dword ptr [ebp - 0x28], edi
004032e7 (-0xcfc) 	mov dword ptr [ebp - 8], eax
004032ea (-0xcfc) 	mov edi, eax
004032ec (-0xcfc) 	mov esi, eax
004032ee (-0xcfc) 	lea eax, [edi + 1]
004032f1 (-0xcfc) 	movzx edi, al
004032f4 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004032f7 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
004032fe (-0xcfc) 	movzx edx, cl
00403301 (-0xcfc) 	add eax, edx
00403303 (-0xcfc) 	movzx eax, al
00403306 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00403309 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00403310 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00403317 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
0040331a (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
00403321 (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
00403329 (-0xcfc) 	add eax, edx
0040332b (-0xcfc) 	movzx eax, al
0040332e (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00403335 (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x24]
ECX: 0x93
EBP: 0x100ffc
		String address: 0x100fd8
00403339 (-0xcfc) 	mov byte ptr [ebp + esi - 0x460], al
00403340 (-0xcfc) 	inc esi
00403341 (-0xcfc) 	cmp esi, 0x18
		CMP 0x18
		String: 352de89c8e173f8ff293b32aa1926f06aa3c4ec16cf0f034
No strings found attempting with candidate
		String: 93000000000000009b9c00000000a100000000a600000000
	\TEST: b'\xae\x1d\xdc\xbd\x03\x14\xa1GrW\\\xe9\xaf:\xf4\x1e\xa8w\x1dR\xd1\x89)\x06'
	\TEST: b'"\x1c\xf1\xe0\xd8\xee\xda\xe6~\xbc\x9a\xf1\x10q\xe0\x07\x86\x8a\x14\xc6\x02\xcb\xb4?'
	\TEST: b':\x0f0\xc2\x05\xd0:\x9b6_\x8c]\xd9\x9f\xd8\x92\x9a\xd6^E\xf0\x9a\xb3b'
	\TEST: b'\xb2B\xa1\x95t\x8e\x0f\xdcB2\x04\xfah\x84\x03\x81r\x0c$k\xe3\xe6lD'
	\TEST: b'\xe1Z\xaf\xae\xcc/H\xbe\x04\xef\xe1I\x8e\xf4\xadN\xf0u6\x00\x0e\x97\xafk'
	\TEST: b'\xd3\xd8[\xae\x14?\x01\x1dw\xf0\x84\xe1\xa4\xfa\x96\xb8\x91\xf8\xd1AB\x1f\x94^'
	\TEST: b'\x9ch\x19\t\xb9!j\x13\xc8\xd1k\xc9\xc5\x051\xbb\x80,V_\xc3V\xce\xcc'
END for RC4 - Reset flags
00403344 (-0xcfc) 	jb 0x4032ee
00403346 (-0xcfc) 	mov esi, 0x42c680
0040334b (-0xcfc) 	mov dword ptr [ebp - 0x5f], 0x56106c3a
00403352 (-0xcfc) 	lea edi, [ebp - 0x2e8]
00403358 (-0xcfc) 	mov dword ptr [ebp - 0x5b], 0xfd45c8de
0040335f (-0xcfc) 	push 0x13
00403361 (-0xd00) 	pop eax
00403362 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'SrchDatasource'
00403363 (-0xcfc) 	xor ecx, ecx
00403365 (-0xcfc) 	add dword ptr [ebp - 0x28], 0x3af51930
0040336c (-0xcfc) 	mov dword ptr [ebp - 0x1d8], eax
00403372 (-0xcfc) 	mov byte ptr [ebp - 0x60], al
00403375 (-0xcfc) 	mov eax, ecx
00403377 (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'Datasource'
00403378 (-0xcfc) 	mov byte ptr [ebp - 0x448], cl
0040337e (-0xcfc) 	mov dword ptr [ebp - 0x57], 0x272d8af1
00403385 (-0xcfc) 	mov dword ptr [ebp - 0x53], 0x1d90a5ac
0040338c (-0xcfc) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'source'
0040338d (-0xcfc) 	mov dword ptr [ebp - 0x4f], 0x6d3b6e5e
00403394 (-0xcfc) 	mov dword ptr [ebp - 0x4b], 0x9443c39d
0040339b (-0xcfc) 	mov dword ptr [ebp - 0x47], 0xac3029a8
004033a2 (-0xcfc) 	movsw word ptr es:[edi], word ptr [esi]
004033a4 (-0xcfc) 	mov dword ptr [ebp - 0x43], 0xa9453774
004033ab (-0xcfc) 	mov dword ptr [ebp - 0x3f], 0x215a7136
004033b2 (-0xcfc) 	mov dword ptr [ebp - 0x3b], 0x19f5ed1
004033b9 (-0xcfc) 	mov word ptr [ebp - 0x37], 0xa078
004033bf (-0xcfc) 	mov byte ptr [ebp - 0x35], 0xfd
004033c3 (-0xcfc) 	movsb byte ptr es:[edi], byte ptr [esi]
004033c4 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
004033cb (-0xcfc) 	inc eax
004033cc (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
004033d1 (-0xcfc) 	jb 0x4033c4
004033d3 (-0xcfc) 	mov esi, ecx
004033d5 (-0xcfc) 	mov edi, ecx
004033d7 (-0xcfc) 	xor edx, edx
004033d9 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
004033e0 (-0xcfc) 	mov eax, esi
004033e2 (-0xcfc) 	mov byte ptr [ebp - 1], cl
004033e5 (-0xcfc) 	div dword ptr [ebp - 0x68]
004033e8 (-0xcfc) 	movzx ecx, cl
004033eb (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x2e8]
004033f3 (-0xcfc) 	add eax, edi
004033f5 (-0xcfc) 	add ecx, eax
004033f7 (-0xcfc) 	movzx edi, cl
004033fa (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
00403401 (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
00403408 (-0xcfc) 	inc esi
00403409 (-0xcfc) 	mov al, byte ptr [ebp - 1]
0040340c (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00403413 (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00403419 (-0xcfc) 	jb 0x4033d7
0040341b (-0xcfc) 	mov edi, dword ptr [ebp - 0x28]
0040341e (-0xcfc) 	xor ecx, ecx
00403420 (-0xcfc) 	mov esi, ecx
00403422 (-0xcfc) 	mov dword ptr [ebp - 0xc], ecx
00403425 (-0xcfc) 	mov edx, ecx
00403427 (-0xcfc) 	lea eax, [edx + 1]
0040342a (-0xcfc) 	or edi, 0xae48d9a9
00403430 (-0xcfc) 	movzx eax, al
00403433 (-0xcfc) 	mov edx, ecx
00403435 (-0xcfc) 	mov dword ptr [ebp - 8], eax
00403438 (-0xcfc) 	push 0xf
0040343a (-0xd00) 	mov dword ptr [ebp - 0x28], edi
0040343d (-0xd00) 	lea edi, [ebp - 0x334]
00403443 (-0xd00) 	mov al, byte ptr [ebp + eax - 0x2d8]
0040344a (-0xd00) 	mov byte ptr [ebp - 1], al
0040344d (-0xd00) 	movzx eax, al
00403450 (-0xd00) 	mov dword ptr [ebp - 0x64], eax
00403453 (-0xd00) 	add eax, esi
00403455 (-0xd00) 	movzx eax, al
00403458 (-0xd00) 	mov esi, 0x42c690
0040345d (-0xd00) 	mov dword ptr [ebp - 0x34], eax
00403460 (-0xd00) 	pop eax
00403461 (-0xcfc) 	mov ecx, eax
00403463 (-0xcfc) 	mov dword ptr [ebp - 0x68], edx
00403466 (-0xcfc) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'onecoreuap\\base\\AppModel\\Search\\common\\include\\TPKPHMAP.hxx'
00403468 (-0xcfc) 	cmp byte ptr [ebp - 0x334], 0x66
0040346f (-0xcfc) 	jne 0x40349c
00403471 (-0xcfc) 	mov al, 0x66
00403473 (-0xcfc) 	test al, al
00403475 (-0xcfc) 	je 0x40349c
00403477 (-0xcfc) 	cmp byte ptr [ebp + edx - 0x334], 0
0040347f (-0xcfc) 	je 0x40349c
00403481 (-0xcfc) 	call 0x4011d8
00403486 (-0xcfc) 	mov edx, dword ptr [ebp - 0x68]
00403489 (-0xcfc) 	inc edx
0040348a (-0xcfc) 	mov dword ptr [ebp - 0x68], edx
0040348d (-0xcfc) 	mov al, byte ptr [edx + 0x42c934]
00403493 (-0xcfc) 	cmp al, byte ptr [ebp + edx - 0x334]
0040349a (-0xcfc) 	je 0x403473
0040349c (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x334]
004034a4 (-0xcfc) 	movzx ecx, byte ptr [edx + 0x42c934]
004034ab (-0xcfc) 	sub ecx, eax
004034ad (-0xcfc) 	cmp ecx, 0xab8
004034b3 (-0xcfc) 	jne 0x4034be
004034b5 (-0xcfc) 	imul edi, dword ptr [ebp - 0x28], 0x3e38a26d
004034bc (-0xcfc) 	jmp 0x4034cc
004034be (-0xcfc) 	call 0x4011d8
004034c3 (-0xcfc) 	mov edi, dword ptr [ebp - 0x28]
004034c6 (-0xcfc) 	add edi, 0xc6f821a2
004034cc (-0xcfc) 	mov esi, dword ptr [ebp - 0x34]
004034cf (-0xcfc) 	mov edx, dword ptr [ebp - 8]
004034d2 (-0xcfc) 	mov ecx, dword ptr [ebp - 0xc]
004034d5 (-0xcfc) 	push 0
004034d7 (-0xd00) 	mov al, byte ptr [ebp + esi - 0x2d8]
004034de (-0xd00) 	mov byte ptr [ebp + edx - 0x2d8], al
004034e5 (-0xd00) 	mov al, byte ptr [ebp - 1]
004034e8 (-0xd00) 	mov byte ptr [ebp + esi - 0x2d8], al
004034ef (-0xd00) 	movzx eax, byte ptr [ebp + edx - 0x2d8]
004034f7 (-0xd00) 	add eax, dword ptr [ebp - 0x64]
004034fa (-0xd00) 	movzx eax, al
004034fd (-0xd00) 	mov dword ptr [0x434050], edi
00403503 (-0xd00) 	mov al, byte ptr [ebp + eax - 0x2d8]
0040350a (-0xd00) 	xor al, byte ptr [ebp + ecx - 0x60]
ECX: 0x0
EBP: 0x100ffc
		String address: 0x100f9c
0040350e (-0xd00) 	mov byte ptr [ebp + ecx - 0x760], al
00403515 (-0xd00) 	inc ecx
00403516 (-0xd00) 	mov dword ptr [ebp - 0xc], ecx
00403519 (-0xd00) 	cmp ecx, 0x2c
		CMP 0x2c
		String: a63a6c1056dec845fdf18a2d27aca5901d5e6e3b6d9dc34394a82930ac743745a936715a21d15e9f0178a0fd
No strings found attempting with candidate
		String: a60000000000000000000000000000000000000000000000000000000000000000000000ca00000000000000
	\TEST: b'\xcfv&lt;;`\xa6\x91\x11\xbe\x82\xe8G\x13\xfa\xc1\xdf/\x1a:l&amp;\xdb\x86\n\xa6\xd1Pj\xc5\x0eQs\xf3b\x1b1\xbc\x82\x0e\xc8rK\xed\xa2'
	\TEST: b'\x9c\xd3\xa3\xb6\x96\x82G\x81Y\xef$P\x9f\xe2XV\xf4\x97I\x82b\x00\x1e\x0e\x8e\xb3#\xd2\xec\x00\x8c\x86\x8b\xf6\x90\x94\xcf\x063$\x8e\xad,a'
	\TEST: b'\xa6G\xf9\x91k\xab\xbb\\\xcb&lt;\xd9\x9fA\xce\x9e{\xfdTc\xe0\xf0\xf7\xd6\xc5b\xee&lt;A^\x96\x83fA1\x8e\x0e\xd9\xf3\x01]0w\xcd\xaf'
	\TEST: b'\xa1\x12\x19\xddVD\x11/\xef\x8e\x07"\x05[\x06\xb6\xc6\x83?1\x9d\xec\x99\xce\x83:\xa3\x9f\xaa\xf9\xac\xefH\x88^\xafP.\xcc\x8a\x90\xdb\x84\x06'
END for RC4 - Reset flags
0040351c (-0xd00) 	pop ecx
0040351d (-0xcfc) 	jb 0x403427
00403523 (-0xcfc) 	push 0x41
00403525 (-0xd00) 	pop eax
00403526 (-0xcfc) 	push 0x1a
00403528 (-0xd00) 	mov byte ptr [ebp - 0x20], al
0040352b (-0xd00) 	mov edi, ecx
0040352d (-0xd00) 	pop eax
0040352e (-0xcfc) 	mov byte ptr [ebp - 0x1e], al
00403531 (-0xcfc) 	push 0xf
00403533 (-0xd00) 	pop eax
00403534 (-0xcfc) 	mov byte ptr [ebp - 0x14], al
00403537 (-0xcfc) 	mov eax, ecx
00403539 (-0xcfc) 	mov byte ptr [ebp - 0x734], cl
0040353f (-0xcfc) 	mov dword ptr [ebp - 0x24], 0x5eb5e993
00403546 (-0xcfc) 	mov byte ptr [ebp - 0x1f], 0xc0
0040354a (-0xcfc) 	mov dword ptr [ebp - 0x1d], 0x746805a4
00403551 (-0xcfc) 	mov dword ptr [ebp - 0x19], 0x5d46e7c7
00403558 (-0xcfc) 	mov byte ptr [ebp - 0x15], 0xd6
0040355c (-0xcfc) 	mov dword ptr [ebp - 0x13], 0x867052d5
00403563 (-0xcfc) 	mov word ptr [ebp - 0xf], 0x6524
00403569 (-0xcfc) 	mov byte ptr [ebp - 0xd], 0x44
0040356d (-0xcfc) 	mov dword ptr [ebp - 0x6c], 0x73657268
00403574 (-0xcfc) 	mov dword ptr [ebp - 0x68], 0x746c75
0040357b (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], al
00403582 (-0xcfc) 	inc eax
00403583 (-0xcfc) 	cmp eax, 0x100
START for RC4 - Set flag
00403588 (-0xcfc) 	jb 0x40357b
0040358a (-0xcfc) 	mov esi, ecx
0040358c (-0xcfc) 	mov dword ptr [ebp - 0x34], 7
00403593 (-0xcfc) 	xor edx, edx
00403595 (-0xcfc) 	mov cl, byte ptr [ebp + esi - 0x2d8]
0040359c (-0xcfc) 	mov eax, esi
0040359e (-0xcfc) 	mov byte ptr [ebp - 1], cl
004035a1 (-0xcfc) 	div dword ptr [ebp - 0x34]
004035a4 (-0xcfc) 	movzx ecx, cl
004035a7 (-0xcfc) 	movzx eax, byte ptr [ebp + edx - 0x6c]
004035ac (-0xcfc) 	add eax, edi
004035ae (-0xcfc) 	add ecx, eax
004035b0 (-0xcfc) 	movzx edi, cl
004035b3 (-0xcfc) 	mov al, byte ptr [ebp + edi - 0x2d8]
004035ba (-0xcfc) 	mov byte ptr [ebp + esi - 0x2d8], al
004035c1 (-0xcfc) 	inc esi
004035c2 (-0xcfc) 	mov al, byte ptr [ebp - 1]
004035c5 (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
004035cc (-0xcfc) 	cmp esi, 0x100
START for key loop - Scanning for XOR
004035d2 (-0xcfc) 	jb 0x403593
004035d4 (-0xcfc) 	xor eax, eax
004035d6 (-0xcfc) 	mov dword ptr [ebp - 8], eax
004035d9 (-0xcfc) 	mov edi, eax
004035db (-0xcfc) 	mov esi, eax
004035dd (-0xcfc) 	lea eax, [edi + 1]
004035e0 (-0xcfc) 	movzx edi, al
004035e3 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
004035e6 (-0xcfc) 	mov cl, byte ptr [ebp + edi - 0x2d8]
004035ed (-0xcfc) 	movzx edx, cl
004035f0 (-0xcfc) 	add eax, edx
004035f2 (-0xcfc) 	movzx eax, al
004035f5 (-0xcfc) 	mov dword ptr [ebp - 8], eax
004035f8 (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
004035ff (-0xcfc) 	mov byte ptr [ebp + edi - 0x2d8], al
00403606 (-0xcfc) 	mov eax, dword ptr [ebp - 8]
00403609 (-0xcfc) 	mov byte ptr [ebp + eax - 0x2d8], cl
00403610 (-0xcfc) 	movzx eax, byte ptr [ebp + edi - 0x2d8]
00403618 (-0xcfc) 	add eax, edx
0040361a (-0xcfc) 	movzx eax, al
0040361d (-0xcfc) 	mov al, byte ptr [ebp + eax - 0x2d8]
00403624 (-0xcfc) 	xor al, byte ptr [ebp + esi - 0x24]
ECX: 0x68
EBP: 0x100ffc
		String address: 0x100fd8
00403628 (-0xcfc) 	mov byte ptr [ebp + esi - 0x47c], al
0040362f (-0xcfc) 	inc esi
00403630 (-0xcfc) 	cmp esi, 0x18
		CMP 0x18
		String: 93e9b55e00c000a4056874c7e7465dd600d5527086246544
No strings found attempting with candidate
		String: 000000000000000000000000000000001000000000000000
END for RC4 - Reset flags
00403633 (-0xcfc) 	jb 0x4035dd
00403635 (-0xcfc) 	mov byte ptr [ebp - 0x464], 0
0040363c (-0xcfc) 	call 0x416910
00403641 (-0xcfc) 	test eax, eax
00403643 (-0xcfc) 	jne 0x40458d
00403649 (-0xcfc) 	lea eax, [ebp - 0x7b0]
0040364f (-0xcfc) 	xor ecx, ecx
00403651 (-0xcfc) 	push eax
00403652 (-0xd00) 	push 1
00403654 (-0xd04) 	push 0
00403656 (-0xd08) 	lea edx, [ebp - 0x364]
0040365c (-0xd08) 	inc ecx
0040365d (-0xd08) 	call 0x40a2e6
00403662 (-0xd08) 	call eax
00403664 (-0xd08) 	xor ecx, ecx
00403666 (-0xd08) 	lea edx, [ebp - 0x380]
0040366c (-0xd08) 	inc ecx
0040366d (-0xd08) 	call 0x40a2e6
00403672 (-0xd08) 	call eax
00403674 (-0xd08) 	cmp eax, 0xb7
00403679 (-0xd08) 	je 0x40458d
0040367f (-0xd08) 	push 7
00403681 (-0xd0c) 	pop eax
00403682 (-0xd08) 	mov ecx, eax
00403684 (-0xd08) 	call 0x40c3d8
00403689 (-0xd08) 	call 0x416029
0040368e (-0xd08) 	mov esi, eax
00403690 (-0xd08) 	mov dword ptr [ebp - 0xcc], 0x77
0040369a (-0xd08) 	xor eax, eax
0040369c (-0xd08) 	mov dword ptr [ebp - 0x34], esi
0040369f (-0xd08) 	xor edi, edi
004036a1 (-0xd08) 	mov dword ptr [ebp - 0x90], eax
004036a7 (-0xd08) 	mov ecx, 0x208
004036ac (-0xd08) 	mov dword ptr [ebp - 0x94], eax
004036b2 (-0xd08) 	inc edi
004036b3 (-0xd08) 	call 0x40a2a8
004036b8 (-0xd08) 	mov ecx, 0x800
004036bd (-0xd08) 	mov dword ptr [ebp - 0x64], eax
004036c0 (-0xd08) 	call 0x40a2a8
004036c5 (-0xd08) 	mov ecx, 0x100000
004036ca (-0xd08) 	mov dword ptr [ebp - 8], eax
004036cd (-0xd08) 	call 0x40a2a8
004036d2 (-0xd08) 	mov ecx, 0x100000
004036d7 (-0xd08) 	mov dword ptr [ebp - 0x28], eax
004036da (-0xd08) 	call 0x40a2a8
004036df (-0xd08) 	mov ecx, 0x100000
004036e4 (-0xd08) 	mov dword ptr [ebp - 0x2c], eax
004036e7 (-0xd08) 	call 0x40a2a8
004036ec (-0xd08) 	mov ecx, 0x100000
004036f1 (-0xd08) 	mov dword ptr [ebp - 0xc], eax
004036f4 (-0xd08) 	call 0x40a2a8
004036f9 (-0xd08) 	mov ecx, esi
004036fb (-0xd08) 	mov dword ptr [ebp - 0x88], eax
00403701 (-0xd08) 	call 0x40b8f4
00403706 (-0xd08) 	mov ecx, dword ptr [ebp - 0x64]
00403709 (-0xd08) 	mov edx, esi
0040370b (-0xd08) 	push eax
0040370c (-0xd0c) 	call 0x40b6ac
00403711 (-0xd0c) 	pop ecx
00403712 (-0xd08) 	lea ecx, [ebp - 0x39c]
00403718 (-0xd08) 	call 0x40b5df
0040371d (-0xd08) 	mov esi, eax
0040371f (-0xd08) 	lea edx, [ebp - 0x3b8]
00403725 (-0xd08) 	lea eax, [ebp - 0xcf4]
0040372b (-0xd08) 	push eax
0040372c (-0xd0c) 	push esi
0040372d (-0xd10) 	push dword ptr [ebp - 0x88]
00403733 (-0xd14) 	push 2
00403735 (-0xd18) 	pop ecx
00403736 (-0xd14) 	call 0x40a2e6
0040373b (-0xd14) 	call eax
0040373d (-0xd14) 	mov ecx, esi
0040373f (-0xd14) 	call 0x40b8e6
00403744 (-0xd14) 	push eax
00403745 (-0xd18) 	push 0
00403747 (-0xd1c) 	push esi
00403748 (-0xd20) 	call 0x40b587
0040374d (-0xd20) 	add esp, 0x18
00403750 (-0xd08) 	mov ecx, esi
00403752 (-0xd08) 	call 0x40a2d2
00403757 (-0xd08) 	lea ecx, [ebp - 0x3d4]
0040375d (-0xd08) 	call 0x40b5df
00403762 (-0xd08) 	push 0x78
00403764 (-0xd0c) 	pop ecx
00403765 (-0xd08) 	mov dword ptr [ebp - 0x68], eax
00403768 (-0xd08) 	call 0x40a2a8
0040376d (-0xd08) 	mov dword ptr [ebp - 0x8c], eax
00403773 (-0xd08) 	xor esi, esi
00403775 (-0xd08) 	mov ecx, 0x400
0040377a (-0xd08) 	call 0x40a2a8
0040377f (-0xd08) 	mov ecx, dword ptr [ebp - 0x8c]
00403785 (-0xd08) 	mov dword ptr [ecx + esi*4], eax
00403788 (-0xd08) 	cmp edi, 1
0040378b (-0xd08) 	jne 0x4037d8
0040378d (-0xd08) 	mov ecx, dword ptr [ebp - 0x88]
00403793 (-0xd08) 	xor eax, eax
00403795 (-0xd08) 	cmp dword ptr [ebp - 0x90], eax
0040379b (-0xd08) 	mov edx, dword ptr [ebp - 0x68]
0040379e (-0xd08) 	cmova ecx, eax
004037a1 (-0xd08) 	call 0x40babc
004037a6 (-0xd08) 	mov ecx, eax
004037a8 (-0xd08) 	test ecx, ecx
004037aa (-0xd08) 	je 0x4037d6
004037ac (-0xd08) 	inc dword ptr [ebp - 0x90]
004037b2 (-0xd08) 	and dword ptr [0x434050], 0x9bd3a4c4
004037bc (-0xd08) 	call 0x40b8e6
004037c1 (-0xd08) 	push eax
004037c2 (-0xd0c) 	mov eax, dword ptr [ebp - 0x8c]
004037c8 (-0xd0c) 	push ecx
004037c9 (-0xd10) 	push dword ptr [eax + esi*4]
004037cc (-0xd14) 	call 0x40b543
004037d1 (-0xd14) 	add esp, 0xc
004037d4 (-0xd08) 	jmp 0x4037d8
004037d6 (-0xd08) 	xor edi, edi
004037d8 (-0xd08) 	inc esi
004037d9 (-0xd08) 	cmp esi, 0x1e
004037dc (-0xd08) 	jl 0x403775
004037de (-0xd08) 	mov esi, dword ptr [ebp - 0x68]
004037e1 (-0xd08) 	mov ecx, esi
004037e3 (-0xd08) 	call 0x40b8e6
004037e8 (-0xd08) 	push eax
004037e9 (-0xd0c) 	push 0
004037eb (-0xd10) 	push esi
004037ec (-0xd14) 	call 0x40b587
004037f1 (-0xd14) 	mov ecx, esi
004037f3 (-0xd14) 	call 0x40a2d2
004037f8 (-0xd14) 	mov edi, dword ptr [ebp - 0x88]
004037fe (-0xd14) 	push 0x100000
00403803 (-0xd18) 	push 0
00403805 (-0xd1c) 	push edi
00403806 (-0xd20) 	call 0x40b587
0040380b (-0xd20) 	mov ecx, 0x19000
00403810 (-0xd20) 	call 0x40a2a8
00403815 (-0xd20) 	push dword ptr [ebp - 0xcc]
0040381b (-0xd24) 	mov edx, dword ptr [ebp - 0x2c]
0040381e (-0xd24) 	mov esi, eax
00403820 (-0xd24) 	push dword ptr [ebp - 0x34]
00403823 (-0xd28) 	mov ecx, dword ptr [ebp - 0x28]
00403826 (-0xd28) 	call 0x4184bf
0040382b (-0xd28) 	push 0x100000
00403830 (-0xd2c) 	push 0
00403832 (-0xd30) 	push dword ptr [ebp - 0x2c]
00403835 (-0xd34) 	call 0x40b587
0040383a (-0xd34) 	lea eax, [ebp - 0x3f0]
00403840 (-0xd34) 	mov edx, edi
00403842 (-0xd34) 	push eax
00403843 (-0xd38) 	lea eax, [ebp - 0x40c]
00403849 (-0xd38) 	mov ecx, esi
0040384b (-0xd38) 	push eax
0040384c (-0xd3c) 	push dword ptr [ebp - 0x2c]
0040384f (-0xd40) 	call 0x418e7e
00403854 (-0xd40) 	mov ecx, dword ptr [ebp - 0x28]
00403857 (-0xd40) 	mov edx, esi
00403859 (-0xd40) 	call 0x40ba5f
0040385e (-0xd40) 	push 0x19000
00403863 (-0xd44) 	push 0
00403865 (-0xd48) 	push esi
00403866 (-0xd4c) 	call 0x40b587
0040386b (-0xd4c) 	add esp, 0x44
0040386e (-0xd08) 	push 2
00403870 (-0xd0c) 	pop ecx
00403871 (-0xd08) 	call 0x40c3d8
00403876 (-0xd08) 	lea eax, [ebp - 0x700]
0040387c (-0xd08) 	mov edx, edi
0040387e (-0xd08) 	push eax
0040387f (-0xd0c) 	lea eax, [ebp - 0x428]
00403885 (-0xd0c) 	mov ecx, esi
00403887 (-0xd0c) 	push eax
00403888 (-0xd10) 	push dword ptr [ebp - 0x2c]
0040388b (-0xd14) 	call 0x418e7e
00403890 (-0xd14) 	imul eax, dword ptr [0x434050], 0x8400a4ff
0040389a (-0xd14) 	mov edx, esi
0040389c (-0xd14) 	mov ecx, dword ptr [ebp - 0x28]
0040389f (-0xd14) 	mov dword ptr [0x434050], eax
004038a4 (-0xd14) 	call 0x40ba5f
004038a9 (-0xd14) 	push 0x19000
004038ae (-0xd18) 	push 0
004038b0 (-0xd1c) 	push esi
004038b1 (-0xd20) 	call 0x40b587
004038b6 (-0xd20) 	add dword ptr [0x434050], 0x897736d
004038c0 (-0xd20) 	push 2
004038c2 (-0xd24) 	pop ecx
004038c3 (-0xd20) 	call 0x40c3d8
004038c8 (-0xd20) 	lea eax, [ebp - 0x730]
004038ce (-0xd20) 	mov edx, edi
004038d0 (-0xd20) 	push eax
004038d1 (-0xd24) 	lea eax, [ebp - 0x444]
004038d7 (-0xd24) 	mov ecx, esi
004038d9 (-0xd24) 	push eax
004038da (-0xd28) 	push dword ptr [ebp - 0x2c]
004038dd (-0xd2c) 	call 0x418e7e
004038e2 (-0xd2c) 	mov ecx, dword ptr [ebp - 0x28]
004038e5 (-0xd2c) 	mov edx, esi
004038e7 (-0xd2c) 	call 0x40ba5f
004038ec (-0xd2c) 	push 0x19000
004038f1 (-0xd30) 	push 0
004038f3 (-0xd34) 	push esi
004038f4 (-0xd38) 	call 0x40b587
004038f9 (-0xd38) 	push 2
004038fb (-0xd3c) 	pop ecx
004038fc (-0xd38) 	call 0x40c3d8
00403901 (-0xd38) 	mov edx, dword ptr [ebp - 0xc]
00403904 (-0xd38) 	lea eax, [ebp - 0x460]
0040390a (-0xd38) 	push eax
0040390b (-0xd3c) 	push dword ptr [ebp - 0x2c]
0040390e (-0xd40) 	mov ecx, esi
00403910 (-0xd40) 	push edi
00403911 (-0xd44) 	call 0x418f5d
00403916 (-0xd44) 	mov ecx, dword ptr [ebp - 0x28]
00403919 (-0xd44) 	mov edx, esi
0040391b (-0xd44) 	call 0x40ba5f
00403920 (-0xd44) 	push 0x19000
00403925 (-0xd48) 	push 0
00403927 (-0xd4c) 	push esi
00403928 (-0xd50) 	call 0x40b587
0040392d (-0xd50) 	mov ecx, dword ptr [ebp - 8]
00403930 (-0xd50) 	lea eax, [ebp - 0x90]
00403936 (-0xd50) 	add esp, 0x48
00403939 (-0xd08) 	push eax
0040393a (-0xd0c) 	push dword ptr [ebp - 0x8c]
00403940 (-0xd10) 	push dword ptr [ebp - 0x2c]
00403943 (-0xd14) 	push edi
00403944 (-0xd18) 	push dword ptr [ebp - 0xcc]
0040394a (-0xd1c) 	mov edi, dword ptr [ebp - 0x28]
0040394d (-0xd1c) 	mov edx, edi
0040394f (-0xd1c) 	call 0x419013
00403954 (-0xd1c) 	add esp, 0x14
00403957 (-0xd08) 	test eax, eax
00403959 (-0xd08) 	jne 0x40458d
0040395f (-0xd08) 	push 0x100000
00403964 (-0xd0c) 	push eax
00403965 (-0xd10) 	push edi
00403966 (-0xd14) 	call 0x40b587
0040396b (-0xd14) 	push 0x19000
00403970 (-0xd18) 	push 0
00403972 (-0xd1c) 	push esi
00403973 (-0xd20) 	call 0x40b587
00403978 (-0xd20) 	add esp, 0x18
0040397b (-0xd08) 	mov ecx, esi
0040397d (-0xd08) 	call 0x40a2d2
00403982 (-0xd08) 	lea ecx, [ebp - 0x760]
00403988 (-0xd08) 	call 0x40b5df
0040398d (-0xd08) 	push dword ptr [ebp - 0x64]
00403990 (-0xd0c) 	mov esi, eax
00403992 (-0xd0c) 	lea edx, [ebp - 0x47c]
00403998 (-0xd0c) 	push esi
00403999 (-0xd10) 	push edi
0040399a (-0xd14) 	push 2
0040399c (-0xd18) 	pop ecx
0040399d (-0xd14) 	call 0x40a2e6
004039a2 (-0xd14) 	call eax
004039a4 (-0xd14) 	mov ecx, esi
004039a6 (-0xd14) 	call 0x40b8e6
004039ab (-0xd14) 	push eax
004039ac (-0xd18) 	push 0
004039ae (-0xd1c) 	push esi
004039af (-0xd20) 	call 0x40b587
004039b4 (-0xd20) 	mov ecx, esi
004039b6 (-0xd20) 	call 0x40a2d2
004039bb (-0xd20) 	mov ecx, edi
004039bd (-0xd20) 	call 0x40b8e6
004039c2 (-0xd20) 	mov edx, dword ptr [ebp - 0x2c]
004039c5 (-0xd20) 	push eax
004039c6 (-0xd24) 	call 0x408921
004039cb (-0xd24) 	add esp, 0x1c
004039ce (-0xd08) 	mov esi, 0x42c6cc
004039d3 (-0xd08) 	mov dword ptr [ebp - 0xc4], 0xf043dfb8
004039dd (-0xd08) 	lea edi, [ebp - 0x348]
004039e3 (-0xd08) 	mov dword ptr [ebp - 0xc0], 0xac823d26
004039ed (-0xd08) 	push 0xa
004039ef (-0xd0c) 	pop eax
004039f0 (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'no such process'
004039f1 (-0xd08) 	xor ecx, ecx
004039f3 (-0xd08) 	mov byte ptr [ebp - 0xaf], al
004039f9 (-0xd08) 	push 0x16
004039fb (-0xd0c) 	pop eax
004039fc (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'uch process'
004039fd (-0xd08) 	mov byte ptr [ebp - 0xa8], al
00403a03 (-0xd08) 	mov eax, ecx
00403a05 (-0xd08) 	mov dword ptr [ebp - 0xbc], 0xcf2afbe6
00403a0f (-0xd08) 	mov dword ptr [ebp - 0xb8], 0x5fb52a76
00403a19 (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'process'
00403a1a (-0xd08) 	mov dword ptr [ebp - 0xb4], 0x95761ec1
00403a24 (-0xd08) 	mov byte ptr [ebp - 0xb0], 0xfe
00403a2b (-0xd08) 	mov dword ptr [ebp - 0xae], 0x363be8c4
00403a35 (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
00403a36 (-0xd08) 	mov word ptr [ebp - 0xaa], 0x576f
00403a3f (-0xd08) 	mov edi, ecx
00403a41 (-0xd08) 	mov dword ptr [ebp - 0xa7], 0x2c6aaada
00403a4b (-0xd08) 	mov dword ptr [ebp - 0xa3], 0x82109017
00403a55 (-0xd08) 	mov dword ptr [ebp - 0x9f], 0xd835b33c
00403a5f (-0xd08) 	mov word ptr [ebp - 0x9b], 0x14e3
00403a68 (-0xd08) 	mov byte ptr [ebp - 0x99], 0xd8
00403a6f (-0xd08) 	mov byte ptr [ebp + eax - 0x5d0], al
00403a76 (-0xd08) 	inc eax
00403a77 (-0xd08) 	cmp eax, 0x100
START for RC4 - Set flag
00403a7c (-0xd08) 	jb 0x403a6f
00403a7e (-0xd08) 	mov esi, ecx
00403a80 (-0xd08) 	xor edx, edx
00403a82 (-0xd08) 	mov cl, byte ptr [ebp + esi - 0x5d0]
00403a89 (-0xd08) 	mov eax, esi
00403a8b (-0xd08) 	mov byte ptr [ebp - 1], cl
00403a8e (-0xd08) 	div dword ptr [ebp - 0x2ec]
00403a94 (-0xd08) 	movzx ecx, cl
00403a97 (-0xd08) 	movzx eax, byte ptr [ebp + edx - 0x348]
00403a9f (-0xd08) 	add eax, edi
00403aa1 (-0xd08) 	add ecx, eax
00403aa3 (-0xd08) 	movzx edi, cl
00403aa6 (-0xd08) 	mov al, byte ptr [ebp + edi - 0x5d0]
00403aad (-0xd08) 	mov byte ptr [ebp + esi - 0x5d0], al
00403ab4 (-0xd08) 	inc esi
00403ab5 (-0xd08) 	mov al, byte ptr [ebp - 1]
00403ab8 (-0xd08) 	mov byte ptr [ebp + edi - 0x5d0], al
00403abf (-0xd08) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00403ac5 (-0xd08) 	jb 0x403a80
00403ac7 (-0xd08) 	xor eax, eax
00403ac9 (-0xd08) 	mov edi, eax
00403acb (-0xd08) 	mov dword ptr [ebp - 0x68], eax
00403ace (-0xd08) 	mov ecx, eax
00403ad0 (-0xd08) 	mov eax, dword ptr [0x434050]
00403ad5 (-0xd08) 	mov dword ptr [ebp - 0x30], eax
00403ad8 (-0xd08) 	lea eax, [ecx + 1]
00403adb (-0xd08) 	movzx esi, al
00403ade (-0xd08) 	mov dword ptr [ebp - 0x34], esi
00403ae1 (-0xd08) 	mov cl, byte ptr [ebp + esi - 0x5d0]
00403ae8 (-0xd08) 	movzx edx, cl
00403aeb (-0xd08) 	lea eax, [edi + edx]
00403aee (-0xd08) 	movzx edi, al
00403af1 (-0xd08) 	mov dword ptr [ebp - 0xc], edi
00403af4 (-0xd08) 	mov al, byte ptr [ebp + edi - 0x5d0]
00403afb (-0xd08) 	mov byte ptr [ebp + esi - 0x5d0], al
00403b02 (-0xd08) 	mov byte ptr [ebp + edi - 0x5d0], cl
00403b09 (-0xd08) 	movzx eax, byte ptr [ebp + esi - 0x5d0]
00403b11 (-0xd08) 	add eax, edx
00403b13 (-0xd08) 	movzx eax, al
00403b16 (-0xd08) 	mov al, byte ptr [ebp + eax - 0x5d0]
00403b1d (-0xd08) 	mov byte ptr [ebp - 1], al
00403b20 (-0xd08) 	call 0x4013ec
00403b25 (-0xd08) 	mov esi, 0x42c6dc
00403b2a (-0xd08) 	lea edi, [ebp - 0x80]
00403b2d (-0xd08) 	xor ecx, ecx
00403b2f (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'SrchCollatorFetch'
00403b30 (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'CollatorFetch'
00403b31 (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'atorFetch'
00403b32 (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'Fetch'
00403b33 (-0xd08) 	movsw word ptr es:[edi], word ptr [esi]
00403b35 (-0xd08) 	cmp byte ptr [ebp - 0x80], 0x6f
00403b39 (-0xd08) 	jne 0x403b55
00403b3b (-0xd08) 	mov al, 0x6f
00403b3d (-0xd08) 	test al, al
00403b3f (-0xd08) 	je 0x403b55
00403b41 (-0xd08) 	cmp byte ptr [ebp + ecx - 0x80], 0
00403b46 (-0xd08) 	je 0x403b55
00403b48 (-0xd08) 	mov al, byte ptr [ecx + 0x42caa1]
00403b4e (-0xd08) 	inc ecx
00403b4f (-0xd08) 	cmp al, byte ptr [ebp + ecx - 0x80]
00403b53 (-0xd08) 	je 0x403b3d
00403b55 (-0xd08) 	movzx eax, byte ptr [ebp + ecx - 0x80]
00403b5a (-0xd08) 	movzx ecx, byte ptr [ecx + 0x42caa0]
00403b61 (-0xd08) 	sub ecx, eax
00403b63 (-0xd08) 	cmp ecx, 0x1e7f
00403b69 (-0xd08) 	jae 0x403b7a
00403b6b (-0xd08) 	call 0x401b4e
00403b70 (-0xd08) 	mov eax, dword ptr [ebp - 0x30]
00403b73 (-0xd08) 	and eax, 0x78b0d7d1
00403b78 (-0xd08) 	jmp 0x403b92
00403b7a (-0xd08) 	mov eax, 0x42c934
00403b7f (-0xd08) 	push eax
00403b80 (-0xd0c) 	push ecx
00403b81 (-0xd10) 	mov edx, eax
00403b83 (-0xd10) 	call 0x401e4c
00403b88 (-0xd10) 	mov eax, dword ptr [ebp - 0x30]
00403b8b (-0xd10) 	pop ecx
00403b8c (-0xd0c) 	pop ecx
00403b8d (-0xd08) 	or eax, 0x5106d3ea
00403b92 (-0xd08) 	mov ecx, dword ptr [ebp - 0x68]
00403b95 (-0xd08) 	mov edi, dword ptr [ebp - 0xc]
00403b98 (-0xd08) 	mov dword ptr [ebp - 0x30], eax
00403b9b (-0xd08) 	mov dword ptr [0x434050], eax
00403ba0 (-0xd08) 	mov al, byte ptr [ebp + ecx - 0xc4]
00403ba7 (-0xd08) 	xor al, byte ptr [ebp - 1]
ECX: 0x0
EBP: 0x100ffc
		String address: 0x100ffb
00403baa (-0xd08) 	mov byte ptr [ebp + ecx - 0x324], al
00403bb1 (-0xd08) 	inc ecx
00403bb2 (-0xd08) 	mov dword ptr [ebp - 0x68], ecx
00403bb5 (-0xd08) 	cmp ecx, 0x2c
		CMP 0x2c
		String: 9300101000000000000000000000000000000000000000000000000000000000000000000000000000000000
No strings found attempting with candidate
		String: b8df43f0263d82ace6fb2acf762ab55fc11e7695fe93c4e83b366f5793daaa6a2c179010823cb335d8e314d8
	\TEST: b'zLP+6xYTCsbj4VdO2DTWK\xdfEI2yyZ\xeczf6ZTjkWSPWs3M_'
	\TEST: b'\x02`~\xb6\x1e\x99\x18\xce)\xaf\xc9\xa6\x9f\xbd\xe0\x96Q\x7f\xb0\rX \xac-\xfa\xf9\xf3\xc1\x8e\xa3e\xcc\xc3\x10\xc4\x8f\xed\x8f~\xeb\xcd\x88\xed\x13'
	\TEST: b'\xc2P\xb0YM\x92\xf8\xa0\x0fv~A\x99fa\xfd\xcf_\x96\x0b.\xae\xa2`hR\xde\xa5\xac\xe4\xd4j\x98\xbf\xce;\xb8\xd0f\xde7\xae\x19\x0c'
	\TEST: b'\xa0O&lt;\xaf\xc6\x07\xb8\xba\xf4\x7f\x0f\xc6\xc2\x95\xd1\x9caO\xac\xc2TX\xd5\xa8;)\xe5\xb7\xfb\xf3\xb2\xb1\xec\xc4\x89\xaa\x82\xd1j\x0f\xebd\xef\xf2'
	\TEST: b'\xb3\xc2\xfar\xd2p\x05_\xbe\xcc&gt;\x9f\x06m\xc4\xac[d\xef~5\xac\x036.&gt;\xdfme\xb8\x1b\x87\x95\xe7g\xdb\xacv\xf6Q\x00Cb\xe3'
	\TEST: b'E\xd4+\x1b\xd2\xc4\x8b\x95\xb7\xce\x1cgg\xb1\x06l\xc1u\x91\xb2\xc2n\x03\x98\xbeC\xef\x9b\xcb\x0b.\x9dD\x9e\xe9\x8d*\x86\xeb\xb7\x117I\xaf'
	\TEST: b'\xc6Y\x1fj\x83s\t\x81\xf4\x85\x125Zch\x90\xb4\xee\xfa\xa6\x04\xc7Jh\x13w\xfa\x95y\xd8\xd1\x05~\x11\x13\xf2~\xa9\xa3&lt;\x89e\xe1\xce'
END for RC4 - Reset flags
00403bb8 (-0xd08) 	mov ecx, dword ptr [ebp - 0x34]
00403bbb (-0xd08) 	jb 0x403ad8
00403bc1 (-0xd08) 	push 0x16
00403bc3 (-0xd0c) 	pop ecx
00403bc4 (-0xd08) 	mov byte ptr [ebp - 0x1a], cl
00403bc7 (-0xd08) 	lea edi, [ebp - 0xf8]
00403bcd (-0xd08) 	mov byte ptr [ebp - 0xe], cl
00403bd0 (-0xd08) 	mov esi, 0x42c6f0
00403bd5 (-0xd08) 	push 6
00403bd7 (-0xd0c) 	pop ecx
00403bd8 (-0xd08) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'IndexEfsCertificateMapFail'
00403bda (-0xd08) 	xor eax, eax
00403bdc (-0xd08) 	mov dword ptr [ebp - 0x24], 0xe5b23162
00403be3 (-0xd08) 	mov byte ptr [ebp - 0x2f8], al
00403be9 (-0xd08) 	mov dword ptr [ebp - 0x20], 0xbd056ffe
00403bf0 (-0xd08) 	movsw word ptr es:[edi], word ptr [esi]
00403bf2 (-0xd08) 	mov word ptr [ebp - 0x1c], 0x37ff
00403bf8 (-0xd08) 	mov dword ptr [ebp - 0x19], 0x56b106c7
00403bff (-0xd08) 	mov dword ptr [ebp - 0x15], 0x56ff6e90
00403c06 (-0xd08) 	mov word ptr [ebp - 0x11], 0xd68f
00403c0c (-0xd08) 	mov byte ptr [ebp - 0xf], 0x99
00403c10 (-0xd08) 	mov byte ptr [ebp - 0xd], 0x87
00403c14 (-0xd08) 	movsb byte ptr es:[edi], byte ptr [esi]
00403c15 (-0xd08) 	mov dword ptr [ebp - 0xc], eax
00403c18 (-0xd08) 	mov dword ptr [ebp - 0x68], eax
00403c1b (-0xd08) 	call 0x401000
00403c20 (-0xd08) 	push 0xc
00403c22 (-0xd0c) 	pop eax
00403c23 (-0xd08) 	mov ecx, eax
00403c25 (-0xd08) 	lea edi, [ebp - 0xc8]
00403c2b (-0xd08) 	mov esi, 0x42c70c
00403c30 (-0xd08) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'RtlRegisterFeatureConfigurationChangeNotification'
00403c32 (-0xd08) 	movsw word ptr es:[edi], word ptr [esi]
00403c34 (-0xd08) 	cmp byte ptr [ebp - 0xc8], 0x66
00403c3b (-0xd08) 	jne 0x403c6c
00403c3d (-0xd08) 	mov al, 0x66
00403c3f (-0xd08) 	xor esi, esi
00403c41 (-0xd08) 	test al, al
00403c43 (-0xd08) 	je 0x403c6c
00403c45 (-0xd08) 	cmp byte ptr [ebp + esi - 0xc8], 0
00403c4d (-0xd08) 	je 0x403c6c
00403c4f (-0xd08) 	push ecx
00403c50 (-0xd0c) 	push 0x42c934
00403c55 (-0xd10) 	call 0x401955
00403c5a (-0xd10) 	mov al, byte ptr [esi + 0x42c935]
00403c60 (-0xd10) 	inc esi
00403c61 (-0xd10) 	pop ecx
00403c62 (-0xd0c) 	pop ecx
00403c63 (-0xd08) 	cmp al, byte ptr [ebp + esi - 0xc8]
00403c6a (-0xd08) 	je 0x403c41
00403c6c (-0xd08) 	mov eax, dword ptr [ebp - 0x68]
00403c6f (-0xd08) 	mov edi, 0x100
00403c74 (-0xd08) 	mov byte ptr [ebp + eax - 0x6d0], al
00403c7b (-0xd08) 	inc eax
00403c7c (-0xd08) 	mov dword ptr [ebp - 0x68], eax
00403c7f (-0xd08) 	cmp eax, edi
START for RC4 - Set flag
00403c81 (-0xd08) 	jb 0x403c1b
00403c83 (-0xd08) 	xor esi, esi
00403c85 (-0xd08) 	xor edx, edx
00403c87 (-0xd08) 	mov cl, byte ptr [ebp + esi - 0x6d0]
00403c8e (-0xd08) 	mov eax, esi
00403c90 (-0xd08) 	mov byte ptr [ebp - 1], cl
00403c93 (-0xd08) 	div dword ptr [ebp - 0xd0]
00403c99 (-0xd08) 	movzx ecx, cl
00403c9c (-0xd08) 	movzx eax, byte ptr [ebp + edx - 0xf8]
00403ca4 (-0xd08) 	add eax, dword ptr [ebp - 0xc]
00403ca7 (-0xd08) 	add ecx, eax
00403ca9 (-0xd08) 	movzx ecx, cl
00403cac (-0xd08) 	mov dword ptr [ebp - 0xc], ecx
00403caf (-0xd08) 	mov al, byte ptr [ebp + ecx - 0x6d0]
00403cb6 (-0xd08) 	mov byte ptr [ebp + esi - 0x6d0], al
00403cbd (-0xd08) 	inc esi
00403cbe (-0xd08) 	mov al, byte ptr [ebp - 1]
00403cc1 (-0xd08) 	mov byte ptr [ebp + ecx - 0x6d0], al
00403cc8 (-0xd08) 	cmp esi, edi
START for key loop - Scanning for XOR
00403cca (-0xd08) 	jb 0x403c85
00403ccc (-0xd08) 	xor eax, eax
00403cce (-0xd08) 	mov dword ptr [ebp - 0x30], eax
00403cd1 (-0xd08) 	mov edi, eax
00403cd3 (-0xd08) 	mov esi, eax
00403cd5 (-0xd08) 	lea eax, [edi + 1]
00403cd8 (-0xd08) 	movzx edi, al
00403cdb (-0xd08) 	mov eax, dword ptr [ebp - 0x30]
00403cde (-0xd08) 	mov cl, byte ptr [ebp + edi - 0x6d0]
00403ce5 (-0xd08) 	movzx edx, cl
00403ce8 (-0xd08) 	add eax, edx
00403cea (-0xd08) 	movzx eax, al
00403ced (-0xd08) 	mov dword ptr [ebp - 0x30], eax
00403cf0 (-0xd08) 	mov al, byte ptr [ebp + eax - 0x6d0]
00403cf7 (-0xd08) 	mov byte ptr [ebp + edi - 0x6d0], al
00403cfe (-0xd08) 	mov eax, dword ptr [ebp - 0x30]
00403d01 (-0xd08) 	mov byte ptr [ebp + eax - 0x6d0], cl
00403d08 (-0xd08) 	movzx eax, byte ptr [ebp + edi - 0x6d0]
00403d10 (-0xd08) 	add eax, edx
00403d12 (-0xd08) 	movzx eax, al
00403d15 (-0xd08) 	mov al, byte ptr [ebp + eax - 0x6d0]
00403d1c (-0xd08) 	xor al, byte ptr [ebp + esi - 0x24]
ECX: 0x61
EBP: 0x100ffc
		String address: 0x100fd8
00403d20 (-0xd08) 	mov byte ptr [ebp + esi - 0x498], al
00403d27 (-0xd08) 	inc esi
00403d28 (-0xd08) 	cmp esi, 0x18
		CMP 0x18
		String: 6231b2e5fe6f05bdff3793c706b156906eff568fd6999387
No strings found attempting with candidate
		String: 610000000000000000000000000000000000000000000000
	\TEST: b'eI\xf8\x92\xb9\x1fi\xee\xcbE^\x95r\xc32\xf2&lt;\xa7:\xf6\x95\xc8I\xd8'
	\TEST: b'\xe8X`\xeb\xce\xa2\x8f^I\tr\xb6\x86\xdd\xc2\xb5\xbd\x99\n\x82f\xbe\xb2\xc6'
END for RC4 - Reset flags
00403d2b (-0xd08) 	jb 0x403cd5
00403d2d (-0xd08) 	push 0x19
00403d2f (-0xd0c) 	pop eax
00403d30 (-0xd08) 	push 0x16
00403d32 (-0xd0c) 	pop edx
00403d33 (-0xd08) 	push 0xb
00403d35 (-0xd0c) 	mov esi, 0x42c22c
00403d3a (-0xd0c) 	mov byte ptr [ebp - 0x1af], al
00403d40 (-0xd0c) 	pop eax
00403d41 (-0xd08) 	lea edi, [ebp - 0x2e8]
00403d47 (-0xd08) 	mov byte ptr [ebp - 0x197], al
00403d4d (-0xd08) 	push 0x41
00403d4f (-0xd0c) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'message size'
00403d50 (-0xd0c) 	xor ecx, ecx
00403d52 (-0xd0c) 	pop eax
00403d53 (-0xd08) 	push 0xc
00403d55 (-0xd0c) 	mov byte ptr [ebp - 0x187], al
00403d5b (-0xd0c) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'age size'
00403d5c (-0xd0c) 	mov byte ptr [ebp - 0x175], al
00403d62 (-0xd0c) 	pop eax
00403d63 (-0xd08) 	push 0x1a
00403d65 (-0xd0c) 	movsd dword ptr es:[edi], dword ptr [esi]
00403d66 (-0xd0c) 	mov byte ptr [ebp - 0x16f], al
00403d6c (-0xd0c) 	pop eax
00403d6d (-0xd08) 	mov byte ptr [ebp - 0x480], cl
00403d73 (-0xd08) 	movsb byte ptr es:[edi], byte ptr [esi]
00403d74 (-0xd08) 	mov dword ptr [ebp - 0x1d0], 0x35743e7d
00403d7e (-0xd08) 	mov edi, ecx
00403d80 (-0xd08) 	mov dword ptr [ebp - 0x1cc], 0xeaad0217
00403d8a (-0xd08) 	mov dword ptr [ebp - 0x1c8], 0x9d67c9d8
00403d94 (-0xd08) 	mov dword ptr [ebp - 0x1c4], 0x37776773
00403d9e (-0xd08) 	mov dword ptr [ebp - 0x1c0], 0x3a2bea5b
00403da8 (-0xd08) 	mov dword ptr [ebp - 0x1bc], 0x9be80538
00403db2 (-0xd08) 	mov dword ptr [ebp - 0x1b8], 0xc5e9ddc4
00403dbc (-0xd08) 	mov dword ptr [ebp - 0x1b4], 0xea96bbcc
00403dc6 (-0xd08) 	mov byte ptr [ebp - 0x1b0], 0x72
00403dcd (-0xd08) 	mov dword ptr [ebp - 0x1ae], 0x671deaea
00403dd7 (-0xd08) 	mov dword ptr [ebp - 0x1aa], 0x4d3e30c9
00403de1 (-0xd08) 	mov word ptr [ebp - 0x1a6], 0x93fa
00403dea (-0xd08) 	mov byte ptr [ebp - 0x1a4], dl
00403df0 (-0xd08) 	mov dword ptr [ebp - 0x1a3], 0xfada30c2
00403dfa (-0xd08) 	mov dword ptr [ebp - 0x19f], 0x9b34b2c5
00403e04 (-0xd08) 	mov dword ptr [ebp - 0x19b], 0xb53e66b6
00403e0e (-0xd08) 	mov dword ptr [ebp - 0x196], 0xfd7c47e3
00403e18 (-0xd08) 	mov dword ptr [ebp - 0x192], 0xee680627
00403e22 (-0xd08) 	mov dword ptr [ebp - 0x18e], 0xa96e50d2
00403e2c (-0xd08) 	mov word ptr [ebp - 0x18a], 0xc8cf
00403e35 (-0xd08) 	mov byte ptr [ebp - 0x188], 0xcf
00403e3c (-0xd08) 	mov dword ptr [ebp - 0x186], 0xee9f2860
00403e46 (-0xd08) 	mov dword ptr [ebp - 0x182], 0xbfa86a8b
00403e50 (-0xd08) 	mov dword ptr [ebp - 0x17e], 0x468e6b2a
00403e5a (-0xd08) 	mov dword ptr [ebp - 0x17a], 0x68e5f734
00403e64 (-0xd08) 	mov byte ptr [ebp - 0x176], 0x7e
00403e6b (-0xd08) 	mov dword ptr [ebp - 0x174], 0xbf208fb6
00403e75 (-0xd08) 	mov byte ptr [ebp - 0x170], 0x89
00403e7c (-0xd08) 	mov dword ptr [ebp - 0x16e], 0x586fcc05
00403e86 (-0xd08) 	mov dword ptr [ebp - 0x16a], 0x7562d853
00403e90 (-0xd08) 	mov dword ptr [ebp - 0x166], 0x6588c1ef
00403e9a (-0xd08) 	mov dword ptr [ebp - 0x162], 0xedf7ed72
00403ea4 (-0xd08) 	mov dword ptr [ebp - 0x15e], 0x70d17309
00403eae (-0xd08) 	mov dword ptr [ebp - 0x15a], 0x1c564d64
00403eb8 (-0xd08) 	mov dword ptr [ebp - 0x156], 0x4f7ab86a
00403ec2 (-0xd08) 	mov dword ptr [ebp - 0x152], 0xdf8aff94
00403ecc (-0xd08) 	mov dword ptr [ebp - 0x14e], 0x6be31c98
00403ed6 (-0xd08) 	mov dword ptr [ebp - 0x14a], 0x42768390
00403ee0 (-0xd08) 	mov byte ptr [ebp - 0x146], 0xdf
00403ee7 (-0xd08) 	mov byte ptr [ebp - 0x145], al
00403eed (-0xd08) 	mov dword ptr [ebp - 0x144], 0x25437b44
00403ef7 (-0xd08) 	mov dword ptr [ebp - 0x140], 0xf2f58b7c
00403f01 (-0xd08) 	mov dword ptr [ebp - 0x13c], 0xb5a996fc
00403f0b (-0xd08) 	mov dword ptr [ebp - 0x138], 0xab18c257
00403f15 (-0xd08) 	mov dword ptr [ebp - 0x134], 0xc6ecb55d
00403f1f (-0xd08) 	mov byte ptr [ebp - 0x130], dl
00403f25 (-0xd08) 	mov dword ptr [ebp - 0x12f], 0x1f730976
00403f2f (-0xd08) 	mov dword ptr [ebp - 0x12b], 0x5d00fa38
00403f39 (-0xd08) 	mov dword ptr [ebp - 0x127], 0x2fcd354
00403f43 (-0xd08) 	mov dword ptr [ebp - 0x123], 0x56a0be14
00403f4d (-0xd08) 	mov dword ptr [ebp - 0x11f], 0xf2e83a74
00403f57 (-0xd08) 	mov dword ptr [ebp - 0x11b], 0xe8b8943e
00403f61 (-0xd08) 	mov dword ptr [ebp - 0x117], 0xb54d3d9f
00403f6b (-0xd08) 	mov word ptr [ebp - 0x113], 0xaf09
00403f74 (-0xd08) 	mov byte ptr [ebp - 0x111], 0x87
00403f7b (-0xd08) 	mov eax, ecx
00403f7d (-0xd08) 	mov byte ptr [ebp + eax - 0x8b0], al
00403f84 (-0xd08) 	inc eax
00403f85 (-0xd08) 	cmp eax, 0x100
START for RC4 - Set flag
00403f8a (-0xd08) 	jb 0x403f7d
00403f8c (-0xd08) 	mov esi, ecx
00403f8e (-0xd08) 	xor edx, edx
00403f90 (-0xd08) 	mov cl, byte ptr [ebp + esi - 0x8b0]
00403f97 (-0xd08) 	mov eax, esi
00403f99 (-0xd08) 	mov byte ptr [ebp - 1], cl
00403f9c (-0xd08) 	div dword ptr [ebp - 0x2f4]
00403fa2 (-0xd08) 	movzx ecx, cl
00403fa5 (-0xd08) 	movzx eax, byte ptr [ebp + edx - 0x2e8]
00403fad (-0xd08) 	add eax, edi
00403faf (-0xd08) 	add ecx, eax
00403fb1 (-0xd08) 	movzx edi, cl
00403fb4 (-0xd08) 	mov al, byte ptr [ebp + edi - 0x8b0]
00403fbb (-0xd08) 	mov byte ptr [ebp + esi - 0x8b0], al
00403fc2 (-0xd08) 	inc esi
00403fc3 (-0xd08) 	mov al, byte ptr [ebp - 1]
00403fc6 (-0xd08) 	mov byte ptr [ebp + edi - 0x8b0], al
00403fcd (-0xd08) 	cmp esi, 0x100
START for key loop - Scanning for XOR
00403fd3 (-0xd08) 	jb 0x403f8e
00403fd5 (-0xd08) 	xor eax, eax
00403fd7 (-0xd08) 	mov dword ptr [ebp - 0x30], eax
00403fda (-0xd08) 	mov edi, eax
00403fdc (-0xd08) 	mov esi, eax
00403fde (-0xd08) 	lea eax, [edi + 1]
00403fe1 (-0xd08) 	movzx edi, al
00403fe4 (-0xd08) 	mov eax, dword ptr [ebp - 0x30]
00403fe7 (-0xd08) 	mov cl, byte ptr [ebp + edi - 0x8b0]
00403fee (-0xd08) 	movzx edx, cl
00403ff1 (-0xd08) 	add eax, edx
00403ff3 (-0xd08) 	movzx eax, al
00403ff6 (-0xd08) 	mov dword ptr [ebp - 0x30], eax
00403ff9 (-0xd08) 	mov al, byte ptr [ebp + eax - 0x8b0]
00404000 (-0xd08) 	mov byte ptr [ebp + edi - 0x8b0], al
00404007 (-0xd08) 	mov eax, dword ptr [ebp - 0x30]
0040400a (-0xd08) 	mov byte ptr [ebp + eax - 0x8b0], cl
00404011 (-0xd08) 	movzx eax, byte ptr [ebp + edi - 0x8b0]
00404019 (-0xd08) 	add eax, edx
0040401b (-0xd08) 	movzx eax, al
0040401e (-0xd08) 	mov al, byte ptr [ebp + eax - 0x8b0]
00404025 (-0xd08) 	xor al, byte ptr [ebp + esi - 0x1d0]
ECX: 0x70
EBP: 0x100ffc
		String address: 0x100e2c
0040402c (-0xd08) 	mov byte ptr [ebp + esi - 0x29c], al
00404033 (-0xd08) 	inc esi
00404034 (-0xd08) 	cmp esi, 0xc0
		CMP 0xc0
		String: 7d3e74351702adead8c9679d736777375bea2b3a3805e89bc4dde9c5ccbb96ea7203eaea1d67c9303e4dfa9300c230dafac5b2349bb6663eb503e3477cfd270668eed2506ea9cfc8cf0360289fee8b6aa8bf2a6b8e4634f7e5687e03b68f20bf890305cc6f5853d86275efc1886572edf7ed0973d170644d561c6ab87a4f94ff8adf981ce36b90837642df03447b43257c8bf5f2fc96a9b557c218ab5db5ecc6007609731f38fa005d54d3fc0214bea056743ae8f23e94b8e89f3d4db509af87
		Decrypted: b'JqtfADIh7MxwkkbEZxydyPfITiE+8D/aIYqaa6eUPGt4cgZqL2UCXPAd1Zz7rrV8/k2o2+hlM hg1qxc2kM0/Ymkk75*+V8ah^Ptke7POxW3nFIqUdeUsRaoG7hOgLvi8m2jLwekq4K*WwveMYEew5B4GmTlMb4ZNJivyeiZJHMlRBHfm9ibufHRZcL3fSkf'
No strings found attempting with candidate
		String: 030000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
	\TEST: b'4O\x00SVF\xe4\x82\xef\x84\x1f\xea\x18\x0c\x15r\x01\x92R^AU\x8e\xd2\x90\xb4\xac\xee\xf4\xff\xb9\x8b;Z\x9b\x8b|Q\xacen\n\x8e\xa7c\xa5j\xab\xb6\xf7\xe7w\xc3\xe6\'Z\x84Y\x99p\x0e\x8fq&gt;G\x85\xe0?\\\x82\xa7\xa4\x82#\x08O\xae\x9f\xf3\t\x9a\xd4g[\xa1\x1fY\x9c\x8e_K)\x9d\xd9\x18\xde\xe1]U\xb8\x04=d\x88-\r\xb8\xf2\xe6#;\x9c\xa2\x89l&amp;\xa2"\x05"\x11+\x02\xf7\x1d\x03\xe2\x96\xb2\xb2\xaav\xaf\x1c\xf5\xe8\x07v\x94)\x13\x0c5@1\xd2\xb0\x97\x8b\xa3\xeb\x81\x10\xafL\xc7\x10\xd7\xd8\x9cN&lt;`\x05f]\x93Z\x17\x1c\x9e\x90PV\xf6\xc6;MS\x8a\x87X\xdc\xea\xb2\xfcq~\xd3Z\xc4\xe1'
	\TEST: b'\x94\xdd\xa6\xbcE\xfd\xb9\xe2m\xd6\x9a\x8e5\x8d\xeb;\xbb\xe2\x1f\xa3\xb61\xc5\xda6\xca\xaac\x13\xae\x11\xe3\xb9zJ\x179\x80b\xbbI\x1e"\xf1\xd0\xb5\xec\xda\x16Y\x03\xceh?R\x81\xc8L\x85U\'ag4N\x84\x87\xf7\r\xfbM\xee\xc4\xa2\x85\xc4[\x9e\x11%8O\xa9\xfa\x13\xdd\x83g\xc3O\xaf L\xfb\xd5\xbdf\xf1b\xdap\x00\x07\xb1.\xe00o\x80(\xeb\x84;\xec\xc7\x1c\x16\xd3\xbd\x1e\xe8\xaf\xb0\xf8\x91\x95\x07\xd7\x90k\x95\x19\xf2\xf7x\x18\x10&gt;"\x13Ep\x0b\x85j\x08\xa6\x91\x9d\x91[\xea\xf8\xbbE\xecU\x042\xd0\xbf\xaaH\xa4\xde\x99\xf4E\xa2\xcb\x80\xe1\x0f\xee\x1dA^\'\xf9m\xeaq\x8f\xc0\x82\x07\x02\xbe\xad\xdd\xac\x17'
END for RC4 - Reset flags
0040403a (-0xd08) 	jb 0x403fde
0040403c (-0xd08) 	mov ecx, dword ptr [ebp - 0xcc]
00404042 (-0xd08) 	mov byte ptr [ebp - 0x1dc], 0
00404049 (-0xd08) 	call 0x40c3d8
0040404e (-0xd08) 	lea ecx, [ebp - 0x324]
00404054 (-0xd08) 	call 0x40b5df
00404059 (-0xd08) 	push dword ptr [ebp - 0x64]
0040405c (-0xd0c) 	mov edi, dword ptr [ebp - 0x28]
0040405f (-0xd0c) 	lea edx, [ebp - 0x498]
00404065 (-0xd0c) 	mov esi, eax
00404067 (-0xd0c) 	push esi
00404068 (-0xd10) 	push edi
00404069 (-0xd14) 	push 2
0040406b (-0xd18) 	pop ecx
0040406c (-0xd14) 	call 0x40a2e6
00404071 (-0xd14) 	call eax
00404073 (-0xd14) 	mov ecx, esi
00404075 (-0xd14) 	call 0x40b8e6
0040407a (-0xd14) 	push eax
0040407b (-0xd18) 	push 0
0040407d (-0xd1c) 	push esi
0040407e (-0xd20) 	call 0x40b587
00404083 (-0xd20) 	mov ecx, esi
00404085 (-0xd20) 	call 0x40a2d2
0040408a (-0xd20) 	mov ecx, edi
0040408c (-0xd20) 	call 0x40b8e6
00404091 (-0xd20) 	mov edx, dword ptr [ebp - 0x2c]
00404094 (-0xd20) 	push eax
00404095 (-0xd24) 	call 0x408921
0040409a (-0xd24) 	mov esi, dword ptr [ebp - 8]
0040409d (-0xd24) 	push 0x800
004040a2 (-0xd28) 	push 0
004040a4 (-0xd2c) 	push esi
004040a5 (-0xd30) 	call 0x40b587
004040aa (-0xd30) 	mov ecx, dword ptr [ebp - 0x94]
004040b0 (-0xd30) 	xor eax, eax
004040b2 (-0xd30) 	cmp ecx, dword ptr [ebp - 0x90]
004040b8 (-0xd30) 	cmove ecx, eax
004040bb (-0xd30) 	mov eax, dword ptr [ebp - 0x8c]
004040c1 (-0xd30) 	mov dword ptr [ebp - 0x94], ecx
004040c7 (-0xd30) 	mov ecx, dword ptr [eax + ecx*4]
004040ca (-0xd30) 	call 0x40b8e6
004040cf (-0xd30) 	mov edx, ecx
004040d1 (-0xd30) 	mov ecx, esi
004040d3 (-0xd30) 	push eax
004040d4 (-0xd34) 	call 0x40b6cf
004040d9 (-0xd34) 	mov esi, dword ptr [ebp - 0x88]
004040df (-0xd34) 	inc dword ptr [ebp - 0x94]
004040e5 (-0xd34) 	push 0x80000
004040ea (-0xd38) 	push 0
004040ec (-0xd3c) 	push esi
004040ed (-0xd40) 	call 0x40b587
004040f2 (-0xd40) 	mov ecx, dword ptr [ebp - 8]
004040f5 (-0xd40) 	lea edx, [ebp - 0x29c]
004040fb (-0xd40) 	push 0
004040fd (-0xd44) 	push dword ptr [ebp - 0x2c]
00404100 (-0xd48) 	push esi
00404101 (-0xd4c) 	push edi
00404102 (-0xd50) 	call 0x40dfcf
00404107 (-0xd50) 	add esp, 0x48
0040410a (-0xd08) 	test eax, eax
0040410c (-0xd08) 	jne 0x4039ce
00404112 (-0xd08) 	mov esi, 0x42c740
00404117 (-0xd08) 	mov dword ptr [ebp - 0x110], 0x9b465860
00404121 (-0xd08) 	lea edi, [ebp - 0x80]
00404124 (-0xd08) 	mov byte ptr [ebp - 0x10c], 0xfb
0040412b (-0xd08) 	push 0xe
0040412d (-0xd0c) 	pop eax
0040412e (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'connection refused'
0040412f (-0xd08) 	mov byte ptr [ebp - 0x10b], al
00404135 (-0xd08) 	imul eax, dword ptr [0x434050], 0xaf6270b
0040413f (-0xd08) 	xor ecx, ecx
00404141 (-0xd08) 	mov dword ptr [ebp - 0x10a], 0x629dac34
0040414b (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'ection refused'
0040414c (-0xd08) 	mov dword ptr [ebp - 0x106], 0x1cc3f262
00404156 (-0xd08) 	mov dword ptr [ebp - 0x102], 0x67a65221
00404160 (-0xd08) 	mov dword ptr [ebp - 0xc], eax
00404163 (-0xd08) 	mov eax, ecx
00404165 (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'on refused'
00404166 (-0xd08) 	mov dword ptr [ebp - 0xfe], 0x240182fd
00404170 (-0xd08) 	mov word ptr [ebp - 0xfa], 0x2fce
00404179 (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'efused'
0040417a (-0xd08) 	movsw word ptr es:[edi], word ptr [esi]
0040417c (-0xd08) 	movsb byte ptr es:[edi], byte ptr [esi]
0040417d (-0xd08) 	mov edi, ecx
0040417f (-0xd08) 	mov byte ptr [ebp + eax - 0x8b0], al
00404186 (-0xd08) 	inc eax
00404187 (-0xd08) 	cmp eax, 0x100
START for RC4 - Set flag
0040418c (-0xd08) 	jb 0x40417f
0040418e (-0xd08) 	mov esi, ecx
00404190 (-0xd08) 	xor edx, edx
00404192 (-0xd08) 	mov cl, byte ptr [ebp + esi - 0x8b0]
00404199 (-0xd08) 	mov eax, esi
0040419b (-0xd08) 	mov byte ptr [ebp - 1], cl
0040419e (-0xd08) 	div dword ptr [ebp - 0x2f0]
004041a4 (-0xd08) 	movzx ecx, cl
004041a7 (-0xd08) 	movzx eax, byte ptr [ebp + edx - 0x80]
004041ac (-0xd08) 	add eax, edi
004041ae (-0xd08) 	add ecx, eax
004041b0 (-0xd08) 	movzx edi, cl
004041b3 (-0xd08) 	mov al, byte ptr [ebp + edi - 0x8b0]
004041ba (-0xd08) 	mov byte ptr [ebp + esi - 0x8b0], al
004041c1 (-0xd08) 	inc esi
004041c2 (-0xd08) 	mov al, byte ptr [ebp - 1]
004041c5 (-0xd08) 	mov byte ptr [ebp + edi - 0x8b0], al
004041cc (-0xd08) 	cmp esi, 0x100
START for key loop - Scanning for XOR
004041d2 (-0xd08) 	jb 0x404190
004041d4 (-0xd08) 	xor eax, eax
004041d6 (-0xd08) 	mov dword ptr [ebp - 0x30], eax
004041d9 (-0xd08) 	mov edi, eax
004041db (-0xd08) 	mov esi, eax
004041dd (-0xd08) 	lea eax, [edi + 1]
004041e0 (-0xd08) 	movzx edi, al
004041e3 (-0xd08) 	mov eax, dword ptr [ebp - 0x30]
004041e6 (-0xd08) 	mov cl, byte ptr [ebp + edi - 0x8b0]
004041ed (-0xd08) 	movzx edx, cl
004041f0 (-0xd08) 	add eax, edx
004041f2 (-0xd08) 	movzx eax, al
004041f5 (-0xd08) 	mov dword ptr [ebp - 0x30], eax
004041f8 (-0xd08) 	mov al, byte ptr [ebp + eax - 0x8b0]
004041ff (-0xd08) 	mov byte ptr [ebp + edi - 0x8b0], al
00404206 (-0xd08) 	mov eax, dword ptr [ebp - 0x30]
00404209 (-0xd08) 	mov byte ptr [ebp + eax - 0x8b0], cl
00404210 (-0xd08) 	movzx eax, byte ptr [ebp + edi - 0x8b0]
00404218 (-0xd08) 	add eax, edx
0040421a (-0xd08) 	movzx eax, al
0040421d (-0xd08) 	mov al, byte ptr [ebp + eax - 0x8b0]
00404224 (-0xd08) 	xor al, byte ptr [ebp + esi - 0x110]
ECX: 0xe1
EBP: 0x100ffc
		String address: 0x100eec
0040422b (-0xd08) 	mov byte ptr [ebp + esi - 0x4b4], al
00404232 (-0xd08) 	inc esi
00404233 (-0xd08) 	cmp esi, 0x18
		CMP 0x18
		String: 6058469bfb7e34ac9d6262f2c31c2152a667fd820124ce2f
		Decrypted: b'Gde8p2iEKFF7lpxrfHR6ag__'
No strings found attempting with candidate
		String: 7e0000000000000000000000000000000000000000000000
	\TEST: b'Y&lt;#\xa3\x8bL]\xe9\xd6$$\xc5\xaflY \xc0/\xaf\xb4`C\x91p'
	\TEST: b"\xce\x91$7\x18\xeb\x1d\xeaW\x8b\x0c\x97\xc5\x15'd\xb0#]\xa4\xaa\xf7\xab\xf4"
	\TEST: b'\x10\x91\xa6@\xbd\x13\xc7O\xc5.\x8e\xc8q\x146\xad\xea[\x07+k\x87\xc4B'
	\TEST: b'E\xf3\xca5\x8e`\xde\xac\xd9IB\xee-\xbc\x08\xd5\x85\x0e\x86\x9d/\x14\xb1\xce'
END for RC4 - Reset flags
00404236 (-0xd08) 	jb 0x4041dd
00404238 (-0xd08) 	push 0x12
0040423a (-0xd0c) 	pop eax
0040423b (-0xd08) 	push 0x13
0040423d (-0xd0c) 	mov byte ptr [ebp - 0xae], al
00404243 (-0xd0c) 	lea edi, [ebp - 0x20]
00404246 (-0xd0c) 	pop eax
00404247 (-0xd08) 	push 5
00404249 (-0xd0c) 	xor edx, edx
0040424b (-0xd0c) 	mov byte ptr [ebp - 0xa2], al
00404251 (-0xd0c) 	pop ecx
00404252 (-0xd08) 	mov esi, 0x42c754
00404257 (-0xd08) 	mov byte ptr [ebp - 0x49c], dl
0040425d (-0xd08) 	rep movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'wrong protocol type'
0040425f (-0xd08) 	mov ecx, dword ptr [ebp - 0xc]
00404262 (-0xd08) 	mov edi, edx
00404264 (-0xd08) 	mov word ptr [ebp - 0xb0], 0x1452
0040426d (-0xd08) 	mov eax, edx
0040426f (-0xd08) 	mov dword ptr [ebp - 0xad], 0x4fb0dd32
00404279 (-0xd08) 	mov dword ptr [ebp - 0xa9], 0xde483272
00404283 (-0xd08) 	mov word ptr [ebp - 0xa5], 0xbfa5
0040428c (-0xd08) 	mov byte ptr [ebp - 0xa3], 0x32
00404293 (-0xd08) 	mov dword ptr [ebp - 0xa1], 0x9be02159
0040429d (-0xd08) 	mov dword ptr [ebp - 0x9d], 0x186a8614
004042a7 (-0xd08) 	mov byte ptr [ebp - 0x99], 0x94
004042ae (-0xd08) 	or ecx, 0x92d25330
004042b4 (-0xd08) 	mov byte ptr [ebp + eax - 0x6d0], al
004042bb (-0xd08) 	inc eax
004042bc (-0xd08) 	cmp eax, 0x100
START for RC4 - Set flag
004042c1 (-0xd08) 	jb 0x4042ae
004042c3 (-0xd08) 	mov dword ptr [ebp - 0xc], ecx
004042c6 (-0xd08) 	mov esi, edx
004042c8 (-0xd08) 	xor edx, edx
004042ca (-0xd08) 	mov cl, byte ptr [ebp + esi - 0x6d0]
004042d1 (-0xd08) 	mov eax, esi
004042d3 (-0xd08) 	mov byte ptr [ebp - 1], cl
004042d6 (-0xd08) 	div dword ptr [ebp - 0x1d8]
004042dc (-0xd08) 	movzx ecx, cl
004042df (-0xd08) 	movzx eax, byte ptr [ebp + edx - 0x20]
004042e4 (-0xd08) 	add eax, edi
004042e6 (-0xd08) 	add ecx, eax
004042e8 (-0xd08) 	movzx edi, cl
004042eb (-0xd08) 	mov al, byte ptr [ebp + edi - 0x6d0]
004042f2 (-0xd08) 	mov byte ptr [ebp + esi - 0x6d0], al
004042f9 (-0xd08) 	inc esi
004042fa (-0xd08) 	mov al, byte ptr [ebp - 1]
004042fd (-0xd08) 	mov byte ptr [ebp + edi - 0x6d0], al
00404304 (-0xd08) 	cmp esi, 0x100
START for key loop - Scanning for XOR
0040430a (-0xd08) 	jb 0x4042c8
0040430c (-0xd08) 	imul eax, dword ptr [ebp - 0xc], 0x49668a7f
00404313 (-0xd08) 	mov dword ptr [ebp - 0x68], eax
00404316 (-0xd08) 	xor eax, eax
00404318 (-0xd08) 	mov dword ptr [ebp - 0xc], eax
0040431b (-0xd08) 	mov edi, eax
0040431d (-0xd08) 	mov esi, eax
0040431f (-0xd08) 	lea eax, [edi + 1]
00404322 (-0xd08) 	movzx edi, al
00404325 (-0xd08) 	mov eax, dword ptr [ebp - 0xc]
00404328 (-0xd08) 	mov cl, byte ptr [ebp + edi - 0x6d0]
0040432f (-0xd08) 	movzx edx, cl
00404332 (-0xd08) 	add eax, edx
00404334 (-0xd08) 	movzx eax, al
00404337 (-0xd08) 	mov dword ptr [ebp - 0xc], eax
0040433a (-0xd08) 	mov al, byte ptr [ebp + eax - 0x6d0]
00404341 (-0xd08) 	mov byte ptr [ebp + edi - 0x6d0], al
00404348 (-0xd08) 	mov eax, dword ptr [ebp - 0xc]
0040434b (-0xd08) 	mov byte ptr [ebp + eax - 0x6d0], cl
00404352 (-0xd08) 	movzx eax, byte ptr [ebp + edi - 0x6d0]
0040435a (-0xd08) 	add eax, edx
0040435c (-0xd08) 	movzx eax, al
0040435f (-0xd08) 	mov al, byte ptr [ebp + eax - 0x6d0]
00404366 (-0xd08) 	xor al, byte ptr [ebp + esi - 0xb0]
ECX: 0x95
EBP: 0x100ffc
		String address: 0x100f4c
0040436d (-0xd08) 	mov byte ptr [ebp + esi - 0x4d0], al
00404374 (-0xd08) 	inc esi
00404375 (-0xd08) 	cmp esi, 0x18
		CMP 0x18
		String: 52141e32ddb04f723248dea5bf321e5921e09b14866a1894
		Decrypted: b'Fo#kBKN23KmOs2Gn+Onlyg__'
No strings found attempting with candidate
		String: 1e0000000000000000000000000000000000000000000000
	\TEST: b'\n{=Y\x9f\xfb\x01@\x01\x03\xb3\xea\xcc\x00Y7\n\xaf\xf5x\xff\rG\xcb'
END for RC4 - Reset flags
00404378 (-0xd08) 	jb 0x40431f
0040437a (-0xd08) 	mov esi, 0x42c768
0040437f (-0xd08) 	mov dword ptr [ebp - 0xf8], 0xddc8a0ab
00404389 (-0xd08) 	lea edi, [ebp - 0xdc]
0040438f (-0xd08) 	mov dword ptr [ebp - 0xf4], 0x8c8e8c9e
00404399 (-0xd08) 	xor eax, eax
0040439b (-0xd08) 	mov dword ptr [ebp - 0xf0], 0xf14bf5fa
004043a5 (-0xd08) 	mov byte ptr [ebp - 0x4b8], al
004043ab (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'bad_address'
004043ac (-0xd08) 	mov dword ptr [ebp - 0xec], 0x685c5bf
004043b6 (-0xd08) 	mov dword ptr [ebp - 0xe8], 0x69a0bb68
004043c0 (-0xd08) 	mov dword ptr [ebp - 0xe4], 0x8572a21
004043ca (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
		Potential key: b'address'
004043cb (-0xd08) 	movsd dword ptr es:[edi], dword ptr [esi]
004043cc (-0xd08) 	mov edi, eax
004043ce (-0xd08) 	call 0x4016bd
004043d3 (-0xd08) 	xor esi, esi
004043d5 (-0xd08) 	call 0x4011d8
004043da (-0xd08) 	mov eax, dword ptr [ebp - 0x68]
004043dd (-0xd08) 	and eax, 0xf91c6e7b
004043e2 (-0xd08) 	inc esi
004043e3 (-0xd08) 	mov dword ptr [ebp - 0x68], eax
004043e6 (-0xd08) 	mov dword ptr [0x434050], eax
004043eb (-0xd08) 	cmp byte ptr [esi + 0x42caa0], 0
004043f2 (-0xd08) 	jne 0x4043d5
004043f4 (-0xd08) 	call 0x401000
004043f9 (-0xd08) 	cmp esi, 0x6cb
004043ff (-0xd08) 	jbe 0x40440d
00404401 (-0xd08) 	mov eax, dword ptr [0x434050]
00404406 (-0xd08) 	add eax, 0x12a96067
0040440b (-0xd08) 	jmp 0x40441c
0040440d (-0xd08) 	call 0x4013ec
00404412 (-0xd08) 	mov eax, dword ptr [0x434050]
00404417 (-0xd08) 	add eax, 0xcf5075a7
0040441c (-0xd08) 	xor ecx, ecx
0040441e (-0xd08) 	mov dword ptr [0x434050], eax
00404423 (-0xd08) 	mov eax, ecx
00404425 (-0xd08) 	mov byte ptr [ebp + eax - 0x5d0], al
0040442c (-0xd08) 	inc eax
0040442d (-0xd08) 	cmp eax, 0x100
START for RC4 - Set flag
00404432 (-0xd08) 	jb 0x404425
00404434 (-0xd08) 	mov esi, ecx
00404436 (-0xd08) 	xor edx, edx
00404438 (-0xd08) 	mov cl, byte ptr [ebp + esi - 0x5d0]
0040443f (-0xd08) 	mov eax, esi
00404441 (-0xd08) 	mov byte ptr [ebp - 1], cl
00404444 (-0xd08) 	div dword ptr [ebp - 0x1d4]
0040444a (-0xd08) 	movzx ecx, cl
0040444d (-0xd08) 	movzx eax, byte ptr [ebp + edx - 0xdc]
00404455 (-0xd08) 	add eax, edi
00404457 (-0xd08) 	add ecx, eax
00404459 (-0xd08) 	movzx edi, cl
0040445c (-0xd08) 	mov al, byte ptr [ebp + edi - 0x5d0]
00404463 (-0xd08) 	mov byte ptr [ebp + esi - 0x5d0], al
0040446a (-0xd08) 	inc esi
0040446b (-0xd08) 	mov al, byte ptr [ebp - 1]
0040446e (-0xd08) 	mov byte ptr [ebp + edi - 0x5d0], al
00404475 (-0xd08) 	cmp esi, 0x100
START for key loop - Scanning for XOR
0040447b (-0xd08) 	jb 0x404436
0040447d (-0xd08) 	xor eax, eax
0040447f (-0xd08) 	mov dword ptr [ebp - 0xc], eax
00404482 (-0xd08) 	mov edi, eax
00404484 (-0xd08) 	mov esi, eax
00404486 (-0xd08) 	lea eax, [edi + 1]
00404489 (-0xd08) 	movzx edi, al
0040448c (-0xd08) 	mov eax, dword ptr [ebp - 0xc]
0040448f (-0xd08) 	mov cl, byte ptr [ebp + edi - 0x5d0]
00404496 (-0xd08) 	movzx edx, cl
00404499 (-0xd08) 	add eax, edx
0040449b (-0xd08) 	movzx eax, al
0040449e (-0xd08) 	mov dword ptr [ebp - 0xc], eax
004044a1 (-0xd08) 	mov al, byte ptr [ebp + eax - 0x5d0]
004044a8 (-0xd08) 	mov byte ptr [ebp + edi - 0x5d0], al
004044af (-0xd08) 	mov eax, dword ptr [ebp - 0xc]
004044b2 (-0xd08) 	mov byte ptr [ebp + eax - 0x5d0], cl
004044b9 (-0xd08) 	movzx eax, byte ptr [ebp + edi - 0x5d0]
004044c1 (-0xd08) 	add eax, edx
004044c3 (-0xd08) 	movzx eax, al
004044c6 (-0xd08) 	mov al, byte ptr [ebp + eax - 0x5d0]
004044cd (-0xd08) 	xor al, byte ptr [ebp + esi - 0xf8]
ECX: 0xae
EBP: 0x100ffc
		String address: 0x100f04
004044d4 (-0xd08) 	mov byte ptr [ebp + esi - 0x50], al
004044d8 (-0xd08) 	inc esi
004044d9 (-0xd08) 	cmp esi, 0x18
		CMP 0x18
		String: aba0c8dd9e8c8e8cfaf54bf1bfc5850668bba069212a5708
		Decrypted: b'MREh/KhgD+V+CogeB7MxBQ__'
No strings found attempting with candidate
		String: 4c0000000000000000000000000000000000000000000000
	\TEST: b'\xaa\xf2\x8d\xb5\xb1\xc7\xe6\xeb\xbe\xde\x1d\xda\xfc\xaa\xe2c*\x8c\xed\x11c{\x08W'
	\TEST: b'\xa4\xd5\xd0s\x95\x91\xa2\x9f\xea\xfb^R\x0c_&lt;\xa8\xab\xdb\xe3e\xdb\xbf\\\xcb'
END for RC4 - Reset flags
004044dc (-0xd08) 	jb 0x404486
004044de (-0xd08) 	lea ecx, [ebp - 0x4b4]
004044e4 (-0xd08) 	mov byte ptr [ebp - 0x38], 0
004044e8 (-0xd08) 	call 0x40b5df
004044ed (-0xd08) 	lea ecx, [ebp - 0x4d0]
004044f3 (-0xd08) 	mov edi, eax
004044f5 (-0xd08) 	call 0x40b5df
004044fa (-0xd08) 	lea ecx, [ebp - 0x50]
004044fd (-0xd08) 	mov esi, eax
004044ff (-0xd08) 	call 0x40b5df
00404504 (-0xd08) 	mov ecx, dword ptr [ebp - 0x88]
0040450a (-0xd08) 	mov edx, edi
0040450c (-0xd08) 	call 0x40babc
00404511 (-0xd08) 	test eax, eax
00404513 (-0xd08) 	je 0x404557
00404515 (-0xd08) 	mov edx, esi
00404517 (-0xd08) 	mov ecx, eax
00404519 (-0xd08) 	call 0x40ba1d
0040451e (-0xd08) 	test eax, eax
00404520 (-0xd08) 	jne 0x404557
00404522 (-0xd08) 	mov edx, dword ptr [ebp - 0x64]
00404525 (-0xd08) 	lea eax, [ebp - 0x94]
0040452b (-0xd08) 	mov ecx, dword ptr [ebp - 8]
0040452e (-0xd08) 	push eax
0040452f (-0xd0c) 	lea eax, [ebp - 0x90]
00404535 (-0xd0c) 	push eax
00404536 (-0xd10) 	push dword ptr [ebp - 0x8c]
0040453c (-0xd14) 	lea eax, [ebp - 0xcc]
00404542 (-0xd14) 	push dword ptr [ebp - 0x2c]
00404545 (-0xd18) 	push dword ptr [ebp - 0x88]
0040454b (-0xd1c) 	push dword ptr [ebp - 0x28]
0040454e (-0xd20) 	push eax
0040454f (-0xd24) 	call 0x42a642
00404554 (-0xd24) 	add esp, 0x1c
00404557 (-0xd08) 	mov ecx, edi
00404559 (-0xd08) 	call 0x40b8e6
0040455e (-0xd08) 	push eax
0040455f (-0xd0c) 	push 0
00404561 (-0xd10) 	push edi
00404562 (-0xd14) 	call 0x40b587
00404567 (-0xd14) 	mov ecx, esi
00404569 (-0xd14) 	call 0x40b8e6
0040456e (-0xd14) 	push eax
0040456f (-0xd18) 	push 0
00404571 (-0xd1c) 	push esi
00404572 (-0xd20) 	call 0x40b587
00404577 (-0xd20) 	add esp, 0x18
0040457a (-0xd08) 	mov ecx, edi
0040457c (-0xd08) 	call 0x40a2d2
00404581 (-0xd08) 	mov ecx, esi
00404583 (-0xd08) 	call 0x40a2d2
00404588 (-0xd08) 	jmp 0x4039ce
</pre>
</div>
</div>

</div>
</div>

</div>
    

</div>



  </div><a class="u-url" href="/pikabot/debugging/string%20decryption/emulation/memulator/2023/11/19/new-pikabot-strings.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p></p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
